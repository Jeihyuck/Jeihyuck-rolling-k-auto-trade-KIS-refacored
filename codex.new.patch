diff --git a/rolling_k_auto_trade_api/kis_api.py b/rolling_k_auto_trade_api/kis_api.py
index c03d36908d57a81a0d158f779e0f86ed477d42e2..ee2af13179a392ad182608d91941442ef1e129e3 100644
--- a/rolling_k_auto_trade_api/kis_api.py
+++ b/rolling_k_auto_trade_api/kis_api.py
@@ -1,72 +1,130 @@
 from __future__ import annotations
 """
 rolling_k_auto_trade_api.kis_api â€” ìµœì‹  ì‘ë‹µë¡œê¹… + íŒŒë¼ë¯¸í„° ìµœì‹ í™” (ì „ì²´ íŒŒì¼)
 
 í•µì‹¬ ê°œì„ 
 - send_order: KIS ì‘ë‹µ ì›ë¬¸(raw text) ë° JSON ëª¨ë‘ ìƒì„¸ ë¡œê¹…(ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹) + ì‹¤íŒ¨ ì‚¬ìœ /ì½”ë“œ í•¨ê»˜ ê¸°ë¡
 - HashKey ë° ì£¼ë¬¸ íŒŒë¼ë¯¸í„° ìµœì‹ í™”: /uapi/hashkey, /uapi/domestic-stock/v1/trading/order-cash
 - TR_ID ìë™ ì „í™˜: (ëª¨ì˜) VTTC0012U/VTTC0011U, (ì‹¤ì „) TTTC0012U/TTTC0011U
 - ì£¼ë¬¸ ë°©ì‹ ì²´ì¸: ì‹œì¥ê°€â†’IOCì‹œì¥ê°€â†’ìµœìœ ë¦¬(ë§¤ìˆ˜/ë§¤ë„ ê³µí†µ)ë¡œ í´ë°±
 - ê²¬ê³ í•œ ì¬ì‹œë„: ê²Œì´íŠ¸ì›¨ì´/5xx/ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ì— ë°±ì˜¤í”„ ì¬ì‹œë„
 - inquire_balance(ë‹¨ì¼/ì „ì²´), inquire_cash_balance, inquire_filled_order(ì‘ë‹µ ë¡œê¹… í¬í•¨)
 
 ì£¼ì˜: settings ëª¨ë“ˆì´ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©í•˜ê³ , ì—†ìœ¼ë©´ í™˜ê²½ë³€ìˆ˜ì—ì„œ ì½ìŠµë‹ˆë‹¤.
 """
 
 import os
 import json
 import time
 import random
 import logging
+from datetime import datetime, time as dtime, timedelta, timezone
 from typing import Any, Dict, Optional, List
 
 import requests
 from requests.adapters import HTTPAdapter
 from urllib3.util.retry import Retry
 
 logger = logging.getLogger(__name__)
+KST = timezone(timedelta(hours=9))
+MARKET_OPEN = dtime(9, 0)
+MARKET_CLOSE = dtime(15, 20)
+
+_ORDER_BLOCK_STATE: Dict[str, Any] = {"date": None, "reason": None}
 
 # =============================
 # ì‹¤í–‰ ë³´í˜¸ í”Œë˜ê·¸ (CI ë“±ì—ì„œ ì‹¤ê±°ë˜ ë°©ì§€)
 # =============================
 
 
 class LiveTradingDisabledError(RuntimeError):
     """Raised when live KIS API calls are disabled via environment flag."""
 
 
 LIVE_TRADING_DISABLED = os.getenv("DISABLE_LIVE_TRADING", "").lower() in {"1", "true", "yes", "on"}
 
 
 def _guard_live_trading(action: str) -> None:
     if LIVE_TRADING_DISABLED:
         logger.warning(
             f"[KIS_DISABLED] {action} skipped because DISABLE_LIVE_TRADING is set"
         )
         raise LiveTradingDisabledError("DISABLE_LIVE_TRADING is enabled; KIS API calls are blocked.")
 
+
+def _is_trading_day(ts: Optional[datetime] = None) -> bool:
+    ts = ts or datetime.now(tz=KST)
+    return ts.weekday() < 5
+
+
+def _is_trading_window(ts: Optional[datetime] = None) -> bool:
+    ts = ts or datetime.now(tz=KST)
+    return _is_trading_day(ts) and MARKET_OPEN <= ts.time() <= MARKET_CLOSE
+
+
+def _order_block_reason(now: Optional[datetime] = None) -> Optional[str]:
+    now = now or datetime.now(tz=KST)
+    state_date = _ORDER_BLOCK_STATE.get("date")
+    state_reason = _ORDER_BLOCK_STATE.get("reason")
+    if state_date and state_date != now.date():
+        _ORDER_BLOCK_STATE.update({"date": None, "reason": None})
+        state_date, state_reason = None, None
+    if state_date == now.date() and state_reason:
+        return str(state_reason)
+    if not _is_trading_day(now):
+        _ORDER_BLOCK_STATE.update({"date": now.date(), "reason": "NON_TRADING_DAY"})
+        return "NON_TRADING_DAY"
+    if not _is_trading_window(now):
+        return "OUTSIDE_TRADING_WINDOW"
+    return None
+
+
+def _mark_order_blocked(reason: str, now: Optional[datetime] = None) -> None:
+    now = now or datetime.now(tz=KST)
+    _ORDER_BLOCK_STATE.update({"date": now.date(), "reason": reason})
+
+
+def _is_order_disallowed(resp: Any) -> Optional[str]:
+    if not isinstance(resp, dict):
+        return None
+    msg1 = str(resp.get("msg1") or "")
+    msg_cd = str(resp.get("msg_cd") or "")
+    msg = f"{msg1} {msg_cd}".strip()
+    primary_phrases = ("ì˜ì—…ì¼ì´ ì•„ë‹™ë‹ˆë‹¤", "ì£¼ë¬¸ ê°€ëŠ¥ ì‹œê°„ì´ ì•„ë‹™ë‹ˆë‹¤", "ì£¼ë¬¸ê°€ëŠ¥ì‹œê°„ì´ ì•„ë‹™ë‹ˆë‹¤")
+    if any(p in msg1 for p in primary_phrases):
+        return msg or "ORDER_NOT_ALLOWED"
+
+    low = msg.lower()
+    keywords = ("íœ´ì¥", "ê°€ëŠ¥ì‹œê°„", "closed")
+    if any(k in low for k in keywords):
+        return msg or "ORDER_NOT_ALLOWED"
+    status = resp.get("_status")
+    if isinstance(status, int) and status in (401, 403):
+        return f"HTTP_{status}"
+    return None
+
 # =============================
 # ì„¤ì • ë¡œë”© (settings ìš°ì„ , ì—†ìœ¼ë©´ ENV)
 # =============================
 try:  # settings.pyê°€ ìˆìœ¼ë©´ í•´ë‹¹ ê°’ì„ ìš°ì„  ì‚¬ìš©
     from settings import APP_KEY as _APP_KEY
     from settings import APP_SECRET as _APP_SECRET
     from settings import API_BASE_URL as _API_BASE_URL
     from settings import CANO as _CANO
     from settings import ACNT_PRDT_CD as _ACNT_PRDT_CD
     from settings import KIS_ENV as _KIS_ENV
     APP_KEY = _APP_KEY
     APP_SECRET = _APP_SECRET
     API_BASE_URL = _API_BASE_URL
     CANO = _CANO
     ACNT_PRDT_CD = _ACNT_PRDT_CD
     KIS_ENV = _KIS_ENV
 except Exception:
     APP_KEY = os.getenv("APP_KEY") or os.getenv("KIS_APP_KEY", "")
     APP_SECRET = os.getenv("APP_SECRET") or os.getenv("KIS_APP_SECRET", "")
     API_BASE_URL = os.getenv("API_BASE_URL", "https://openapi.koreainvestment.com:9443")
     CANO = os.getenv("CANO", "")
     ACNT_PRDT_CD = os.getenv("ACNT_PRDT_CD", "01")
     KIS_ENV = (os.getenv("KIS_ENV", "practice") or "practice").lower()
 
 # í•„ìˆ˜ê°’ ì²´í¬ ë¡œê·¸
@@ -262,96 +320,124 @@ def _order_cash(body: Dict[str, Any], *, is_sell: bool) -> Dict[str, Any]:
 
             # ì •ìƒ ì²˜ë¦¬
             if r.status_code == 200 and isinstance(j, dict) and j.get("rt_cd") == "0":
                 logger.info(f"[ORDER_OK] ord_dvsn={ord_dvsn} output={j.get('output')}")
                 return j
 
             # ê²Œì´íŠ¸ì›¨ì´/ê³¼ë‹¤/5xx ì¬ì‹œë„
             msg_cd = (j or {}).get("msg_cd", "") if isinstance(j, dict) else ""
             msg1 = (j or {}).get("msg1", "") if isinstance(j, dict) else ""
             if r.status_code >= 500 or msg_cd == "IGW00008" or (isinstance(msg1, str) and ("MCA" in msg1 or "ì´ˆë‹¹" in msg1)):
                 back = min(0.6 * (1.7 ** (attempt - 1)), 5.0) + random.uniform(0, 0.3)
                 logger.warning(f"[ORDER_GATEWAY_RETRY] ord_dvsn={ord_dvsn} attempt={attempt} resp={j} â†’ sleep {back:.2f}s")
                 time.sleep(back)
                 last_err = j
                 continue
 
             # ë¹„ì¦ˆë‹ˆìŠ¤ ì‹¤íŒ¨ëŠ” ê·¸ëŒ€ë¡œ ë°˜í™˜(ìƒìœ„ì—ì„œ íŒë‹¨)
             logger.error(f"[ORDER_FAIL_BIZ] ord_dvsn={ord_dvsn} resp={j} raw_head={raw[:300]}")
             return j if isinstance(j, dict) else {"_status": r.status_code, "raw": raw[:500]}
 
         logger.warning(f"[ORDER_FALLBACK] ord_dvsn={ord_dvsn} ì‹¤íŒ¨ â†’ ë‹¤ìŒ ë°©ì‹")
 
     raise RuntimeError(f"ORDER_FAIL: {last_err}")
 
 
-def send_order(code: str, qty: int, price: Optional[int] = None, side: str = "buy") -> Dict[str, Any]:
+def send_order(
+    code: str,
+    qty: int,
+    price: Optional[int] = None,
+    side: str = "buy",
+    order_type: Optional[str] = None,
+    **kwargs: Any,
+) -> Dict[str, Any]:
     """ê³µìš© ì£¼ë¬¸ API
     side: 'buy' or 'sell'
     price: Noneì´ë©´ ì‹œì¥ê°€ ì²´ì¸, ì§€ì •ê°€ë©´ ì§€ì •ê°€ ê³ ì •(00)
+    order_type: ê³¼ê±° í˜¸ì¶œë¶€ í˜¸í™˜ìš©(ì˜ˆ: "market"); ì¸ì‹ ê°€ëŠ¥í•œ ê°’ì€ priceë¥¼ ë¬´ì‹œí•˜ê³  ì‹œì¥ê°€ë¡œ ì²˜ë¦¬
     ë°˜í™˜: KIS ì‘ë‹µ(dict). ë¹„ì •ìƒ ì‘ë‹µ ì‹œì—ë„ ì›ë¬¸/ìƒíƒœ ì¼ë¶€ í¬í•¨
     """
     _guard_live_trading("order")
     code = str(code).strip()
     is_sell = (side.lower() == "sell")
+    now = datetime.now(tz=KST)
+
+    block_reason = _order_block_reason(now)
+    if block_reason:
+        logger.warning("[ORDER_BLOCK] %s code=%s qty=%s", block_reason, code, qty)
+        return {"rt_cd": "1", "msg_cd": "ORDER_BLOCK", "msg1": block_reason, "output": {}}
+
+    # í˜¸í™˜ì„± ì²˜ë¦¬: order_type="market" ë“±ìœ¼ë¡œ í˜¸ì¶œë¼ë„ TypeError ì—†ì´ ì‹œì¥ê°€ë¡œ ì²˜ë¦¬
+    ord_type_norm = str(order_type).lower() if order_type is not None else ""
+    if ord_type_norm in {"market", "mkt"}:
+        price = None
+    if kwargs:
+        logger.debug(f"[ORDER_KWARGS_IGNORED] extra_keys={list(kwargs.keys())}")
 
     if price is None:
         # ì‹œì¥ê°€ ì²´ì¸
         body = {
             "CANO": CANO,
             "ACNT_PRDT_CD": ACNT_PRDT_CD,
             "PDNO": code,
             "ORD_QTY": str(int(qty)),
         }
-        return _order_cash(body, is_sell=is_sell)
+        resp = _order_cash(body, is_sell=is_sell)
+        blocked = _is_order_disallowed(resp)
+        if blocked:
+            _mark_order_blocked(blocked, now)
+        return resp
     else:
         # ì§€ì •ê°€(ê³ ì •, 00)
         body = {
             "CANO": CANO,
             "ACNT_PRDT_CD": ACNT_PRDT_CD,
             "PDNO": code,
             "ORD_QTY": str(int(qty)),
             "ORD_DVSN": "00",
             "ORD_UNPR": str(int(price)),
             "EXCG_ID_DVSN_CD": "KRX",
         }
         if is_sell:
             body["SLL_TYPE"] = "01"
         hk = _create_hashkey(body)
         tr_id = ("VTTC0011U" if KIS_ENV == "practice" else "TTTC0011U") if is_sell else ("VTTC0012U" if KIS_ENV == "practice" else "TTTC0012U")
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/order-cash"
         hdr = _headers(tr_id, hashkey=hk)
 
         log_body = {k: ("***" if k in ("CANO", "ACNT_PRDT_CD") else v) for k, v in body.items()}
         logger.info(f"[ORDER_REQ_LIMIT] tr_id={tr_id} body={log_body}")
         r = session.post(url, headers=hdr, data=_json_dumps(body).encode("utf-8"), timeout=(3.0, 7.0))
         raw = r.text
         try:
             j = r.json()
         except Exception:
             j = {"_non_json": True}
         logger.info(f"[ORDER_RESP_LIMIT] status={r.status_code} json={j} raw_head={raw[:300]}")
+        blocked = _is_order_disallowed(j)
+        if blocked:
+            _mark_order_blocked(blocked, now)
         return j if isinstance(j, dict) else {"_status": r.status_code, "raw": raw[:500]}
 
 
 # =============================
 # ì”ê³ /ì˜ˆìˆ˜ê¸ˆ/ì²´ê²° ì¡°íšŒ
 # =============================
 
 def inquire_cash_balance() -> int:
     _guard_live_trading("cash_balance")
     url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/inquire-balance"
     tr_id = "VTTC8434R" if KIS_ENV == "practice" else "TTTC8434R"
     hdr = _headers(tr_id)
     params = {
         "CANO": CANO,
         "ACNT_PRDT_CD": ACNT_PRDT_CD,
         "AFHR_FLPR_YN": "N",
         "UNPR_YN": "N",
         "UNPR_DVSN": "01",
         "FUND_STTL_ICLD_YN": "N",
         "FNCG_AMT_AUTO_RDPT_YN": "N",
         "PRCS_DVSN": "01",
         "OFL_YN": "N",
         "INQR_DVSN": "02",
         "CTX_AREA_FK100": "",
         "CTX_AREA_NK100": "",
diff --git a/trader/kis_wrapper.py b/trader/kis_wrapper.py
index 4c39f3597e36875092e849d5abe9b03f4d7804ff..10e0da1e91b96a1a1651c13cc8ef47fe6144491a 100644
--- a/trader/kis_wrapper.py
+++ b/trader/kis_wrapper.py
@@ -4,52 +4,54 @@
 # - í† í° ìºì‹œ
 # - ì‹œì„¸/ì¼ë´‰/ATR
 # - ì”ê³ /ì£¼ë¬¸
 # - âœ… ì˜ˆìˆ˜ê¸ˆ: output2.ord_psbl_cash ìš°ì„  ì‚¬ìš© (fallback: nrcvb_buy_amt â†’ dnca_tot_amt, ìµœí›„: ìµœê·¼ ìºì‹œ)
 # - âœ… SSL EOF/JSON Decode ë“± ì¼ì‹œ ì˜¤ë¥˜ ë‚´ì„± ê°•í™”
 # - âœ… ì‹œì„¸ 0ì› ë°©ì§€(Jâ†”U, Aì ‘ë‘/ë¬´ì ‘ë‘ êµì°¨, ì§€ìˆ˜ ë°±ì˜¤í”„ ì¬ì‹œë„)
 # - âœ… ì”ê³  í˜ì´ì§•(ctx_area_*) , empty ìˆœê°„ì‘ë‹µ ë””ë°”ìš´ìŠ¤
 # - âœ… [NEW] ì„¸ì…˜ ë¦¬ì…‹/ì§€ìˆ˜í˜• ë°±ì˜¤í”„ë¥¼ í¬í•¨í•œ ì•ˆì „ìš”ì²­(_safe_request), ì²´ê²° í›„ ì”ê³  ë™ê¸°í™”(refresh_after_order)
 
 import os
 import json
 import time
 import random
 import logging
 import threading
 import csv
 from datetime import datetime, timedelta
 from typing import Dict, List, Optional, Tuple, Any
 
 import requests
 import pytz
 from requests.adapters import HTTPAdapter
 from urllib3.util.retry import Retry
 
 from settings import APP_KEY, APP_SECRET, API_BASE_URL, CANO, ACNT_PRDT_CD, KIS_ENV
+from trader.time_utils import is_trading_day, is_trading_window, now_kst
 
 logger = logging.getLogger(__name__)
+_ORDER_BLOCK_STATE: Dict[str, Any] = {"date": None, "reason": None}
 
 
 class NetTemporaryError(Exception):
     """ë„¤íŠ¸ì›Œí¬/SSL ë“± ì¼ì‹œì  ì˜¤ë¥˜ë¥¼ ì˜ë¯¸ (ì œì™¸ ê¸ˆì§€, ë£¨í”„ ìŠ¤í‚µ)."""
     pass
 
 
 class DataEmptyError(Exception):
     """ì •ìƒì‘ë‹µì´ë‚˜ ìº”ë“¤ì´ 0ê°œ (ì‹¤ì œ ë°ì´í„° ì—†ìŒ)."""
     pass
 
 
 class DataShortError(Exception):
     """ì •ìƒì‘ë‹µì´ë‚˜ ìº”ë“¤ì´ need_n ë¯¸ë§Œ."""
     pass
 
 
 def _build_session():
     s = requests.Session()
     retry = Retry(
         total=6, connect=5, read=5, status=3,
         backoff_factor=0.6,
         status_forcelist=[429, 500, 502, 503, 504],
         allowed_methods=["GET", "POST"]
     )
@@ -92,50 +94,92 @@ def append_fill(side: str, code: str, name: str, qty: int, price: float, odno: s
     try:
         os.makedirs("fills", exist_ok=True)
         path = f"fills/fills_{datetime.now().strftime('%Y%m%d')}.csv"
         header = ["ts", "side", "code", "name", "qty", "price", "ODNO", "note"]
         row = [
             datetime.now().isoformat(),
             side,
             code,
             name or "",
             int(qty),
             float(price) if price is not None else 0.0,
             str(odno) if odno is not None else "",
             note or "",
         ]
         new = not os.path.exists(path)
         with open(path, "a", newline="", encoding="utf-8") as f:
             w = csv.writer(f)
             if new:
                 w.writerow(header)
             w.writerow(row)
         logger.info(f"[APPEND_FILL] {side} {code} qty={qty} price={price} odno={odno}")
     except Exception as e:
         logger.warning(f"[APPEND_FILL_FAIL] side={side} code={code} ex={e}")
 
 
+def _order_block_reason(now: datetime | None = None) -> Optional[str]:
+    now = now or now_kst()
+    state_date = _ORDER_BLOCK_STATE.get("date")
+    state_reason = _ORDER_BLOCK_STATE.get("reason")
+    if state_date and state_date != now.date():
+        _ORDER_BLOCK_STATE.update({"date": None, "reason": None})
+        state_date, state_reason = None, None
+    if state_date == now.date() and state_reason:
+        return str(state_reason)
+    if not is_trading_day(now):
+        _ORDER_BLOCK_STATE.update({"date": now.date(), "reason": "NON_TRADING_DAY"})
+        return "NON_TRADING_DAY"
+    if not is_trading_window(now):
+        return "OUTSIDE_TRADING_WINDOW"
+    return None
+
+
+def _mark_order_blocked(reason: str, now: datetime | None = None) -> None:
+    now = now or now_kst()
+    _ORDER_BLOCK_STATE.update({"date": now.date(), "reason": reason})
+
+
+def _is_order_disallowed(resp: Any) -> Optional[str]:
+    if not isinstance(resp, dict):
+        return None
+    msg1 = str(resp.get("msg1") or "")
+    msg_cd = str(resp.get("msg_cd") or "")
+    msg = f"{msg1} {msg_cd}".strip()
+    primary_phrases = ("ì˜ì—…ì¼ì´ ì•„ë‹™ë‹ˆë‹¤", "ì£¼ë¬¸ ê°€ëŠ¥ ì‹œê°„ì´ ì•„ë‹™ë‹ˆë‹¤", "ì£¼ë¬¸ê°€ëŠ¥ì‹œê°„ì´ ì•„ë‹™ë‹ˆë‹¤")
+    if any(p in msg1 for p in primary_phrases):
+        return msg or "ORDER_NOT_ALLOWED"
+
+    low = msg.lower()
+    keywords = ("íœ´ì¥", "ê°€ëŠ¥ì‹œê°„", "closed")
+    if any(k in low for k in keywords):
+        return msg or "ORDER_NOT_ALLOWED"
+    status = resp.get("_status")
+    if isinstance(status, int) and status in (401, 403):
+        return f"HTTP_{status}"
+    return None
+
+
 class _RateLimiter:
     def __init__(self, min_interval_sec: float = 0.20):
         self.min_interval = float(min_interval_sec)
         self.last_at: Dict[str, float] = {}
         self._lock = threading.Lock()
 
     def wait(self, key: str):
         with self._lock:
             now = time.time()
             last = self.last_at.get(key, 0.0)
             delta = now - last
             if delta < self.min_interval:
                 time.sleep(self.min_interval - delta + random.uniform(0, 0.03))
             self.last_at[key] = time.time()
 
 
 TR_MAP = {
     "practice": {
         "ORDER_BUY": [os.getenv("KIS_TR_ID_ORDER_BUY", "VTTC0012U"), "VTTC0802U"],
         "ORDER_SELL": [os.getenv("KIS_TR_ID_ORDER_SELL", "VTTC0011U"), "VTTC0801U"],
         "BALANCE": [os.getenv("KIS_TR_ID_BALANCE", "VTTC8434R")],
         "PRICE": [os.getenv("KIS_TR_ID_PRICE", "FHKST01010100")],
         "ORDERBOOK": [os.getenv("KIS_TR_ID_ORDERBOOK", "FHKST01010200")],
         "DAILY_CHART": [os.getenv("KIS_TR_ID_DAILY_CHART", "FHKST03010100")],
         "INTRADAY_CHART": [os.getenv("KIS_TR_ID_INTRADAY_CHART", "FHKST03010200")],
@@ -1088,50 +1132,56 @@ class KisAPI:
                 qty = hldg if hldg > 0 else ord_psbl
                 if pdno and qty > 0:
                     mp[pdno] = qty
             except Exception:
                 continue
         logger.info(f"[ë³´ìœ ìˆ˜ëŸ‰ë§µ] {len(mp)}ì¢…ëª©")
         return mp
 
     # --- í˜¸í™˜ ì…”ì„(ê¸°ì¡´ trader.py í˜¸ì¶œ ëŒ€ì‘) ---
     def get_balance(self) -> Dict[str, object]:
         return {"cash": self.get_cash_balance(), "positions": self.get_positions()}
 
     def get_balance_all(self) -> Dict[str, object]:
         """trader.pyì˜ _fetch_balancesì—ì„œ ìš°ì„  í˜¸ì¶œë˜ëŠ” í˜¸í™˜ìš© ë©”ì„œë“œ."""
         return self.get_balance()
 
     # -------------------------------
     # ì£¼ë¬¸ ê³µí†µ, ì‹œì¥ê°€/ì§€ì •ê°€, ë§¤ìˆ˜/ë§¤ë„
     # -------------------------------
     def _order_cash(self, body: dict, *, is_sell: bool) -> Optional[dict]:
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/order-cash"
 
         # TR í›„ë³´ ìˆœì°¨ ì‹œë„
         tr_list = _pick_tr(self.env, "ORDER_SELL" if is_sell else "ORDER_BUY")
 
+        now = now_kst()
+        block_reason = _order_block_reason(now)
+        if block_reason:
+            logger.warning("[ORDER_BLOCK] %s code=%s qty=%s", block_reason, body.get("PDNO"), body.get("ORD_QTY"))
+            return {"rt_cd": "1", "msg_cd": "ORDER_BLOCK", "msg1": block_reason, "output": {}}
+
         # Fallback: ì‹œì¥ê°€ â†’ IOCì‹œì¥ê°€ â†’ ìµœìœ ë¦¬
         ord_dvsn_chain = ["01", "13", "03"]
         last_err = None
 
         for tr_id in tr_list:
             for ord_dvsn in ord_dvsn_chain:
                 body["ORD_DVSN"] = ord_dvsn
                 body["ORD_UNPR"] = "0"
                 if is_sell and not body.get("SLL_TYPE"):
                     body["SLL_TYPE"] = "01"
                 body.setdefault("EXCG_ID_DVSN_CD", "KRX")
 
                 # HashKey
                 try:
                     hk = self._create_hashkey(body)
                 except Exception as e:
                     logger.error(f"[ORDER_HASH_FAIL] body={body} ex={e}")
                     last_err = e
                     continue
 
                 headers = self._headers(tr_id, hk)
 
                 # ë ˆì´íŠ¸ë¦¬ë°‹(ì£¼ë¬¸ì€ ë³„ í‚¤)
                 self._limiter.wait("orders")
 
@@ -1193,50 +1243,53 @@ class KisAPI:
                                 code=pdno,
                                 name="",
                                 qty=qty,
                                 price=price_for_fill,
                                 odno=odno,
                                 note=f"tr={tr_id},ord_dvsn={ord_dvsn}",
                             )
                         except Exception as e:
                             logger.warning(f"[APPEND_FILL_EX] ex={e} resp={data}")
                         return data
 
                     msg_cd = data.get("msg_cd", "")
                     msg1 = data.get("msg1", "")
                     # ê²Œì´íŠ¸ì›¨ì´/ì„œë²„ ì—ëŸ¬ë¥˜ëŠ” ì¬ì‹œë„
                     if msg_cd == "IGW00008" or "MCA" in msg1 or resp.status_code >= 500:
                         backoff = min(0.6 * (1.7 ** (attempt - 1)), 5.0) + random.uniform(0, 0.35)
                         logger.error(
                             f"[ORDER_FAIL_GATEWAY] tr_id={tr_id} ord_dvsn={ord_dvsn} attempt={attempt} "
                             f"resp={data} â†’ sleep {backoff:.2f}s"
                         )
                         time.sleep(backoff)
                         last_err = data
                         continue
 
                     logger.error(f"[ORDER_FAIL_BIZ] tr_id={tr_id} ord_dvsn={ord_dvsn} resp={data}")
+                    blocked = _is_order_disallowed(data)
+                    if blocked:
+                        _mark_order_blocked(blocked, now)
                     return None
 
                 logger.warning(f"[ORDER_FALLBACK] tr_id={tr_id} ord_dvsn={ord_dvsn} ì‹¤íŒ¨ â†’ ë‹¤ìŒ ë°©ì‹ ì‹œë„")
 
         raise Exception(f"ì£¼ë¬¸ ì‹¤íŒ¨: {last_err}")
 
     # -------------------------------
     # ë§¤ìˆ˜/ë§¤ë„ (ê¸°ë³¸)
     # -------------------------------
     def buy_stock_market(self, pdno: str, qty: int) -> Optional[dict]:
         body = {
             "CANO": self.CANO,
             "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
             "PDNO": safe_strip(pdno),
             "ORD_QTY": str(int(qty)),
             "ORD_DVSN": "01",  # ì‹œì¥ê°€
             "ORD_UNPR": "0",
         }
         return self._order_cash(body, is_sell=False)
 
     def sell_stock_market(self, pdno: str, qty: int) -> Optional[dict]:
         # --- ê°•í™”ëœ ì‚¬ì „ì ê²€: ë³´ìœ ìˆ˜ëŸ‰ ìš°ì„  ---
         pos = self.get_positions() or []
         hldg = 0
         ord_psbl = 0
@@ -1267,95 +1320,110 @@ class KisAPI:
                     f"last={last} age={now_ts-last:.1f}s"
                 )
                 return None
 
         body = {
             "CANO": self.CANO,
             "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
             "PDNO": safe_strip(pdno),
             "SLL_TYPE": "01",  # ì¼ë°˜ë§¤ë„
             "ORD_QTY": str(int(qty)),
             "ORD_DVSN": "01",
             "ORD_UNPR": "0",
             "EXCG_ID_DVSN_CD": "KRX",
         }
         resp = self._order_cash(body, is_sell=True)
         if resp and isinstance(resp, dict) and resp.get("rt_cd") == "0":
             with self._recent_sells_lock:
                 self._recent_sells[pdno] = time.time()
                 cutoff = time.time() - (self._recent_sells_cooldown * 5)
                 keys_to_del = [k for k, v in self._recent_sells.items() if v < cutoff]
                 for k in keys_to_del:
                     del self._recent_sells[k]
         return resp
 
     def buy_stock_limit(self, pdno: str, qty: int, price: int) -> Optional[dict]:
+        now = now_kst()
+        block_reason = _order_block_reason(now)
+        if block_reason:
+            logger.warning("[ORDER_BLOCK] %s code=%s qty=%s", block_reason, pdno, qty)
+            return {"rt_cd": "1", "msg_cd": "ORDER_BLOCK", "msg1": block_reason, "output": {}}
+
         body = {
             "CANO": self.CANO,
             "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
             "PDNO": safe_strip(pdno),
             "ORD_QTY": str(int(qty)),
             "ORD_DVSN": "00",  # ì§€ì •ê°€
             "ORD_UNPR": str(int(price)),
             "EXCG_ID_DVSN_CD": "KRX",
         }
         hk = self._create_hashkey(body)
         tr_list = _pick_tr(self.env, "ORDER_BUY")
         if not tr_list:
             raise Exception("ORDER_BUY TR ë¯¸êµ¬ì„±")
         tr_id = tr_list[0]
         headers = self._headers(tr_id, hk)
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/order-cash"
         # [CHG] ì•ˆì „ìš”ì²­ ì‚¬ìš©
         resp = self._safe_request(
             "POST", url, headers=headers, data=_json_dumps(body).encode("utf-8"), timeout=(3.0, 7.0)
         )
         data = resp.json()
         if resp.status_code == 200 and data.get("rt_cd") == "0":
             logger.info(f"[BUY_LIMIT_OK] output={data.get('output')}")
             try:
                 out = data.get("output") or {}
                 odno = out.get("ODNO") or out.get("ord_no") or ""
                 pdno = safe_strip(body.get("PDNO", ""))
                 qty_int = int(float(body.get("ORD_QTY", "0")))
                 price_for_fill = float(body.get("ORD_UNPR", 0))
                 append_fill(
                     side="BUY",
                     code=pdno,
                     name="",
                     qty=qty_int,
                     price=price_for_fill,
                     odno=odno,
                     note=f"limit,tr={tr_id}",
                 )
             except Exception as e:
                 logger.warning(f"[APPEND_FILL_LIMIT_BUY_FAIL] ex={e}")
             return data
         logger.error(f"[BUY_LIMIT_FAIL] {data}")
+        blocked = _is_order_disallowed(data)
+        if blocked:
+            _mark_order_blocked(blocked, now)
         return None
 
     def sell_stock_limit(self, pdno: str, qty: int, price: int) -> Optional[dict]:
+        now = now_kst()
+        block_reason = _order_block_reason(now)
+        if block_reason:
+            logger.warning("[ORDER_BLOCK] %s code=%s qty=%s", block_reason, pdno, qty)
+            return {"rt_cd": "1", "msg_cd": "ORDER_BLOCK", "msg1": block_reason, "output": {}}
+
         # --- ê°•í™”ëœ ì‚¬ì „ì ê²€: ë³´ìœ ìˆ˜ëŸ‰ ìš°ì„  ---
         pos = self.get_positions() or []
         hldg = 0
         ord_psbl = 0
         for r in pos:
             if safe_strip(r.get("pdno")) == safe_strip(pdno):
                 hldg = int(float(r.get("hldg_qty", "0")))
                 ord_psbl = int(float(r.get("ord_psbl_qty", "0")))
                 break
 
         base_qty = hldg if hldg > 0 else ord_psbl
         if base_qty <= 0:
             logger.error(
                 f"[SELL_LIMIT_PRECHECK] ë³´ìœ  ì—†ìŒ/ìˆ˜ëŸ‰ 0 pdno={pdno} hldg={hldg} ord_psbl={ord_psbl}"
             )
             return None
 
         if qty > base_qty:
             logger.warning(
                 f"[SELL_LIMIT_PRECHECK] ìˆ˜ëŸ‰ ë³´ì •: req={qty} -> base={base_qty} "
                 f"(hldg={hldg}, ord_psbl={ord_psbl})"
             )
             qty = base_qty
 
         # ì¤‘ë³µ ë§¤ë„ ë°©ì§€(ë©”ëª¨ë¦¬ ê¸°ë°˜)
@@ -1392,50 +1460,53 @@ class KisAPI:
         )
         data = resp.json()
         if resp.status_code == 200 and data.get("rt_cd") == "0":
             logger.info(f"[SELL_LIMIT_OK] output={data.get('output')}")
             try:
                 out = data.get("output") or {}
                 odno = out.get("ODNO") or out.get("ord_no") or ""
                 pdno = safe_strip(body.get("PDNO", ""))
                 qty_int = int(float(body.get("ORD_QTY", "0")))
                 price_for_fill = float(body.get("ORD_UNPR", 0))
                 append_fill(
                     side="SELL",
                     code=pdno,
                     name="",
                     qty=qty_int,
                     price=price_for_fill,
                     odno=odno,
                     note=f"limit,tr={tr_id}",
                 )
             except Exception as e:
                 logger.warning(f"[APPEND_FILL_LIMIT_SELL_FAIL] ex={e}")
             with self._recent_sells_lock:
                 self._recent_sells[pdno] = time.time()
             return data
         logger.error(f"[SELL_LIMIT_FAIL] {data}")
+        blocked = _is_order_disallowed(data)
+        if blocked:
+            _mark_order_blocked(blocked, now)
         return None
 
     # -------------------------------
     # ë§¤ìˆ˜/ë§¤ë„ (ì‹ ê·œ ê°€ë“œ ì‚¬ìš© ë²„ì „)
     # -------------------------------
     def buy_stock_limit_guarded(self, code: str, qty: int, limit_price: int, **kwargs):
         """
         ì§€ì •ê°€ ë§¤ìˆ˜ ì‹œ ì˜ˆìˆ˜ê¸ˆ ë¶€ì¡±/ê³¼ë§¤ìˆ˜ ìë™ ì¶•ì†Œ ë˜ëŠ” ìŠ¤í‚µ.
         âœ… practice í™˜ê²½ì—ì„œëŠ” KISì—ê²Œ ì§ì ‘ íŒë‹¨ì„ ë§¡ê¸°ê³ , ë‚´ë¶€ ê°€ë“œëŠ” ìƒëµ.
         """
         # ğŸ”¸ ëª¨ì˜íˆ¬ì(practice) ê³„ì¢Œì—ì„œëŠ” ì˜ˆìˆ˜ê¸ˆ ê°€ë“œ ì‚¬ìš© X â†’ ë°”ë¡œ KISë¡œ ì£¼ë¬¸
         if self.env == "practice":
             logger.info(
                 f"[BUY_GUARD] practice env â†’ guard ìƒëµ, ì§ì ‘ ì§€ì •ê°€ ì£¼ë¬¸ "
                 f"(code={code}, qty={qty}, limit={limit_price})"
             )
             return self.buy_stock_limit(code, qty, limit_price)
 
         try:
             limit_price = int(limit_price)
         except Exception:
             limit_price = 0
         if limit_price <= 0 or int(qty) <= 0:
             raise ValueError("invalid limit buy params")
 
diff --git a/trader/legacy_kosdaq_runner.py b/trader/legacy_kosdaq_runner.py
index bb43aca8a424795b6b996333ba3c4ee240edb2ca..bd9f8177b8b8fe0b635557b3b6fe1208950e2cb6 100644
--- a/trader/legacy_kosdaq_runner.py
+++ b/trader/legacy_kosdaq_runner.py
@@ -1,52 +1,74 @@
 # -*- coding: utf-8 -*-
 """ê±°ë˜ ë©”ì¸ ë£¨í”„.
 
 ê¸°ì¡´ trader.pyì˜ ì„¤ì •/ìœ í‹¸ì„ ë¶„ë¦¬í•˜ê³ , ë©”ì¸ ì§„ì…ì ë§Œ ë‚¨ê²¨ ì „ëµ ì¶”ê°€ê°€
 ì‰¬ìš´ êµ¬ì¡°ë¡œ ë³€ê²½í–ˆë‹¤.
 """
 from __future__ import annotations
 
 import time
 from datetime import datetime, time as dtime, timedelta
 from typing import Any, Dict, List, Tuple, TYPE_CHECKING
 
 
-from .config import (
-    DAILY_CAPITAL,
-    FORCE_SELL_PASSES_CLOSE,
-    FORCE_SELL_PASSES_CUTOFF,
-    KST,
-    RATE_SLEEP_SEC,
-    SELL_ALL_BALANCES_AT_CUTOFF,
-    SELL_FORCE_TIME,
-    SLIPPAGE_ENTER_GUARD_PCT,
-    USE_PULLBACK_ENTRY,
-    PULLBACK_MAX_BUYS_PER_DAY,
-    _cfg,
-    logger,
-)
+try:
+    from .config import (
+        DAILY_CAPITAL,
+        FORCE_SELL_PASSES_CLOSE,
+        FORCE_SELL_PASSES_CUTOFF,
+        ALLOW_WHEN_CLOSED,
+        KST,
+        RATE_SLEEP_SEC,
+        SELL_ALL_BALANCES_AT_CUTOFF,
+        SELL_FORCE_TIME,
+        SLIPPAGE_ENTER_GUARD_PCT,
+        USE_PULLBACK_ENTRY,
+        PULLBACK_MAX_BUYS_PER_DAY,
+        _cfg,
+        logger,
+    )
+except ImportError:
+    # ALLOW_WHEN_CLOSEDê°€ ëˆ„ë½ë¼ë„ ëŸ¬ë„ˆê°€ ì¦‰ì‹œ ì¤‘ë‹¨ë˜ì§€ ì•Šë„ë¡ ì•ˆì „í•œ ê¸°ë³¸ê°’ì„ ì œê³µí•œë‹¤.
+    from .config import (
+        DAILY_CAPITAL,
+        FORCE_SELL_PASSES_CLOSE,
+        FORCE_SELL_PASSES_CUTOFF,
+        KST,
+        RATE_SLEEP_SEC,
+        SELL_ALL_BALANCES_AT_CUTOFF,
+        SELL_FORCE_TIME,
+        SLIPPAGE_ENTER_GUARD_PCT,
+        USE_PULLBACK_ENTRY,
+        PULLBACK_MAX_BUYS_PER_DAY,
+        _cfg,
+        logger,
+    )
+
+    ALLOW_WHEN_CLOSED = False
+    logger.warning("[CONFIG] ALLOW_WHEN_CLOSED missing; defaulting to False")
+from trader.time_utils import MARKET_CLOSE, MARKET_OPEN, is_trading_day
 from .core import *  # noqa: F401,F403 - ì „ëµ ìœ í‹¸ ì „ì²´ ë…¸ì¶œë¡œ í™•ì¥ì„± í™•ë³´
 
 if TYPE_CHECKING:
     # core ìª½ì— êµ¬í˜„ë¼ ìˆëŠ” í—¬í¼ë“¤ì„ íƒ€ì…ì²´ì»¤ì—ê²Œë§Œ ëª…ì‹œì ìœ¼ë¡œ ì•Œë ¤ì¤€ë‹¤.
     from .core import (
         _this_iso_week_key,
         _get_effective_ord_cash,
         _to_float,
         _to_int,
         _weight_to_qty,
         _classify_champion_grade,
         _update_market_regime,
         _notional_to_qty,
         _fetch_balances,
         _init_position_state_from_balance,
         _sell_once,
         _adaptive_exit,
         _compute_daily_entry_context,
         _compute_intraday_entry_context,
         _safe_get_price,
         _round_to_tick,
         _init_position_state,
         _detect_pullback_reversal,
         _has_bullish_trend_structure,
     )
@@ -490,78 +512,110 @@ def main(capital_override: float | None = None):
     code_to_target: Dict[str, Any] = selected_targets
 
     # ëˆŒë¦¼ëª© ìŠ¤ìº”ìš© ì½”ìŠ¤ë‹¥ ì‹œì´ ìƒìœ„ ë¦¬ìŠ¤íŠ¸ (ì±”í”¼ì–¸ê³¼ ë³„ë„ë¡œ ê´€ë¦¬)
     pullback_watch: Dict[str, Dict[str, Any]] = {}
     if USE_PULLBACK_ENTRY:
         try:
             pb_weight = max(0.0, min(PULLBACK_UNIT_WEIGHT, 1.0))
             base_notional = int(round(capital_active * pb_weight))
             pb_df = get_kosdaq_top_n(date_str=rebalance_date, n=PULLBACK_TOPN)
             for _, row in pb_df.iterrows():
                 code = str(row.get("Code") or row.get("code") or "").zfill(6)
                 if not code:
                     continue
                 pullback_watch[code] = {
                     "code": code,
                     "name": row.get("Name") or row.get("name"),
                     "notional": base_notional,
                 }
             logger.info(
                 f"[PULLBACK-WATCH] ì½”ìŠ¤ë‹¥ ì‹œì´ Top{PULLBACK_TOPN} {len(pullback_watch)}ì¢…ëª© ìŠ¤ìº” ì¤€ë¹„"
             )
         except Exception as e:
             logger.warning(f"[PULLBACK-WATCH-FAIL] ì‹œì´ ìƒìœ„ ë¡œë“œ ì‹¤íŒ¨: {e}")
 
     loop_sleep_sec = 2.5  # ë©”ì¸ ë£¨í”„ ëŒ€ê¸° ì‹œê°„(ì´ˆ)
+    max_closed_checks = 3
+    closed_checks = 0
 
     try:
         while True:
             # === ì½”ìŠ¤ë‹¥ ë ˆì§ ì—…ë°ì´íŠ¸ ===
             regime = _update_market_regime(kis)
             regime_state = regime
             pct_txt = f"{regime.get('pct_change'):.2f}%" if regime.get("pct_change") is not None else "N/A"
             logger.info(f"[REGIME] mode={regime['mode']} stage={regime['bear_stage']} pct={pct_txt}")
 
             # ì¥ ìƒíƒœ
             now_dt_kst = datetime.now(KST)
             is_open = kis.is_market_open()
             now_str = now_dt_kst.strftime("%Y-%m-%d %H:%M:%S")
             today_prefix = now_dt_kst.strftime("%Y-%m-%d")
             _cleanup_expired_pending(traded, now_dt_kst, ttl_sec=300)
             traded_today = _traded_today(traded, today_prefix)
 
             if now_dt_kst.date() != pullback_buy_date:
                 pullback_buy_date = now_dt_kst.date()
                 pullback_buys_today = 0
 
             if not is_open:
+                if not is_trading_day(now_dt_kst):
+                    logger.error("[CLOSED] ë¹„ê±°ë˜ì¼ ê°ì§€ â†’ ë£¨í”„ ì¢…ë£Œ")
+                    break
+
+                if now_dt_kst.time() < MARKET_OPEN:
+                    seconds_to_open = int(
+                        (datetime.combine(now_dt_kst.date(), MARKET_OPEN, tzinfo=KST) - now_dt_kst).total_seconds()
+                    )
+                    sleep_for = max(1, min(seconds_to_open, 300))
+                    logger.info(
+                        "[PREOPEN] ì¥ ì‹œì‘ê¹Œì§€ %ss ë‚¨ìŒ â†’ %ss ëŒ€ê¸° í›„ ì¬í™•ì¸", seconds_to_open, sleep_for
+                    )
+                    time.sleep(sleep_for)
+                    closed_checks = 0
+                    continue
+
+                if now_dt_kst.time() >= MARKET_CLOSE:
+                    logger.error("[CLOSED] ì¥ ë§ˆê° ì´í›„ â†’ ë£¨í”„ ì¢…ë£Œ")
+                    break
+
+                closed_checks += 1
                 if not ALLOW_WHEN_CLOSED:
-                    logger.info("[CLOSED] ì¥ ì¢…ë£Œ â†’ 10ì´ˆ ëŒ€ê¸° í›„ ì¬í™•ì¸")
+                    if closed_checks > max_closed_checks:
+                        logger.error("[CLOSED] ì¥ ì¢…ë£Œ ë°˜ë³µ %síšŒ ì´ˆê³¼ â†’ ë£¨í”„ ì¢…ë£Œ", max_closed_checks)
+                        break
+                    logger.info(
+                        "[CLOSED] ì¥ì¤‘ì¸ë° APIê°€ ë‹«í˜ ì‘ë‹µ â†’ 10ì´ˆ ëŒ€ê¸° í›„ ì¬í™•ì¸ (%s/%s)",
+                        closed_checks,
+                        max_closed_checks,
+                    )
                     time.sleep(10)
                     continue
                 else:
                     logger.warning("[CLOSED-DATA] ì¥ ì¢…ë£Œì§€ë§Œ í™˜ê²½ì„¤ì • í—ˆìš© â†’ ì‹œì„¸ ì¡°íšŒ í›„ ì§„í–‰")
+            else:
+                closed_checks = 0
 
             if kis.should_cooldown(now_dt_kst):
                 logger.warning("[COOLDOWN] 2ì´ˆê°„ ëŒ€ê¸° (API ì œí•œ ë³´í˜¸)")
                 time.sleep(2)
 
             # ì”ê³  ê°€ì ¸ì˜¤ê¸°
             prev_holding = holding if isinstance(holding, dict) else {}
             balances = _fetch_balances(kis)
             holding = {}
             for bal in balances:
                 code = bal.get("code")
                 qty = int(bal.get("qty", 0))
                 if qty <= 0:
                     continue
                 price = float(bal.get("avg_price", 0.0))
                 holding[code] = {
                     "qty": qty,
                     "buy_price": price,
                     "bear_s1_done": False,
                     "bear_s2_done": False,
                 }
                 _init_position_state_from_balance(kis, holding, code, price, qty)
 
             # ì”ê³  ê¸°ì¤€ìœ¼ë¡œ ë³´ìœ ì¢…ëª© ë§¤ë„ ê°€ëŠ¥ ìˆ˜ëŸ‰ ë§µ ìƒì„±
             ord_psbl_map = {bal.get("code"): int(bal.get("sell_psbl_qty", 0)) for bal in balances}
diff --git a/trader/time_utils.py b/trader/time_utils.py
new file mode 100644
index 0000000000000000000000000000000000000000..bf7615cacd95e434da76c648d740dbac5c5a5126
--- /dev/null
+++ b/trader/time_utils.py
@@ -0,0 +1,30 @@
+"""ê±°ë˜ì¼/ê±°ë˜ ê°€ëŠ¥ ì‹œê°„ í—¬í¼."""
+
+from __future__ import annotations
+
+from datetime import datetime, time, timedelta, timezone
+
+KST = timezone(timedelta(hours=9))
+MARKET_OPEN = time(9, 0)
+MARKET_CLOSE = time(15, 20)
+
+
+def now_kst() -> datetime:
+    """í˜„ì¬ KST ì‹œê°ì„ ë°˜í™˜."""
+
+    return datetime.now(tz=KST)
+
+
+def is_trading_day(ts: datetime | None = None) -> bool:
+    """ì£¼ë§ì„ ì œì™¸í•œ ê¸°ë³¸ ê±°ë˜ì¼ ì—¬ë¶€ë¥¼ íŒì •."""
+
+    ts = ts or now_kst()
+    return ts.weekday() < 5
+
+
+def is_trading_window(ts: datetime | None = None) -> bool:
+    """ë‹¹ì¼ ì¥ì¤‘(09:00~15:20) ì—¬ë¶€."""
+
+    ts = ts or now_kst()
+    return is_trading_day(ts) and MARKET_OPEN <= ts.time() <= MARKET_CLOSE
+
diff --git a/trader/trader.py b/trader/trader.py
index 16de2145910bc107321f2375bafa6906df654a73..15dae007b8e876fe99556ad9726a40a6d05128a8 100644
--- a/trader/trader.py
+++ b/trader/trader.py
@@ -1,19 +1,25 @@
 # -*- coding: utf-8 -*-
 """Thin entrypoint orchestrating KOSPI core + KOSDAQ alpha engines."""
 from __future__ import annotations
 
 import logging
 
 from portfolio.portfolio_manager import PortfolioManager
+from trader.time_utils import is_trading_day, now_kst
 
 logger = logging.getLogger(__name__)
 
 
 def main() -> None:
+    now = now_kst()
+    if not is_trading_day(now):
+        logger.warning("[TRADER] ë¹„ê±°ë˜ì¼(%s) â†’ ì¦‰ì‹œ ì¢…ë£Œ", now.date())
+        return
+
     mgr = PortfolioManager()
     result = mgr.run_once()
     logger.info("[TRADER] cycle complete %s", result)
 
 
 if __name__ == "__main__":
     main()
