diff --git a/.github/workflows/trade-monitor.yml b/.github/workflows/trade-monitor.yml
index 33250f2ae64fb9f61bddc127def5b0195ce44688..6bf54fb1000399a15b71fc9ba5f2f8a3498f4270 100644
--- a/.github/workflows/trade-monitor.yml
+++ b/.github/workflows/trade-monitor.yml
@@ -1,41 +1,51 @@
 name: Trade Monitor (trader_refactor branch)
 
+permissions:
+  contents: write
+
+concurrency:
+  group: trade-bot-state
+  cancel-in-progress: false
+
 on:
   push:
     branches: [ main, trader_refactor ]
+    paths-ignore:
+      - "bot_state/**"
   pull_request:
     branches: [ main, trader_refactor ]
   schedule:
     - cron: "57 23 * * 0-6"
   workflow_dispatch:
 
 
 jobs:
   monitor-trade:
     # ğŸ”’ ì•ˆì „ì¥ì¹˜: main ë¸Œëœì¹˜ì—ì„œë§Œ ëª¨ë‹ˆí„°ë§/ìë™ë§¤ë§¤ ì‹¤í–‰
     # if: github.ref == 'refs/heads/main'
+    if: github.ref != 'refs/heads/bot-state'
     runs-on: ubuntu-latest
 
     env:
       #FORCE_TRADING_DAY: "1"   # ğŸ‘ˆ í…ŒìŠ¤íŠ¸ ì‹œì—ë§Œ
       #ALLOW_NON_TRADING_ORDER: "1"
       # === KIS ì¸ì¦í‚¤(ë‘ ì´ë¦„ ëª¨ë‘ ëŒ€ì‘: ë¨¼ì € KIS_*ê°€ ìˆìœ¼ë©´ ê·¸ê±¸, ì—†ìœ¼ë©´ APP_* ì‚¬ìš©) ===
       KIS_APP_KEY:    ${{ secrets.KIS_APP_KEY != '' && secrets.KIS_APP_KEY || secrets.APP_KEY }}
       KIS_APP_SECRET: ${{ secrets.KIS_APP_SECRET != '' && secrets.KIS_APP_SECRET || secrets.APP_SECRET }}
       # (ì¼ë¶€ ëª¨ë“ˆì´ APP_*ë¥¼ ì½ì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ ë™ì¼ ê°’ ë™ì‹œ ì£¼ì…)
       APP_KEY:        ${{ secrets.KIS_APP_KEY != '' && secrets.KIS_APP_KEY || secrets.APP_KEY }}
       APP_SECRET:     ${{ secrets.KIS_APP_SECRET != '' && secrets.KIS_APP_SECRET || secrets.APP_SECRET }}
 
       CANO:           ${{ secrets.CANO }}
       ACNT_PRDT_CD:   ${{ secrets.ACNT_PRDT_CD }}
       KIS_ENV:        ${{ secrets.KIS_ENV }}          # practice / real
 
       # settings.pyê°€ KIS_ENVë¡œ ìë™íŒë‹¨í•˜ë¯€ë¡œ API_BASE_URLì€ ë³´í†µ ë¶ˆí•„ìš”
       API_BASE_URL:   ${{ secrets.API_BASE_URL }}
 
       # === trader.py ìš´ì˜ íŒŒë¼ë¯¸í„° ===
       PARTIAL1: "0.5"
       PARTIAL2: "0.3"
       TRAIL_PCT: "0.02"
       FAST_STOP: "0.01"
       ATR_STOP: "1.5"
@@ -88,60 +98,81 @@ jobs:
       API_RATE_SLEEP_SEC: "0.3"
 
       # === VWAP ë¶„ë´‰ TR (ì„ íƒ: ì½”ë“œì— ê¸°ë³¸ê°’ ì´ë¯¸ ìˆìœ¼ë¯€ë¡œ ìƒëµí•´ë„ ë™ì‘) ===
       # í•œêµ­íˆ¬ìì¦ê¶Œ ì—‘ì…€ ê¸°ì¤€ ì£¼ì‹ë‹¹ì¼ë¶„ë´‰ì¡°íšŒ TR_ID (FHKST03010200)
       KIS_TR_ID_INTRADAY_CHART: "FHKST03010200"
       KIS_TR_ID_INTRADAY_CHART_REAL: "FHKST03010200"
 
       # === FastAPI ë¦¬ë°¸ëŸ°ì‹± ì„œë²„(ì„ ì • í•„í„°) ===
       MIN_TRADES: "5"
       MAX_MDD_PCT: "30"
       MIN_WINRATE: "50"
       MIN_CUMRET: "2"
       TOP_K_LIMIT: "20"
       TOTAL_CAPITAL: "10000000"
       MIN_QTY_PER_TICKET: "1"
       K_MIN: "0.1"
       K_MAX: "0.9"
       K_STEP: "0.1"
       ALLOW_AFTER_HOURS: "0"
       REBALANCE_OUT_DIR: "rebalance_results"
 
     steps:
       - uses: actions/checkout@v4
         with:
           fetch-depth: 0
+          persist-credentials: true
+          token: ${{ secrets.GITHUB_TOKEN }}
+
+      - name: Set git identity
+        run: |
+          git config user.name "trade-bot"
+          git config user.email "trade-bot@users.noreply.github.com"
 
       - uses: actions/setup-python@v5
         with:
           python-version: "3.11"
 
+      - name: Ensure state scripts executable
+        if: github.event_name != 'pull_request'
+        run: |
+          chmod +x scripts/state_pull_plain.sh scripts/state_push_plain.sh || true
+
+      - name: Pull state (plain)
+        if: github.event_name != 'pull_request'
+        run: |
+          bash scripts/state_pull_plain.sh
+
       - name: Dependencies ì„¤ì¹˜
         run: |
           python -m pip install --upgrade pip
           pip install -r requirements.txt
 
+      - name: Ledger smoke test
+        run: |
+          python -m trader.ledger_test
+
       - name: (ì§„ë‹¨) í•µì‹¬ í™˜ê²½ë³€ìˆ˜ ì£¼ì… ì—¬ë¶€ë§Œ í™•ì¸
         run: |
           python - << 'PY'
           import os
           def chk(k):
               v = os.getenv(k) or ''
               print(f"{k}: {'OK' if v else 'MISSING'} (len={len(v)})")
           for k in [
               'KIS_APP_KEY','KIS_APP_SECRET','APP_KEY','APP_SECRET',
               'CANO','ACNT_PRDT_CD','KIS_ENV'
           ]:
               chk(k)
           PY
 
       # ğŸ” ì—¬ê¸° ì¶”ê°€: ì‹¤ì œë¡œ ì–´ë–¤ trader.trader íŒŒì¼ì„ ì½ëŠ”ì§€ í™•ì¸
       - name: (ë””ë²„ê·¸) trader ëª¨ë“ˆ ê²½ë¡œ ë° ë‚´ìš© í™•ì¸
         env:
           PYTHONPATH: ${{ github.workspace }}
         run: |
           python - << 'PY'
           import trader
           from trader import trader as t
           print("trader package path:", trader.__file__)
           print("trader.trader module path:", t.__file__)
           print("=== HEAD OF trader.trader ===")
@@ -200,28 +231,32 @@ jobs:
       - name: Trades ë¡œê·¸ ì—…ë¡œë“œ
         if: always()
         uses: actions/upload-artifact@v4
         with:
           name: trade-logs
           path: trader/logs/*.json
           if-no-files-found: ignore
           retention-days: 14
 
       - name: FastAPI ë¡œê·¸ ì¶œë ¥ (cat)
         if: always()
         run: |
           echo "::group::FastAPI Server Log"
           cat fastapi.log || true
           echo "::endgroup::"
 
       - name: FastAPI ë¡œê·¸ ì—…ë¡œë“œ (artifact)
         if: always()
         uses: actions/upload-artifact@v4
         with:
           name: fastapi-log
           path: fastapi.log
           if-no-files-found: ignore
           retention-days: 14
 
+      - name: Push state (plain)
+        if: success() && github.event_name != 'pull_request'
+        run: |
+          bash scripts/state_push_plain.sh
 
             
           
diff --git a/.gitignore b/.gitignore
index 74eca0abc13a6aec993a132012702b2c5e2818c9..3292ac2655b3aa679127eceae82744c91cf2cf8a 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,9 +1,10 @@
 __pycache__/
 .venv/
 .vscode/
 .idea/
 logs/
 watchlists/
 *.log
 *.json
 .env
+bot_state/state.json
diff --git a/README.md b/README.md
index 9b19f0d21950cfa874ecc0a37bdcd8144fb3b409..8d133c309b2c59198d9eed4e2a624803e18e4bec 100644
--- a/README.md
+++ b/README.md
@@ -9,28 +9,30 @@ portfolio/
   kospi_core_engine.py
   kosdaq_alpha_engine.py
   portfolio_manager.py
 strategy/
   kospi/{universe.py, rebalance.py, signals.py}
   kosdaq/{universe.py, rolling_entry.py, pullback.py}
 trader/
   trader.py (entrypoint)
   state_manager.py
   legacy_kosdaq_runner.py (previous KOSDAQ loop kept intact)
 ```
 
 ## Engine responsibilities
 - **KOSPI core engine**: KOSPI market-cap Top-N universe, equal-weight targets, periodic rebalance with market orders and KIS quotes.
 - **KOSDAQ alpha engine**: delegates to the legacy rolling-K/VWAP/pullback loop unchanged, using its original state file for backward compatibility.
 - **Capital split**: `PortfolioManager` divides `DAILY_CAPITAL` (or supplied total) into KOSPI and KOSDAQ ratios (default 60/40) and runs each engine independently.
 - **Performance**: portfolio-level PnL snapshots combine KIS cash/positions with engine allocation ratios for unified reporting without coupling the two engines.
   - Engine-level PnL is an attribution estimate based on capital split ratios because positions are pooled at the account level.
 
 ## How to run
 ```
 python -m trader.trader
 ```
 This initializes the portfolio manager, runs KOSPI rebalance if due, then executes the existing KOSDAQ intraday loop without interrupting either engine on errors. The KOSDAQ loop is blocking, so the entrypoint runs a single orchestrated cycle via `run_once()` rather than a repeating scheduler.
 
+WorkflowëŠ” bot-state ë¸Œëœì¹˜ì— bot_state/state.jsonì„ ì»¤ë°‹í•˜ì—¬ ëŸ° ê°„ ìƒíƒœë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
+
 ## CI and live-trading safeguards
 - CI (pull_request) runs set `DISABLE_LIVE_TRADING=true` so all KIS API calls are blocked and only static checks execute.
 - The live trading workflow is restricted to the `main` branch and triggers only via schedule or manual dispatch with the branch guard enabled.
diff --git a/bot_state/.gitkeep b/bot_state/.gitkeep
new file mode 100644
index 0000000000000000000000000000000000000000..8b137891791fe96927ad78e64b0aad7bded08bdc
--- /dev/null
+++ b/bot_state/.gitkeep
@@ -0,0 +1 @@
+
diff --git a/scripts/state_pull_plain.sh b/scripts/state_pull_plain.sh
new file mode 100755
index 0000000000000000000000000000000000000000..270f53b534f94f6eb5b3cefa4dfea67810046f80
--- /dev/null
+++ b/scripts/state_pull_plain.sh
@@ -0,0 +1,23 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+STATE_DIR="bot_state"
+JSON_PATH="${STATE_DIR}/state.json"
+REMOTE_PATH="${STATE_DIR}/state.json"
+DEFAULT_STATE='{"version": 1, "lots": [], "updated_at": null}'
+
+mkdir -p "${STATE_DIR}"
+
+if git ls-remote --exit-code --heads origin bot-state >/dev/null 2>&1; then
+  git fetch --no-tags origin bot-state:refs/remotes/origin/bot-state >/dev/null 2>&1 || true
+  if git cat-file -e "origin/bot-state:${REMOTE_PATH}" 2>/dev/null; then
+    git show "origin/bot-state:${REMOTE_PATH}" > "${JSON_PATH}"
+    echo "[STATE] Pulled ${REMOTE_PATH} from bot-state branch."
+  else
+    echo "[STATE] WARN: state.json not found in bot-state branch. Initializing."
+    echo "${DEFAULT_STATE}" > "${JSON_PATH}"
+  fi
+else
+  echo "[STATE] WARN: bot-state branch not found. Initializing."
+  echo "${DEFAULT_STATE}" > "${JSON_PATH}"
+fi
diff --git a/scripts/state_push_plain.sh b/scripts/state_push_plain.sh
new file mode 100755
index 0000000000000000000000000000000000000000..bce0d96ce6a5afadb4254cfc2afe07eaa3b7c93b
--- /dev/null
+++ b/scripts/state_push_plain.sh
@@ -0,0 +1,39 @@
+#!/usr/bin/env bash
+set -euo pipefail
+
+STATE_DIR="bot_state"
+JSON_PATH="${STATE_DIR}/state.json"
+
+if [[ ! -f "${JSON_PATH}" ]]; then
+  echo "[STATE] WARN: ${JSON_PATH} not found. Skipping."
+  exit 0
+fi
+
+tmp_state="$(mktemp)"
+trap 'rm -f "${tmp_state}"' EXIT
+cp -f "${JSON_PATH}" "${tmp_state}"
+
+# IMPORTANT: avoid "untracked would be overwritten by checkout"
+rm -f "${JSON_PATH}" || true
+
+if git ls-remote --exit-code --heads origin bot-state >/dev/null 2>&1; then
+  git fetch --no-tags origin bot-state:refs/remotes/origin/bot-state >/dev/null 2>&1 || true
+  git checkout -B bot-state origin/bot-state
+else
+  git checkout --orphan bot-state
+  git rm -r --cached . >/dev/null 2>&1 || true
+fi
+
+mkdir -p "${STATE_DIR}"
+cp -f "${tmp_state}" "${JSON_PATH}"
+
+git add -f "${JSON_PATH}"
+git status --porcelain
+if git diff --cached --quiet; then
+  echo "[STATE] No changes to commit."
+  exit 0
+fi
+
+git commit -m "Update bot state (plain) [skip ci]"
+git push --force-with-lease origin HEAD:bot-state
+echo "[STATE] Pushed ${JSON_PATH} to bot-state branch."
diff --git a/trader/config.py b/trader/config.py
index 422be67deb716b524eac9f0c3f5b5878aabebb81..e7e0d81e9202f92a546b8364e1a3c07786e4598e 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -2,50 +2,51 @@
 """ê³µìš© ì„¤ì • ë° í™˜ê²½ íŒŒì‹± ëª¨ë“ˆ.
 
 trader.pyê°€ ë¶„ë¦¬ë˜ì–´ë„ ëª¨ë“  ì „ëµ/ìœ í‹¸ì´ ë™ì¼í•œ ì„¤ì •ì„ ì°¸ì¡°í•  ìˆ˜ ìˆë„ë¡
 CONFIGì™€ íŒŒìƒ ìƒìˆ˜ë¥¼ í•œ ê³³ì— ëª¨ì•˜ë‹¤.
 """
 from __future__ import annotations
 
 import logging
 import os
 from datetime import datetime, time as dtime
 from pathlib import Path
 from typing import Dict
 from zoneinfo import ZoneInfo
 
 # =========================
 # [CONFIG] .env ì—†ì´ë„ ë™ì‘
 # - ì•„ë˜ ê°’ì„ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©
 # - (ì„ íƒ) ë™ì¼ í‚¤ë¥¼ í™˜ê²½ë³€ìˆ˜ë¡œ ë„˜ê¸°ë©´ override
 # =========================
 CONFIG = {
     "SELL_FORCE_TIME": "14:40",
     "SELL_ALL_BALANCES_AT_CUTOFF": "false",  # "true"ë©´ ì»¤íŠ¸ì˜¤í”„ì— ì „ì²´ ì”ê³  í¬í•¨ ê°•ì œë§¤ë„ ë£¨í‹´ ì‚¬ìš©
     "API_RATE_SLEEP_SEC": "0.5",
     "FORCE_SELL_PASSES_CUTOFF": "2",
     "FORCE_SELL_PASSES_CLOSE": "4",
+    "FORCE_SELL_BLOCKED_LOTS": "0",
     "PARTIAL1": "0.5",
     "PARTIAL2": "0.3",
     "TRAIL_PCT": "0.02",
     "FAST_STOP": "0.01",
     "ATR_STOP": "1.5",
     "TIME_STOP_HHMM": "13:00",
     "DEFAULT_PROFIT_PCT": "3.0",
     "DEFAULT_LOSS_PCT": "-5.0",
     "DAILY_CAPITAL": "250000000",
     "CAP_CAP": "0.8",
     "SLIPPAGE_LIMIT_PCT": "0.25",
     "SLIPPAGE_ENTER_GUARD_PCT": "2.5",
     "VWAP_TOL": "0.003",  # ğŸ”¸ VWAP í—ˆìš© ì˜¤ì°¨(ê¸°ë³¸ 0.3%)
     "W_MAX_ONE": "0.25",
     "W_MIN_ONE": "0.03",
     "REBALANCE_ANCHOR": "weekly",             # weekly | today | monthly
     "WEEKLY_ANCHOR_REF": "last",              # NEW: 'last'(ì§ì „ ì¼ìš”ì¼) | 'next'(ë‹¤ìŒ ì¼ìš”ì¼)
     "MOMENTUM_OVERRIDES_FORCE_SELL": "true",
     # ë ˆì§(ì½”ìŠ¤ë‹¥) íŒŒë¼ë¯¸í„°
     "KOSDAQ_INDEX_CODE": "KOSDAQ",
     "KOSDAQ_ETF_FALLBACK": "229200",
     "REG_BULL_MIN_UP_PCT": "0.5",
     "REG_BULL_MIN_MINUTES": "10",
     "REG_BEAR_VWAP_MINUTES": "10",
     "REG_BEAR_DROP_FROM_HIGH": "0.7",
@@ -97,50 +98,51 @@ def _cfg(key: str) -> str:
     return os.getenv(key, CONFIG.get(key, ""))
 
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 LOG_DIR = Path(__file__).parent / "logs"
 LOG_DIR.mkdir(exist_ok=True)
 STATE_FILE = Path(__file__).parent / "trade_state.json"
 
 # ì¢…ëª©ë³„ ì‹œì¥ì½”ë“œ ê³ ì • ë§µ (ì‹¤ì „ì—ì„œëŠ” ë§ˆìŠ¤í„°í…Œì´ë¸” ë¡œë“œë¡œ ëŒ€ì²´ ê¶Œì¥)
 MARKET_MAP: Dict[str, str] = {
     # ì˜ˆì‹œ: '145020': 'J', '347850': 'J', '257720': 'U', '178320': 'J', '348370': 'U'
 }
 
 # ë°ì´í„° ì—†ìŒ 1ì°¨ ê°ì§€ ìƒíƒœ ì €ì¥(ì—°ì† DATA_EMPTY í™•ì¸ìš©)
 EXCLUDE_STATE: Dict[str, Dict[str, bool]] = {}
 
 KST = ZoneInfo("Asia/Seoul")
 
 SELL_FORCE_TIME_STR = _cfg("SELL_FORCE_TIME").strip()
 SELL_ALL_BALANCES_AT_CUTOFF = _cfg("SELL_ALL_BALANCES_AT_CUTOFF").lower() == "true"
 RATE_SLEEP_SEC = float(_cfg("API_RATE_SLEEP_SEC"))
 FORCE_SELL_PASSES_CUTOFF = int(_cfg("FORCE_SELL_PASSES_CUTOFF"))
 FORCE_SELL_PASSES_CLOSE = int(_cfg("FORCE_SELL_PASSES_CLOSE"))
+FORCE_SELL_BLOCKED_LOTS = _cfg("FORCE_SELL_BLOCKED_LOTS").lower() in ("1", "true", "yes")
 PARTIAL1 = float(_cfg("PARTIAL1"))
 PARTIAL2 = float(_cfg("PARTIAL2"))
 TRAIL_PCT = float(_cfg("TRAIL_PCT"))
 FAST_STOP = float(_cfg("FAST_STOP"))
 ATR_STOP = float(_cfg("ATR_STOP"))
 TIME_STOP_HHMM = _cfg("TIME_STOP_HHMM")
 DEFAULT_PROFIT_PCT = float(_cfg("DEFAULT_PROFIT_PCT"))
 DEFAULT_LOSS_PCT = float(_cfg("DEFAULT_LOSS_PCT"))
 DAILY_CAPITAL = int(_cfg("DAILY_CAPITAL"))
 CAP_CAP = float(_cfg("CAP_CAP"))
 SLIPPAGE_LIMIT_PCT = float(_cfg("SLIPPAGE_LIMIT_PCT"))
 SLIPPAGE_ENTER_GUARD_PCT = float(_cfg("SLIPPAGE_ENTER_GUARD_PCT"))
 VWAP_TOL = float(_cfg("VWAP_TOL"))  # ğŸ”¸ VWAP í—ˆìš© ì˜¤ì°¨(ì˜ˆ: 0.003 = -0.3%ê¹Œì§€ í—ˆìš©)
 W_MAX_ONE = float(_cfg("W_MAX_ONE"))
 W_MIN_ONE = float(_cfg("W_MIN_ONE"))
 ALLOW_PYRAMID = (_cfg("ALLOW_PYRAMID") or "false").lower() == "true"
 REBALANCE_ANCHOR = _cfg("REBALANCE_ANCHOR")
 WEEKLY_ANCHOR_REF = _cfg("WEEKLY_ANCHOR_REF").lower()
 MOMENTUM_OVERRIDES_FORCE_SELL = _cfg("MOMENTUM_OVERRIDES_FORCE_SELL").lower() == "true"
 BASE_QTY_MODE = (_cfg("BASE_QTY_MODE") or "initial").lower()
 if BASE_QTY_MODE not in {"initial", "current"}:
     logging.getLogger(__name__).warning(
         f"[CONFIG] BASE_QTY_MODE={BASE_QTY_MODE} ì§€ì› ì•ˆ í•¨ â†’ initialë¡œ ëŒ€ì²´"
     )
     BASE_QTY_MODE = "initial"
@@ -192,26 +194,25 @@ GOOD_ENTRY_MIN_INTRADAY_SIG = 2  # GOOD íƒ€ì ìœ¼ë¡œ ì¸ì •í•˜ê¸° ìœ„í•œ ìµœì†Œ
 BAD_ENTRY_MAX_MA20_DIST = 1.25  # í˜„ì¬ê°€/20MA ìƒí•œ(ì¶”ê²©ë§¤ìˆ˜ ë°©ì§€)
 BAD_ENTRY_MAX_PULLBACK = 20.0  # ì‹ ê³ ê°€ ëŒ€ë¹„ ëˆŒë¦¼í­ ìƒí•œ(ê³¼ë„í•œ ë¶•ê´´ ë°©ì§€)
 BAD_ENTRY_MAX_BELOW_VWAP_RATIO = 0.7  # ë¶„ë´‰ì—ì„œ VWAP ì•„ë˜ ì²´ë¥˜ ë¹„ì¤‘ì´ ì´ ì´ìƒì´ë©´ BAD
 NEUTRAL_ENTRY_SCALE = float(_cfg("NEUTRAL_ENTRY_SCALE") or "0.6")
 
 
 def _parse_hhmm(hhmm: str) -> dtime:
     try:
         hh, mm = hhmm.split(":")
         return dtime(hour=int(hh), minute=int(mm))
     except Exception:
         logger.warning(f"[ì„¤ì •ê²½ê³ ] SELL_FORCE_TIME í˜•ì‹ ì˜¤ë¥˜ â†’ ê¸°ë³¸ê°’ 14:40 ì ìš©: {hhmm}")
         return dtime(hour=14, minute=40)
 
 
 SELL_FORCE_TIME = _parse_hhmm(SELL_FORCE_TIME_STR)
 TIME_STOP_TIME = _parse_hhmm(TIME_STOP_HHMM)
 ALLOW_WHEN_CLOSED = _cfg("MARKET_DATA_WHEN_CLOSED").lower() == "true"
 
 # === [NEW] ì£¼ê°„ ë¦¬ë°¸ëŸ°ì‹± ê°•ì œ íŠ¸ë¦¬ê±° ìƒíƒœ íŒŒì¼ ===
 STATE_WEEKLY_PATH = Path(__file__).parent / "state_weekly.json"
 
 def _this_iso_week_key(now=None):
     now = now or datetime.now(KST)
     return f"{now.year}-W{now.isocalendar().week:02d}"
-
diff --git a/trader/ledger.py b/trader/ledger.py
new file mode 100644
index 0000000000000000000000000000000000000000..9100e77815e899b10e9f8fd6a780292eccf4cf34
--- /dev/null
+++ b/trader/ledger.py
@@ -0,0 +1,194 @@
+from __future__ import annotations
+
+from datetime import datetime
+from typing import Any, Dict, List
+
+from .config import KST
+
+
+def _normalize_code(pdno: str) -> str:
+    return str(pdno).zfill(6)
+
+
+def _ensure_state(state: Dict[str, Any]) -> List[Dict[str, Any]]:
+    lots = state.get("lots")
+    if not isinstance(lots, list):
+        lots = []
+        state["lots"] = lots
+    return lots
+
+
+def _norm_sid(value: int | str | None) -> int | str | None:
+    if value is None:
+        return None
+    text = str(value)
+    return int(text) if text.isdigit() else text
+
+
+def record_buy_fill(
+    state: Dict[str, Any],
+    *,
+    lot_id: str,
+    pdno: str,
+    strategy_id: int | str,
+    engine: str,
+    entry_ts: str,
+    entry_price: float,
+    qty: int,
+    meta: Dict[str, Any] | None,
+) -> None:
+    lots = _ensure_state(state)
+    if any(lot.get("lot_id") == lot_id for lot in lots):
+        return
+    lots.append(
+        {
+            "lot_id": lot_id,
+            "pdno": _normalize_code(pdno),
+            "strategy_id": strategy_id,
+            "engine": engine,
+            "entry_ts": entry_ts,
+            "entry_price": float(entry_price),
+            "qty": int(qty),
+            "remaining_qty": int(qty),
+            "meta": meta or {},
+        }
+    )
+
+
+def apply_sell_fill_fifo(
+    state: Dict[str, Any],
+    *,
+    pdno: str,
+    qty_filled: int,
+    sell_ts: str,
+    strategy_id: int | str | None = None,
+    allow_blocked: bool = False,
+) -> None:
+    lots = _ensure_state(state)
+    remaining = int(qty_filled)
+    if remaining <= 0:
+        return
+    req_sid = _norm_sid(strategy_id)
+    for lot in lots:
+        if _normalize_code(lot.get("pdno")) != _normalize_code(pdno):
+            continue
+        if not allow_blocked and lot.get("meta", {}).get("sell_blocked") is True:
+            continue
+        lot_sid = _norm_sid(lot.get("strategy_id"))
+        if req_sid is not None and lot_sid != req_sid:
+            continue
+        lot_remaining = int(lot.get("remaining_qty") or 0)
+        if lot_remaining <= 0:
+            continue
+        delta = min(lot_remaining, remaining)
+        lot["remaining_qty"] = int(lot_remaining - delta)
+        if delta > 0:
+            lot["last_sell_ts"] = sell_ts
+        remaining -= delta
+        if remaining <= 0:
+            break
+
+
+def owned_lots_by_strategy(state: Dict[str, Any], strategy_id: int | str) -> List[Dict[str, Any]]:
+    lots = _ensure_state(state)
+    return [
+        lot
+        for lot in lots
+        if int(lot.get("remaining_qty") or 0) > 0
+        and _norm_sid(lot.get("strategy_id")) == _norm_sid(strategy_id)
+    ]
+
+
+def remaining_qty_for_strategy(state: Dict[str, Any], pdno: str, strategy_id: int | str) -> int:
+    lots = _ensure_state(state)
+    total = 0
+    for lot in lots:
+        if _normalize_code(lot.get("pdno")) != _normalize_code(pdno):
+            continue
+        if int(lot.get("remaining_qty") or 0) <= 0:
+            continue
+        if _norm_sid(lot.get("strategy_id")) != _norm_sid(strategy_id):
+            continue
+        total += int(lot.get("remaining_qty") or 0)
+    return total
+
+
+def dominant_strategy_for(state: Dict[str, Any], pdno: str) -> int | None:
+    lots = _ensure_state(state)
+    totals: Dict[int, int] = {}
+    for lot in lots:
+        if _normalize_code(lot.get("pdno")) != _normalize_code(pdno):
+            continue
+        remaining = int(lot.get("remaining_qty") or 0)
+        if remaining <= 0:
+            continue
+        sid = _norm_sid(lot.get("strategy_id"))
+        if isinstance(sid, int) and 1 <= sid <= 5:
+            totals[sid] = totals.get(sid, 0) + remaining
+    if not totals:
+        return None
+    return max(totals.items(), key=lambda item: item[1])[0]
+
+
+def reconcile_with_broker_holdings(state: Dict[str, Any], holdings: List[Dict[str, Any]]) -> None:
+    lots = _ensure_state(state)
+    holdings_map: Dict[str, Dict[str, Any]] = {}
+    for row in holdings:
+        code = _normalize_code(row.get("code") or row.get("pdno") or "")
+        if not code:
+            continue
+        qty = int(row.get("qty") or 0)
+        avg_price = row.get("avg_price")
+        existing = holdings_map.get(code)
+        if existing:
+            existing["qty"] += qty
+            if existing.get("avg_price") is None:
+                existing["avg_price"] = avg_price
+        else:
+            holdings_map[code] = {"qty": qty, "avg_price": avg_price}
+
+    now_ts = datetime.now(KST).isoformat()
+
+    for lot in lots:
+        pdno = _normalize_code(lot.get("pdno"))
+        if pdno not in holdings_map or holdings_map[pdno]["qty"] <= 0:
+            if int(lot.get("remaining_qty") or 0) > 0:
+                lot["remaining_qty"] = 0
+
+    for pdno, payload in holdings_map.items():
+        hold_qty = int(payload.get("qty") or 0)
+        if hold_qty <= 0:
+            continue
+        total_remaining = sum(
+            int(lot.get("remaining_qty") or 0)
+            for lot in lots
+            if _normalize_code(lot.get("pdno")) == pdno
+        )
+        if total_remaining < hold_qty:
+            diff = hold_qty - total_remaining
+            lots.append(
+                {
+                    "lot_id": f"{pdno}-RECON-{now_ts}",
+                    "pdno": pdno,
+                    "strategy_id": "UNKNOWN",
+                    "engine": "reconcile",
+                    "entry_ts": now_ts,
+                    "entry_price": float(payload.get("avg_price") or 0.0),
+                    "qty": int(diff),
+                    "remaining_qty": int(diff),
+                    "meta": {"reconciled": True, "sell_blocked": True},
+                }
+            )
+        elif total_remaining > hold_qty:
+            extra = total_remaining - hold_qty
+            for lot in reversed(lots):
+                if _normalize_code(lot.get("pdno")) != pdno:
+                    continue
+                lot_remaining = int(lot.get("remaining_qty") or 0)
+                if lot_remaining <= 0:
+                    continue
+                delta = min(lot_remaining, extra)
+                lot["remaining_qty"] = int(lot_remaining - delta)
+                extra -= delta
+                if extra <= 0:
+                    break
diff --git a/trader/ledger_test.py b/trader/ledger_test.py
new file mode 100644
index 0000000000000000000000000000000000000000..24e5eabb7af43b286aeca438043220600c176a5e
--- /dev/null
+++ b/trader/ledger_test.py
@@ -0,0 +1,63 @@
+from __future__ import annotations
+
+from trader.ledger import apply_sell_fill_fifo, record_buy_fill
+
+
+def _sample_state() -> dict:
+    return {"version": 1, "lots": [], "updated_at": None}
+
+
+def test_fifo_and_fallback() -> None:
+    state = _sample_state()
+    record_buy_fill(
+        state,
+        lot_id="L1",
+        pdno="005930",
+        strategy_id=1,
+        engine="test",
+        entry_ts="2025-01-01T09:00:00+09:00",
+        entry_price=70000.0,
+        qty=5,
+        meta={},
+    )
+    record_buy_fill(
+        state,
+        lot_id="L2",
+        pdno="005930",
+        strategy_id=2,
+        engine="test",
+        entry_ts="2025-01-01T09:05:00+09:00",
+        entry_price=70500.0,
+        qty=5,
+        meta={},
+    )
+
+    apply_sell_fill_fifo(
+        state,
+        pdno="005930",
+        qty_filled=3,
+        sell_ts="2025-01-01T10:00:00+09:00",
+        strategy_id=1,
+    )
+    lots = state["lots"]
+    assert lots[0]["remaining_qty"] == 2
+    assert lots[1]["remaining_qty"] == 5
+
+    apply_sell_fill_fifo(
+        state,
+        pdno="005930",
+        qty_filled=4,
+        sell_ts="2025-01-01T10:10:00+09:00",
+        strategy_id=1,
+    )
+    assert lots[0]["remaining_qty"] == 0
+    assert lots[1]["remaining_qty"] == 3
+
+
+def main() -> None:
+    test_fifo_and_fallback()
+    print("OK")
+
+
+if __name__ == "__main__":
+    main()
diff --git a/trader/legacy_kosdaq_runner.py b/trader/legacy_kosdaq_runner.py
index a6582d9c89b18fb078ecff4e2f090255f1e9cbf4..6cfd01a59e3e9870e60c3c5f0d31bc870c43bc39 100644
--- a/trader/legacy_kosdaq_runner.py
+++ b/trader/legacy_kosdaq_runner.py
@@ -1,86 +1,97 @@
 # -*- coding: utf-8 -*-
 """ê±°ë˜ ë©”ì¸ ë£¨í”„.
 
 ê¸°ì¡´ trader.pyì˜ ì„¤ì •/ìœ í‹¸ì„ ë¶„ë¦¬í•˜ê³ , ë©”ì¸ ì§„ì…ì ë§Œ ë‚¨ê²¨ ì „ëµ ì¶”ê°€ê°€
 ì‰¬ìš´ êµ¬ì¡°ë¡œ ë³€ê²½í–ˆë‹¤.
 """
 from __future__ import annotations
 
 import json
+import re
 import time
 from datetime import date, datetime, time as dtime, timedelta
 from typing import Any, Dict, List, Tuple, TYPE_CHECKING
 
 
 try:
     from .config import (
         DAILY_CAPITAL,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
+        FORCE_SELL_BLOCKED_LOTS,
         ALLOW_WHEN_CLOSED,
         ALLOW_PYRAMID,
         BASE_QTY_MODE,
         KST,
         LOG_DIR,
         RATE_SLEEP_SEC,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         _cfg,
         logger,
     )
 except ImportError:
     # ALLOW_WHEN_CLOSEDê°€ ëˆ„ë½ë¼ë„ ëŸ¬ë„ˆê°€ ì¦‰ì‹œ ì¤‘ë‹¨ë˜ì§€ ì•Šë„ë¡ ì•ˆì „í•œ ê¸°ë³¸ê°’ì„ ì œê³µí•œë‹¤.
     from .config import (
         DAILY_CAPITAL,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
+        FORCE_SELL_BLOCKED_LOTS,
         KST,
         LOG_DIR,
         BASE_QTY_MODE,
         RATE_SLEEP_SEC,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         _cfg,
         logger,
     )
 
     ALLOW_WHEN_CLOSED = False
     logger.warning("[CONFIG] ALLOW_WHEN_CLOSED missing; defaulting to False")
     ALLOW_PYRAMID = False
     logger.warning("[CONFIG] ALLOW_PYRAMID missing; defaulting to False")
 from . import signals
 from trader.time_utils import MARKET_CLOSE, MARKET_OPEN, is_trading_day
 from trader.subject_flow import get_subject_flow_with_fallback, reset_flow_call_count
+from trader.ledger import (
+    apply_sell_fill_fifo,
+    dominant_strategy_for,
+    record_buy_fill,
+    remaining_qty_for_strategy,
+    reconcile_with_broker_holdings,
+)
+from trader.state_store import load_state as load_lot_state, save_state as save_lot_state
 from .core import *  # noqa: F401,F403 - ì „ëµ ìœ í‹¸ ì „ì²´ ë…¸ì¶œë¡œ í™•ì¥ì„± í™•ë³´
 
 if TYPE_CHECKING:
     # core ìª½ì— êµ¬í˜„ë¼ ìˆëŠ” í—¬í¼ë“¤ì„ íƒ€ì…ì²´ì»¤ì—ê²Œë§Œ ëª…ì‹œì ìœ¼ë¡œ ì•Œë ¤ì¤€ë‹¤.
     from .core import (
         _this_iso_week_key,
         _get_effective_ord_cash,
         _to_float,
         _to_int,
         _weight_to_qty,
         _classify_champion_grade,
         _update_market_regime,
         _notional_to_qty,
         _fetch_balances,
         _init_position_state_from_balance,
         _sell_once,
         _adaptive_exit,
         _compute_daily_entry_context,
         _compute_intraday_entry_context,
         _safe_get_price,
         _round_to_tick,
         _init_position_state,
         _detect_pullback_reversal,
         _has_bullish_trend_structure,
     )
@@ -94,98 +105,314 @@ def main(
     effective_capital = (
         int(capital_override) if capital_override is not None else DAILY_CAPITAL
     )
     kis = KisAPI()
 
     rebalance_date = get_rebalance_anchor_date()
     logger.info(
         f"[â„¹ï¸ ë¦¬ë°¸ëŸ°ì‹± ê¸°ì¤€ì¼(KST)]: {rebalance_date} (anchor={REBALANCE_ANCHOR}, ref={WEEKLY_ANCHOR_REF})"
     )
     logger.info(
         f"[â±ï¸ ì»¤íŠ¸ì˜¤í”„(KST)] SELL_FORCE_TIME={SELL_FORCE_TIME.strftime('%H:%M')} / ì „ì²´ì”ê³ ë§¤ë„={SELL_ALL_BALANCES_AT_CUTOFF} / "
         f"íŒ¨ìŠ¤(ì»¤íŠ¸ì˜¤í”„/ë§ˆê°)={FORCE_SELL_PASSES_CUTOFF}/{FORCE_SELL_PASSES_CLOSE}"
     )
     logger.info(
         f"[ğŸ’° CAPITAL] {effective_capital:,}ì› (configured DAILY_CAPITAL={DAILY_CAPITAL:,})"
     )
     logger.info(f"[ğŸ›¡ï¸ SLIPPAGE_ENTER_GUARD_PCT] {SLIPPAGE_ENTER_GUARD_PCT:.2f}%")
 
     # ìƒíƒœ ë³µêµ¬
     state_loaded_at = datetime.now(KST)
     state_loaded_date = state_loaded_at.strftime("%Y-%m-%d")
     state_loaded_str = state_loaded_at.strftime("%Y-%m-%d %H:%M:%S")
     state_loaded_midnight = f"{state_loaded_date} 00:00:00"
 
     holding, traded = load_state()
+    lot_state_path = "bot_state/state.json"
+    lot_state = load_lot_state(lot_state_path)
     triggered_today: set[str] = set()
     s1_done_today: set[str] = set()
     last_price_map: dict[str, float] = {}
     last_today_prefix: str | None = None
 
     if isinstance(traded, (set, list, tuple)):
         logger.warning(
             f"[STATE-MIGRATE] traded íƒ€ì… {type(traded)} â†’ dictë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜(ì¤‘ë³µ ì§„ì… ê°€ë“œ ìœ ì§€)"
         )
         traded = {
             code: {"buy_time": state_loaded_midnight, "qty": 0, "price": 0.0}
             for code in traded
         }
     elif not isinstance(traded, dict):
         logger.warning(
             f"[STATE-FORMAT] traded íƒ€ì… {type(traded)} ì§€ì› ì•ˆ í•¨ â†’ ë¹ˆ dictë¡œ ì¬ì„¤ì •"
         )
         traded = {}
 
     def _traded_codes(traded_state: Any) -> List[str]:
         if isinstance(traded_state, dict):
             return list(traded_state.keys())
         return []
 
     def _traded_today(traded_state: Any, today_prefix: str) -> set:
         if not isinstance(traded_state, dict):
             return set()
 
         today_codes = set()
         for code, payload in traded_state.items():
             payload = payload or {}
             buy_time = payload.get("buy_time")
             status = payload.get("status")
             # pending/other ìƒíƒœëŠ” ì¬ì‹œë„ í—ˆìš©, filled/ê¸°ì¡´(None)ë§Œ ì¤‘ë³µ ë°©ì§€
             if status not in (None, "filled"):
                 continue
             if isinstance(buy_time, str) and buy_time.startswith(today_prefix):
                 today_codes.add(code)
         return today_codes
 
     def _record_trade(traded_state: Any, code: str, payload: Dict[str, Any]) -> None:
         try:
             traded_state[code] = payload
         except Exception:
             logger.warning(
                 f"[TRADED-STATE] tradedì— ì½”ë“œ ì¶”ê°€ ì‹¤íŒ¨: type={type(traded_state)}"
             )
 
+    def _lot_state_signature(state: dict) -> tuple:
+        lots = state.get("lots")
+        if not isinstance(lots, list):
+            return tuple()
+        return tuple(
+            (
+                str(lot.get("lot_id")),
+                str(lot.get("pdno")),
+                int(lot.get("remaining_qty") or 0),
+            )
+            for lot in lots
+        )
+
+    def _maybe_save_lot_state(before_signature: tuple) -> None:
+        after_signature = _lot_state_signature(lot_state)
+        if after_signature != before_signature:
+            save_lot_state(lot_state_path, lot_state)
+
+    def _remaining_qty_for(pdno: str) -> int:
+        return sum(
+            int(lot.get("remaining_qty") or 0)
+            for lot in lot_state.get("lots", [])
+            if str(lot.get("pdno")).zfill(6) == str(pdno).zfill(6)
+        )
+
+    def _normalize_strategy_id(value: Any) -> int:
+        try:
+            strategy_num = int(value)
+        except Exception:
+            return 1
+        if 1 <= strategy_num <= 5:
+            return strategy_num
+        return 1
+
+    def _derive_strategy_id(payload: Dict[str, Any]) -> int:
+        raw = (
+            payload.get("strategy_id")
+            or payload.get("strategyId")
+            or payload.get("strategy_no")
+            or payload.get("strategyNo")
+        )
+        if raw is not None and str(raw).isdigit():
+            strategy_id = _normalize_strategy_id(raw)
+            if strategy_id != int(raw):
+                logger.info(
+                    "[STRATEGY_ID_NORMALIZE] raw=%s -> %s (clamped)",
+                    raw,
+                    strategy_id,
+                )
+            return strategy_id
+        name = str(payload.get("strategy") or "")
+        name_lower = name.lower()
+        match = re.search(r"(?:ì „ëµ|strategy)\s*([1-5])", name_lower)
+        if match:
+            strategy_id = _normalize_strategy_id(match.group(1))
+            logger.info(
+                "[STRATEGY_ID_DERIVE] source=strategy_name(%s) -> %s",
+                name,
+                strategy_id,
+            )
+            return strategy_id
+        if "pullback" in name_lower or "ëˆŒë¦¼ëª©" in name:
+            logger.info("[STRATEGY_ID_DERIVE] source=pullback -> 5")
+            return 5
+        logger.info("[STRATEGY_ID_DERIVE] source=default -> 1")
+        return 1
+
+    def _build_lot_id(result: Any, fallback_ts: str, pdno: str) -> str:
+        order_no = ""
+        fill_seq = ""
+        if isinstance(result, dict):
+            out = result.get("output") or {}
+            order_no = (
+                out.get("ODNO")
+                or out.get("ord_no")
+                or out.get("order_no")
+                or result.get("ODNO")
+                or result.get("ord_no")
+                or result.get("order_no")
+                or ""
+            )
+            fill_seq = (
+                out.get("CCLD_SQ")
+                or out.get("ccld_sq")
+                or out.get("fill_seq")
+                or out.get("CCLD_NO")
+                or out.get("ccld_no")
+                or ""
+            )
+        if not order_no:
+            order_no = f"NOORDER-{str(pdno).zfill(6)}-{fallback_ts}"
+        if not fill_seq:
+            fill_seq = "0"
+        return f"{kis.CANO}-{kis.ACNT_PRDT_CD}-{order_no}-{fill_seq}"
+
+    def _resolve_sell_sid(code: str) -> int | None:
+        try:
+            sid = (holding.get(code) or {}).get("strategy_id")
+        except Exception:
+            sid = None
+        if sid is not None:
+            try:
+                return int(sid)
+            except Exception:
+                sid = None
+        dominant = dominant_strategy_for(lot_state, code)
+        if dominant is None:
+            return None
+        try:
+            return int(dominant)
+        except Exception:
+            return None
+
+    def _estimate_sold_qty(
+        code: str, requested_qty: int, prev_qty: int, delay_sec: float = 1.0
+    ) -> int:
+        if requested_qty <= 0:
+            return 0
+        try:
+            time.sleep(delay_sec)
+            try:
+                balances = _fetch_balances(kis, ttl_sec=0)
+            except TypeError:
+                balances = _fetch_balances(kis)
+        except Exception:
+            return int(requested_qty)
+        for row in balances:
+            if str(row.get("code")).zfill(6) != str(code).zfill(6):
+                continue
+            new_qty = int(row.get("qty") or 0)
+            sold = max(0, int(prev_qty) - int(new_qty))
+            if sold <= 0:
+                return 0
+            return min(int(requested_qty), int(sold))
+        return int(requested_qty)
+
+    def _apply_sell_to_ledger_with_balance(
+        code: str,
+        requested_qty: int,
+        sell_ts: str,
+        result: Any,
+        strategy_id: int | None = None,
+        prev_qty_before: int | None = None,
+        allow_blocked: bool = False,
+    ) -> None:
+        if not _is_order_success(result):
+            return
+        prev_qty = int(prev_qty_before if prev_qty_before is not None else (holding.get(code) or {}).get("qty") or requested_qty)
+        if strategy_id is not None:
+            available_qty = remaining_qty_for_strategy(lot_state, code, strategy_id)
+            requested_qty = min(int(requested_qty), int(available_qty))
+            if requested_qty <= 0:
+                return
+        sold_qty = _estimate_sold_qty(code, requested_qty, prev_qty)
+        if sold_qty <= 0:
+            return
+        before_lot_signature = _lot_state_signature(lot_state)
+        _apply_sell_to_ledger(
+            code,
+            int(sold_qty),
+            sell_ts,
+            result,
+            strategy_id=strategy_id,
+            allow_blocked=allow_blocked,
+        )
+        _maybe_save_lot_state(before_lot_signature)
+
+    def _apply_sell_to_ledger(
+        pdno: str,
+        qty: int,
+        sell_ts: str,
+        result: Any,
+        strategy_id: int | None = None,
+        allow_blocked: bool = False,
+    ) -> None:
+        if not _is_order_success(result):
+            return
+        before = _remaining_qty_for(pdno)
+        apply_sell_fill_fifo(
+            lot_state,
+            pdno=pdno,
+            qty_filled=qty,
+            sell_ts=sell_ts,
+            strategy_id=strategy_id,
+            allow_blocked=allow_blocked,
+        )
+        after = _remaining_qty_for(pdno)
+        logger.info(
+            "[LEDGER][SELL] code=%s sid=%s sold=%s before=%s after=%s",
+            pdno,
+            strategy_id,
+            qty,
+            before,
+            after,
+        )
+        if strategy_id is not None and after == before:
+            apply_sell_fill_fifo(
+                lot_state,
+                pdno=pdno,
+                qty_filled=qty,
+                sell_ts=sell_ts,
+                strategy_id=None,
+                allow_blocked=allow_blocked,
+            )
+            fallback_after = _remaining_qty_for(pdno)
+            logger.info(
+                "[LEDGER][SELL][FALLBACK] code=%s sid=%s sold=%s before=%s after=%s",
+                pdno,
+                strategy_id,
+                qty,
+                before,
+                fallback_after,
+            )
+
     def _cleanup_expired_pending(
         traded_state: dict, now_dt: datetime, ttl_sec: int = 300
     ) -> set:
         expired: set[str] = set()
         if not isinstance(traded_state, dict):
             return expired
 
         for code, payload in list(traded_state.items()):
             payload = payload or {}
             if payload.get("status") != "pending":
                 continue
 
             ts = payload.get("pending_since") or payload.get("buy_time")
             if not isinstance(ts, str):
                 continue
 
             try:
                 pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(
                     tzinfo=now_dt.tzinfo
                 )
                 if (now_dt - pending_dt).total_seconds() > ttl_sec:
                     logger.warning(
                         f"[PENDING-EXPIRE] {code}: {ttl_sec}s ì´ˆê³¼ â†’ pending ì œê±°"
                     )
                     traded_state.pop(code, None)
@@ -472,76 +699,84 @@ def main(
         targets = fetch_rebalancing_targets(rebalance_date)
 
     # === [NEW] ì˜ˆì‚° ê°€ë“œ: ì˜ˆìˆ˜ê¸ˆì´ 0/ë¶€ì¡±ì´ë©´ ì‹ ê·œ ë§¤ìˆ˜ë§Œ ìŠ¤í‚µ ===
     effective_cash = _get_effective_ord_cash(kis, soft_cap=effective_capital)
     if effective_cash <= 0:
         can_buy = False
         logger.warning("[BUDGET] ìœ íš¨ ì˜ˆì‚° 0 â†’ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ(ë³´ìœ  ê´€ë¦¬ë§Œ ìˆ˜í–‰)")
     else:
         can_buy = True
     logger.info(
         f"[BUDGET] today effective cash = {effective_cash:,} KRW (capital base={effective_capital:,})"
     )
 
     # ë¦¬ë°¸ëŸ°ì‹± ëŒ€ìƒ í›„ì²˜ë¦¬: qty ì—†ê³  weightë§Œ ìˆìœ¼ë©´ ë°°ì • ìë³¸ìœ¼ë¡œ ìˆ˜ëŸ‰ ê³„ì‚°
     processed_targets: Dict[str, Any] = {}
     for t in targets:
         code = t.get("stock_code") or t.get("code")
         if not code:
             continue
         name = t.get("name") or t.get("ì¢…ëª©ëª…")
         k_best = t.get("best_k") or t.get("K") or t.get("k")
         target_price = _to_float(t.get("ëª©í‘œê°€") or t.get("target_price"))
         qty = _to_int(t.get("ë§¤ìˆ˜ìˆ˜ëŸ‰") or t.get("qty"), 0)
         weight = t.get("weight")
         strategy = t.get("strategy") or "ì „ì›” rolling K ìµœì í™”"
+        strategy_id = _normalize_strategy_id(_derive_strategy_id(t))
+        logger.info(
+            "[STRATEGY_ID_TARGET] code=%s strategy=%s strategy_id=%s",
+            code,
+            strategy,
+            strategy_id,
+        )
         avg_return_pct = _to_float(t.get("avg_return_pct") or t.get("ìˆ˜ìµë¥ (%)"), 0.0)
         win_rate_pct = _to_float(t.get("win_rate_pct") or t.get("ìŠ¹ë¥ (%)"), 0.0)
         mdd_pct = _to_float(t.get("mdd_pct") or t.get("MDD(%)"), 0.0)
         trades = _to_int(t.get("trades"), 0)
         sharpe_m = _to_float(t.get("sharpe_m"), 0.0)
         cumret_pct = _to_float(
             t.get("cumulative_return_pct") or t.get("ìˆ˜ìµë¥ (%)"), 0.0
         )
 
         if qty <= 0 and weight is not None:
             ref_px = _to_float(t.get("close")) or _to_float(t.get("prev_close"))
             try:
                 qty = _weight_to_qty(
                     kis, code, float(weight), effective_capital, ref_price=ref_px
                 )
             except Exception as e:
                 logger.warning("[REBALANCE] weightâ†’qty ë³€í™˜ ì‹¤íŒ¨ %s: %s", code, e)
                 qty = 0
 
         processed_targets[code] = {
             "code": code,
             "name": name,
             "best_k": k_best,
             "target_price": target_price,
             "qty": qty,
             "strategy": strategy,
+            "strategy_id": strategy_id,
             "avg_return_pct": avg_return_pct,
             "win_rate_pct": win_rate_pct,
             "mdd_pct": mdd_pct,
             "trades": trades,
             "sharpe_m": sharpe_m,
             "cumulative_return_pct": cumret_pct,
             "prev_open": t.get("prev_open"),
             "prev_high": t.get("prev_high"),
             "prev_low": t.get("prev_low"),
             "prev_close": t.get("prev_close"),
             "prev_volume": t.get("prev_volume"),
         }
 
     filtered_targets: Dict[str, Any] = {}
     for code, info in processed_targets.items():
         trades = _to_int(info.get("trades"), 0)
         win_rate = _to_float(info.get("win_rate_pct"), 0.0)
         mdd = abs(_to_float(info.get("mdd_pct"), 0.0) or 0.0)
         sharpe = _to_float(info.get("sharpe_m"), 0.0)
 
         if (
             trades < CHAMPION_MIN_TRADES
             or win_rate < CHAMPION_MIN_WINRATE
             or mdd > CHAMPION_MAX_MDD
             or sharpe < CHAMPION_MIN_SHARPE
@@ -913,50 +1148,64 @@ def main(
             else:
                 closed_checks = 0
 
             if kis.should_cooldown(now_dt_kst):
                 logger.warning("[COOLDOWN] 2ì´ˆê°„ ëŒ€ê¸° (API ì œí•œ ë³´í˜¸)")
                 time.sleep(2)
 
             # ì”ê³  ê°€ì ¸ì˜¤ê¸°
             prev_holding = holding if isinstance(holding, dict) else {}
             balances = _fetch_balances(kis)
             holding = {}
             for bal in balances:
                 code = bal.get("code")
                 qty = int(bal.get("qty", 0))
                 if qty <= 0:
                     continue
                 price = float(bal.get("avg_price", 0.0))
                 holding[code] = {
                     "qty": qty,
                     "buy_price": price,
                     "bear_s1_done": False,
                     "bear_s2_done": False,
                 }
                 _init_position_state_from_balance(kis, holding, code, price, qty)
 
+            for code in holding.keys():
+                sid = dominant_strategy_for(lot_state, code)
+                if sid is not None:
+                    holding[code]["strategy_id"] = sid
+                    logger.info(
+                        "[HOLDING_STRATEGY_RESTORE] code=%s sid=%s source=ledger",
+                        code,
+                        sid,
+                    )
+
+            before_lot_signature = _lot_state_signature(lot_state)
+            reconcile_with_broker_holdings(lot_state, balances)
+            _maybe_save_lot_state(before_lot_signature)
+
             # ì”ê³  ê¸°ì¤€ìœ¼ë¡œ ë³´ìœ ì¢…ëª© ë§¤ë„ ê°€ëŠ¥ ìˆ˜ëŸ‰ ë§µ ìƒì„±
             ord_psbl_map = {
                 bal.get("code"): int(bal.get("sell_psbl_qty", 0)) for bal in balances
             }
 
             if isinstance(traded, dict):
                 for code, payload in list(traded.items()):
                     if (payload or {}).get("status") == "pending" and code in holding:
                         traded[code]["status"] = "filled"
 
             traded_today = _traded_today(traded, today_prefix)
             for bal in balances:
                 code = bal.get("code")
                 raw = bal.get("raw") or {}
                 raw_l = {str(k).lower(): v for k, v in raw.items()}
                 thdt_buy_qty = _to_int(
                     raw_l.get("thdt_buyqty")
                     or raw_l.get("thdt_buy_qty")
                     or raw_l.get("thdt_buy_q")
                 )
                 if thdt_buy_qty > 0:
                     traded_today.add(code)
 
             if not ALLOW_PYRAMID:
                 traded_today.update(holding.keys())
@@ -986,67 +1235,77 @@ def main(
                         buy_dt = buy_dt.replace(tzinfo=now_dt_kst.tzinfo)
                         if now_dt_kst - buy_dt <= timedelta(
                             minutes=recent_keep_minutes
                         ):
                             holding[code] = info
                             ord_psbl_map.setdefault(code, int(info.get("qty", 0)))
                             logger.info(
                                 f"[HOLDING-MERGE] {code} ìµœê·¼ ë§¤ìˆ˜({buy_time_str}) ë°˜ì˜ â†’ ì”ê³  ë¯¸ë°˜ì˜ ë³´í˜¸"
                             )
                     except Exception as e:
                         logger.warning(f"[HOLDING-MERGE-FAIL] {code}: {e}")
 
             logger.info(
                 f"[STATUS] holdings={holding} traded_today={sorted(traded_today)} ord_psbl={ord_psbl_map}"
             )
 
             # ì»¤íŠ¸ì˜¤í”„ íƒ€ì„ ë„ë‹¬ ì‹œ ê°•ì œë§¤ë„ ë£¨í‹´
             if now_dt_kst.time() >= SELL_FORCE_TIME and SELL_ALL_BALANCES_AT_CUTOFF:
                 logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ë„ë‹¬: ì „ëŸ‰ë§¤ë„ ë£¨í‹´ ì‹¤í–‰]")
                 pass_count = FORCE_SELL_PASSES_CUTOFF
                 if now_dt_kst.time() >= dtime(hour=15, minute=0):
                     pass_count = FORCE_SELL_PASSES_CLOSE
                 for code, qty in ord_psbl_map.items():
                     if qty <= 0:
                         continue
+                    prev_qty_before = int((holding.get(code) or {}).get("qty") or 0)
                     exec_px, result = _sell_once(kis, code, qty, prefer_market=True)
                     log_trade(
                         {
                             "datetime": now_str,
                             "code": code,
                             "name": None,
                             "qty": int(qty),
                             "K": None,
                             "target_price": None,
                             "strategy": "ê°•ì œë§¤ë„",
                             "side": "SELL",
                             "price": exec_px,
                             "amount": int((exec_px or 0)) * int(qty),
                             "result": result,
                             "reason": "ì»¤íŠ¸ì˜¤í”„ ê°•ì œë§¤ë„",
                         }
                     )
+                    _apply_sell_to_ledger_with_balance(
+                        code,
+                        int(qty),
+                        now_dt_kst.isoformat(),
+                        result,
+                        strategy_id=None,
+                        prev_qty_before=prev_qty_before,
+                        allow_blocked=FORCE_SELL_BLOCKED_LOTS,
+                    )
                     time.sleep(RATE_SLEEP_SEC)
                 for _ in range(pass_count - 1):
                     logger.info(
                         f"[ì»¤íŠ¸ì˜¤í”„ ì¶”ê°€íŒ¨ìŠ¤] {pass_count}íšŒ ì¤‘ ë‚¨ì€ íŒ¨ìŠ¤ ì‹¤í–‰ (ì”ê³ ë³€ë™ ê°ì§€ìš©)"
                     )
                     time.sleep(loop_sleep_sec)
                     continue
                 logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ì¢…ë£Œ] ë£¨í”„ ì¢…ë£Œ")
                 break
 
             # === (1) ì”ì—¬ ë¬¼ëŸ‰ ëŒ€ìƒ ìŠ¤íƒ‘/ë¦¬ë°¸ëŸ°ìŠ¤ ê´€ë¦¬ ===
             for code in list(holding.keys()):
                 # ì‹ ê·œ ì§„ì… ê¸ˆì§€ ëª¨ë“œ
                 if code not in code_to_target:
                     continue
 
                 # --- 1a) ê°•ì œ ë ˆì§ë³„ ì¶•ì†Œ ë¡œì§ ---
                 sellable_qty = ord_psbl_map.get(code, 0)
                 if sellable_qty <= 0:
                     continue
 
                 regime_key = regime.get("key")
                 mode = regime.get("mode")
                 if regime_key and regime_key[0] == "bear":
                     if regime["bear_stage"] >= 1:
@@ -1070,92 +1329,122 @@ def main(
                         else:
                             target_qty = max(1, int(base_qty * REG_PARTIAL_S1))
                             sold_today = int(guard.get("sold", 0))
                             remaining = max(0, target_qty - sold_today)
 
                             if remaining <= 0 or sellable_qty <= 0:
                                 if remaining <= 0:
                                     holding[code]["bear_s1_done"] = True
                                     s1_done_today.add(code)
                                 regime_s1_summary["skipped"] += 1
                                 _log_s1_action(
                                     code,
                                     "SKIP",
                                     base_qty,
                                     target_qty,
                                     sold_today,
                                     remaining,
                                     0,
                                     (
                                         "target_met"
                                         if remaining <= 0
                                         else "no_sellable_qty"
                                     ),
                                 )
                             else:
+                                sid = _resolve_sell_sid(code)
                                 sell_qty = min(remaining, sellable_qty)
+                                if sid is not None:
+                                    sell_qty = min(
+                                        sell_qty,
+                                        remaining_qty_for_strategy(lot_state, code, sid),
+                                    )
+                                if sell_qty <= 0:
+                                    regime_s1_summary["skipped"] += 1
+                                    _log_s1_action(
+                                        code,
+                                        "SKIP",
+                                        base_qty,
+                                        target_qty,
+                                        sold_today,
+                                        remaining,
+                                        0,
+                                        "strategy_qty_zero",
+                                    )
+                                    continue
                                 regime_s1_summary["total_qty"] += int(sell_qty)
                                 try:
+                                    prev_qty_before = int(
+                                        (holding.get(code) or {}).get("qty") or 0
+                                    )
                                     exec_px, result = _sell_once(
                                         kis, code, sell_qty, prefer_market=True
                                     )
                                     status, skip_reason = _sell_result_status(result)
                                 except Exception as e:
                                     exec_px, result = None, None
                                     status, skip_reason = "ERROR", str(e)
 
                                 reason_msg = skip_reason or "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ"
 
                                 if status == "SENT":
                                     guard["sold"] = sold_today + int(sell_qty)
                                     holding[code]["qty"] = max(
                                         0, holding[code]["qty"] - int(sell_qty)
                                     )
                                     if guard["sold"] >= target_qty:
                                         holding[code]["bear_s1_done"] = True
                                         s1_done_today.add(code)
                                     _persist_guard_state(now_dt_kst.date())
                                     regime_s1_summary["sent_qty"] += int(sell_qty)
                                     regime_s1_summary["sent_orders"] += 1
                                     trade_payload = {
                                         "datetime": now_str,
                                         "code": code,
                                         "name": None,
                                         "qty": int(sell_qty),
                                         "K": holding[code].get("k_value"),
                                         "target_price": holding[code].get(
                                             "target_price_src"
                                         ),
                                         "strategy": "ë ˆì§ì¶•ì†Œ",  # ì‹ ê·œ ì „ëµ êµ¬ë¶„ì„ ìœ„í•´ strategy í•„ë“œ í™œìš©
                                         "side": "SELL",
                                         "price": exec_px,
                                         "amount": int((exec_px or 0)) * int(sell_qty),
                                         "reason": reason_msg,
                                     }
                                     if result is not None:
                                         trade_payload["result"] = result
                                     log_trade(trade_payload)
+                                    _apply_sell_to_ledger_with_balance(
+                                        code,
+                                        int(sell_qty),
+                                        now_dt_kst.isoformat(),
+                                        result,
+                                        strategy_id=sid,
+                                        prev_qty_before=prev_qty_before,
+                                    )
                                     save_state(holding, traded)
                                     time.sleep(RATE_SLEEP_SEC)
                                 elif status == "SKIP":
                                     regime_s1_summary["skipped"] += 1
                                 else:
                                     regime_s1_summary["skipped"] += 1
 
                                 _log_s1_action(
                                     code,
                                     status,
                                     base_qty,
                                     target_qty,
                                     sold_today,
                                     remaining,
                                     sell_qty,
                                     reason_msg,
                                 )
 
                     if regime["bear_stage"] >= 2 and not holding[code].get(
                         "bear_s2_done"
                     ):
                         if not holding[code].get("bear_s1_done"):
                             _log_s2_action(
                                 code,
                                 "SKIP",
@@ -1188,157 +1477,214 @@ def main(
                                 "base_qty_zero",
                             )
                         else:
                             target_qty = max(1, int(base_qty * REG_PARTIAL_S2))
                             sold_today = int(guard.get("sold", 0))
                             remaining = max(0, target_qty - sold_today)
 
                             if remaining <= 0 or sellable_qty <= 0:
                                 if remaining <= 0:
                                     holding[code]["bear_s2_done"] = True
                                 _log_s2_action(
                                     code,
                                     "SKIP",
                                     base_qty,
                                     target_qty,
                                     sold_today,
                                     remaining,
                                     0,
                                     (
                                         "target_met"
                                         if remaining <= 0
                                         else "no_sellable_qty"
                                     ),
                                 )
                             else:
+                                sid = _resolve_sell_sid(code)
                                 sell_qty = min(remaining, sellable_qty)
+                                if sid is not None:
+                                    sell_qty = min(
+                                        sell_qty,
+                                        remaining_qty_for_strategy(lot_state, code, sid),
+                                    )
+                                if sell_qty <= 0:
+                                    _log_s2_action(
+                                        code,
+                                        "SKIP",
+                                        base_qty,
+                                        target_qty,
+                                        sold_today,
+                                        remaining,
+                                        0,
+                                        "strategy_qty_zero",
+                                    )
+                                    continue
                                 try:
+                                    prev_qty_before = int(
+                                        (holding.get(code) or {}).get("qty") or 0
+                                    )
                                     exec_px, result = _sell_once(
                                         kis, code, sell_qty, prefer_market=True
                                     )
                                     status, skip_reason = _sell_result_status(result)
                                 except Exception as e:
                                     exec_px, result = None, None
                                     status, skip_reason = "ERROR", str(e)
 
                                 reason_msg = skip_reason or "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ"
 
                                 if status == "SENT":
                                     guard["sold"] = sold_today + int(sell_qty)
                                     holding[code]["qty"] = max(
                                         0, holding[code]["qty"] - int(sell_qty)
                                     )
                                     if guard["sold"] >= target_qty:
                                         holding[code]["bear_s2_done"] = True
                                     _persist_guard_state(now_dt_kst.date())
                                     log_trade(
                                         {
                                             "datetime": now_str,
                                             "code": code,
                                             "name": None,
                                             "qty": int(sell_qty),
                                             "K": holding[code].get("k_value"),
                                             "target_price": holding[code].get(
                                                 "target_price_src"
                                             ),
                                             "strategy": "ë ˆì§ì¶•ì†Œ",
                                             "side": "SELL",
                                             "price": exec_px,
                                             "amount": int((exec_px or 0))
                                             * int(sell_qty),
                                             "result": result,
                                             "reason": reason_msg,
                                         }
                                     )
+                                    _apply_sell_to_ledger_with_balance(
+                                        code,
+                                        int(sell_qty),
+                                        now_dt_kst.isoformat(),
+                                        result,
+                                        strategy_id=sid,
+                                        prev_qty_before=prev_qty_before,
+                                    )
                                     save_state(holding, traded)
                                     time.sleep(RATE_SLEEP_SEC)
                                 elif status == "SKIP":
                                     pass
                                 _log_s2_action(
                                     code,
                                     status,
                                     base_qty,
                                     target_qty,
                                     sold_today,
                                     remaining,
                                     sell_qty,
                                     reason_msg,
                                 )
 
                 # --- 1b) TP/SL/íŠ¸ë ˆì¼ë§, VWAP ê°€ë“œ ---
                 try:
                     exit_reason, exec_px, exit_result, sold_qty = _adaptive_exit(
                         kis,
                         code,
                         holding[code],
                         regime_mode=mode or "neutral",
                     )
                 except Exception as e:
                     logger.error(f"[_adaptive_exit ì‹¤íŒ¨] {code}: {e}")
                     exit_reason = exec_px = exit_result = sold_qty = None
 
                 if sold_qty:
+                    sid = _resolve_sell_sid(code)
+                    if sid is not None:
+                        sold_qty = min(
+                            int(sold_qty),
+                            remaining_qty_for_strategy(lot_state, code, sid),
+                        )
+                    if sold_qty <= 0:
+                        continue
+                    prev_qty_before = int((holding.get(code) or {}).get("qty") or 0)
+                    _apply_sell_to_ledger_with_balance(
+                        code,
+                        int(sold_qty),
+                        now_dt_kst.isoformat(),
+                        exit_result,
+                        strategy_id=sid,
+                        prev_qty_before=prev_qty_before,
+                    )
                     save_state(holding, traded)
                     time.sleep(RATE_SLEEP_SEC)
 
             # === (2) ì‹ ê·œ ì§„ì… ë¡œì§ (ì±”í”¼ì–¸) ===
             for code, info in code_to_target.items():
                 if not can_buy:
                     continue
 
                 if code in traded_today:
                     continue
 
                 if code in holding and not ALLOW_PYRAMID:
                     continue
 
                 if code in triggered_today:
                     logger.info(f"[TRIGGER-SKIP] {code}: ê¸ˆì¼ ì´ë¯¸ íŠ¸ë¦¬ê±° ë°œìƒ")
                     continue
 
                 target_qty = int(info.get("qty", 0))
                 if target_qty <= 0:
                     logger.info(f"[REBALANCE] {code}: target_qty=0 â†’ ìŠ¤í‚µ")
                     continue
 
                 target_price = info.get("target_price")
                 k_value = info.get("best_k")
                 strategy = info.get("strategy")
                 weight = _to_float(info.get("weight") or 0.0)
 
                 planned_notional = int(
                     _to_float(info.get("target_notional") or 0.0) or 0
                 )
                 logger.info(
                     f"[TARGET] {code} qty={target_qty} tgt_px={target_price} notional={planned_notional} K={k_value}"
                 )
 
                 # [ì¤‘ë³µ ì§„ì… ë°©ì§€] ì´ë¯¸ ì£¼ë¬¸ëœ ì¢…ëª©ì¸ì§€ í™•ì¸
                 if code in traded_today:
                     logger.info(f"[SKIP] {code}: ì´ë¯¸ ê¸ˆì¼ ê±°ë˜ë¨")
                     continue
 
+                strategy_id = info.get("strategy_id")
+                if strategy_id is not None and remaining_qty_for_strategy(
+                    lot_state, code, strategy_id
+                ) > 0:
+                    logger.info(
+                        "[ENTRY-SKIP] already owned in ledger: code=%s sid=%s",
+                        code,
+                        strategy_id,
+                    )
+                    continue
+
                 if _pending_block(traded, code, now_dt_kst, block_sec=45):
                     logger.info(
                         f"[SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘ â†’ ì¬ì£¼ë¬¸ ë°©ì§€"
                     )
                     continue
 
                 prev_price = last_price_map.get(code)
                 if prev_price is None:
                     try:
                         cached = signals._LAST_PRICE_CACHE.get(code) or {}
                         ts = cached.get("ts")
                         if ts and (time.time() - float(ts) <= 120):
                             prev_price = cached.get("px")
                     except Exception:
                         prev_price = None
 
                 price_res = _safe_get_price(kis, code, with_source=True)
                 if isinstance(price_res, tuple):
                     current_price, price_source = price_res
                 else:
                     current_price, price_source = price_res, None
 
                 if not current_price or current_price <= 0:
                     logger.warning(f"[PRICE_FAIL] {code}: í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ")
                     continue
@@ -1446,50 +1792,51 @@ def main(
                     logger.warning(
                         f"[VWAP_GUARD_FAIL] {code}: VWAP ê°€ë“œ ì˜¤ë¥˜ â†’ ì§„ì… ë³´ë¥˜ ({e})"
                     )
                     continue
 
                 if not guard_passed:
                     logger.info(f"[VWAP_GUARD] {code}: ìŠ¬ë¦¬í”¼ì§€ ìœ„í—˜ â†’ ë§¤ìˆ˜ ìŠ¤í‚µ")
                     continue
 
                 qty = target_qty
                 if mode == "neutral":
                     scaled_qty = max(1, int(qty * NEUTRAL_ENTRY_SCALE))
                     if scaled_qty < qty:
                         logger.info(
                             f"[ENTRY-SIZE] {code}: neutral ë ˆì§ ê°ì¶• {qty}â†’{scaled_qty} (ìŠ¤ì¼€ì¼={NEUTRAL_ENTRY_SCALE})"
                         )
                     qty = scaled_qty
                 trade_ctx = {
                     "datetime": now_str,
                     "code": code,
                     "name": info.get("name"),
                     "qty": int(qty),
                     "K": k_value,
                     "target_price": target_price,
                     "strategy": strategy,
+                    "strategy_id": info.get("strategy_id"),
                     "side": "BUY",
                 }
 
                 limit_px, mo_px = compute_entry_target(kis, info)
                 if limit_px is None and mo_px is None:
                     logger.warning(
                         f"[TARGET-PRICE] {code}: limit/mo ê°€ê²© ì‚°ì¶œ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ"
                     )
                     continue
 
                 if (
                     limit_px
                     and abs(limit_px - current_price) / current_price * 100
                     > SLIPPAGE_LIMIT_PCT
                 ):
                     logger.info(
                         f"[SLIPPAGE_LIMIT] {code}: í˜¸ê°€ä¹–é›¢ {abs(limit_px - current_price) / current_price * 100:.2f}% â†’ ìŠ¤í‚µ"
                     )
                     continue
 
                 logger.info(
                     f"[BUY-TRY] {code}: qty={qty} limit={limit_px} mo={mo_px} target={target_price} k={k_value}"
                 )
 
                 prev_qty = int((holding.get(code) or {}).get("qty", 0))
@@ -1522,84 +1869,123 @@ def main(
                     )
                     continue
                 traded[code]["status"] = "filled"
                 _record_trade(
                     traded,
                     code,
                     {
                         "buy_time": now_str,
                         "qty": int(qty),
                         "price": float(exec_price),
                         "status": "filled",
                         "pending_since": None,
                     },
                 )
 
                 _init_position_state(
                     kis,
                     holding,
                     code,
                     float(exec_price),
                     int(qty),
                     k_value,
                     target_price,
                 )
 
+                lot_id = _build_lot_id(
+                    result,
+                    now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
+                    code,
+                )
+                before_lot_signature = _lot_state_signature(lot_state)
+                record_buy_fill(
+                    lot_state,
+                    lot_id=lot_id,
+                    pdno=code,
+                    strategy_id=info.get("strategy_id") or _derive_strategy_id(info),
+                    engine="legacy_kosdaq_runner",
+                    entry_ts=now_dt_kst.isoformat(),
+                    entry_price=float(exec_price),
+                    qty=int(qty),
+                    meta={
+                        "strategy_name": strategy,
+                        "k": k_value,
+                        "target_price": target_price,
+                        "engine": "legacy_kosdaq_runner",
+                        "rebalance_date": str(rebalance_date),
+                    },
+                )
+                logger.info(
+                    "[LEDGER][BUY] code=%s sid=%s lot_id=%s qty=%s",
+                    code,
+                    info.get("strategy_id") or _derive_strategy_id(info),
+                    lot_id,
+                    qty,
+                )
+                _maybe_save_lot_state(before_lot_signature)
+
                 log_trade(
                     {
                         **trade_ctx,
                         "price": float(exec_price),
                         "amount": int(float(exec_price) * int(qty)),
                         "result": result,
                     }
                 )
                 effective_cash = _get_effective_ord_cash(
                     kis, soft_cap=effective_capital
                 )
                 if effective_cash <= 0:
                     can_buy = False
                 save_state(holding, traded)
                 time.sleep(RATE_SLEEP_SEC)
 
             # ====== ëˆŒë¦¼ëª© ì „ìš© ë§¤ìˆ˜ (ì±”í”¼ì–¸ê³¼ ë…ë¦½ì ìœ¼ë¡œ Top-N ì‹œì´ ë¦¬ìŠ¤íŠ¸ ìŠ¤ìº”) ======
             if USE_PULLBACK_ENTRY and is_open:
                 if not can_buy:
                     logger.info("[PULLBACK-SKIP] can_buy=False â†’ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ")
                 else:
                     if pullback_watch:
                         logger.info(f"[PULLBACK-SCAN] {len(pullback_watch)}ì¢…ëª© ê²€ì‚¬")
 
                     for code, info in list(pullback_watch.items()):
                         if pullback_buys_today >= PULLBACK_MAX_BUYS_PER_DAY:
                             logger.info(
                                 f"[PULLBACK-LIMIT] í•˜ë£¨ ìµœëŒ€ {PULLBACK_MAX_BUYS_PER_DAY}ê±´ ë„ë‹¬ â†’ ìŠ¤ìº” ì¤‘ë‹¨"
                             )
                             break
 
                         if code in traded_today or code in holding:
                             continue  # ì±”í”¼ì–¸ ë£¨í”„ì™€ ë³„ë„ë¡œë§Œ ì²˜ë¦¬
 
+                        if remaining_qty_for_strategy(lot_state, code, 5) > 0:
+                            logger.info(
+                                "[ENTRY-SKIP] already owned in ledger: code=%s sid=5",
+                                code,
+                            )
+                            continue
+
                         if _pending_block(traded, code, now_dt_kst, block_sec=45):
                             logger.info(
                                 f"[PULLBACK-SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘"
                             )
                             continue
 
                         base_notional = int(info.get("notional") or 0)
                         if base_notional <= 0:
                             logger.info(f"[PULLBACK-SKIP] {code}: ì˜ˆì‚° 0")
                             continue
 
                         try:
                             resp = _detect_pullback_reversal(
                                 kis,
                                 code,
                                 lookback=PULLBACK_LOOKBACK,
                                 pullback_days=PULLBACK_DAYS,
                                 reversal_buffer_pct=PULLBACK_REVERSAL_BUFFER_PCT,
                             )
 
                             pullback_ok = False
                             trigger_price = None
 
                             if isinstance(resp, dict):
                                 pullback_ok = bool(resp.get("setup")) and bool(
@@ -1705,63 +2091,96 @@ def main(
                             traded,
                             code,
                             {
                                 "buy_time": now_str,
                                 "qty": int(qty),
                                 "price": float(exec_price),
                                 "status": "filled",
                                 "pending_since": None,
                             },
                         )
                         pullback_buys_today += 1
 
                         try:
                             _init_position_state(
                                 kis,
                                 holding,
                                 code,
                                 float(exec_price),
                                 int(qty),
                                 None,
                                 trigger_price,
                             )
                         except Exception as e:
                             logger.warning(f"[PULLBACK-INIT-FAIL] {code}: {e}")
 
+                        lot_id = _build_lot_id(
+                            result,
+                            now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
+                            code,
+                        )
+                        before_lot_signature = _lot_state_signature(lot_state)
+                        record_buy_fill(
+                            lot_state,
+                            lot_id=lot_id,
+                            pdno=code,
+                            strategy_id=5,
+                            engine="legacy_kosdaq_runner",
+                            entry_ts=now_dt_kst.isoformat(),
+                            entry_price=float(exec_price),
+                            qty=int(qty),
+                            meta={
+                                "strategy_name": f"ì½”ìŠ¤ë‹¥ Top{PULLBACK_TOPN} ëˆŒë¦¼ëª©",
+                                "k": None,
+                                "target_price": trigger_price,
+                                "engine": "legacy_kosdaq_runner",
+                                "rebalance_date": str(rebalance_date),
+                            },
+                        )
+                        logger.info(
+                            "[LEDGER][BUY] code=%s sid=%s lot_id=%s qty=%s",
+                            code,
+                            5,
+                            lot_id,
+                            qty,
+                        )
+                        _maybe_save_lot_state(before_lot_signature)
+
                         logger.info(
                             f"[âœ… ëˆŒë¦¼ëª© ë§¤ìˆ˜] {code}, qty={qty}, price={exec_price}, trigger={trigger_price}, result={result}"
                         )
 
                         log_trade(
                             {
                                 "datetime": now_str,
                                 "code": code,
                                 "name": info.get("name"),
                                 "qty": int(qty),
                                 "K": None,
                                 "target_price": trigger_price,
                                 "strategy": f"ì½”ìŠ¤ë‹¥ Top{PULLBACK_TOPN} ëˆŒë¦¼ëª©",
+                                "strategy_id": 5,
                                 "side": "BUY",
                                 "price": float(exec_price),
                                 "amount": int(float(exec_price) * int(qty)),
                                 "result": result,
                             }
                         )
                         effective_cash = _get_effective_ord_cash(
                             kis, soft_cap=effective_capital
                         )
                         if effective_cash <= 0:
                             can_buy = False
                         save_state(holding, traded)
                         time.sleep(RATE_SLEEP_SEC)
 
             # ====== (A) ë¹„íƒ€ê²Ÿ ë³´ìœ ë¶„ë„ ì¥ì¤‘ ëŠ¥ë™ê´€ë¦¬ ======
             if is_open:
                 for code in list(holding.keys()):
                     if code in code_to_target:
                         continue  # ìœ„ ë£¨í”„ì—ì„œ ì´ë¯¸ ì²˜ë¦¬
 
                     # ì•½ì„¸ ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)
                     if regime["mode"] == "bear":
                         sellable_here = ord_psbl_map.get(code, 0)
                         if sellable_here > 0:
                             if regime["bear_stage"] >= 1:
@@ -1786,99 +2205,132 @@ def main(
                                 else:
                                     target_qty = max(1, int(base_qty * REG_PARTIAL_S1))
                                     sold_today = int(guard.get("sold", 0))
                                     remaining = max(0, target_qty - sold_today)
 
                                     if remaining <= 0 or sellable_here <= 0:
                                         if remaining <= 0:
                                             holding[code]["bear_s1_done"] = True
                                             s1_done_today.add(code)
                                         regime_s1_summary["skipped"] += 1
                                         _log_s1_action(
                                             code,
                                             "SKIP",
                                             base_qty,
                                             target_qty,
                                             sold_today,
                                             remaining,
                                             0,
                                             (
                                                 "target_met"
                                                 if remaining <= 0
                                                 else "no_sellable_qty"
                                             ),
                                         )
                                     else:
+                                        sid = _resolve_sell_sid(code)
                                         sell_qty = min(remaining, sellable_here)
+                                        if sid is not None:
+                                            sell_qty = min(
+                                                sell_qty,
+                                                remaining_qty_for_strategy(
+                                                    lot_state, code, sid
+                                                ),
+                                            )
+                                        if sell_qty <= 0:
+                                            regime_s1_summary["skipped"] += 1
+                                            _log_s1_action(
+                                                code,
+                                                "SKIP",
+                                                base_qty,
+                                                target_qty,
+                                                sold_today,
+                                                remaining,
+                                                0,
+                                                "strategy_qty_zero",
+                                            )
+                                            continue
                                         regime_s1_summary["total_qty"] += int(sell_qty)
                                         try:
+                                            prev_qty_before = int(
+                                                (holding.get(code) or {}).get("qty")
+                                                or 0
+                                            )
                                             exec_px, result = _sell_once(
                                                 kis, code, sell_qty, prefer_market=True
                                             )
                                             status, skip_reason = _sell_result_status(
                                                 result
                                             )
                                         except Exception as e:
                                             exec_px, result = None, None
                                             status, skip_reason = "ERROR", str(e)
 
                                         reason_msg = (
                                             skip_reason or "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)"
                                         )
 
                                         if status == "SENT":
                                             guard["sold"] = sold_today + int(sell_qty)
                                             holding[code]["qty"] = max(
                                                 0, holding[code]["qty"] - int(sell_qty)
                                             )
                                             if guard["sold"] >= target_qty:
                                                 holding[code]["bear_s1_done"] = True
                                                 s1_done_today.add(code)
                                             _persist_guard_state(now_dt_kst.date())
                                             regime_s1_summary["sent_qty"] += int(
                                                 sell_qty
                                             )
                                             regime_s1_summary["sent_orders"] += 1
                                             trade_payload = {
                                                 "datetime": now_str,
                                                 "code": code,
                                                 "name": None,
                                                 "qty": int(sell_qty),
                                                 "K": holding[code].get("k_value"),
                                                 "target_price": holding[code].get(
                                                     "target_price_src"
                                                 ),
                                                 "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
                                                 "side": "SELL",
                                                 "price": exec_px,
                                                 "amount": int((exec_px or 0))
                                                 * int(sell_qty),
                                                 "reason": reason_msg,
                                             }
                                             if result is not None:
                                                 trade_payload["result"] = result
                                             log_trade(trade_payload)
+                                            _apply_sell_to_ledger_with_balance(
+                                                code,
+                                                int(sell_qty),
+                                                now_dt_kst.isoformat(),
+                                                result,
+                                                strategy_id=sid,
+                                                prev_qty_before=prev_qty_before,
+                                            )
                                             save_state(holding, traded)
                                             time.sleep(RATE_SLEEP_SEC)
                                         elif status == "SKIP":
                                             regime_s1_summary["skipped"] += 1
                                         else:
                                             regime_s1_summary["skipped"] += 1
 
                                         _log_s1_action(
                                             code,
                                             status,
                                             base_qty,
                                             target_qty,
                                             sold_today,
                                             remaining,
                                             sell_qty,
                                             reason_msg,
                                         )
 
                             if regime["bear_stage"] >= 2 and not holding[code].get(
                                 "bear_s2_done"
                             ):
                                 if not holding[code].get("bear_s1_done"):
                                     _log_s2_action(
                                         code,
                                         "SKIP",
@@ -1913,93 +2365,125 @@ def main(
                                         "base_qty_zero",
                                     )
                                 else:
                                     target_qty = max(1, int(base_qty * REG_PARTIAL_S2))
                                     sold_today = int(guard.get("sold", 0))
                                     remaining = max(0, target_qty - sold_today)
 
                                     if remaining <= 0 or sellable_here <= 0:
                                         if remaining <= 0:
                                             holding[code]["bear_s2_done"] = True
                                         _log_s2_action(
                                             code,
                                             "SKIP",
                                             base_qty,
                                             target_qty,
                                             sold_today,
                                             remaining,
                                             0,
                                             (
                                                 "target_met"
                                                 if remaining <= 0
                                                 else "no_sellable_qty"
                                             ),
                                         )
                                     else:
+                                        sid = _resolve_sell_sid(code)
                                         sell_qty = min(remaining, sellable_here)
+                                        if sid is not None:
+                                            sell_qty = min(
+                                                sell_qty,
+                                                remaining_qty_for_strategy(
+                                                    lot_state, code, sid
+                                                ),
+                                            )
+                                        if sell_qty <= 0:
+                                            _log_s2_action(
+                                                code,
+                                                "SKIP",
+                                                base_qty,
+                                                target_qty,
+                                                sold_today,
+                                                remaining,
+                                                0,
+                                                "strategy_qty_zero",
+                                            )
+                                            continue
                                         try:
+                                            prev_qty_before = int(
+                                                (holding.get(code) or {}).get("qty")
+                                                or 0
+                                            )
                                             exec_px, result = _sell_once(
                                                 kis, code, sell_qty, prefer_market=True
                                             )
                                             status, skip_reason = _sell_result_status(
                                                 result
                                             )
                                         except Exception as e:
                                             exec_px, result = None, None
                                             status, skip_reason = "ERROR", str(e)
 
                                         reason_msg = (
                                             skip_reason or "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)"
                                         )
 
                                         if status == "SENT":
                                             guard["sold"] = sold_today + int(sell_qty)
                                             holding[code]["qty"] = max(
                                                 0, holding[code]["qty"] - int(sell_qty)
                                             )
                                             if guard["sold"] >= target_qty:
                                                 holding[code]["bear_s2_done"] = True
                                             _persist_guard_state(now_dt_kst.date())
                                             log_trade(
                                                 {
                                                     "datetime": now_str,
                                                     "code": code,
                                                     "name": None,
                                                     "qty": int(sell_qty),
                                                     "K": holding[code].get("k_value"),
                                                     "target_price": holding[code].get(
                                                         "target_price_src"
                                                     ),
                                                     "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
                                                     "side": "SELL",
                                                     "price": exec_px,
                                                     "amount": int((exec_px or 0))
                                                     * int(sell_qty),
                                                     "result": result,
                                                     "reason": reason_msg,
                                                 }
                                             )
+                                            _apply_sell_to_ledger_with_balance(
+                                                code,
+                                                int(sell_qty),
+                                                now_dt_kst.isoformat(),
+                                                result,
+                                                strategy_id=sid,
+                                                prev_qty_before=prev_qty_before,
+                                            )
                                             save_state(holding, traded)
                                             time.sleep(RATE_SLEEP_SEC)
                                         elif status == "SKIP":
                                             pass
 
                                         _log_s2_action(
                                             code,
                                             status,
                                             base_qty,
                                             target_qty,
                                             sold_today,
                                             remaining,
                                             sell_qty,
                                             reason_msg,
                                         )
 
                     try:
                         momentum_intact, trend_ctx = _has_bullish_trend_structure(
                             kis, code
                         )
                     except NetTemporaryError:
                         logger.warning(
                             f"[20D_TREND_TEMP_SKIP] {code}: ë„¤íŠ¸ì›Œí¬ ì¼ì‹œ ì‹¤íŒ¨ â†’ ì´ë²ˆ ë£¨í”„ ìŠ¤í‚µ"
                         )
                         continue
diff --git a/trader/state_store.py b/trader/state_store.py
new file mode 100644
index 0000000000000000000000000000000000000000..0cc2cbccf033ecd4c9c8c9a56118ee80b38190bb
--- /dev/null
+++ b/trader/state_store.py
@@ -0,0 +1,48 @@
+from __future__ import annotations
+
+import json
+import logging
+from datetime import datetime
+from pathlib import Path
+from typing import Any, Dict
+
+from .config import KST
+
+logger = logging.getLogger(__name__)
+
+
+def _default_state() -> Dict[str, Any]:
+    return {"version": 1, "lots": [], "updated_at": None}
+
+
+def load_state(path_json: str) -> Dict[str, Any]:
+    path = Path(path_json)
+    if path.exists():
+        try:
+            with open(path, "r", encoding="utf-8") as f:
+                state = json.load(f)
+            if not isinstance(state, dict):
+                logger.warning("[STATE_STORE] invalid state format: %s", type(state))
+                return _default_state()
+            state.setdefault("version", 1)
+            state.setdefault("lots", [])
+            state.setdefault("updated_at", None)
+            return state
+        except Exception:
+            logger.exception("[STATE_STORE] failed to load %s", path_json)
+            return _default_state()
+    return _default_state()
+
+
+def save_state(path_json: str, state: Dict[str, Any]) -> None:
+    path = Path(path_json)
+    try:
+        path.parent.mkdir(parents=True, exist_ok=True)
+        payload = dict(state)
+        payload.setdefault("version", 1)
+        payload.setdefault("lots", [])
+        payload["updated_at"] = datetime.now(KST).isoformat()
+        with open(path, "w", encoding="utf-8") as f:
+            json.dump(payload, f, ensure_ascii=False, indent=2)
+    except Exception:
+        logger.exception("[STATE_STORE] failed to save %s", path_json)
