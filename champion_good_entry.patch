diff --git a/trader/trader.py b/trader/trader.py
index 3cace83a37853dd03cca6de198bd75b8971efbe6..dab14d03a6a50937d4de124a842fb62c35424bb9 100644
--- a/trader/trader.py
+++ b/trader/trader.py
@@ -164,50 +164,70 @@ CAP_CAP = float(_cfg("CAP_CAP"))
 SLIPPAGE_LIMIT_PCT = float(_cfg("SLIPPAGE_LIMIT_PCT"))
 SLIPPAGE_ENTER_GUARD_PCT = float(_cfg("SLIPPAGE_ENTER_GUARD_PCT"))
 VWAP_TOL = float(_cfg("VWAP_TOL"))  # üî∏ VWAP ÌóàÏö© Ïò§Ï∞®(Ïòà: 0.003 = -0.3%ÍπåÏßÄ ÌóàÏö©)
 W_MAX_ONE = float(_cfg("W_MAX_ONE"))
 W_MIN_ONE = float(_cfg("W_MIN_ONE"))
 REBALANCE_ANCHOR = _cfg("REBALANCE_ANCHOR")
 WEEKLY_ANCHOR_REF = _cfg("WEEKLY_ANCHOR_REF").lower()
 MOMENTUM_OVERRIDES_FORCE_SELL = _cfg("MOMENTUM_OVERRIDES_FORCE_SELL").lower() == "true"
 
 # NEW: 1Î∂ÑÎ¥â Î™®Î©òÌÖÄ ÌååÎùºÎØ∏ÌÑ∞
 MOM_FAST = int(_cfg("MOM_FAST") or "5")
 MOM_SLOW = int(_cfg("MOM_SLOW") or "20")
 MOM_TH_PCT = float(_cfg("MOM_TH_PCT") or "0.5")
 # Ïã†Í≥†Í∞Ä ‚Üí 3Ïùº ÎàåÎ¶º ‚Üí Î∞òÎì± ÌôïÏù∏ ÌõÑ Îß§Ïàò ÌååÎùºÎØ∏ÌÑ∞
 USE_PULLBACK_ENTRY = _cfg("USE_PULLBACK_ENTRY").lower() != "false"
 PULLBACK_LOOKBACK = int(_cfg("PULLBACK_LOOKBACK") or "60")
 PULLBACK_DAYS = int(_cfg("PULLBACK_DAYS") or "3")
 PULLBACK_REVERSAL_BUFFER_PCT = float(_cfg("PULLBACK_REVERSAL_BUFFER_PCT") or "0.2")
 PULLBACK_TOPN = int(_cfg("PULLBACK_TOPN") or "50")
 PULLBACK_UNIT_WEIGHT = float(_cfg("PULLBACK_UNIT_WEIGHT") or "0.03")
 CHAMPION_MIN_TRADES = int(_cfg("CHAMPION_MIN_TRADES") or "5")
 CHAMPION_MIN_WINRATE = float(_cfg("CHAMPION_MIN_WINRATE") or "45.0")
 CHAMPION_MAX_MDD = float(_cfg("CHAMPION_MAX_MDD") or "30.0")
 CHAMPION_MIN_SHARPE = float(_cfg("CHAMPION_MIN_SHARPE") or "0.0")
 
+# Ï±îÌîºÏñ∏ Îì±Í∏â & GOOD/BAD ÌÉÄÏ†ê ÌåêÎ≥Ñ ÌååÎùºÎØ∏ÌÑ∞
+CHAMPION_A_RULES = {
+    "min_trades": 30,
+    "min_cumret_pct": 40.0,
+    "max_mdd_pct": 25.0,
+    "min_win_pct": 50.0,
+    "min_sharpe": 1.2,
+    "min_turnover": 3_000_000_000,  # 30Ïñµ
+}
+
+GOOD_ENTRY_PULLBACK_RANGE = (5.0, 15.0)  # Ïã†Í≥†Í∞Ä ÎåÄÎπÑ ÎàåÎ¶ºÌè≠(%): ÏµúÏÜå~ÏµúÎåÄ
+GOOD_ENTRY_MA20_RANGE = (1.0, 1.15)  # ÌòÑÏû¨Í∞Ä/20MA ÌóàÏö© Íµ¨Í∞Ñ
+GOOD_ENTRY_MAX_FROM_PEAK = 0.97  # ÌòÑÏû¨Í∞Ä/ÏµúÍ∑ºÍ≥†Ï†ê ÏµúÎåÄÏπò(‚â§0.97)
+GOOD_ENTRY_MIN_RR = 2.0  # Í∏∞ÎåÄÏàòÏùµ/Î¶¨Ïä§ÌÅ¨ ÏµúÏÜå ÎπÑÏú®
+GOOD_ENTRY_MIN_INTRADAY_SIG = 2  # GOOD ÌÉÄÏ†êÏúºÎ°ú Ïù∏Ï†ïÌïòÍ∏∞ ÏúÑÌïú ÏµúÏÜå intraday ÏãúÍ∑∏ÎÑê Í∞úÏàò
+
+BAD_ENTRY_MAX_MA20_DIST = 1.25  # ÌòÑÏû¨Í∞Ä/20MA ÏÉÅÌïú(Ï∂îÍ≤©Îß§Ïàò Î∞©ÏßÄ)
+BAD_ENTRY_MAX_PULLBACK = 20.0  # Ïã†Í≥†Í∞Ä ÎåÄÎπÑ ÎàåÎ¶ºÌè≠ ÏÉÅÌïú(Í≥ºÎèÑÌïú Î∂ïÍ¥¥ Î∞©ÏßÄ)
+BAD_ENTRY_MAX_BELOW_VWAP_RATIO = 0.7  # Î∂ÑÎ¥âÏóêÏÑú VWAP ÏïÑÎûò Ï≤¥Î•ò ÎπÑÏ§ëÏù¥ Ïù¥ Ïù¥ÏÉÅÏù¥Î©¥ BAD
+
 def _parse_hhmm(hhmm: str) -> dtime:
     try:
         hh, mm = hhmm.split(":")
         return dtime(hour=int(hh), minute=int(mm))
     except Exception:
         logger.warning(f"[ÏÑ§Ï†ïÍ≤ΩÍ≥†] SELL_FORCE_TIME ÌòïÏãù Ïò§Î•ò ‚Üí Í∏∞Î≥∏Í∞í 14:40 Ï†ÅÏö©: {hhmm}")
         return dtime(hour=14, minute=40)
 
 SELL_FORCE_TIME = _parse_hhmm(SELL_FORCE_TIME_STR)
 TIME_STOP_TIME = _parse_hhmm(TIME_STOP_HHMM)
 ALLOW_WHEN_CLOSED = _cfg("MARKET_DATA_WHEN_CLOSED").lower() == "true"
 
 # === [NEW] Ï£ºÍ∞Ñ Î¶¨Î∞∏Îü∞Ïã± Í∞ïÏ†ú Ìä∏Î¶¨Í±∞ ÏÉÅÌÉú ÌååÏùº ===
 STATE_WEEKLY_PATH = Path(__file__).parent / "state_weekly.json"
 
 def _this_iso_week_key(now=None):
     now = now or datetime.now(KST)
     return f"{now.year}-W{now.isocalendar().week:02d}"
 
 def _read_last_weekly():
     if not STATE_WEEKLY_PATH.exists():
         return None
     try:
         return (json.loads(STATE_WEEKLY_PATH.read_text(encoding="utf-8"))).get("weekly_rebalanced_at")
     except Exception:
@@ -574,50 +594,287 @@ def _detect_pullback_reversal(
 
     last_down = window[len(window) - 1]
     try:
         reversal_line = max(
             float(last_down.get("high") or 0.0), float(last_down.get("close") or 0.0)
         )
     except Exception:
         reversal_line = 0.0
 
     reversal_price = reversal_line * (1.0 + buffer_pct / 100.0)
     reversing = (
         current_price is not None
         and reversal_price > 0
         and float(current_price) >= float(reversal_price)
     )
 
     return {
         "setup": True,
         "reversing": bool(reversing),
         "reversal_price": float(reversal_price) if reversal_price > 0 else None,
         "peak_price": float(peak_price),
         "peak_date": window[peak_idx].get("date"),
         "last_down_date": last_down.get("date"),
     }
 
+
+def _classify_champion_grade(info: Dict[str, Any]) -> str:
+    trades = _to_int(info.get("trades"), 0)
+    win = _to_float(info.get("win_rate_pct"), 0.0)
+    mdd = abs(_to_float(info.get("mdd_pct"), 0.0) or 0.0)
+    sharpe = _to_float(info.get("sharpe_m") or info.get("sharpe"), 0.0)
+    cumret = _to_float(
+        info.get("cumulative_return_pct") or info.get("avg_return_pct"), 0.0
+    )
+    turnover = _to_float(
+        info.get("prev_turnover") or info.get("avg_turnover") or info.get("turnover"),
+        0.0,
+    )
+
+    turnover_ok = turnover <= 0 or turnover >= CHAMPION_A_RULES["min_turnover"]
+    if (
+        trades >= CHAMPION_A_RULES["min_trades"]
+        and cumret >= CHAMPION_A_RULES["min_cumret_pct"]
+        and mdd <= CHAMPION_A_RULES["max_mdd_pct"]
+        and win >= CHAMPION_A_RULES["min_win_pct"]
+        and sharpe >= CHAMPION_A_RULES["min_sharpe"]
+        and turnover_ok
+    ):
+        return "A"
+
+    if (
+        trades >= CHAMPION_MIN_TRADES
+        and win >= CHAMPION_MIN_WINRATE
+        and mdd <= CHAMPION_MAX_MDD
+        and sharpe >= CHAMPION_MIN_SHARPE
+    ):
+        return "B"
+
+    return "C"
+
+
+def _compute_daily_entry_context(
+    kis: KisAPI, code: str, current_price: Optional[float]
+) -> Dict[str, Any]:
+    ctx: Dict[str, Any] = {"current_price": current_price}
+    try:
+        candles = _get_daily_candles_cached(kis, code, count=max(PULLBACK_LOOKBACK, 60))
+    except Exception:
+        return ctx
+
+    today = datetime.now(KST).strftime("%Y%m%d")
+    completed = list(candles)
+    if completed and str(completed[-1].get("date")) == today:
+        completed = completed[:-1]
+
+    if not completed:
+        return ctx
+
+    closes = [float(c.get("close") or 0.0) for c in completed if c.get("close")]
+    highs = [float(c.get("high") or 0.0) for c in completed if c.get("high")]
+    lows = [float(c.get("low") or 0.0) for c in completed if c.get("low")]
+
+    if len(closes) >= 20:
+        ma20 = sum(closes[-20:]) / 20.0
+        ctx["ma20"] = ma20
+        if current_price:
+            ctx["ma20_ratio"] = current_price / ma20
+            ctx["ma20_risk"] = max(0.0, current_price - ma20)
+
+    if highs:
+        window_60 = highs[-60:] if len(highs) >= 60 else highs
+        peak_price = max(window_60)
+        ctx["peak_price"] = peak_price
+        if current_price and peak_price > 0:
+            ctx["distance_to_peak"] = current_price / peak_price
+            ctx["pullback_depth_pct"] = (peak_price - current_price) / peak_price * 100.0
+
+    # Ïó∞ÏÜç ÌïòÎùΩ ÏùºÏàò Ï≤¥ÌÅ¨ (Ïã†Í≥†Í∞Ä Ïù¥ÌõÑ ÎàåÎ¶º ÌåêÎã®)
+    down_streak = 0
+    for idx in range(len(completed) - 1, 0, -1):
+        cur = float(completed[idx].get("close") or 0.0)
+        prev = float(completed[idx - 1].get("close") or 0.0)
+        if cur <= 0 or prev <= 0:
+            break
+        if cur < prev:
+            down_streak += 1
+        else:
+            break
+    ctx["down_streak"] = down_streak
+
+    try:
+        atr = _get_atr(kis, code)
+        if atr:
+            ctx["atr"] = float(atr)
+    except Exception:
+        pass
+
+    if closes and highs:
+        recent_high = max(highs[-20:])
+        ctx["recent_high_20"] = recent_high
+        ctx["setup_ok"] = bool(
+            down_streak >= 2
+            and ctx.get("pullback_depth_pct") is not None
+            and ctx.get("pullback_depth_pct") >= GOOD_ENTRY_PULLBACK_RANGE[0]
+            and (ctx.get("ma20_ratio") or 0) >= GOOD_ENTRY_MA20_RANGE[0]
+            and recent_high >= max(highs[-60:]) * 0.95
+        )
+
+    return ctx
+
+
+def _compute_intraday_entry_context(
+    kis: KisAPI, code: str, prev_high: Optional[float] = None
+) -> Dict[str, Any]:
+    ctx: Dict[str, Any] = {}
+    candles = _get_intraday_1min(kis, code, count=120)
+    if not candles:
+        return ctx
+
+    vwap_val = _compute_vwap_from_1min(candles)
+    ctx["vwap"] = vwap_val
+    last = candles[-1]
+    last_close = _to_float(last.get("close"), None)
+    last_high = _to_float(last.get("high") or last.get("close"), None)
+    last_low = _to_float(last.get("low") or last.get("close"), None)
+    ctx["last_close"] = last_close
+    ctx["last_high"] = last_high
+    ctx["last_low"] = last_low
+
+    if vwap_val and last_close:
+        ctx["vwap_reclaim"] = last_close >= vwap_val
+
+    highs = [
+        float(c.get("high") or c.get("close") or 0.0)
+        for c in candles
+        if c.get("high") or c.get("close")
+    ]
+    lows = [
+        float(c.get("low") or c.get("close") or 0.0)
+        for c in candles
+        if c.get("low") or c.get("close")
+    ]
+    vols = [float(c.get("volume") or 0.0) for c in candles]
+
+    if highs:
+        box_high = max(highs[-20:])
+        box_low = min(lows[-20:]) if lows else None
+        if last_high is not None and box_high:
+            ctx["range_break"] = last_high >= box_high * 0.999
+        if last_low is not None and box_low:
+            ctx["box_floor"] = box_low
+
+    if vols and len(vols) >= 10:
+        recent_vol = sum(vols[-5:]) / 5.0
+        base_vol = sum(vols[:-5]) / max(1, len(vols) - 5)
+        if base_vol > 0:
+            ctx["volume_spike"] = recent_vol >= base_vol * 1.5
+
+    if vwap_val:
+        below = sum(1 for c in candles if _to_float(c.get("close"), 0.0) < vwap_val)
+        ctx["below_vwap_ratio"] = below / len(candles)
+
+    if prev_high and last_high:
+        ctx["prev_high_retest"] = last_high >= float(prev_high) * 0.999
+
+    return ctx
+
+
+def is_bad_entry(
+    code: str,
+    daily_ctx: Dict[str, Any],
+    intraday_ctx: Dict[str, Any],
+    regime_state: Optional[Dict[str, Any]] = None,
+) -> bool:
+    ma20_ratio = daily_ctx.get("ma20_ratio")
+    if ma20_ratio and ma20_ratio > BAD_ENTRY_MAX_MA20_DIST:
+        return True
+
+    pullback = daily_ctx.get("pullback_depth_pct")
+    if pullback and pullback > BAD_ENTRY_MAX_PULLBACK:
+        return True
+
+    if regime_state:
+        try:
+            kosdaq_drop = _to_float(regime_state.get("pct_change"), None)
+            if kosdaq_drop is not None and kosdaq_drop <= -2.5:
+                return True
+        except Exception:
+            pass
+
+    below_vwap_ratio = intraday_ctx.get("below_vwap_ratio")
+    if below_vwap_ratio is not None and below_vwap_ratio >= BAD_ENTRY_MAX_BELOW_VWAP_RATIO:
+        return True
+
+    return False
+
+
+def is_good_entry(
+    code: str,
+    daily_ctx: Dict[str, Any],
+    intraday_ctx: Dict[str, Any],
+    prev_high: Optional[float] = None,
+) -> bool:
+    if not daily_ctx.get("setup_ok"):
+        return False
+
+    pullback = daily_ctx.get("pullback_depth_pct")
+    if pullback is None or not (
+        GOOD_ENTRY_PULLBACK_RANGE[0] <= pullback <= GOOD_ENTRY_PULLBACK_RANGE[1]
+    ):
+        return False
+
+    ma20_ratio = daily_ctx.get("ma20_ratio")
+    if ma20_ratio is None or not (
+        GOOD_ENTRY_MA20_RANGE[0] <= ma20_ratio <= GOOD_ENTRY_MA20_RANGE[1]
+    ):
+        return False
+
+    dist_peak = daily_ctx.get("distance_to_peak")
+    if dist_peak is None or dist_peak > GOOD_ENTRY_MAX_FROM_PEAK:
+        return False
+
+    cur_px = daily_ctx.get("current_price")
+    atr = daily_ctx.get("atr") or 0.0
+    ma_risk = daily_ctx.get("ma20_risk") or 0.0
+    risk = max(atr, ma_risk, (cur_px or 0) * 0.03)
+    reward = max(0.0, (daily_ctx.get("peak_price") or 0) - (cur_px or 0)) + atr
+    if risk <= 0 or reward / risk < GOOD_ENTRY_MIN_RR:
+        return False
+
+    signals = []
+    if intraday_ctx.get("vwap_reclaim"):
+        signals.append("vwap")
+    if intraday_ctx.get("range_break"):
+        signals.append("range")
+    if intraday_ctx.get("volume_spike"):
+        signals.append("volume")
+    if prev_high and intraday_ctx.get("prev_high_retest"):
+        signals.append("prev_high")
+
+    return len(signals) >= GOOD_ENTRY_MIN_INTRADAY_SIG
+
 from .kis_wrapper import NetTemporaryError, DataEmptyError, DataShortError
 
 # === [ANCHOR: INTRADAY_MOMENTUM] 1Î∂ÑÎ¥â VWAP + Îã®Í∏∞ Î™®Î©òÌÖÄ ===
 def _get_intraday_1min(kis: KisAPI, code: str, count: int = 60) -> List[Dict[str, Any]]:
     """
     KisAPIÏóê 1Î∂ÑÎ¥â Î©îÏÑúÎìúÍ∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©ÌïòÍ≥†, ÏóÜÏúºÎ©¥ Ìò∏Ìôò Î©îÏÑúÎìúÎ°ú fallback.
     Î∞òÌôòÏùÄ ÏµúÏÜåÌïú 'close'ÏôÄ 'volume' Ï†ïÎ≥¥Î•º Í∞ÄÏßÑ dict Î¶¨Ïä§Ìä∏ÎùºÍ≥† Í∞ÄÏ†ïÌïúÎã§.
     """
     try:
         if hasattr(kis, "get_intraday_1min"):
             return kis.get_intraday_1min(code, count=count)
         if hasattr(kis, "get_minute_candles"):
             return kis.get_minute_candles(code, unit=1, count=count)
         if hasattr(kis, "get_intraday_candles"):
             return kis.get_intraday_candles(code, unit="1", count=count)
     except Exception as e:
         logger.warning(f"[INTRADAY_1M_FAIL] {code}: {e}")
     return []
 
 def _compute_vwap_from_1min(candles: List[Dict[str, Any]]) -> Optional[float]:
     if not candles:
         return None
     pv = 0.0
     vol_sum = 0.0
     for c in candles:
@@ -1927,50 +2184,75 @@ def main():
             "prev_volume": t.get("prev_volume"),
         }
 
     filtered_targets: Dict[str, Any] = {}
     for code, info in processed_targets.items():
         trades = _to_int(info.get("trades"), 0)
         win_rate = _to_float(info.get("win_rate_pct"), 0.0)
         mdd = abs(_to_float(info.get("mdd_pct"), 0.0) or 0.0)
         sharpe = _to_float(info.get("sharpe_m"), 0.0)
 
         if (
             trades < CHAMPION_MIN_TRADES
             or win_rate < CHAMPION_MIN_WINRATE
             or mdd > CHAMPION_MAX_MDD
             or sharpe < CHAMPION_MIN_SHARPE
         ):
             logger.info(
                 f"[CHAMPION_FILTER_SKIP] {code}: trades={trades}, win={win_rate:.1f}%, mdd={mdd:.1f}%, sharpe={sharpe:.2f}"
             )
             continue
 
         filtered_targets[code] = info
 
     processed_targets = filtered_targets
 
+    # Ï±îÌîºÏñ∏ Îì±Í∏âÌôî (A/B/C) ‚Üí Ïã§Ï†ú Îß§Ïàò ÌõÑÎ≥¥Îäî AÍ∏âÎßå ÏÇ¨Ïö©
+    graded_targets: Dict[str, Any] = {}
+    grade_counts = {"A": 0, "B": 0, "C": 0}
+    for code, info in processed_targets.items():
+        grade = _classify_champion_grade(info)
+        info["champion_grade"] = grade
+        graded_targets[code] = info
+        grade_counts[grade] = grade_counts.get(grade, 0) + 1
+
+    logger.info(
+        "[CHAMPION-GRADE] A:%d / B:%d / C:%d (AÍ∏âÎßå Ïã§Ï†ú Îß§Ïàò)",
+        grade_counts.get("A", 0),
+        grade_counts.get("B", 0),
+        grade_counts.get("C", 0),
+    )
+
+    processed_targets = {code: info for code, info in graded_targets.items() if info.get("champion_grade") == "A"}
+    non_a = [code for code, info in graded_targets.items() if info.get("champion_grade") != "A"]
+    if non_a:
+        logger.info(
+            "[CHAMPION-HOLD] B/CÍ∏â %dÏ¢ÖÎ™©ÏùÄ Í¥ÄÏ∞∞Îßå ÌïòÍ≥† Îß§Ïàò Ï†úÏô∏: %s",
+            len(non_a),
+            ",".join(non_a),
+        )
+
     if processed_targets:
         cumrets = [
             _to_float(info.get("cumulative_return_pct"), 0.0) or 0.0 for info in processed_targets.values()
         ]
         win_rates = [_to_float(info.get("win_rate_pct"), 0.0) or 0.0 for info in processed_targets.values()]
         sharpes = [_to_float(info.get("sharpe_m"), 0.0) or 0.0 for info in processed_targets.values()]
         mdds = [abs(_to_float(info.get("mdd_pct"), 0.0) or 0.0) for info in processed_targets.values()]
 
         for code, info in processed_targets.items():
             cum = _to_float(info.get("cumulative_return_pct"), 0.0) or 0.0
             win = _to_float(info.get("win_rate_pct"), 0.0) or 0.0
             sharpe = _to_float(info.get("sharpe_m"), 0.0) or 0.0
             mdd_val = abs(_to_float(info.get("mdd_pct"), 0.0) or 0.0)
 
             score = (
                 _percentile_rank(cumrets, cum) * 0.35
                 + _percentile_rank(win_rates, win) * 0.25
                 + _percentile_rank(sharpes, sharpe) * 0.25
                 + _percentile_rank(mdds, mdd_val, higher_is_better=False) * 0.15
             )
 
             info["composite_score"] = round(score, 4)
             processed_targets[code] = info
     else:
         logger.warning("[CHAMPION_FILTER] Ï°∞Í±¥ Ï∂©Ï°± Ï¢ÖÎ™© ÏóÜÏùå ‚Üí Ï±îÌîºÏñ∏ Î£®ÌîÑ Ïä§ÌÇµ")
@@ -2213,81 +2495,112 @@ def main():
                 time.sleep(60.0)
                 continue
 
             # ====== Îß§Ïàò/Îß§ÎèÑ(Ï†ÑÎûµ) LOOP ‚Äî Ïò§ÎäòÏùò ÌÉÄÍ≤ü ======
             for code, target in code_to_target.items():
                 prev_volume = _to_float(target.get("prev_volume"))
                 prev_open = _to_float(target.get("prev_open"))
                 prev_close = _to_float(target.get("prev_close"))
                 logger.debug(
                     f"[prev_volume Ï≤¥ÌÅ¨] {code} Í±∞ÎûòÎüâ:{prev_volume}, Ï†ÑÏùºÏãúÍ∞Ä:{prev_open}, Ï†ÑÏùºÏ¢ÖÍ∞Ä:{prev_close}"
                 )
 
                 planned_total_qty = _to_int(target.get("Îß§ÏàòÏàòÎüâ") or target.get("qty"), 0)
                 if planned_total_qty <= 0:
                     logger.info(f"[SKIP] {code}: Îß§ÏàòÏàòÎüâ ÏóÜÏùå/0")
                     continue
 
                 # ÎàåÎ¶ºÎ™© 3Îã®Í≥Ñ ÏßÑÏûÖ(40/35/25%)ÏùÑ ÏúÑÌïú Ïä§ÌÖåÏù¥ÏßÄÎ≥Ñ Î™©Ìëú ÏàòÎüâ
                 stage1_qty = max(1, int(planned_total_qty * ENTRY_LADDERS[0]))
                 stage2_qty = max(0, int(planned_total_qty * ENTRY_LADDERS[1]))
                 stage3_qty = max(0, int(planned_total_qty - stage1_qty - stage2_qty))
 
                 # 1Ï∞® ÏßÑÏûÖ Ïãú Ïã§Ï†ú Îß§Ïàò ÏàòÎüâÏùÄ stage1(40%)Îßå ÏÇ¨Ïö©
                 qty = stage1_qty
 
+                grade = target.get("champion_grade") or "C"
+                if grade != "A":
+                    logger.info(
+                        f"[CHAMPION-SKIP] {code}: grade={grade} ‚Üí Îß§Ïàò Î£®ÌîÑÏóêÏÑú Ï†úÏô∏"
+                    )
+                    continue
+
                 k_value = target.get("best_k") or target.get("K") or target.get("k")
                 _ = None if k_value is None else _to_float(k_value)
 
                 eff_target_price, k_used = compute_entry_target(kis, target)
                 strategy = target.get("strategy") or "Ï†ÑÏõî rolling K ÏµúÏ†ÅÌôî"
                 name = target.get("name") or target.get("Ï¢ÖÎ™©Î™Ö") or name_map.get(code)
 
                 try:
                     current_price = _safe_get_price(kis, code)
                     logger.info(f"[üìà ÌòÑÏû¨Í∞Ä] {code}: {current_price}")
 
                     pullback_info: Dict[str, Any] = {}
                     try:
                         pullback_info = _detect_pullback_reversal(
                             kis=kis,
                             code=code,
                             current_price=float(current_price) if current_price else None,
                         )
                     except Exception:
                         pullback_info = {}
 
                     trade_common_buy = {
                         "datetime": now_str,
                         "code": code,
                         "name": name,
                         "qty": qty,
                         "K": k_value if k_value is not None else k_used,
                         "target_price": eff_target_price,
                         "strategy": strategy,
                     }
 
+                    daily_ctx = _compute_daily_entry_context(
+                        kis, code, float(current_price) if current_price else None
+                    )
+                    intraday_ctx = _compute_intraday_entry_context(
+                        kis, code, prev_high=target.get("prev_high")
+                    )
+
+                    if is_bad_entry(code, daily_ctx, intraday_ctx, REGIME_STATE):
+                        logger.info(
+                            f"[CHAMPION-HOLD] {code}: AÍ∏âÏù¥ÏßÄÎßå BAD ÌÉÄÏ†ê ‚Üí Ïò§ÎäòÏùÄ Îß§Ïàò Î≥¥Î•ò"
+                        )
+                        continue
+
+                    if not is_good_entry(
+                        code,
+                        daily_ctx,
+                        intraday_ctx,
+                        prev_high=target.get("prev_high"),
+                    ):
+                        logger.info(
+                            f"[WAIT] {code}: AÍ∏âÏù¥ÎÇò GOOD ÌÉÄÏ†ê ÎØ∏Ï∂©Ï°± ‚Üí ÎàåÎ¶º ÎåÄÍ∏∞"
+                        )
+                        continue
+
                     # --- Îß§Ïàò --- (ÎèåÌåå ÏßÑÏûÖ + Ïä¨Î¶¨ÌîºÏßÄ Í∞ÄÎìú + ÏòàÏÇ∞ Í∞ÄÎìú)
                     if is_open and code not in holding and code not in traded:
                         if not can_buy:
                             logger.info(
                                 f"[BUDGET_SKIP] {code}: ÏòàÏÇ∞ ÏóÜÏùå ‚Üí Ïã†Í∑ú Îß§Ïàò Ïä§ÌÇµ"
                             )
                             continue
 
                         trigger_price = eff_target_price
                         if pullback_info.get("reversal_price"):
                             if trigger_price is None:
                                 trigger_price = float(pullback_info.get("reversal_price"))
                             else:
                                 trigger_price = max(
                                     float(trigger_price),
                                     float(pullback_info.get("reversal_price")),
                                 )
 
                         enter_cond = (
                             current_price is not None
                             and trigger_price is not None
                             and int(current_price) >= int(trigger_price)
                         )
 
                         if enter_cond:
