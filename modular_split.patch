diff --git a/trader/close_betting.py b/trader/close_betting.py
new file mode 100644
index 0000000000000000000000000000000000000000..07a8331668aaada50e0a37432bab6682d669ba39
--- /dev/null
+++ b/trader/close_betting.py
@@ -0,0 +1,165 @@
+import logging
+from datetime import datetime
+from typing import Any, Callable, Dict, List, Optional
+
+from .kis_wrapper import KisAPI
+
+logger = logging.getLogger(__name__)
+
+
+class CloseBettingEngine:
+    def __init__(
+        self,
+        topn: int,
+        cap_fraction: float,
+        min_ret_pct: float,
+        max_pullback_pct: float,
+        min_vol_spike: float,
+        price_fetcher: Callable[[KisAPI, str], Optional[float]],
+        daily_ctx_fetcher: Callable[[KisAPI, str, float], Dict[str, Any]],
+        intraday_ctx_fetcher: Callable[[KisAPI, str, Optional[float]], Dict[str, Any]],
+        qty_calculator: Callable[[KisAPI, str, int, Optional[float]], int],
+        buyer: Callable[[KisAPI, str, int, Optional[int]], Dict[str, Any]],
+        state_initializer: Callable[[KisAPI, Dict[str, Any], str, float, int, Optional[Any], Optional[Any], Any], None],
+        trade_logger: Callable[[dict], None],
+    ) -> None:
+        self.topn = topn
+        self.cap_fraction = cap_fraction
+        self.min_ret_pct = min_ret_pct
+        self.max_pullback_pct = max_pullback_pct
+        self.min_vol_spike = min_vol_spike
+        self._price_fetcher = price_fetcher
+        self._daily_ctx_fetcher = daily_ctx_fetcher
+        self._intraday_ctx_fetcher = intraday_ctx_fetcher
+        self._qty_calculator = qty_calculator
+        self._buyer = buyer
+        self._state_initializer = state_initializer
+        self._trade_logger = trade_logger
+        self.candidates: List[Dict[str, Any]] = []
+        self.entered: Dict[str, Any] = {}
+
+    def _score_candidate(self, daily_ctx: Dict[str, Any], intraday_ctx: Dict[str, Any]) -> float:
+        ret = daily_ctx.get("ret_today_pct") or 0.0
+        vol_ratio = daily_ctx.get("volume_ratio") or 0.0
+        from_high = intraday_ctx.get("from_high_pct") or 0.0
+        m5 = daily_ctx.get("ma5") or 0.0
+        m20 = daily_ctx.get("ma20") or 0.0
+        trend_bonus = 2.0 if (m5 and m20 and m5 > m20) else 0.0
+        location_score = max(0.0, 5.0 - from_high)
+        return ret * 0.6 + vol_ratio * 3.0 + location_score + trend_bonus
+
+    def scan_candidates(
+        self,
+        kis: KisAPI,
+        now_dt: datetime,
+        universe: Dict[str, Dict[str, Any]],
+        holding: Dict[str, Any],
+        traded: Dict[str, Any],
+    ) -> List[Dict[str, Any]]:
+        self.candidates = []
+        for code, info in universe.items():
+            if code in holding or code in traded:
+                continue
+            try:
+                price = self._price_fetcher(kis, code)
+            except Exception:
+                price = None
+            if price is None or price <= 0:
+                continue
+            daily_ctx = self._daily_ctx_fetcher(kis, code, price)
+            intraday_ctx = self._intraday_ctx_fetcher(kis, code, prev_high=info.get("prev_high"))
+
+            ret_pct = daily_ctx.get("ret_today_pct")
+            if ret_pct is None or ret_pct < self.min_ret_pct:
+                continue
+            vol_ratio = daily_ctx.get("volume_ratio") or 0.0
+            if vol_ratio < self.min_vol_spike:
+                continue
+            from_high = intraday_ctx.get("from_high_pct")
+            if from_high is not None and from_high > self.max_pullback_pct:
+                continue
+            if intraday_ctx.get("vwap") and intraday_ctx.get("last_close"):
+                if intraday_ctx["last_close"] < intraday_ctx["vwap"]:
+                    continue
+            if daily_ctx.get("ma5") and daily_ctx.get("ma20"):
+                if daily_ctx["ma5"] <= daily_ctx["ma20"]:
+                    continue
+
+            score = self._score_candidate(daily_ctx, intraday_ctx)
+            self.candidates.append(
+                {
+                    "code": code,
+                    "name": info.get("name"),
+                    "price": price,
+                    "score": score,
+                    "daily_ctx": daily_ctx,
+                    "intraday_ctx": intraday_ctx,
+                }
+            )
+        picked = sorted(self.candidates, key=lambda x: x.get("score", 0), reverse=True)[: self.topn]
+        if picked:
+            msg = ", ".join([f"{c.get('code')}({c.get('score'):.2f})" for c in picked])
+            logger.info("[CLOSE-BET-SCAN] %dê°œ í›„ë³´ ì •ë ¬ ê²°ê³¼: %s", len(picked), msg)
+        else:
+            logger.info("[CLOSE-BET-SCAN] ì¢…ê°€ ë² íŒ… í›„ë³´ ì—†ìŒ")
+        return picked
+
+    def enter_close_bets(
+        self,
+        kis: KisAPI,
+        now_dt: datetime,
+        capital_active: int,
+        holding: Dict[str, Any],
+        traded: Dict[str, Any],
+        can_buy: bool,
+    ) -> None:
+        if not can_buy:
+            logger.info("[CLOSE-BET-ENTRY] ì˜ˆìˆ˜ê¸ˆ ë¶€ì¡± â†’ ì¢…ê°€ ë² íŒ… ë§¤ìˆ˜ ìŠ¤í‚µ")
+            return
+        if not self.candidates:
+            return
+        per_notional = int(max(0, capital_active * self.cap_fraction) / max(1, len(self.candidates)))
+        for cand in self.candidates[: self.topn]:
+            code = cand.get("code")
+            if not code or code in holding or code in traded:
+                continue
+            qty = self._qty_calculator(kis, code, per_notional, ref_price=cand.get("price"))
+            if qty <= 0:
+                continue
+            result = self._buyer(kis, code, qty, limit_price=int(cand.get("price") or 0))
+            self._state_initializer(
+                kis,
+                holding,
+                code,
+                float(cand.get("price") or 0.0),
+                int(qty),
+                None,
+                cand.get("price"),
+                strategy="CLOSE_BET",
+            )
+            traded[code] = {
+                "buy_time": now_dt.strftime("%Y-%m-%d %H:%M:%S"),
+                "qty": int(qty),
+                "price": float(cand.get("price") or 0.0),
+                "strategy": "CLOSE_BET",
+            }
+            logger.info(
+                "[CLOSE-BET-ENTRY] code=%s qty=%s price=%s score=%.2f",
+                code,
+                qty,
+                cand.get("price"),
+                cand.get("score", 0.0),
+            )
+            self._trade_logger(
+                {
+                    "datetime": now_dt.strftime("%Y-%m-%d %H:%M:%S"),
+                    "code": code,
+                    "name": cand.get("name"),
+                    "qty": int(qty),
+                    "side": "BUY",
+                    "price": cand.get("price"),
+                    "amount": int(qty) * int(cand.get("price") or 0),
+                    "strategy": "ì¢…ê°€ ë² íŒ…",
+                    "result": result,
+                }
+            )

diff --git a/trader/config.py b/trader/config.py
new file mode 100644
index 0000000000000000000000000000000000000000..18da6b8aa7790880324fcfc8cb1047f3017c3949
--- /dev/null
+++ b/trader/config.py
@@ -0,0 +1,96 @@
+import os
+
+# =========================
+# [CONFIG] .env ì—†ì´ë„ ë™ìž‘
+# - ì•„ëž˜ ê°’ì„ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©
+# - (ì„ íƒ) ë™ì¼ í‚¤ë¥¼ í™˜ê²½ë³€ìˆ˜ë¡œ ë„˜ê¸°ë©´ override
+# =========================
+CONFIG = {
+    "SELL_FORCE_TIME": "15:25",
+    "SELL_ALL_BALANCES_AT_CUTOFF": "false",  # "true"ë©´ ì»¤íŠ¸ì˜¤í”„ì— ì „ì²´ ìž”ê³  í¬í•¨ ê°•ì œë§¤ë„ ë£¨í‹´ ì‚¬ìš©
+    "API_RATE_SLEEP_SEC": "0.5",
+    "FORCE_SELL_PASSES_CUTOFF": "2",
+    "FORCE_SELL_PASSES_CLOSE": "4",
+    "PARTIAL1": "0.5",
+    "PARTIAL2": "0.3",
+    "TRAIL_PCT": "0.02",
+    "FAST_STOP": "0.01",
+    "ATR_STOP": "1.5",
+    "TIME_STOP_HHMM": "13:00",
+    "DEFAULT_PROFIT_PCT": "3.0",
+    "DEFAULT_LOSS_PCT": "5.0",
+    "DAILY_CAPITAL": "250000000",
+    "CAP_CAP": "0.8",
+    "SLIPPAGE_LIMIT_PCT": "0.25",
+    "SLIPPAGE_ENTER_GUARD_PCT": "2.5",
+    "VWAP_TOL": "0.003",  # ðŸ”¸ VWAP í—ˆìš© ì˜¤ì°¨(ê¸°ë³¸ 0.3%)
+    "W_MAX_ONE": "0.25",
+    "W_MIN_ONE": "0.03",
+    "REBALANCE_ANCHOR": "weekly",  # weekly | today | monthly
+    "WEEKLY_ANCHOR_REF": "last",  # NEW: 'last'(ì§ì „ ì¼ìš”ì¼) | 'next'(ë‹¤ìŒ ì¼ìš”ì¼)
+    "MOMENTUM_OVERRIDES_FORCE_SELL": "true",
+    # ë ˆì§(ì½”ìŠ¤ë‹¥) íŒŒë¼ë¯¸í„°
+    "KOSDAQ_INDEX_CODE": "KOSDAQ",
+    "KOSDAQ_ETF_FALLBACK": "229200",
+    "REG_BULL_MIN_UP_PCT": "0.5",
+    "REG_BULL_MIN_MINUTES": "10",
+    "REG_BEAR_VWAP_MINUTES": "10",
+    "REG_BEAR_DROP_FROM_HIGH": "0.7",
+    "REG_BEAR_STAGE1_MINUTES": "20",
+    "REG_BEAR_STAGE2_ADD_DROP": "0.5",
+    "REG_PARTIAL_S1": "0.30",
+    "REG_PARTIAL_S2": "0.30",
+    "TRAIL_PCT_BULL": "0.025",
+    "TRAIL_PCT_BEAR": "0.012",
+    "TP_PROFIT_PCT_BULL": "3.5",
+    # ì‹ ê³ ê°€ ëŒíŒŒ í›„ 3ì¼ ëˆŒë¦¼ + ë°˜ë“± ë§¤ìˆ˜ìš© íŒŒë¼ë¯¸í„°
+    "USE_PULLBACK_ENTRY": "true",  # trueë©´ 'ì‹ ê³ ê°€ â†’ 3ì¼ ì—°ì† í•˜ë½ â†’ ë°˜ë“±' íŒ¨í„´ ì¶©ì¡± ì‹œì—ë§Œ ëˆŒë¦¼ëª© ì§„ìž… í—ˆìš©
+    "PULLBACK_LOOKBACK": "60",  # ì‹ ê³ ê°€ íƒìƒ‰ ë²”ìœ„(ê±°ëž˜ì¼ ê¸°ì¤€)
+    "PULLBACK_DAYS": "3",  # ì—°ì† í•˜ë½ ì¼ìˆ˜
+    "PULLBACK_REVERSAL_BUFFER_PCT": "0.2",  # ë˜ëŒë¦¼ í™•ì¸ ì—¬ìœ (%): ì§ì „ í•˜ë½ì¼ ê³ ê°€ ëŒ€ë¹„ ì—¬ìœ ìœ¨
+    "PULLBACK_TOPN": "50",  # ëˆŒë¦¼ëª© ìŠ¤ìº”ìš© ê° ì‹œìž¥ë³„ ì‹œì´ ìƒìœ„ ì¢…ëª© ìˆ˜
+    "PULLBACK_UNIT_WEIGHT": "0.03",  # ëˆŒë¦¼ëª© ë§¤ìˆ˜ 1ê±´ë‹¹ ìžë³¸ ë°°ë¶„(í™œì„± ìžë³¸ ë¹„ìœ¨)
+    # ì±”í”¼ì–¸ í›„ë³´ í•„í„°
+    "CHAMPION_MIN_TRADES": "5",  # ìµœì†Œ ê±°ëž˜ìˆ˜
+    "CHAMPION_MIN_WINRATE": "45.0",  # ìµœì†Œ ìŠ¹ë¥ (%)
+    "CHAMPION_MAX_MDD": "30.0",  # ìµœëŒ€ í—ˆìš© MDD(%)
+    "CHAMPION_MIN_SHARPE": "0.0",  # ìµœì†Œ ìƒ¤í”„ ë¹„ìœ¨
+    # ê¸°íƒ€
+    "MARKET_DATA_WHEN_CLOSED": "false",
+    "FORCE_WEEKLY_REBALANCE": "0",
+    # NEW: 1ë¶„ë´‰ VWAP ëª¨ë©˜í…€ íŒŒë¼ë¯¸í„°
+    "MOM_FAST": "5",  # 1ë¶„ë´‰ fast MA ê¸¸ì´
+    "MOM_SLOW": "20",  # 1ë¶„ë´‰ slow MA ê¸¸ì´
+    "MOM_TH_PCT": "0.5",  # fast/slow ê´´ë¦¬ ìž„ê³„ê°’(%) â€“ 0.5% ì´ìƒì´ë©´ ê°•ì„¸ë¡œ ë³¸ë‹¤
+    # ì‹œê°„ êµ¬ê°„
+    "ACTIVE_START_HHMM": "09:30",
+    "FULL_ACTIVE_END_HHMM": "14:30",
+    "CLOSE_BET_PREP_START_HHMM": "14:30",
+    "CLOSE_BET_ENTRY_START_HHMM": "15:10",
+    "MARKET_CLOSE_HHMM": "15:30",
+    # ì¢…ê°€ ë² íŒ…
+    "CLOSE_BET_TOPN": "5",
+    "CLOSE_BET_CAP_FRACTION": "0.2",
+    "CLOSE_BET_MIN_RET_PCT": "3.0",
+    "CLOSE_BET_MAX_PULLBACK_PCT": "3.0",
+    "CLOSE_BET_MIN_VOL_SPIKE": "2.0",
+    # ì½”ì–´ í¬ì§€ì…˜
+    "ENABLE_CORE_POSITIONS": "true",
+    "CORE_MAX_FRACTION": "0.6",
+    "CORE_W_MAX_ONE": "0.10",
+    "CORE_SCAN_TOPN": "250",
+    "CORE_BOX_RANGE_PCT": "5.0",
+    "CORE_BREAKOUT_PCT": "2.0",
+    # ìœ ë‹ˆë²„ìŠ¤ êµ¬ì„± (ì½”ìŠ¤ë‹¥/ì½”ìŠ¤í”¼ ë¹„ìœ¨ ë° ì‚¬ìš© ì—¬ë¶€)
+    "UNIVERSE_INCLUDE_MARKETS": "KOSDAQ,KOSPI",  # "KOSDAQ", "KOSPI", "KOSDAQ,KOSPI"
+    "UNIVERSE_KOSDAQ_TOPN": "50",
+    "UNIVERSE_KOSPI_TOPN": "50",
+}
+
+
+def cfg(key: str) -> str:
+    """í™˜ê²½ë³€ìˆ˜ > CONFIG ê¸°ë³¸ê°’."""
+    return os.getenv(key, CONFIG.get(key, ""))
+
+
+__all__ = ["CONFIG", "cfg"]

diff --git a/trader/core_positions.py b/trader/core_positions.py
new file mode 100644
index 0000000000000000000000000000000000000000..c49cf6a0952da167f3026eb721ae6efffda2e94c
--- /dev/null
+++ b/trader/core_positions.py
@@ -0,0 +1,144 @@
+import logging
+from datetime import datetime
+from typing import Any, Callable, Dict, List, Optional
+
+from .kis_wrapper import KisAPI
+
+logger = logging.getLogger(__name__)
+
+
+class CorePositionEngine:
+    def __init__(
+        self,
+        box_range_pct: float,
+        breakout_pct: float,
+        min_vol_spike: float,
+        max_fraction: float,
+        weight_one: float,
+        daily_candle_fetcher: Callable[[KisAPI, str, int], List[Dict[str, Any]]],
+        qty_calculator: Callable[[KisAPI, str, int, Optional[float]], int],
+        price_fetcher: Callable[[KisAPI, str], Optional[float]],
+        buyer: Callable[[KisAPI, str, int, Optional[int]], Dict[str, Any]],
+        state_initializer: Callable[[KisAPI, Dict[str, Any], str, float, int, Optional[Any], Optional[Any], Any], None],
+        trade_logger: Callable[[dict], None],
+        tzinfo,
+    ) -> None:
+        self.box_range_pct = box_range_pct
+        self.breakout_pct = breakout_pct
+        self.min_vol_spike = min_vol_spike
+        self.max_fraction = max_fraction
+        self.weight_one = weight_one
+        self._daily_candle_fetcher = daily_candle_fetcher
+        self._qty_calculator = qty_calculator
+        self._price_fetcher = price_fetcher
+        self._buyer = buyer
+        self._state_initializer = state_initializer
+        self._trade_logger = trade_logger
+        self._tzinfo = tzinfo
+        self.candidates: List[Dict[str, Any]] = []
+
+    def _is_core_candidate(self, kis: KisAPI, code: str) -> Dict[str, Any]:
+        ctx: Dict[str, Any] = {"ok": False}
+        try:
+            candles = self._daily_candle_fetcher(kis, code, 220)
+        except Exception as e:
+            return {"ok": False, "reason": f"fetch_fail:{e}"}
+        if not candles or len(candles) < 200:
+            return {"ok": False, "reason": "not_enough_candles"}
+        today = datetime.now(self._tzinfo).strftime("%Y%m%d")
+        completed = list(candles)
+        if completed and str(completed[-1].get("date")) == today:
+            completed = completed[:-1]
+        if len(completed) < 200:
+            return {"ok": False, "reason": "not_enough_completed"}
+        closes = [float(c.get("close") or 0.0) for c in completed if c.get("close")]
+        highs = [float(c.get("high") or 0.0) for c in completed if c.get("high")]
+        opens = [float(c.get("open") or 0.0) for c in completed if c.get("open")]
+        vols = [float(c.get("volume") or 0.0) for c in completed if c.get("volume")]
+        if len(closes) < 200:
+            return {"ok": False, "reason": "close_short"}
+        ma200 = sum(closes[-200:]) / 200.0
+        ctx["ma200"] = ma200
+        last_close = closes[-1]
+        last_open = opens[-1] if opens else last_close
+        box_high = max(closes[-40:])
+        box_low = min(closes[-40:])
+        box_range_pct = (box_high - box_low) / box_low * 100.0 if box_low else 0.0
+        ctx["box_range_pct"] = box_range_pct
+        volume_ratio = 0.0
+        if vols and len(vols) >= 21:
+            volume_ratio = (vols[-1] / (sum(vols[-21:-1]) / 20.0)) if (sum(vols[-21:-1]) > 0) else 0.0
+        ctx["volume_ratio"] = volume_ratio
+        breakout = (
+            box_range_pct <= self.box_range_pct
+            and last_close >= ma200 * (1 + self.breakout_pct / 100.0)
+            and last_close >= last_open * (1 + self.breakout_pct / 100.0)
+            and volume_ratio >= self.min_vol_spike
+        )
+        near_ma200 = abs(last_close - ma200) / ma200 * 100.0 <= self.box_range_pct
+        ctx["near_ma200"] = near_ma200
+        ctx["breakout"] = breakout
+        ctx["ok"] = breakout and near_ma200
+        return ctx
+
+    def scan(self, kis: KisAPI, universe: Dict[str, Dict[str, Any]]) -> List[Dict[str, Any]]:
+        self.candidates = []
+        for code, info in universe.items():
+            ctx = self._is_core_candidate(kis, code)
+            if ctx.get("ok"):
+                self.candidates.append({"code": code, "name": info.get("name"), "ctx": ctx})
+        if self.candidates:
+            logger.info(
+                "[CORE-SCAN] ì½”ì–´ í¬ì§€ì…˜ í›„ë³´ %dì¢…ëª© íƒìƒ‰ ì™„ë£Œ: %s",
+                len(self.candidates),
+                ",".join([c.get("code", "") for c in self.candidates]),
+            )
+        return self.candidates
+
+    def enter(
+        self, kis: KisAPI, capital_active: int, holding: Dict[str, Any], traded: Dict[str, Any], can_buy: bool
+    ) -> None:
+        if not self.candidates or capital_active <= 0 or not can_buy:
+            if not can_buy:
+                logger.info("[CORE-ENTRY] ì˜ˆìˆ˜ê¸ˆ ë¶€ì¡± â†’ ì½”ì–´ í¬ì§€ì…˜ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ")
+            return
+        max_core_cap = int(capital_active * self.max_fraction)
+        per_notional = int(max_core_cap * self.weight_one)
+        for cand in self.candidates:
+            code = cand.get("code")
+            if not code or code in holding or code in traded:
+                continue
+            qty = self._qty_calculator(kis, code, per_notional)
+            if qty <= 0:
+                continue
+            price = self._price_fetcher(kis, code)
+            result = self._buyer(kis, code, qty, limit_price=int(price or 0))
+            self._state_initializer(
+                kis, holding, code, float(price or 0.0), int(qty), None, price, strategy="CORE"
+            )
+            traded[code] = {
+                "buy_time": datetime.now(self._tzinfo).strftime("%Y-%m-%d %H:%M:%S"),
+                "qty": int(qty),
+                "price": float(price or 0.0),
+                "strategy": "CORE",
+            }
+            logger.info(
+                "[CORE-ENTRY] code=%s qty=%s price=%s ctx=%s",
+                code,
+                qty,
+                price,
+                cand.get("ctx"),
+            )
+            self._trade_logger(
+                {
+                    "datetime": datetime.now(self._tzinfo).strftime("%Y-%m-%d %H:%M:%S"),
+                    "code": code,
+                    "name": cand.get("name"),
+                    "qty": int(qty),
+                    "side": "BUY",
+                    "price": price,
+                    "amount": int(qty) * int(price or 0),
+                    "strategy": "ì½”ì–´ í¬ì§€ì…˜",
+                    "result": result,
+                }
+            )

diff --git a/trader/time_modes.py b/trader/time_modes.py
new file mode 100644
index 0000000000000000000000000000000000000000..74719235c9e8970457109becbefbc8f170d0e97c
--- /dev/null
+++ b/trader/time_modes.py
@@ -0,0 +1,81 @@
+import logging
+from dataclasses import dataclass
+from datetime import datetime, time as dtime
+
+
+@dataclass
+class TimeModeState:
+    """Legacy time-mode flags used by the orchestrator loop.
+
+    The names mirror the original inline definition inside ``trader.py`` so
+    existing conditionals (intraday entry gates, close-bet scanning/entry
+    checks) keep working without attribute changes after the module split.
+    """
+
+    mode: str
+    allow_intraday_entries: bool
+    allow_close_bet_scan: bool
+    allow_close_bet_entry: bool
+
+
+class TimeModeController:
+    def __init__(
+        self,
+        active_start: dtime,
+        full_active_end: dtime,
+        close_bet_prep: dtime,
+        close_bet_entry: dtime,
+        cutoff: dtime,
+        market_close: dtime,
+    ) -> None:
+        self.active_start = active_start
+        self.full_active_end = full_active_end
+        self.close_bet_prep = close_bet_prep
+        self.close_bet_entry = close_bet_entry
+        self.cutoff = cutoff
+        self.market_close = market_close
+        self._last_mode: str = ""
+
+    def evaluate(self, now_dt: datetime) -> TimeModeState:
+        now_time = now_dt.time()
+        if now_time >= self.market_close:
+            mode = "shutdown"
+            return TimeModeState(mode, False, False, False)
+        if now_time >= self.cutoff:
+            mode = "cutoff"
+            return TimeModeState(mode, False, False, True)
+        if now_time >= self.close_bet_entry:
+            mode = "close_bet_entry"
+            return TimeModeState(mode, False, False, True)
+        if now_time >= self.close_bet_prep:
+            mode = "light_active"
+            return TimeModeState(mode, False, True, False)
+        if now_time >= self.active_start:
+            mode = "full_active"
+            return TimeModeState(mode, True, False, False)
+        mode = "pre_open"
+        return TimeModeState(mode, False, False, False)
+
+    def log_if_changed(self, logger: logging.Logger, state: TimeModeState) -> None:
+        if state.mode != self._last_mode:
+            self._last_mode = state.mode
+            if state.mode == "full_active":
+                logger.info(
+                    f"[TIME-MODE] FULL_ACTIVE ({self.active_start.strftime('%H:%M')}~{self.full_active_end.strftime('%H:%M')})"
+                )
+            elif state.mode == "light_active":
+                logger.info(
+                    f"[TIME-MODE] LIGHT_ACTIVE ({self.close_bet_prep.strftime('%H:%M')}~{self.close_bet_entry.strftime('%H:%M')}) ì‹ ê·œ ì§„ìž… ì œí•œ, ì¢…ê°€ ë² íŒ… ì¤€ë¹„"
+                )
+            elif state.mode == "close_bet_entry":
+                logger.info(
+                    f"[TIME-MODE] CLOSE_BET_ENTRY ({self.close_bet_entry.strftime('%H:%M')}~{self.cutoff.strftime('%H:%M')})"
+                )
+            elif state.mode == "shutdown":
+                logger.info(
+                    f"[TIME-MODE] SHUTDOWN ì¤€ë¹„ (ì»¤íŠ¸ì˜¤í”„ {self.cutoff.strftime('%H:%M')} ë„ë‹¬ ì˜ˆì •)"
+                )
+            else:
+                logger.info(
+                    "[TIME-MODE] PRE_OPEN (ìž¥ ì‹œìž‘ ì „ ì¤€ë¹„)"
+                )

diff --git a/trader/trader.py b/trader/trader.py
index 40e156187d3f0ac940c9a5c2cf677023335c8db7..ed40d383265806992c87c2453ede5720c9581ac5 100644
--- a/trader/trader.py
+++ b/trader/trader.py
@@ -1,174 +1,87 @@
 # -*- coding: utf-8 -*-
 # trader.py â€” KOSDAQ ë ˆì§(ê°•ì„¸/ì•½ì„¸) ê¸°ë°˜ ëª¨ë©˜í…€ ê°•í™” + ë‹¨ê³„ì  ì¶•ì†Œ, 14:40 ë¦¬í¬íŠ¸ ìƒì„± í›„ ì¢…ë£Œ(ì „ëŸ‰ë§¤ë„ ì—†ìŒ)
 
 import logging
 import requests
 from .kis_wrapper import KisAPI, append_fill
 from datetime import datetime, time as dtime, timedelta
 from zoneinfo import ZoneInfo
 import json
 from pathlib import Path
 import time
-import os
 import random
 from typing import Optional, Dict, Any, Tuple, List
 import csv
-from dataclasses import dataclass
+
+from .close_betting import CloseBettingEngine
+from .core_positions import CorePositionEngine
+from .time_modes import TimeModeController, TimeModeState
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 from .report_ceo import ceo_report
 from .metrics import vwap_guard   # ðŸ”¸ VWAP ê°€ë“œ í•¨ìˆ˜
 # ëª¨ë©˜í…€ ì²´í¬ í•¨ìˆ˜ê°€ ì¡´ìž¬í•˜ë©´ í™œìš©í•˜ê³ , ì—†ìœ¼ë©´ í•­ìƒ Falseë¡œ ì²˜ë¦¬í•´ ë§¤ë„ ë¡œì§ë§Œ ë³´ìˆ˜ì ìœ¼ë¡œ ë™ìž‘
 try:
     from .metrics import is_strong_momentum
 except Exception:
 
     def is_strong_momentum(*args, **kwargs):  # type: ignore
         return False
 try:
     from rolling_k_auto_trade_api.best_k_meta_strategy import (
         get_kosdaq_top_n,
         get_kospi_top_n,
         get_kosdaq_kospi_top_n,
     )
 except Exception as import_err:
     logger.warning(
         "[UNIVERSE-FALLBACK] ì‹œì´ TopN í†µí•© í—¬í¼ import ì‹¤íŒ¨: %s â†’ ì½”ìŠ¤ë‹¥ ì „ìš©ìœ¼ë¡œ í´ë°±",
         import_err,
     )
 
     try:
         from rolling_k_auto_trade_api.best_k_meta_strategy import get_kosdaq_top_n
     except Exception:
 
         def get_kosdaq_top_n(*args, **kwargs):  # type: ignore
             logger.warning(
                 "[UNIVERSE-FALLBACK] get_kosdaq_top_n ë¯¸ì§€ì› â†’ ìœ ë‹ˆë²„ìŠ¤ê°€ ë¹„ì–´ ìžˆì„ ìˆ˜ ìžˆìŒ"
             )
             return []
 
     def get_kospi_top_n(*args, **kwargs):  # type: ignore
         logger.warning("[UNIVERSE-FALLBACK] get_kospi_top_n ì‚¬ìš© ë¶ˆê°€ â†’ ì½”ìŠ¤ë‹¥ë§Œ ì‚¬ìš©")
         return []
 
     def get_kosdaq_kospi_top_n(*args, **kwargs):  # type: ignore
         logger.warning("[UNIVERSE-FALLBACK] í†µí•© ìœ ë‹ˆë²„ìŠ¤ ë¯¸ì§€ì› â†’ ì½”ìŠ¤ë‹¥ë§Œ ì‚¬ìš©")
         return []
 
-# =========================
-# [CONFIG] .env ì—†ì´ë„ ë™ìž‘
-# - ì•„ëž˜ ê°’ì„ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©
-# - (ì„ íƒ) ë™ì¼ í‚¤ë¥¼ í™˜ê²½ë³€ìˆ˜ë¡œ ë„˜ê¸°ë©´ override
-# =========================
-CONFIG = {
-    "SELL_FORCE_TIME": "15:25",
-    "SELL_ALL_BALANCES_AT_CUTOFF": "false",  # "true"ë©´ ì»¤íŠ¸ì˜¤í”„ì— ì „ì²´ ìž”ê³  í¬í•¨ ê°•ì œë§¤ë„ ë£¨í‹´ ì‚¬ìš©
-    "API_RATE_SLEEP_SEC": "0.5",
-    "FORCE_SELL_PASSES_CUTOFF": "2",
-    "FORCE_SELL_PASSES_CLOSE": "4",
-    "PARTIAL1": "0.5",
-    "PARTIAL2": "0.3",
-    "TRAIL_PCT": "0.02",
-    "FAST_STOP": "0.01",
-    "ATR_STOP": "1.5",
-    "TIME_STOP_HHMM": "13:00",
-    "DEFAULT_PROFIT_PCT": "3.0",
-    "DEFAULT_LOSS_PCT": "5.0",
-    "DAILY_CAPITAL": "250000000",
-    "CAP_CAP": "0.8",
-    "SLIPPAGE_LIMIT_PCT": "0.25",
-    "SLIPPAGE_ENTER_GUARD_PCT": "2.5",
-    "VWAP_TOL": "0.003",  # ðŸ”¸ VWAP í—ˆìš© ì˜¤ì°¨(ê¸°ë³¸ 0.3%)
-    "W_MAX_ONE": "0.25",
-    "W_MIN_ONE": "0.03",
-    "REBALANCE_ANCHOR": "weekly",             # weekly | today | monthly
-    "WEEKLY_ANCHOR_REF": "last",              # NEW: 'last'(ì§ì „ ì¼ìš”ì¼) | 'next'(ë‹¤ìŒ ì¼ìš”ì¼)
-    "MOMENTUM_OVERRIDES_FORCE_SELL": "true",
-    # ë ˆì§(ì½”ìŠ¤ë‹¥) íŒŒë¼ë¯¸í„°
-    "KOSDAQ_INDEX_CODE": "KOSDAQ",
-    "KOSDAQ_ETF_FALLBACK": "229200",
-    "REG_BULL_MIN_UP_PCT": "0.5",
-    "REG_BULL_MIN_MINUTES": "10",
-    "REG_BEAR_VWAP_MINUTES": "10",
-    "REG_BEAR_DROP_FROM_HIGH": "0.7",
-    "REG_BEAR_STAGE1_MINUTES": "20",
-    "REG_BEAR_STAGE2_ADD_DROP": "0.5",
-    "REG_PARTIAL_S1": "0.30",
-    "REG_PARTIAL_S2": "0.30",
-    "TRAIL_PCT_BULL": "0.025",
-    "TRAIL_PCT_BEAR": "0.012",
-    "TP_PROFIT_PCT_BULL": "3.5",
-    # ì‹ ê³ ê°€ ëŒíŒŒ í›„ 3ì¼ ëˆŒë¦¼ + ë°˜ë“± ë§¤ìˆ˜ìš© íŒŒë¼ë¯¸í„°
-    "USE_PULLBACK_ENTRY": "true",          # trueë©´ 'ì‹ ê³ ê°€ â†’ 3ì¼ ì—°ì† í•˜ë½ â†’ ë°˜ë“±' íŒ¨í„´ ì¶©ì¡± ì‹œì—ë§Œ ëˆŒë¦¼ëª© ì§„ìž… í—ˆìš©
-    "PULLBACK_LOOKBACK": "60",             # ì‹ ê³ ê°€ íƒìƒ‰ ë²”ìœ„(ê±°ëž˜ì¼ ê¸°ì¤€)
-    "PULLBACK_DAYS": "3",                  # ì—°ì† í•˜ë½ ì¼ìˆ˜
-    "PULLBACK_REVERSAL_BUFFER_PCT": "0.2", # ë˜ëŒë¦¼ í™•ì¸ ì—¬ìœ (%): ì§ì „ í•˜ë½ì¼ ê³ ê°€ ëŒ€ë¹„ ì—¬ìœ ìœ¨
-    "PULLBACK_TOPN": "50",                 # ëˆŒë¦¼ëª© ìŠ¤ìº”ìš© ê° ì‹œìž¥ë³„ ì‹œì´ ìƒìœ„ ì¢…ëª© ìˆ˜
-    "PULLBACK_UNIT_WEIGHT": "0.03",        # ëˆŒë¦¼ëª© ë§¤ìˆ˜ 1ê±´ë‹¹ ìžë³¸ ë°°ë¶„(í™œì„± ìžë³¸ ë¹„ìœ¨)
-    # ì±”í”¼ì–¸ í›„ë³´ í•„í„°
-    "CHAMPION_MIN_TRADES": "5",            # ìµœì†Œ ê±°ëž˜ìˆ˜
-    "CHAMPION_MIN_WINRATE": "45.0",        # ìµœì†Œ ìŠ¹ë¥ (%)
-    "CHAMPION_MAX_MDD": "30.0",            # ìµœëŒ€ í—ˆìš© MDD(%)
-    "CHAMPION_MIN_SHARPE": "0.0",          # ìµœì†Œ ìƒ¤í”„ ë¹„ìœ¨
-    # ê¸°íƒ€
-    "MARKET_DATA_WHEN_CLOSED": "false",
-    "FORCE_WEEKLY_REBALANCE": "0",
-    # NEW: 1ë¶„ë´‰ VWAP ëª¨ë©˜í…€ íŒŒë¼ë¯¸í„°
-    "MOM_FAST": "5",        # 1ë¶„ë´‰ fast MA ê¸¸ì´
-    "MOM_SLOW": "20",       # 1ë¶„ë´‰ slow MA ê¸¸ì´
-    "MOM_TH_PCT": "0.5",    # fast/slow ê´´ë¦¬ ìž„ê³„ê°’(%) â€“ 0.5% ì´ìƒì´ë©´ ê°•ì„¸ë¡œ ë³¸ë‹¤
-    # ì‹œê°„ êµ¬ê°„
-    "ACTIVE_START_HHMM": "09:30",
-    "FULL_ACTIVE_END_HHMM": "14:30",
-    "CLOSE_BET_PREP_START_HHMM": "14:30",
-    "CLOSE_BET_ENTRY_START_HHMM": "15:10",
-    "MARKET_CLOSE_HHMM": "15:30",
-    # ì¢…ê°€ ë² íŒ…
-    "CLOSE_BET_TOPN": "5",
-    "CLOSE_BET_CAP_FRACTION": "0.2",
-    "CLOSE_BET_MIN_RET_PCT": "3.0",
-    "CLOSE_BET_MAX_PULLBACK_PCT": "3.0",
-    "CLOSE_BET_MIN_VOL_SPIKE": "2.0",
-    # ì½”ì–´ í¬ì§€ì…˜
-    "ENABLE_CORE_POSITIONS": "true",
-    "CORE_MAX_FRACTION": "0.6",
-    "CORE_W_MAX_ONE": "0.10",
-    "CORE_SCAN_TOPN": "250",
-    "CORE_BOX_RANGE_PCT": "5.0",
-    "CORE_BREAKOUT_PCT": "2.0",
-    # ìœ ë‹ˆë²„ìŠ¤ êµ¬ì„± (ì½”ìŠ¤ë‹¥/ì½”ìŠ¤í”¼ ë¹„ìœ¨ ë° ì‚¬ìš© ì—¬ë¶€)
-    "UNIVERSE_INCLUDE_MARKETS": "KOSDAQ,KOSPI",  # "KOSDAQ", "KOSPI", "KOSDAQ,KOSPI"
-    "UNIVERSE_KOSDAQ_TOPN": "50",
-    "UNIVERSE_KOSPI_TOPN": "50",
-}
-
-def _cfg(key: str) -> str:
-    """í™˜ê²½ë³€ìˆ˜ > CONFIG ê¸°ë³¸ê°’"""
-    return os.getenv(key, CONFIG.get(key, ""))
+from .config import CONFIG, cfg as _cfg
 
 # RK-Max ìœ í‹¸(ê°€ëŠ¥í•˜ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ graceful fallback)
 try:
     from .rkmax_utils import blend_k, recent_features
 except Exception:
     def blend_k(k_month: float, day: int, atr20: Optional[float], atr60: Optional[float]) -> float:
         return float(k_month) if k_month is not None else 0.5
 
     def recent_features(kis, code: str) -> Dict[str, Optional[float]]:
         return {"atr20": None, "atr60": None}
 
 # === [ANCHOR: TICK_UTILS] KRX í˜¸ê°€ë‹¨ìœ„ & ë¼ìš´ë”© ===
 def _krx_tick(price: float) -> int:
     p = float(price or 0)
     if p >= 500_000:
         return 1_000
     if p >= 100_000:
         return 500
     if p >= 50_000:
         return 100
     if p >= 10_000:
         return 50
     if p >= 5_000:
         return 10
     if p >= 1_000:
@@ -304,364 +217,50 @@ GOOD_ENTRY_MAX_FROM_PEAK = 0.97  # í˜„ìž¬ê°€/ìµœê·¼ê³ ì  ìµœëŒ€ì¹˜(â‰¤0.97)
 GOOD_ENTRY_MIN_RR = 2.0  # ê¸°ëŒ€ìˆ˜ìµ/ë¦¬ìŠ¤í¬ ìµœì†Œ ë¹„ìœ¨
 GOOD_ENTRY_MIN_INTRADAY_SIG = 2  # GOOD íƒ€ì ìœ¼ë¡œ ì¸ì •í•˜ê¸° ìœ„í•œ ìµœì†Œ intraday ì‹œê·¸ë„ ê°œìˆ˜
 
 BAD_ENTRY_MAX_MA20_DIST = 1.25  # í˜„ìž¬ê°€/20MA ìƒí•œ(ì¶”ê²©ë§¤ìˆ˜ ë°©ì§€)
 BAD_ENTRY_MAX_PULLBACK = 20.0  # ì‹ ê³ ê°€ ëŒ€ë¹„ ëˆŒë¦¼í­ ìƒí•œ(ê³¼ë„í•œ ë¶•ê´´ ë°©ì§€)
 BAD_ENTRY_MAX_BELOW_VWAP_RATIO = 0.7  # ë¶„ë´‰ì—ì„œ VWAP ì•„ëž˜ ì²´ë¥˜ ë¹„ì¤‘ì´ ì´ ì´ìƒì´ë©´ BAD
 
 def _parse_hhmm(hhmm: str) -> dtime:
     try:
         hh, mm = hhmm.split(":")
         return dtime(hour=int(hh), minute=int(mm))
     except Exception:
         logger.warning(f"[ì„¤ì •ê²½ê³ ] SELL_FORCE_TIME í˜•ì‹ ì˜¤ë¥˜ â†’ ê¸°ë³¸ê°’ 14:40 ì ìš©: {hhmm}")
         return dtime(hour=14, minute=40)
 
 SELL_FORCE_TIME = _parse_hhmm(SELL_FORCE_TIME_STR)
 TIME_STOP_TIME = _parse_hhmm(TIME_STOP_HHMM)
 ACTIVE_START_TIME = _parse_hhmm(ACTIVE_START_HHMM)
 FULL_ACTIVE_END_TIME = _parse_hhmm(FULL_ACTIVE_END_HHMM)
 CLOSE_BET_PREP_START_TIME = _parse_hhmm(CLOSE_BET_PREP_START_HHMM)
 CLOSE_BET_ENTRY_START_TIME = _parse_hhmm(CLOSE_BET_ENTRY_START_HHMM)
 MARKET_CLOSE_TIME = _parse_hhmm(MARKET_CLOSE_HHMM)
 ALLOW_WHEN_CLOSED = _cfg("MARKET_DATA_WHEN_CLOSED").lower() == "true"
 
 
-@dataclass
-class TimeModeState:
-    mode: str
-    allow_intraday_entries: bool
-    allow_close_bet_scan: bool
-    allow_close_bet_entry: bool
-
-
-class TimeModeController:
-    def __init__(
-        self,
-        active_start: dtime,
-        full_active_end: dtime,
-        close_bet_prep: dtime,
-        close_bet_entry: dtime,
-        cutoff: dtime,
-        market_close: dtime,
-    ):
-        self.active_start = active_start
-        self.full_active_end = full_active_end
-        self.close_bet_prep = close_bet_prep
-        self.close_bet_entry = close_bet_entry
-        self.cutoff = cutoff
-        self.market_close = market_close
-        self._last_mode: Optional[str] = None
-
-    def evaluate(self, now_dt: datetime) -> TimeModeState:
-        now_time = now_dt.time()
-        if now_time >= self.cutoff:
-            mode = "shutdown"
-            return TimeModeState(mode, False, False, False)
-        if now_time >= self.close_bet_entry:
-            mode = "close_bet_entry"
-            return TimeModeState(mode, False, False, True)
-        if now_time >= self.close_bet_prep:
-            mode = "light_active"
-            return TimeModeState(mode, False, True, False)
-        if now_time >= self.active_start:
-            mode = "full_active"
-            return TimeModeState(mode, True, False, False)
-        mode = "pre_open"
-        return TimeModeState(mode, False, False, False)
-
-    def log_if_changed(self, logger: logging.Logger, state: TimeModeState) -> None:
-        if state.mode != self._last_mode:
-            self._last_mode = state.mode
-            if state.mode == "full_active":
-                logger.info(
-                    f"[TIME-MODE] FULL_ACTIVE ({ACTIVE_START_TIME.strftime('%H:%M')}~{FULL_ACTIVE_END_TIME.strftime('%H:%M')})"
-                )
-            elif state.mode == "light_active":
-                logger.info(
-                    f"[TIME-MODE] LIGHT_ACTIVE ({CLOSE_BET_PREP_START_TIME.strftime('%H:%M')}~{CLOSE_BET_ENTRY_START_TIME.strftime('%H:%M')}) ì‹ ê·œ ì§„ìž… ì œí•œ, ì¢…ê°€ ë² íŒ… ì¤€ë¹„"
-                )
-            elif state.mode == "close_bet_entry":
-                logger.info(
-                    f"[TIME-MODE] CLOSE_BET_ENTRY ({CLOSE_BET_ENTRY_START_TIME.strftime('%H:%M')}~{SELL_FORCE_TIME.strftime('%H:%M')})"
-                )
-            elif state.mode == "shutdown":
-                logger.info(
-                    f"[TIME-MODE] SHUTDOWN ì¤€ë¹„ (ì»¤íŠ¸ì˜¤í”„ {SELL_FORCE_TIME.strftime('%H:%M')} ë„ë‹¬ ì˜ˆì •)"
-                )
-            else:
-                logger.info(
-                    f"[TIME-MODE] PRE_OPEN (ìž¥ ì‹œìž‘ ì „ ì¤€ë¹„)"
-                )
-
-
-class CloseBettingEngine:
-    def __init__(self, topn: int, cap_fraction: float):
-        self.topn = topn
-        self.cap_fraction = cap_fraction
-        self.candidates: List[Dict[str, Any]] = []
-        self.entered: Dict[str, Any] = {}
-
-    def _score_candidate(self, daily_ctx: Dict[str, Any], intraday_ctx: Dict[str, Any]) -> float:
-        ret = daily_ctx.get("ret_today_pct") or 0.0
-        vol_ratio = daily_ctx.get("volume_ratio") or 0.0
-        from_high = intraday_ctx.get("from_high_pct") or 0.0
-        m5 = daily_ctx.get("ma5") or 0.0
-        m20 = daily_ctx.get("ma20") or 0.0
-        trend_bonus = 2.0 if (m5 and m20 and m5 > m20) else 0.0
-        location_score = max(0.0, 5.0 - from_high)
-        return ret * 0.6 + vol_ratio * 3.0 + location_score + trend_bonus
-
-    def scan_candidates(
-        self,
-        kis: KisAPI,
-        now_dt: datetime,
-        universe: Dict[str, Dict[str, Any]],
-        holding: Dict[str, Any],
-        traded: Dict[str, Any],
-    ) -> List[Dict[str, Any]]:
-        self.candidates = []
-        for code, info in universe.items():
-            if code in holding or code in traded:
-                continue
-            try:
-                price = _safe_get_price(kis, code)
-            except Exception:
-                price = None
-            if price is None or price <= 0:
-                continue
-            daily_ctx = _compute_daily_entry_context(kis, code, price)
-            intraday_ctx = _compute_intraday_entry_context(kis, code, prev_high=info.get("prev_high"))
-
-            ret_pct = daily_ctx.get("ret_today_pct")
-            if ret_pct is None or ret_pct < CLOSE_BET_MIN_RET_PCT:
-                continue
-            vol_ratio = daily_ctx.get("volume_ratio") or 0.0
-            if vol_ratio < CLOSE_BET_MIN_VOL_SPIKE:
-                continue
-            from_high = intraday_ctx.get("from_high_pct")
-            if from_high is not None and from_high > CLOSE_BET_MAX_PULLBACK_PCT:
-                continue
-            if intraday_ctx.get("vwap") and intraday_ctx.get("last_close"):
-                if intraday_ctx["last_close"] < intraday_ctx["vwap"]:
-                    continue
-            if daily_ctx.get("ma5") and daily_ctx.get("ma20"):
-                if daily_ctx["ma5"] <= daily_ctx["ma20"]:
-                    continue
-
-            score = self._score_candidate(daily_ctx, intraday_ctx)
-            self.candidates.append(
-                {
-                    "code": code,
-                    "name": info.get("name"),
-                    "price": price,
-                    "score": score,
-                    "daily_ctx": daily_ctx,
-                    "intraday_ctx": intraday_ctx,
-                }
-            )
-
-        self.candidates.sort(key=lambda x: x.get("score", 0.0), reverse=True)
-        picked = self.candidates[: self.topn]
-        if picked:
-            logger.info(
-                "[CLOSE-BET-SCAN] ì¢…ê°€ ë² íŒ… í›„ë³´ %dì¢…ëª© íƒìƒ‰ ì™„ë£Œ: %s",
-                len(picked),
-                ",".join([p.get("code", "") for p in picked]),
-            )
-        else:
-            logger.info("[CLOSE-BET-SCAN] ì¢…ê°€ ë² íŒ… í›„ë³´ ì—†ìŒ")
-        return picked
-
-    def enter_close_bets(
-        self,
-        kis: KisAPI,
-        now_dt: datetime,
-        capital_active: int,
-        holding: Dict[str, Any],
-        traded: Dict[str, Any],
-        can_buy: bool,
-    ) -> None:
-        if not can_buy:
-            logger.info("[CLOSE-BET-ENTRY] ì˜ˆìˆ˜ê¸ˆ ë¶€ì¡± â†’ ì¢…ê°€ ë² íŒ… ë§¤ìˆ˜ ìŠ¤í‚µ")
-            return
-        if not self.candidates:
-            return
-        per_notional = int(max(0, capital_active * self.cap_fraction) / max(1, len(self.candidates)))
-        for cand in self.candidates[: self.topn]:
-            code = cand.get("code")
-            if not code or code in holding or code in traded:
-                continue
-            qty = _notional_to_qty(kis, code, per_notional, ref_price=cand.get("price"))
-            if qty <= 0:
-                continue
-            result = place_buy_with_fallback(kis, code, qty, limit_price=int(cand.get("price") or 0))
-            _init_position_state(
-                kis,
-                holding,
-                code,
-                float(cand.get("price") or 0.0),
-                int(qty),
-                None,
-                cand.get("price"),
-                strategy="CLOSE_BET",
-            )
-            traded[code] = {
-                "buy_time": now_dt.strftime("%Y-%m-%d %H:%M:%S"),
-                "qty": int(qty),
-                "price": float(cand.get("price") or 0.0),
-                "strategy": "CLOSE_BET",
-            }
-            logger.info(
-                "[CLOSE-BET-ENTRY] code=%s qty=%s price=%s score=%.2f",
-                code,
-                qty,
-                cand.get("price"),
-                cand.get("score", 0.0),
-            )
-            log_trade(
-                {
-                    "datetime": now_dt.strftime("%Y-%m-%d %H:%M:%S"),
-                    "code": code,
-                    "name": cand.get("name"),
-                    "qty": int(qty),
-                    "side": "BUY",
-                    "price": cand.get("price"),
-                    "amount": int(qty) * int(cand.get("price") or 0),
-                    "strategy": "ì¢…ê°€ ë² íŒ…",
-                    "result": result,
-                }
-            )
-
-
-class CorePositionEngine:
-    def __init__(self):
-        self.candidates: List[Dict[str, Any]] = []
-
-    def _is_core_candidate(self, kis: KisAPI, code: str) -> Tuple[bool, Dict[str, Any]]:
-        ctx: Dict[str, Any] = {}
-        try:
-            candles = _get_daily_candles_cached(kis, code, count=220)
-        except Exception as e:
-            return False, {"reason": f"fetch_fail:{e}"}
-        if not candles or len(candles) < 200:
-            return False, {"reason": "not_enough_candles"}
-        today = datetime.now(KST).strftime("%Y%m%d")
-        completed = list(candles)
-        if completed and str(completed[-1].get("date")) == today:
-            completed = completed[:-1]
-        if len(completed) < 200:
-            return False, {"reason": "not_enough_completed"}
-        closes = [float(c.get("close") or 0.0) for c in completed if c.get("close")]
-        highs = [float(c.get("high") or 0.0) for c in completed if c.get("high")]
-        opens = [float(c.get("open") or 0.0) for c in completed if c.get("open")]
-        vols = [float(c.get("volume") or 0.0) for c in completed if c.get("volume")]
-        if len(closes) < 200:
-            return False, {"reason": "close_short"}
-        ma200 = sum(closes[-200:]) / 200.0
-        ctx["ma200"] = ma200
-        last_close = closes[-1]
-        last_open = opens[-1] if opens else last_close
-        box_high = max(closes[-40:])
-        box_low = min(closes[-40:])
-        box_range_pct = (box_high - box_low) / box_low * 100.0 if box_low else 0.0
-        ctx["box_range_pct"] = box_range_pct
-        volume_ratio = 0.0
-        if vols and len(vols) >= 21:
-            volume_ratio = (vols[-1] / (sum(vols[-21:-1]) / 20.0)) if (sum(vols[-21:-1]) > 0) else 0.0
-        ctx["volume_ratio"] = volume_ratio
-        breakout = (
-            box_range_pct <= CORE_BOX_RANGE_PCT
-            and last_close >= ma200 * (1 + CORE_BREAKOUT_PCT / 100.0)
-            and last_close >= last_open * (1 + CORE_BREAKOUT_PCT / 100.0)
-            and volume_ratio >= CLOSE_BET_MIN_VOL_SPIKE
-        )
-        near_ma200 = abs(last_close - ma200) / ma200 * 100.0 <= CORE_BOX_RANGE_PCT
-        ctx["near_ma200"] = near_ma200
-        ctx["breakout"] = breakout
-        return breakout and near_ma200, ctx
-
-    def scan(self, kis: KisAPI, universe: Dict[str, Dict[str, Any]]) -> List[Dict[str, Any]]:
-        self.candidates = []
-        for code, info in universe.items():
-            ok, ctx = self._is_core_candidate(kis, code)
-            if ok:
-                self.candidates.append({"code": code, "name": info.get("name"), "ctx": ctx})
-        if self.candidates:
-            logger.info(
-                "[CORE-SCAN] ì½”ì–´ í¬ì§€ì…˜ í›„ë³´ %dì¢…ëª© íƒìƒ‰ ì™„ë£Œ: %s",
-                len(self.candidates),
-                ",".join([c.get("code", "") for c in self.candidates]),
-            )
-        return self.candidates
-
-    def enter(
-        self, kis: KisAPI, capital_active: int, holding: Dict[str, Any], traded: Dict[str, Any], can_buy: bool
-    ) -> None:
-        if not self.candidates or capital_active <= 0 or not can_buy:
-            if not can_buy:
-                logger.info("[CORE-ENTRY] ì˜ˆìˆ˜ê¸ˆ ë¶€ì¡± â†’ ì½”ì–´ í¬ì§€ì…˜ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ")
-            return
-        max_core_cap = int(capital_active * CORE_MAX_FRACTION)
-        per_notional = int(max_core_cap * CORE_W_MAX_ONE)
-        for cand in self.candidates:
-            code = cand.get("code")
-            if not code or code in holding or code in traded:
-                continue
-            qty = _notional_to_qty(kis, code, per_notional)
-            if qty <= 0:
-                continue
-            price = _safe_get_price(kis, code)
-            result = place_buy_with_fallback(kis, code, qty, limit_price=int(price or 0))
-            _init_position_state(
-                kis, holding, code, float(price or 0.0), int(qty), None, price, strategy="CORE"
-            )
-            traded[code] = {
-                "buy_time": datetime.now(KST).strftime("%Y-%m-%d %H:%M:%S"),
-                "qty": int(qty),
-                "price": float(price or 0.0),
-                "strategy": "CORE",
-            }
-            logger.info(
-                "[CORE-ENTRY] code=%s ê°€ê²©=%s ë¹„ì¤‘â‰ˆ%.2f%%",
-                code,
-                price,
-                CORE_W_MAX_ONE * 100,
-            )
-            log_trade(
-                {
-                    "datetime": datetime.now(KST).strftime("%Y-%m-%d %H:%M:%S"),
-                    "code": code,
-                    "name": cand.get("name"),
-                    "qty": int(qty),
-                    "side": "BUY",
-                    "price": price,
-                    "amount": int(price or 0) * int(qty),
-                    "strategy": "ì½”ì–´ í¬ì§€ì…˜",
-                    "result": result,
-                }
-            )
 
 # === [NEW] ì£¼ê°„ ë¦¬ë°¸ëŸ°ì‹± ê°•ì œ íŠ¸ë¦¬ê±° ìƒíƒœ íŒŒì¼ ===
 STATE_WEEKLY_PATH = Path(__file__).parent / "state_weekly.json"
 
 def _this_iso_week_key(now=None):
     now = now or datetime.now(KST)
     return f"{now.year}-W{now.isocalendar().week:02d}"
 
 def _read_last_weekly():
     if not STATE_WEEKLY_PATH.exists():
         return None
     try:
         return (json.loads(STATE_WEEKLY_PATH.read_text(encoding="utf-8"))).get("weekly_rebalanced_at")
     except Exception:
         return None
 
 def _write_last_weekly(now=None):
     now = now or datetime.now(KST)
     try:
         STATE_WEEKLY_PATH.write_text(
             json.dumps({"weekly_rebalanced_at": _this_iso_week_key(now)}, ensure_ascii=False),
             encoding="utf-8",
         )
     except Exception as e:
         logger.warning(f"[STATE_WRITE_FAIL] weekly: {e}")
@@ -2643,52 +2242,78 @@ def _adaptive_exit(
         return None, None, None, None
 
     return reason, exec_px, result, sold_qty
 
 
 def main():
     kis = KisAPI()
 
     rebalance_date = get_rebalance_anchor_date()
     logger.info(f"[â„¹ï¸ ë¦¬ë°¸ëŸ°ì‹± ê¸°ì¤€ì¼(KST)]: {rebalance_date} (anchor={REBALANCE_ANCHOR}, ref={WEEKLY_ANCHOR_REF})")
     logger.info(
         f"[â±ï¸ ì»¤íŠ¸ì˜¤í”„(KST)] SELL_FORCE_TIME={SELL_FORCE_TIME.strftime('%H:%M')} / ì „ì²´ìž”ê³ ë§¤ë„={SELL_ALL_BALANCES_AT_CUTOFF} / "
         f"íŒ¨ìŠ¤(ì»¤íŠ¸ì˜¤í”„/ë§ˆê°)={FORCE_SELL_PASSES_CUTOFF}/{FORCE_SELL_PASSES_CLOSE}"
     )
     logger.info(f"[ðŸ’° DAILY_CAPITAL] {DAILY_CAPITAL:,}ì›")
     logger.info(f"[ðŸ›¡ï¸ SLIPPAGE_ENTER_GUARD_PCT] {SLIPPAGE_ENTER_GUARD_PCT:.2f}%")
 
     time_controller = TimeModeController(
         active_start=ACTIVE_START_TIME,
         full_active_end=FULL_ACTIVE_END_TIME,
         close_bet_prep=CLOSE_BET_PREP_START_TIME,
         close_bet_entry=CLOSE_BET_ENTRY_START_TIME,
         cutoff=SELL_FORCE_TIME,
         market_close=MARKET_CLOSE_TIME,
     )
-    close_bet_engine = CloseBettingEngine(CLOSE_BET_TOPN, CLOSE_BET_CAP_FRACTION)
-    core_engine = CorePositionEngine()
+    close_bet_engine = CloseBettingEngine(
+        topn=CLOSE_BET_TOPN,
+        cap_fraction=CLOSE_BET_CAP_FRACTION,
+        min_ret_pct=CLOSE_BET_MIN_RET_PCT,
+        max_pullback_pct=CLOSE_BET_MAX_PULLBACK_PCT,
+        min_vol_spike=CLOSE_BET_MIN_VOL_SPIKE,
+        price_fetcher=_safe_get_price,
+        daily_ctx_fetcher=_compute_daily_entry_context,
+        intraday_ctx_fetcher=_compute_intraday_entry_context,
+        qty_calculator=_notional_to_qty,
+        buyer=place_buy_with_fallback,
+        state_initializer=_init_position_state,
+        trade_logger=log_trade,
+    )
+    core_engine = CorePositionEngine(
+        box_range_pct=CORE_BOX_RANGE_PCT,
+        breakout_pct=CORE_BREAKOUT_PCT,
+        min_vol_spike=CLOSE_BET_MIN_VOL_SPIKE,
+        max_fraction=CORE_MAX_FRACTION,
+        weight_one=CORE_W_MAX_ONE,
+        daily_candle_fetcher=_get_daily_candles_cached,
+        qty_calculator=_notional_to_qty,
+        price_fetcher=_safe_get_price,
+        buyer=place_buy_with_fallback,
+        state_initializer=_init_position_state,
+        trade_logger=log_trade,
+        tzinfo=KST,
+    )
 
     # ìƒíƒœ ë³µêµ¬
     holding, traded = load_state()
     logger.info(f"[ìƒíƒœë³µêµ¬] holding: {list(holding.keys())}, traded: {list(traded.keys())}")
 
     # === [NEW] ì£¼ê°„ ë¦¬ë°¸ëŸ°ì‹± ê°•ì œ/ì¤‘ë³µ ë°©ì§€ ===
     targets: List[Dict[str, Any]] = []
     if REBALANCE_ANCHOR == "weekly":
         if should_weekly_rebalance_now():
             targets = fetch_rebalancing_targets(kis, rebalance_date)
             # ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ë¥¼ ìœ„í•´ ì¦‰ì‹œ ìŠ¤íƒ¬í”„(í•„ìš” ì‹œ FORCEë¡œ ìž¬ì‹¤í–‰ ê°€ëŠ¥)
             stamp_weekly_done()
             logger.info(f"[REBALANCE] ì´ë²ˆ ì£¼ ë¦¬ë°¸ëŸ°ì‹± ì‹¤í–‰ ê¸°ë¡ ì €ìž¥({_this_iso_week_key()})")
         else:
             logger.info("[REBALANCE] ì´ë²ˆ ì£¼ ì´ë¯¸ ì‹¤í–‰ë¨ â†’ ì‹ ê·œ ë¦¬ë°¸ëŸ°ì‹± ìƒëžµ (ë³´ìœ  ê´€ë¦¬ë§Œ)")
     else:
         # today/monthly ë“± ë‹¤ë¥¸ ì•µì»¤ ëª¨ë“œëŠ” ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ë°”ë¡œ í˜¸ì¶œ
         targets = fetch_rebalancing_targets(kis, rebalance_date)
 
     # === [NEW] ì˜ˆì‚° ê°€ë“œ: ì˜ˆìˆ˜ê¸ˆì´ 0/ë¶€ì¡±ì´ë©´ ì‹ ê·œ ë§¤ìˆ˜ë§Œ ìŠ¤í‚µ ===
     can_buy = True
     try:
         cash = kis.get_cash_available_today()
         logger.info(f"[BUDGET] today cash available = {cash:,} KRW")
         if cash <= 0:
