import os
import json
import time
import random
import logging
import threading
import csv
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any

import requests
import pytz
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

from settings import APP_KEY, APP_SECRET, API_BASE_URL, CANO, ACNT_PRDT_CD, KIS_ENV

logger = logging.getLogger(__name__)

class NetTemporaryError(Exception):
    """ÎÑ§Ìä∏ÏõåÌÅ¨/SSL Îì± ÏùºÏãúÏ†Å Ïò§Î•òÎ•º ÏùòÎØ∏ (Ï†úÏô∏ Í∏àÏßÄ, Î£®ÌîÑ Ïä§ÌÇµ)."""
    pass

class DataEmptyError(Exception):
    """Ï†ïÏÉÅÏùëÎãµÏù¥ÎÇò Ï∫îÎì§Ïù¥ 0Í∞ú (Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå)."""
    pass

class DataShortError(Exception):
    """Ï†ïÏÉÅÏùëÎãµÏù¥ÎÇò Ï∫îÎì§Ïù¥ need_n ÎØ∏Îßå."""
    pass

def _build_session():
    s = requests.Session()
    retry = Retry(
        total=6, connect=5, read=5, status=3,
        backoff_factor=0.6,
        status_forcelist=[429, 500, 502, 503, 504],
        allowed_methods=["GET", "POST"]
    )
    adapter = HTTPAdapter(max_retries=retry, pool_connections=50, pool_maxsize=50)
    s.mount("https://", adapter)
    s.mount("http://", adapter)
    s.headers.update({"User-Agent": "RKMax/1.0"})
    return s

SESSION = _build_session()

def _get_json(url, params=None, timeout=(3.0, 7.0)):
    try:
        r = SESSION.get(url, params=params, timeout=timeout)
        r.raise_for_status()
        return r.json()
    except requests.exceptions.SSLError as e:
        logger.warning("[NET:SSL_ERROR] %s %s", url, e)
        raise NetTemporaryError()
    except requests.exceptions.RequestException as e:
        logger.warning("[NET:REQ_ERROR] %s %s", url, e)
        raise NetTemporaryError()


def safe_strip(val):
    if val is None:
        return ""
    if isinstance(val, str):
        return val.replace("\n", "").replace("\r", "").strip()
    return str(val).strip()

def _json_dumps(body: dict) -> str:
    return json.dumps(body, ensure_ascii=False, separators=(",", ":"), sort_keys=False)

def append_fill(side: str, code: str, name: str, qty: int, price: float, odno: str, note: str = ""):
    try:
        os.makedirs("fills", exist_ok=True)
        path = f"fills/fills_{datetime.now().strftime('%Y%m%d')}.csv"
        header = ["ts", "side", "code", "name", "qty", "price", "ODNO", "note"]
        row = [
            datetime.now().isoformat(),
            side,
            code,
            name or "",
            int(qty),
            float(price) if price is not None else 0.0,
            str(odno) if odno is not None else "",
            note or "",
        ]
        new = not os.path.exists(path)
        with open(path, "a", newline="", encoding="utf-8") as f:
            w = csv.writer(f)
            if new:
                w.writerow(header)
            w.writerow(row)
        logger.info(f"[APPEND_FILL] {side} {code} qty={qty} price={price} odno={odno}")
    except Exception as e:
        logger.warning(f"[APPEND_FILL_FAIL] side={side} code={code} ex={e}")

class _RateLimiter:
    def __init__(self, min_interval_sec: float = 0.20):
        self.min_interval = float(min_interval_sec)
        self.last_at: Dict[str, float] = {}
        self._lock = threading.Lock()
    def wait(self, key: str):
        with self._lock:
            now = time.time()
            last = self.last_at.get(key, 0.0)
            delta = now - last
            if delta < self.min_interval:
                time.sleep(self.min_interval - delta + random.uniform(0, 0.03))
            self.last_at[key] = time.time()

TR_MAP = {
    "practice": {
        "ORDER_BUY": [os.getenv("KIS_TR_ID_ORDER_BUY", "VTTC0012U"), "VTTC0802U"],
        "ORDER_SELL": [os.getenv("KIS_TR_ID_ORDER_SELL", "VTTC0011U"), "VTTC0801U"],
        "BALANCE": [os.getenv("KIS_TR_ID_BALANCE", "VTTC8434R")],
        "PRICE": [os.getenv("KIS_TR_ID_PRICE", "FHKST01010100")],
        "ORDERBOOK": [os.getenv("KIS_TR_ID_ORDERBOOK", "FHKST01010200")],
        "DAILY_CHART": [os.getenv("KIS_TR_ID_DAILY_CHART", "FHKST03010100")],
        "TOKEN": "/oauth2/tokenP",
    },
    "real": {
        "ORDER_BUY": [os.getenv("KIS_TR_ID_ORDER_BUY_REAL", "TTTC0012U")],
        "ORDER_SELL": [os.getenv("KIS_TR_ID_ORDER_SELL_REAL", "TTTC0011U")],
        "BALANCE": [os.getenv("KIS_TR_ID_BALANCE_REAL", "TTTC8434R")],
        "PRICE": [os.getenv("KIS_TR_ID_PRICE_REAL", "FHKST01010100")],
        "ORDERBOOK": [os.getenv("KIS_TR_ID_ORDERBOOK_REAL", "FHKST01010200")],
        "DAILY_CHART": [os.getenv("KIS_TR_ID_DAILY_CHART_REAL", "FHKST03010100")],
        "TOKEN": "/oauth2/token",
    },
}
def _pick_tr(env: str, key: str) -> List[str]:
    try:
        return TR_MAP[env][key]
    except Exception:
        return []

# --- KisAPI Ïù¥Ìïò Ïã§Ï†Ñ Ï†ÑÏ≤¥ Î°úÏßÅ (ÌÜ†ÌÅ∞, Ï£ºÎ¨∏, Îß§Ïàò/Îß§ÎèÑ, Ï≤¥Í≤∞, Ïã§Ï†Ñ Ï†ÑÎûµ Îì±) ---
# (ÏΩîÎìú Í∏∏Ïù¥ Î¨∏Ï†úÎ°ú, "Í≥ÑÏÜç" ÏöîÏ≤≠ Ïãú ÏïÑÎûò Ï†ÑÏ≤¥ Ìï®Ïàò/ÌÅ¥ÎûòÏä§(ÏûîÍ≥†/Ï£ºÎ¨∏/ÏãúÏû•Í∞Ä/ÏßÄÏ†ïÍ∞Ä/Ïã§Ï†ÑÎ≥¥Ï°∞ Îì±) ÏàúÏ∞®Ï†Å Ï†úÍ≥µ)

class KisAPI:
    _token_cache = {"token": None, "expires_at": 0, "last_issued": 0}
    _cache_path = "kis_token_cache.json"
    _token_lock = threading.Lock()

    def __init__(self):
        self.CANO = safe_strip(CANO)
        self.ACNT_PRDT_CD = safe_strip(ACNT_PRDT_CD)
        self.env = safe_strip(KIS_ENV or "practice").lower()
        if self.env not in ("practice", "real"):
            self.env = "practice"
        self.session = requests.Session()
        retry = Retry(
            total=3, connect=3, read=3, status=3, backoff_factor=0.5,
            status_forcelist=(500, 502, 503, 504),
            allowed_methods=frozenset(["GET", "POST"]), raise_on_status=False,
        )
        adapter = HTTPAdapter(max_retries=retry, pool_connections=50, pool_maxsize=50)
        self.session.mount("https://", adapter)
        self.session.mount("http://", adapter)
        self._limiter = _RateLimiter(min_interval_sec=0.20)
        self._recent_sells: Dict[str, float] = {}
        self._recent_sells_lock = threading.Lock()
        self._recent_sells_cooldown = 60.0
        self.token = self.get_valid_token()
        logger.info(f"[ÏÉùÏÑ±Ïûê Ï≤¥ÌÅ¨] CANO={repr(self.CANO)}, ACNT_PRDT_CD={repr(self.ACNT_PRDT_CD)}, ENV={self.env}")
        self._today_open_cache: Dict[str, Tuple[float, float]] = {}  # code -> (open_price, ts)
        self._today_open_ttl = 60 * 60 * 9  # 9ÏãúÍ∞Ñ TTL (ÎãπÏùºÎßå Ïú†Ìö®)

    def get_valid_token(self):
        with KisAPI._token_lock:
            now = time.time()
            if self._token_cache["token"] and now < self._token_cache["expires_at"] - 300:
                return self._token_cache["token"]
            if os.path.exists(self._cache_path):
                try:
                    with open(self._cache_path, "r", encoding="utf-8") as f:
                        cache = json.load(f)
                    if "access_token" in cache and now < cache["expires_at"] - 300:
                        self._token_cache.update({
                            "token": cache["access_token"],
                            "expires_at": cache["expires_at"],
                            "last_issued": cache.get("last_issued", 0),
                        })
                        logger.info(f"[ÌÜ†ÌÅ∞Ï∫êÏãú] ÌååÏùºÏ∫êÏãú ÏÇ¨Ïö©: {cache['access_token'][:10]}... ÎßåÎ£å:{cache['expires_at']}")
                        return cache["access_token"]
                except Exception as e:
                    logger.warning(f"[ÌÜ†ÌÅ∞Ï∫êÏãú ÏùΩÍ∏∞ Ïã§Ìå®] {e}")
            if now - self._token_cache["last_issued"] < 61:
                logger.warning("[ÌÜ†ÌÅ∞] 1Î∂Ñ Ïù¥ÎÇ¥ Ïû¨Î∞úÍ∏â ÏãúÎèÑ Ï∞®Îã®, Í∏∞Ï°¥ ÌÜ†ÌÅ∞ Ïû¨ÏÇ¨Ïö©")
                if self._token_cache["token"]:
                    return self._token_cache["token"]
                raise Exception("ÌÜ†ÌÅ∞ Î∞úÍ∏â Ï†úÌïú(1Î∂Ñ 1Ìöå), Ïû†Ïãú ÌõÑ Ïû¨ÏãúÎèÑ ÌïÑÏöî")
            token, expires_in = self._issue_token_and_expire()
            expires_at = now + int(expires_in)
            self._token_cache.update({"token": token, "expires_at": expires_at, "last_issued": now})
            try:
                with open(self._cache_path, "w", encoding="utf-8") as f:
                    json.dump({"access_token": token, "expires_at": expires_at, "last_issued": now}, f, ensure_ascii=False)
            except Exception as e:
                logger.warning(f"[ÌÜ†ÌÅ∞Ï∫êÏãú Ïì∞Í∏∞ Ïã§Ìå®] {e}")
            logger.info("[ÌÜ†ÌÅ∞Ï∫êÏãú] ÏÉà ÌÜ†ÌÅ∞ Î∞úÍ∏â Î∞è Ï∫êÏãú")
            return token

    def _issue_token_and_expire(self):
        token_path = TR_MAP[self.env]["TOKEN"]
        url = f"{API_BASE_URL}{token_path}"
        headers = {"content-type": "application/json"}
        data = {"grant_type": "client_credentials", "appkey": APP_KEY, "appsecret": APP_SECRET}
        try:
            resp = self.session.post(url, json=data, headers=headers, timeout=(3.0, 7.0))
            j = resp.json()
        except Exception as e:
            logger.error(f"[üîë ÌÜ†ÌÅ∞Î∞úÍ∏â ÏòàÏô∏] {e}")
            raise
        if "access_token" in j:
            logger.info(f"[üîë ÌÜ†ÌÅ∞Î∞úÍ∏â] ÏÑ±Í≥µ: {j}")
            return j["access_token"], j.get("expires_in", 86400)
        logger.error(f"[üîë ÌÜ†ÌÅ∞Î∞úÍ∏â Ïã§Ìå®] {j.get('error_description', j)}")
        raise Exception(f"ÌÜ†ÌÅ∞ Î∞úÍ∏â Ïã§Ìå®: {j.get('error_description', j)}")

    def _headers(self, tr_id: str, hashkey: Optional[str] = None):
        h = {
            "authorization": f"Bearer {self.get_valid_token()}",
            "appkey": APP_KEY,
            "appsecret": APP_SECRET,
            "tr_id": tr_id,
            "custtype": "P",
            "content-type": "application/json; charset=utf-8",
        }
        if hashkey:
            h["hashkey"] = hashkey
        return h

    def _create_hashkey(self, body_dict: dict) -> str:
        url = f"{API_BASE_URL}/uapi/hashkey"
        headers = {
            "content-type": "application/json; charset=utf-8",
            "appkey": APP_KEY,
            "appsecret": APP_SECRET,
        }
        body_str = _json_dumps(body_dict)
        try:
            r = self.session.post(url, headers=headers, data=body_str.encode("utf-8"), timeout=(3.0, 5.0))
            j = r.json()
        except Exception as e:
            logger.error(f"[HASHKEY ÏòàÏô∏] {e}")
            raise
        hk = j.get("HASH") or j.get("hash") or j.get("hashkey")
        if not hk:
            logger.error(f"[HASHKEY Ïã§Ìå®] resp={j}")
            raise Exception(f"HashKey ÏÉùÏÑ± Ïã§Ìå®: {j}")
        return hk

    # === Ïã§Ï†Ñ: ÏãúÏÑ∏, ÏûîÍ≥†, ÏãúÏû•Í∞Ä/ÏßÄÏ†ïÍ∞Ä, Îß§Ïàò/Îß§ÎèÑ, Ï≤¥Í≤∞Í∞ïÎèÑ, ATR Îì± ===
    # (3Î∂ÄÎ°ú Í≥ÑÏÜç Ïù¥Ïñ¥ÏßëÎãàÎã§. ÏïÑÎûò "Í≥ÑÏÜç"ÏùÑ ÎàåÎü¨Ï£ºÏãúÎ©¥ 3Î∂Ä Ï†ÑÏ≤¥ Ï†úÍ≥µ)

    def get_current_price(self, code: str) -> float:
        url = f"{API_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-price"
        self._limiter.wait("quotes")
        tried = []
        for tr in _pick_tr(self.env, "PRICE"):
            headers = self._headers(tr)
            markets = ["J", "U"]
            c = code.strip()
            codes = [c, f"A{c}"] if not c.startswith("A") else [c, c[1:]]
            for market_div in markets:
                for code_fmt in codes:
                    params = {"fid_cond_mrkt_div_code": market_div, "fid_input_iscd": code_fmt}
                    try:
                        resp = self.session.get(url, headers=headers, params=params, timeout=(3.0, 5.0))
                        data = resp.json()
                    except Exception as e:
                        tried.append((market_div, code_fmt, f"EXC:{e}"))
                        continue
                    tried.append((market_div, code_fmt, data.get("rt_cd"), data.get("msg1")))
                    if "Ï¥àÎãπ Í±∞ÎûòÍ±¥Ïàò" in (data.get("msg1") or ""):
                        time.sleep(0.35 + random.uniform(0, 0.15))
                        continue
                    if resp.status_code == 200 and data.get("rt_cd") == "0" and data.get("output"):
                        try:
                            return float(data["output"].get("stck_prpr"))
                        except Exception:
                            pass
        raise Exception(f"ÌòÑÏû¨Í∞Ä Ï°∞Ìöå Ïã§Ìå®({code}): tried={tried}")

    def _get_cached_today_open(self, code: str) -> Optional[float]:
        try:
            op, ts = self._today_open_cache.get(code, (None, 0.0))
            if op and (time.time() - ts) < self._today_open_ttl:
                return op
        except Exception:
         pass
        return None

    def _set_cached_today_open(self, code: str, price: float):
        try:
            if price and price > 0:
                self._today_open_cache[code] = (float(price), time.time())
        except Exception:
            pass

    def get_today_open(self, code: str) -> Optional[float]:
        """
        Ïò§Îäò ÏãúÏ¥àÍ∞Ä(09:00 Í∏∞Ï§Ä)Î•º Î∞òÌôòÌïúÎã§.
        1ÏàúÏúÑ: Ïã§ÏãúÍ∞Ñ Ïä§ÎÉÖÏÉ∑(inquire-price)Ïùò stck_oprc
        2ÏàúÏúÑ: ÏãúÍ∞ÑÏ≤¥Í≤∞(Ï≤´ Ìã±Í∞Ä) Îì± Î≥¥Ï°∞ ÏàòÎã®(ÎØ∏Íµ¨ÌòÑ Ïãú ÏÉùÎûµ Í∞ÄÎä•)
        """
        code = safe_strip(code)
        # 0) Ï∫êÏãú
        cached = self._get_cached_today_open(code)
        if cached:
            return cached

        # 1) Ïä§ÎÉÖÏÉ∑ÏóêÏÑú stck_oprc (Ïû•Ï§ëÏóêÎèÑ Ïú†ÏßÄÎê®)
        url = f"{API_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-price"
        self._limiter.wait("quotes-open")
        tried = []
        for tr in _pick_tr(self.env, "PRICE"):
            headers = self._headers(tr)
            # Ïä§ÎÉÖÏÉ∑ÏùÄ Î≥¥ÌÜµ Ï†ëÎëêÏÇ¨ ÏóÜÏù¥ '277810' ÌòïÌÉúÍ∞Ä Í∏∞Î≥∏Ïù¥ÏßÄÎßå, ÌòºÏö©ÏùÑ ÎåÄÎπÑÌï¥ Îëò Îã§ ÏãúÎèÑ
            markets = ["J", "U"]
            c = code
            codes = [c, f"A{c}"] if not c.startswith("A") else [c, c[1:]]
            for market_div in markets:
                for code_fmt in codes:
                    params = {"fid_cond_mrkt_div_code": market_div, "fid_input_iscd": code_fmt}
                    try:
                        resp = self.session.get(url, headers=headers, params=params, timeout=(3.0, 5.0))
                        data = resp.json()
                    except Exception as e:
                        tried.append((market_div, code_fmt, f"EXC:{e}"))
                        continue
                    tried.append((market_div, code_fmt, data.get("rt_cd"), data.get("msg1")))
                    if "Ï¥àÎãπ Í±∞ÎûòÍ±¥Ïàò" in (data.get("msg1") or ""):
                        time.sleep(0.35 + random.uniform(0, 0.15))
                        continue
                    if resp.status_code == 200 and data.get("rt_cd") == "0" and data.get("output"):
                        op_str = data["output"].get("stck_oprc")
                        try:
                            op = float(op_str) if op_str is not None else 0.0
                            if op > 0:
                                self._set_cached_today_open(code, op)
                                return op
                        except Exception:
                            pass
        # 2) (ÏòµÏÖò) ÏãúÍ∞ÑÏ≤¥Í≤∞ Ï≤´ Ìã±Í∞Ä Î≥¥Ï°∞ ‚Üí ÌïÑÏöîÌïòÎ©¥ Î≥ÑÎèÑ Íµ¨ÌòÑ
        return None


    def get_orderbook_strength(self, code: str) -> Optional[float]:
        url = f"{API_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-askprice"
        self._limiter.wait("orderbook")
        for tr in _pick_tr(self.env, "ORDERBOOK"):
            headers = self._headers(tr)
            markets = ["J", "U"]
            c = code.strip()
            codes = [c, f"A{c}"] if not c.startswith("A") else [c, c[1:]]
            for market_div in markets:
                for code_fmt in codes:
                    params = {"fid_cond_mrkt_div_code": market_div, "fid_input_iscd": code_fmt}
                    try:
                        resp = self.session.get(url, headers=headers, params=params, timeout=(3.0, 5.0))
                        data = resp.json()
                    except Exception:
                        continue
                    if resp.status_code == 200 and data.get("rt_cd") == "0" and data.get("output"):
                        out = data["output"]
                        bid = sum(float(out.get(f"bidp_rsqn{i}") or 0) for i in range(1, 6))
                        ask = sum(float(out.get(f"askp_rsqn{i}") or 0) for i in range(1, 6))
                        if (bid + ask) > 0:
                            return 100.0 * bid / max(1.0, ask)
        return None

    from typing import List, Dict, Any
    import os, time, random, requests

    def get_daily_candles(self, code: str, count: int = 30) -> List[Dict[str, Any]]:
        """
        ÏùºÎ¥â Ï°∞Ìöå (ÏãúÏû•ÏΩîÎìú Í≥†Ï†ï, ÎÑ§Ìä∏ÏõåÌÅ¨ Ïã§Ìå®/Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°± Î∂ÑÎ¶¨)
        - ÎÑ§Ìä∏ÏõåÌÅ¨/SSL Ïã§Ìå®: NetTemporaryError (Ï†úÏô∏ Í∏àÏßÄ, ÏÉÅÏúÑ Î£®ÌîÑÏóêÏÑú TEMP_SKIP)
        - Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå(0Í∞ú): DataEmptyError (Ïó∞ÏÜç ÌôïÏù∏ ÌõÑ Ï†úÏô∏)
        - Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±(<21Í∞ú): DataShortError (Ï¶âÏãú Ï†úÏô∏)

        Ï∂îÍ∞Ä:
        - ÏùëÎãµ RAW ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ Ï∂úÎ†•
        - output2 / output1 / output ÏûêÎèô ÌÉêÏÉâ
        - .envÏùò DAILY_CAPITAL ÎØ∏ÏÑ§Ï†ï Ïãú 1Ìöå Í≤ΩÍ≥† Î°úÍ∑∏
        """
        # ---- (A) .env Ï†êÍ≤Ä: DAILY_CAPITAL ÎØ∏ÏÑ§Ï†ï Í≤ΩÍ≥† (Ìï®Ïàò ÏµúÏ¥à 1ÌöåÎßå) -----------------------
        try:
            if not getattr(self, "_env_checked_daily_capital", False):
                if os.getenv("DAILY_CAPITAL") in (None, ""):
                    # settingsÏóêÏÑú Í∏∞Î≥∏Í∞í(10_000_000)ÏúºÎ°ú Îñ®Ïñ¥Ïßà Í∞ÄÎä•ÏÑ±ÏùÑ ÏïåÎ¶º
                    logger.warning("[ENV] DAILY_CAPITAL Ïù¥ .envÏóê ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. "
                                   "settingsÏùò Í∏∞Î≥∏Í∞í(10,000,000)Ïù¥ ÏÇ¨Ïö©Îê† Ïàò ÏûàÏäµÎãàÎã§.")
                self._env_checked_daily_capital = True
        except Exception:
            # ÌôòÍ≤Ω Ï†êÍ≤Ä Î°úÏßÅÏùÄ Í±∞ÎûòÏôÄ Î¨¥Í¥ÄÌïòÎØÄÎ°ú ÏïàÏ†ÑÌïòÍ≤å Î¨¥Ïãú
            pass

        # ---- (1) ÏãúÏû•ÏΩîÎìú Í≥†Ï†ï (J/U Ïä§Ïôë Í∏àÏßÄ) ------------------------------------------------
        # Ïã§Ï†ÑÏùÄ ÎßàÏä§ÌÑ∞ÌÖåÏù¥Î∏î/Ï∫êÏãúÏóêÏÑú Î°úÎìú. Î™®Î•¥Î©¥ JÎ°ú Í≥†Ï†ï
        market_code = self.market_map.get(code.lstrip("A"), "J") if hasattr(self, "market_map") else "J"

        url = f"{API_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-daily-itemchartprice"
        self._limiter.wait("daily")

        # AÏ†ëÎëê Ï≤òÎ¶¨
        iscd = code if code.startswith("A") else f"A{code}"

        last_err = None

        for tr in _pick_tr(self.env, "DAILY_CHART"):   # TR ÌõÑÎ≥¥Î•º ÏàúÏ∞®Ï†ÅÏúºÎ°ú ÏãúÎèÑ
            headers = self._headers(tr)
            params = {
                "fid_cond_mrkt_div_code": market_code,  # J: ÏΩîÏä§Ìîº, U: ÏΩîÏä§Îã• Îì±
                "fid_input_iscd": iscd,
                "fid_org_adj_prc": "0",
                "fid_period_div_code": "D",
            }

            for attempt in range(1, 4):  # Í∞ÄÎ≤ºÏö¥ Ïû¨ÏãúÎèÑ (ÏÑ∏ÏÖò Î†àÎ≤® RetryÏôÄ Ï§ëÏ≤©)
                try:
                    resp = self.session.get(url, headers=headers, params=params, timeout=(3.0, 7.0))
                    resp.raise_for_status()
                    data = resp.json()
                    # ‚úÖ RAW ÏùëÎãµ ÎîîÎ≤ÑÍπÖ
                    logger.debug("[DAILY_RAW_JSON] %s TR=%s attempt=%d ‚Üí %s", iscd, tr, attempt, data)
                except requests.exceptions.SSLError as e:
                    last_err = e
                    logger.warning("[NET:SSL_ERROR] DAILY %s attempt=%s %s", iscd, attempt, e)
                    time.sleep(0.4 * attempt)
                    continue
                except requests.exceptions.RequestException as e:
                    last_err = e
                    logger.warning("[NET:REQ_ERROR] DAILY %s attempt=%s %s", iscd, attempt, e)
                    time.sleep(0.4 * attempt)
                    continue
                except ValueError as e:
                    # JSON ÎîîÏΩîÎìú Ïã§Ìå® ‚Üí ÏùºÏãúÏ†Å ÏùëÎãµÍπ®ÏßêÏúºÎ°ú Î≥¥Í≥† Ïû¨ÏãúÎèÑ
                    last_err = e
                    logger.warning("[NET:JSON_DECODE] DAILY %s attempt=%s %s", iscd, attempt, e)
                    time.sleep(0.35 + random.uniform(0, 0.15))
                    continue
                except Exception as e:
                    last_err = e
                    logger.warning("[NET:UNEXPECTED] DAILY %s attempt=%s %s", iscd, attempt, e)
                    time.sleep(0.4 * attempt)
                    continue

                # Í≤åÏù¥Ìä∏Ïõ®Ïù¥/ÏøºÌÑ∞ Î¨∏Íµ¨Î©¥ Ïû†Íπê Ïâº ÌõÑ Ïû¨ÏãúÎèÑ
                if "Ï¥àÎãπ Í±∞ÎûòÍ±¥Ïàò" in str(data.get("msg1") or ""):
                    time.sleep(0.35 + random.uniform(0, 0.15))
                    continue

                # ---- (2) ÏÑ±Í≥µ ÏºÄÏù¥Ïä§ ÌåêÏ†ï: rt_cd / output ÌÇ§ ÏÖÄÎ†âÏÖò --------------------------
                rt_cd = data.get("rt_cd", "")
               # ÏùºÎ∂Ä ÌôòÍ≤Ω(ÌäπÌûà Î™®Ïùò)ÏóêÏÑúÎäî rt_cdÍ∞Ä ÏïÑÏòà ÎπÑÏñ¥ÏûàÎäî {}Í∞Ä Ïò¨ Ïàò ÏûàÏùå ‚Üí ÌÇ§ Ï°¥Ïû¨Ïóê ÏùòÏ°¥ X
                arr = data.get("output2") or data.get("output1") or data.get("output")

                if resp.status_code == 200 and arr:
                    # Ï†ïÏÉÅ ÌååÏã±
                    rows = []
                    for r in arr:
                        try:
                            d = r.get("stck_bsop_date")
                            o = r.get("stck_oprc")
                            h = r.get("stck_hgpr")
                            l = r.get("stck_lwpr")
                            c = r.get("stck_clpr")
                            if d and o is not None and h is not None and l is not None and c is not None:
                                rows.append({
                                    "date": d,
                                    "open": float(o),
                                    "high": float(h),
                                    "low":  float(l),
                                    "close":float(c),
                                })
                        except Exception as e:
                            # Í∞úÎ≥Ñ Î†àÏΩîÎìú ÌååÏã± Ïã§Ìå®Îäî Ïä§ÌÇµ
                            logger.debug("[DAILY_ROW_SKIP] %s rec=%s err=%s", iscd, r, e)

                    # ÎÇ†Ïßú Ïò§Î¶ÑÏ∞®Ïàú Ï†ïÎ†¨
                    rows.sort(key=lambda x: x["date"])

                    # --- ÌïµÏã¨ ÌåêÏ†ï Î°úÏßÅ ---
                    if len(rows) == 0:
                        # ÏßÑÏßú Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå ‚Üí DataEmptyError
                        raise DataEmptyError(f"{iscd} 0 candles")
                    if len(rows) < 21:
                        # 21Í∞ú ÎØ∏Îßå ‚Üí DataShortError
                        raise DataShortError(f"{iscd} {len(rows)} candles (<21)")

                    # ÏµúÏÜå 21Í∞ú ÌôïÎ≥¥ Î≥¥Ïû•. countÍ∞Ä 21Î≥¥Îã§ ÏûëÏïÑÎèÑ 21ÏùÄ ÌôïÎ≥¥Îêú ÏÉÅÌÉú
                    # ÏµúÍ∑º countÍ∞ú Î∞òÌôò (Í∏∞Î≥∏ ÎèôÏûë Ïú†ÏßÄ)
                    need = max(count, 21)
                    return rows[-need:][-count:]

                # Ïó¨Í∏∞ÍπåÏßÄ ÏôîÎäîÎç∞ arrÍ∞Ä ÎπÑÏóàÏúºÎ©¥, ÏùëÎãµ ÏûêÏ≤¥Í∞Ä ÎπÑÏ†ïÏÉÅÏù∏ ÏºÄÏù¥Ïä§
                # rt_cdÍ∞Ä "0"Ïù¥ ÏïÑÎãàÍ±∞ÎÇò, ÏïÑÏòà ÌÇ§Í∞Ä ÏóÜÎäî {} Îì±
                last_err = RuntimeError(f"BAD_RESP rt_cd={rt_cd} msg={data.get('msg1')} arr=None")
                logger.warning("[DAILY_FAIL] %s: %s | raw=%s", iscd, last_err, data)
                time.sleep(0.35 + random.uniform(0, 0.15))

        # Î™®Îì† TR/Ïû¨ÏãúÎèÑ Ïã§Ìå® ‚Üí ÎÑ§Ìä∏ÏõåÌÅ¨/Í≤åÏù¥Ìä∏Ïõ®Ïù¥ Îì±ÏúºÎ°ú Ï†ïÏÉÅ ÌôïÎ≥¥ Ïã§Ìå®
        if last_err:
            logger.warning("[DAILY_FAIL] %s: %s", iscd, last_err)
        # ‚ùó ÎÑ§Ìä∏ÏõåÌÅ¨ Ïã§Ìå®Î•º []Î°ú ÎÇ¥Î†§Î≥¥ÎÇ¥Î©¥ '0Ï∫îÎì§'Î°ú Ïò§Ïù∏Îê® ‚Üí ÏòàÏô∏Î°ú Ïò¨Î†§ÏÑú TEMP_SKIP Ï≤òÎ¶¨
        raise NetTemporaryError(f"DAILY {iscd} net fail")




    def get_atr(self, code: str, window: int = 14) -> Optional[float]:
        try:
            candles = self.get_daily_candles(code, count=window + 2)
            if len(candles) < window + 1:
                return None
            trs: List[float] = []
            for i in range(1, len(candles)):
                h = candles[i]["high"]; l = candles[i]["low"]; c_prev = candles[i - 1]["close"]
                tr = max(h - l, abs(h - c_prev), abs(l - c_prev))
                trs.append(tr)
            if not trs:
                return None
            return sum(trs[-window:]) / float(window)
        except Exception as e:
            logger.warning(f"[ATR] Í≥ÑÏÇ∞ Ïã§Ìå® code={code}: {e}")
            return None

    def is_market_open(self) -> bool:
        kst = pytz.timezone("Asia/Seoul")
        now = datetime.now(kst)
        if now.weekday() >= 5:
            return False
        open_time = now.replace(hour=9, minute=0, second=0, microsecond=0)
        close_time = now.replace(hour=15, minute=20, second=0, microsecond=0)
        return open_time <= now <= close_time

    # ----- ÏûîÍ≥†/Ìè¨ÏßÄÏÖò -----
    def get_cash_balance(self) -> int:
        url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/inquire-balance"
        headers = None
        for tr in _pick_tr(self.env, "BALANCE"):
            headers = self._headers(tr)
            params = {
                "CANO": self.CANO,
                "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
                "AFHR_FLPR_YN": "N",
                "UNPR_YN": "N",
                "UNPR_DVSN": "01",
                "FUND_STTL_ICLD_YN": "N",
                "FNCG_AMT_AUTO_RDPT_YN": "N",
                "PRCS_DVSN": "01",
                "OFL_YN": "N",
                "INQR_DVSN": "02",
                "CTX_AREA_FK100": "",
                "CTX_AREA_NK100": "",
            }
            logger.info(f"[ÏûîÍ≥†Ï°∞Ìöå ÏöîÏ≤≠ÌååÎùºÎØ∏ÌÑ∞] {params}")
            try:
                resp = self.session.get(url, headers=headers, params=params, timeout=(3.0, 7.0))
                j = resp.json()
            except Exception as e:
                logger.error(f"[ÏûîÍ≥†Ï°∞Ìöå ÏòàÏô∏] {e}")
                continue
            logger.info(f"[ÏûîÍ≥†Ï°∞Ìöå ÏùëÎãµ] {j}")
            if j.get("rt_cd") == "0" and "output2" in j and j["output2"]:
                try:
                    cash = int(j["output2"][0]["dnca_tot_amt"])
                    logger.info(f"[CASH_BALANCE] ÌòÑÏû¨ ÏòàÏàòÍ∏à: {cash:,}Ïõê")
                    return cash
                except Exception as e:
                    logger.error(f"[CASH_BALANCE_PARSE_FAIL] {e}")
                    continue
        logger.error("[CASH_BALANCE_FAIL] Î™®Îì† TR Ïã§Ìå®")
        return 0

    def get_positions(self) -> List[Dict]:
        url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/inquire-balance"
        for tr in _pick_tr(self.env, "BALANCE"):
            headers = self._headers(tr)
            params = {
                "CANO": self.CANO,
                "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
                "AFHR_FLPR_YN": "N",
                "UNPR_YN": "N",
                "UNPR_DVSN": "01",
                "FUND_STTL_ICLD_YN": "N",
                "FNCG_AMT_AUTO_RDPT_YN": "N",
                "PRCS_DVSN": "01",
                "OFL_YN": "N",
                "INQR_DVSN": "02",
                "CTX_AREA_FK100": "",
                "CTX_AREA_NK100": "",
            }
            try:
                resp = self.session.get(url, headers=headers, params=params, timeout=(3.0, 7.0))
                j = resp.json()
            except Exception:
                continue
            if j.get("rt_cd") == "0" and j.get("output1") is not None:
                return j.get("output1") or []
        return []

    def get_balance_map(self) -> Dict[str, int]:
        pos = self.get_positions()
        mp: Dict[str, int] = {}
        for row in pos or []:
            try:
                pdno = safe_strip(row.get("pdno"))
                hldg = int(float(row.get("hldg_qty", "0")))
                ord_psbl = int(float(row.get("ord_psbl_qty", "0")))
                qty = hldg if hldg > 0 else ord_psbl
                if pdno and qty > 0:
                    mp[pdno] = qty
            except Exception:
                continue
        logger.info(f"[Î≥¥Ïú†ÏàòÎüâÎßµ] {len(mp)}Ï¢ÖÎ™©")
        return mp

    # --- Ìò∏Ìôò ÏÖîÏûÑ(Í∏∞Ï°¥ trader.py Ìò∏Ï∂ú ÎåÄÏùë) ---
    def get_balance(self) -> Dict[str, object]:
        return {"cash": self.get_cash_balance(), "positions": self.get_positions()}

    # -------------------------------
    # Ï£ºÎ¨∏ Í≥µÌÜµ, ÏãúÏû•Í∞Ä/ÏßÄÏ†ïÍ∞Ä, Îß§Ïàò/Îß§ÎèÑ(ÏÉÅÏÑ∏ Íµ¨ÌòÑÏùÄ 1Î∂Ä Ï∞∏Í≥†)
    # (Ïù¥ÎØ∏ ÏúÑ 1,2Î∂ÄÏóêÏÑú Ï†ÑÎ∂Ä Ï†úÍ≥µ. ÌïÑÏöîÏãú Ïû¨ÏóÖÎ°úÎìú ÏïàÎÇ¥)
    # -------------------------------
    # -------------------------------
    # Ï£ºÎ¨∏ Í≥µÌÜµ
    # -------------------------------
    def _order_cash(self, body: dict, *, is_sell: bool) -> Optional[dict]:
        url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/order-cash"

        # TR ÌõÑÎ≥¥ ÏàúÏ∞® ÏãúÎèÑ
        tr_list = _pick_tr(self.env, "ORDER_SELL" if is_sell else "ORDER_BUY")

        # Fallback: ÏãúÏû•Í∞Ä ‚Üí IOCÏãúÏû•Í∞Ä ‚Üí ÏµúÏú†Î¶¨
        ord_dvsn_chain = ["01", "13", "03"]
        last_err = None

        for tr_id in tr_list:
            for ord_dvsn in ord_dvsn_chain:
                body["ORD_DVSN"] = ord_dvsn
                body["ORD_UNPR"] = "0"
                if is_sell and not body.get("SLL_TYPE"):
                    body["SLL_TYPE"] = "01"
                body.setdefault("EXCG_ID_DVSN_CD", "KRX")

                # HashKey
                try:
                    hk = self._create_hashkey(body)
                except Exception as e:
                    logger.error(f"[ORDER_HASH_FAIL] body={body} ex={e}")
                    last_err = e
                    continue

                headers = self._headers(tr_id, hk)

                # Î†àÏù¥Ìä∏Î¶¨Î∞ã(Ï£ºÎ¨∏ÏùÄ Î≥Ñ ÌÇ§)
                self._limiter.wait("orders")

                # Î°úÍπÖ(ÎØºÍ∞ê Mask)
                log_body_masked = {k: (v if k not in ("CANO", "ACNT_PRDT_CD") else "***") for k, v in body.items()}
                logger.info(f"[Ï£ºÎ¨∏ÏöîÏ≤≠] tr_id={tr_id} ord_dvsn={ord_dvsn} body={log_body_masked}")

                # ÎÑ§Ìä∏ÏõåÌÅ¨/Í≤åÏù¥Ìä∏Ïõ®Ïù¥ Ïû¨ÏãúÎèÑ
                for attempt in range(1, 4):
                    try:
                        resp = self.session.post(
                            url, headers=headers, data=_json_dumps(body).encode("utf-8"), timeout=(3.0, 7.0)
                        )
                        data = resp.json()
                    except Exception as e:
                        backoff = min(0.6 * (1.7 ** (attempt - 1)), 5.0) + random.uniform(0, 0.35)
                        logger.error(
                            f"[ORDER_NET_EX] tr_id={tr_id} ord_dvsn={ord_dvsn} attempt={attempt} ex={e} ‚Üí sleep {backoff:.2f}s"
                        )
                        time.sleep(backoff)
                        last_err = e
                        continue

                    if resp.status_code == 200 and data.get("rt_cd") == "0":
                        logger.info(f"[ORDER_OK] tr_id={tr_id} ord_dvsn={ord_dvsn} output={data.get('output')}")
                        # Ï£ºÎ¨∏ ÏÑ±Í≥µ ‚Üí fillsÏóê Í∏∞Î°ù (Ï∂îÏ†ï Ï≤¥Í≤∞Í∞Ä ÏÇ¨Ïö©)
                        try:
                            out = data.get("output") or {}
                            odno = out.get("ODNO") or out.get("ord_no") or ""
                            pdno = safe_strip(body.get("PDNO", ""))
                            qty = int(float(body.get("ORD_QTY", "0")))
                            # Í∞ÄÎä•Ìïú Í≤ΩÏö∞ ÏßÄÏ†ïÍ∞Ä ÏÇ¨Ïö©, ÏïÑÎãàÎ©¥ ÌòÑÏû¨Í∞ÄÎ°ú Ï∂îÏ†ï
                            price_for_fill = None
                            try:
                                ord_unpr = body.get("ORD_UNPR")
                                if ord_unpr and str(ord_unpr) not in ("0", "0.0", ""):
                                    price_for_fill = float(ord_unpr)
                                else:
                                    try:
                                        price_for_fill = float(self.get_current_price(pdno))
                                    except Exception:
                                        price_for_fill = 0.0
                            except Exception:
                                price_for_fill = 0.0

                            side = "SELL" if is_sell else "BUY"
                            append_fill(side=side, code=pdno, name="", qty=qty, price=price_for_fill, odno=odno, note=f"tr={tr_id},ord_dvsn={ord_dvsn}")
                        except Exception as e:
                            logger.warning(f"[APPEND_FILL_EX] ex={e} resp={data}")
                        return data

                    msg_cd = data.get("msg_cd", "")
                    msg1 = data.get("msg1", "")
                    # Í≤åÏù¥Ìä∏Ïõ®Ïù¥/ÏÑúÎ≤Ñ ÏóêÎü¨Î•òÎäî Ïû¨ÏãúÎèÑ
                    if msg_cd == "IGW00008" or "MCA" in msg1 or resp.status_code >= 500:
                        backoff = min(0.6 * (1.7 ** (attempt - 1)), 5.0) + random.uniform(0, 0.35)
                        logger.error(
                            f"[ORDER_FAIL_GATEWAY] tr_id={tr_id} ord_dvsn={ord_dvsn} attempt={attempt} resp={data} ‚Üí sleep {backoff:.2f}s"
                        )
                        time.sleep(backoff)
                        last_err = data
                        continue

                    logger.error(f"[ORDER_FAIL_BIZ] tr_id={tr_id} ord_dvsn={ord_dvsn} resp={data}")
                    return None

                logger.warning(f"[ORDER_FALLBACK] tr_id={tr_id} ord_dvsn={ord_dvsn} Ïã§Ìå® ‚Üí Îã§Ïùå Î∞©Ïãù ÏãúÎèÑ")

        raise Exception(f"Ï£ºÎ¨∏ Ïã§Ìå®: {last_err}")

    # -------------------------------
    # Îß§Ïàò/Îß§ÎèÑ (Ïã†Í∑ú)
    # -------------------------------
    def buy_stock_market(self, pdno: str, qty: int) -> Optional[dict]:
        body = {
            "CANO": self.CANO,
            "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
            "PDNO": safe_strip(pdno),
            "ORD_QTY": str(int(qty)),
            "ORD_DVSN": "01",  # ÏãúÏû•Í∞Ä
            "ORD_UNPR": "0",
        }
        return self._order_cash(body, is_sell=False)

    def sell_stock_market(self, pdno: str, qty: int) -> Optional[dict]:
        # --- Í∞ïÌôîÎêú ÏÇ¨Ï†ÑÏ†êÍ≤Ä: Î≥¥Ïú†ÏàòÎüâ Ïö∞ÏÑ† ---
        pos = self.get_positions() or []
        hldg = 0
        ord_psbl = 0
        for r in pos:
            if safe_strip(r.get("pdno")) == safe_strip(pdno):
                hldg = int(float(r.get("hldg_qty", "0")))
                ord_psbl = int(float(r.get("ord_psbl_qty", "0")))
                break

        base_qty = hldg if hldg > 0 else ord_psbl
        if base_qty <= 0:
            logger.error(f"[SELL_PRECHECK] Î≥¥Ïú† ÏóÜÏùå/ÏàòÎüâ 0 pdno={pdno} hldg={hldg} ord_psbl={ord_psbl}")
            return None

        if qty > base_qty:
            logger.warning(
                f"[SELL_PRECHECK] ÏàòÎüâ Î≥¥Ï†ï: req={qty} -> base={base_qty} (hldg={hldg}, ord_psbl={ord_psbl})"
            )
            qty = base_qty

        # --- Ï§ëÎ≥µ Îß§ÎèÑ Î∞©ÏßÄ(Î©îÎ™®Î¶¨ Í∏∞Î∞ò) ---
        now_ts = time.time()
        with self._recent_sells_lock:
            last = self._recent_sells.get(pdno)
            if last and (now_ts - last) < self._recent_sells_cooldown:
                logger.warning(f"[SELL_DUP_BLOCK] ÏµúÍ∑º Îß§ÎèÑ Í∏∞Î°ùÏúºÎ°ú Ï§ëÎ≥µ Îß§ÎèÑ Ï∞®Îã® pdno={pdno} last={last} age={now_ts-last:.1f}s")
                return None

        body = {
            "CANO": self.CANO,
            "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
            "PDNO": safe_strip(pdno),
            "SLL_TYPE": "01",  # ÏùºÎ∞òÎß§ÎèÑ
            "ORD_QTY": str(int(qty)),
            "ORD_DVSN": "01",
            "ORD_UNPR": "0",
            "EXCG_ID_DVSN_CD": "KRX",
        }
        resp = self._order_cash(body, is_sell=True)
        if resp and isinstance(resp, dict) and resp.get("rt_cd") == "0":
            with self._recent_sells_lock:
                self._recent_sells[pdno] = time.time()
                cutoff = time.time() - (self._recent_sells_cooldown * 5)
                keys_to_del = [k for k, v in self._recent_sells.items() if v < cutoff]
                for k in keys_to_del:
                    del self._recent_sells[k]
        return resp

    def buy_stock_limit(self, pdno: str, qty: int, price: int) -> Optional[dict]:
        body = {
            "CANO": self.CANO,
            "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
            "PDNO": safe_strip(pdno),
            "ORD_QTY": str(int(qty)),
            "ORD_DVSN": "00",  # ÏßÄÏ†ïÍ∞Ä
            "ORD_UNPR": str(int(price)),
            "EXCG_ID_DVSN_CD": "KRX",
        }
        hk = self._create_hashkey(body)
        tr_list = _pick_tr(self.env, "ORDER_BUY")
        if not tr_list:
            raise Exception("ORDER_BUY TR ÎØ∏Íµ¨ÏÑ±")
        tr_id = tr_list[0]
        headers = self._headers(tr_id, hk)
        url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/order-cash"
        resp = self.session.post(url, headers=headers, data=_json_dumps(body).encode("utf-8"), timeout=(3.0, 7.0))
        data = resp.json()
        if resp.status_code == 200 and data.get("rt_cd") == "0":
            logger.info(f"[BUY_LIMIT_OK] output={data.get('output')}")
            try:
                out = data.get("output") or {}
                odno = out.get("ODNO") or out.get("ord_no") or ""
                pdno = safe_strip(body.get("PDNO", ""))
                qty_int = int(float(body.get("ORD_QTY", "0")))
                price_for_fill = float(body.get("ORD_UNPR", 0))
                append_fill(side="BUY", code=pdno, name="", qty=qty_int, price=price_for_fill, odno=odno, note=f"limit,tr={tr_id}")
            except Exception as e:
                logger.warning(f"[APPEND_FILL_LIMIT_BUY_FAIL] ex={e}")
            return data
        logger.error(f"[BUY_LIMIT_FAIL] {data}")
        return None

    def sell_stock_limit(self, pdno: str, qty: int, price: int) -> Optional[dict]:
        # --- Í∞ïÌôîÎêú ÏÇ¨Ï†ÑÏ†êÍ≤Ä: Î≥¥Ïú†ÏàòÎüâ Ïö∞ÏÑ† ---
        pos = self.get_positions() or []
        hldg = 0
        ord_psbl = 0
        for r in pos:
            if safe_strip(r.get("pdno")) == safe_strip(pdno):
                hldg = int(float(r.get("hldg_qty", "0")))
                ord_psbl = int(float(r.get("ord_psbl_qty", "0")))
                break

        base_qty = hldg if hldg > 0 else ord_psbl
        if base_qty <= 0:
            logger.error(f"[SELL_LIMIT_PRECHECK] Î≥¥Ïú† ÏóÜÏùå/ÏàòÎüâ 0 pdno={pdno} hldg={hldg} ord_psbl={ord_psbl}")
            return None

        if qty > base_qty:
            logger.warning(
                f"[SELL_LIMIT_PRECHECK] ÏàòÎüâ Î≥¥Ï†ï: req={qty} -> base={base_qty} (hldg={hldg}, ord_psbl={ord_psbl})"
            )
            qty = base_qty

        # Ï§ëÎ≥µ Îß§ÎèÑ Î∞©ÏßÄ(Î©îÎ™®Î¶¨ Í∏∞Î∞ò)
        now_ts = time.time()
        with self._recent_sells_lock:
            last = self._recent_sells.get(pdno)
            if last and (now_ts - last) < self._recent_sells_cooldown:
                logger.warning(f"[SELL_DUP_BLOCK_LIMIT] ÏµúÍ∑º Îß§ÎèÑ Í∏∞Î°ùÏúºÎ°ú Ï§ëÎ≥µ Îß§ÎèÑ Ï∞®Îã® pdno={pdno} last={last} age={now_ts-last:.1f}s")
                return None

        body = {
            "CANO": self.CANO,
            "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
            "PDNO": safe_strip(pdno),
            "SLL_TYPE": "01",
            "ORD_QTY": str(int(qty)),
            "ORD_DVSN": "00",  # ÏßÄÏ†ïÍ∞Ä
            "ORD_UNPR": str(int(price)),
            "EXCG_ID_DVSN_CD": "KRX",
        }
        hk = self._create_hashkey(body)
        tr_list = _pick_tr(self.env, "ORDER_SELL")
        if not tr_list:
            raise Exception("ORDER_SELL TR ÎØ∏Íµ¨ÏÑ±")
        tr_id = tr_list[0]
        headers = self._headers(tr_id, hk)
        url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/order-cash"
        resp = self.session.post(url, headers=headers, data=_json_dumps(body).encode("utf-8"), timeout=(3.0, 7.0))
        data = resp.json()
        if resp.status_code == 200 and data.get("rt_cd") == "0":
            logger.info(f"[SELL_LIMIT_OK] output={data.get('output')}")
            try:
                out = data.get("output") or {}
                odno = out.get("ODNO") or out.get("ord_no") or ""
                pdno = safe_strip(body.get("PDNO", ""))
                qty_int = int(float(body.get("ORD_QTY", "0")))
                price_for_fill = float(body.get("ORD_UNPR", 0))
                append_fill(side="SELL", code=pdno, name="", qty=qty_int, price=price_for_fill, odno=odno, note=f"limit,tr={tr_id}")
            except Exception as e:
                logger.warning(f"[APPEND_FILL_LIMIT_SELL_FAIL] ex={e}")
            with self._recent_sells_lock:
                self._recent_sells[pdno] = time.time()
            return data
        logger.error(f"[SELL_LIMIT_FAIL] {data}")
        return None

    # --- Ìò∏Ìôò ÏÖîÏûÑ(Í∏∞Ï°¥ trader.py Ìò∏Ï∂ú ÎåÄÏùë) ---
    def buy_stock(self, code: str, qty: int, price: Optional[int] = None):
        """
        Í∏∞Ï°¥ ÏΩîÎìú Ìò∏ÌôòÏö©:
        - price Í∞Ä None ‚Üí ÏãúÏû•Í∞Ä Îß§Ïàò
        - price ÏßÄÏ†ï ‚Üí ÏßÄÏ†ïÍ∞Ä Îß§Ïàò
        """
        if price is None:
            return self.buy_stock_market(code, qty)
        return self.buy_stock_limit(code, qty, price)

    def sell_stock(self, code: str, qty: int, price: Optional[int] = None):
        """
        Í∏∞Ï°¥ ÏΩîÎìú Ìò∏ÌôòÏö©:
        - price Í∞Ä None ‚Üí ÏãúÏû•Í∞Ä Îß§ÎèÑ
        - price ÏßÄÏ†ï ‚Üí ÏßÄÏ†ïÍ∞Ä Îß§ÎèÑ
        """
        if price is None:
            return self.sell_stock_market(code, qty)
        return self.sell_stock_limit(code, qty, price)
