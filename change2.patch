diff --git a/trader/config.py b/trader/config.py
index 00ebc400c72ac870268f06119fcdf2cdf42fe65d..4143adc14a06ae527b0984ef6c3f2a18070e8c58 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -100,50 +100,51 @@ MARKET_MAP: Dict[str, str] = {
 # Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå 1Ï∞® Í∞êÏßÄ ÏÉÅÌÉú Ï†ÄÏû•(Ïó∞ÏÜç DATA_EMPTY ÌôïÏù∏Ïö©)
 EXCLUDE_STATE: Dict[str, Dict[str, bool]] = {}
 
 KST = ZoneInfo("Asia/Seoul")
 
 SELL_FORCE_TIME_STR = _cfg("SELL_FORCE_TIME").strip()
 SELL_ALL_BALANCES_AT_CUTOFF = _cfg("SELL_ALL_BALANCES_AT_CUTOFF").lower() == "true"
 RATE_SLEEP_SEC = float(_cfg("API_RATE_SLEEP_SEC"))
 FORCE_SELL_PASSES_CUTOFF = int(_cfg("FORCE_SELL_PASSES_CUTOFF"))
 FORCE_SELL_PASSES_CLOSE = int(_cfg("FORCE_SELL_PASSES_CLOSE"))
 PARTIAL1 = float(_cfg("PARTIAL1"))
 PARTIAL2 = float(_cfg("PARTIAL2"))
 TRAIL_PCT = float(_cfg("TRAIL_PCT"))
 FAST_STOP = float(_cfg("FAST_STOP"))
 ATR_STOP = float(_cfg("ATR_STOP"))
 TIME_STOP_HHMM = _cfg("TIME_STOP_HHMM")
 DEFAULT_PROFIT_PCT = float(_cfg("DEFAULT_PROFIT_PCT"))
 DEFAULT_LOSS_PCT = float(_cfg("DEFAULT_LOSS_PCT"))
 DAILY_CAPITAL = int(_cfg("DAILY_CAPITAL"))
 CAP_CAP = float(_cfg("CAP_CAP"))
 SLIPPAGE_LIMIT_PCT = float(_cfg("SLIPPAGE_LIMIT_PCT"))
 SLIPPAGE_ENTER_GUARD_PCT = float(_cfg("SLIPPAGE_ENTER_GUARD_PCT"))
 VWAP_TOL = float(_cfg("VWAP_TOL"))  # üî∏ VWAP ÌóàÏö© Ïò§Ï∞®(Ïòà: 0.003 = -0.3%ÍπåÏßÄ ÌóàÏö©)
 W_MAX_ONE = float(_cfg("W_MAX_ONE"))
 W_MIN_ONE = float(_cfg("W_MIN_ONE"))
+ALLOW_PYRAMID = (_cfg("ALLOW_PYRAMID") or "false").lower() == "true"
 REBALANCE_ANCHOR = _cfg("REBALANCE_ANCHOR")
 WEEKLY_ANCHOR_REF = _cfg("WEEKLY_ANCHOR_REF").lower()
 MOMENTUM_OVERRIDES_FORCE_SELL = _cfg("MOMENTUM_OVERRIDES_FORCE_SELL").lower() == "true"
 
 # NEW: 1Î∂ÑÎ¥â Î™®Î©òÌÖÄ ÌååÎùºÎØ∏ÌÑ∞
 MOM_FAST = int(_cfg("MOM_FAST") or "5")
 MOM_SLOW = int(_cfg("MOM_SLOW") or "20")
 MOM_TH_PCT = float(_cfg("MOM_TH_PCT") or "0.5")
 # Ïã†Í≥†Í∞Ä ‚Üí 3Ïùº ÎàåÎ¶º ‚Üí Î∞òÎì± ÌôïÏù∏ ÌõÑ Îß§Ïàò ÌååÎùºÎØ∏ÌÑ∞
 USE_PULLBACK_ENTRY = _cfg("USE_PULLBACK_ENTRY").lower() != "false"
 PULLBACK_LOOKBACK = int(_cfg("PULLBACK_LOOKBACK") or "60")
 PULLBACK_DAYS = int(_cfg("PULLBACK_DAYS") or "3")
 PULLBACK_REVERSAL_BUFFER_PCT = float(_cfg("PULLBACK_REVERSAL_BUFFER_PCT") or "0.2")
 PULLBACK_TOPN = int(_cfg("PULLBACK_TOPN") or "50")
 PULLBACK_UNIT_WEIGHT = float(_cfg("PULLBACK_UNIT_WEIGHT") or "0.03")
 PULLBACK_MAX_BUYS_PER_DAY = int(_cfg("PULLBACK_MAX_BUYS_PER_DAY") or "5")
 CHAMPION_MIN_TRADES = int(_cfg("CHAMPION_MIN_TRADES") or "5")
 CHAMPION_MIN_WINRATE = float(_cfg("CHAMPION_MIN_WINRATE") or "45.0")
 CHAMPION_MAX_MDD = float(_cfg("CHAMPION_MAX_MDD") or "30.0")
 CHAMPION_MIN_SHARPE = float(_cfg("CHAMPION_MIN_SHARPE") or "0.0")
 
 # Ï±îÌîºÏñ∏ Îì±Í∏â & GOOD/BAD ÌÉÄÏ†ê ÌåêÎ≥Ñ ÌååÎùºÎØ∏ÌÑ∞
 CHAMPION_A_RULES = {
     "min_trades": 30,
     "min_cumret_pct": 40.0,
diff --git a/trader/core_constants.py b/trader/core_constants.py
index 8585a18a3ac767679ebf85837128b0d9e33baee7..eceb6625d67f7a587441006348c4075f79ba6205 100644
--- a/trader/core_constants.py
+++ b/trader/core_constants.py
@@ -41,50 +41,51 @@ WEEKLY_ANCHOR_REF = config.WEEKLY_ANCHOR_REF
 MOMENTUM_OVERRIDES_FORCE_SELL = config.MOMENTUM_OVERRIDES_FORCE_SELL
 MOM_FAST = config.MOM_FAST
 MOM_SLOW = config.MOM_SLOW
 MOM_TH_PCT = config.MOM_TH_PCT
 USE_PULLBACK_ENTRY = config.USE_PULLBACK_ENTRY
 PULLBACK_LOOKBACK = config.PULLBACK_LOOKBACK
 PULLBACK_DAYS = config.PULLBACK_DAYS
 PULLBACK_REVERSAL_BUFFER_PCT = config.PULLBACK_REVERSAL_BUFFER_PCT
 PULLBACK_TOPN = config.PULLBACK_TOPN
 PULLBACK_UNIT_WEIGHT = config.PULLBACK_UNIT_WEIGHT
 CHAMPION_MIN_TRADES = config.CHAMPION_MIN_TRADES
 CHAMPION_MIN_WINRATE = config.CHAMPION_MIN_WINRATE
 CHAMPION_MAX_MDD = config.CHAMPION_MAX_MDD
 CHAMPION_MIN_SHARPE = config.CHAMPION_MIN_SHARPE
 CHAMPION_A_RULES = config.CHAMPION_A_RULES
 GOOD_ENTRY_PULLBACK_RANGE = config.GOOD_ENTRY_PULLBACK_RANGE
 GOOD_ENTRY_MA20_RANGE = config.GOOD_ENTRY_MA20_RANGE
 GOOD_ENTRY_MAX_FROM_PEAK = config.GOOD_ENTRY_MAX_FROM_PEAK
 GOOD_ENTRY_MIN_RR = config.GOOD_ENTRY_MIN_RR
 GOOD_ENTRY_MIN_INTRADAY_SIG = config.GOOD_ENTRY_MIN_INTRADAY_SIG
 BAD_ENTRY_MAX_MA20_DIST = config.BAD_ENTRY_MAX_MA20_DIST
 BAD_ENTRY_MAX_PULLBACK = config.BAD_ENTRY_MAX_PULLBACK
 BAD_ENTRY_MAX_BELOW_VWAP_RATIO = config.BAD_ENTRY_MAX_BELOW_VWAP_RATIO
 NEUTRAL_ENTRY_SCALE = config.NEUTRAL_ENTRY_SCALE
 ALLOW_WHEN_CLOSED = config.ALLOW_WHEN_CLOSED
+ALLOW_PYRAMID = config.ALLOW_PYRAMID
 STATE_WEEKLY_PATH = config.STATE_WEEKLY_PATH
 _this_iso_week_key = config._this_iso_week_key
 
 __all__ = [
     "logger",
     "_cfg",
     "LOG_DIR",
     "STATE_FILE",
     "MARKET_MAP",
     "EXCLUDE_STATE",
     "KST",
     "SELL_FORCE_TIME_STR",
     "SELL_FORCE_TIME",
     "SELL_ALL_BALANCES_AT_CUTOFF",
     "RATE_SLEEP_SEC",
     "FORCE_SELL_PASSES_CUTOFF",
     "FORCE_SELL_PASSES_CLOSE",
     "PARTIAL1",
     "PARTIAL2",
     "TRAIL_PCT",
     "FAST_STOP",
     "ATR_STOP",
     "TIME_STOP_TIME",
     "DEFAULT_PROFIT_PCT",
     "DEFAULT_LOSS_PCT",
@@ -100,29 +101,30 @@ __all__ = [
     "MOMENTUM_OVERRIDES_FORCE_SELL",
     "MOM_FAST",
     "MOM_SLOW",
     "MOM_TH_PCT",
     "USE_PULLBACK_ENTRY",
     "PULLBACK_LOOKBACK",
     "PULLBACK_DAYS",
     "PULLBACK_REVERSAL_BUFFER_PCT",
     "PULLBACK_TOPN",
     "PULLBACK_UNIT_WEIGHT",
     "CHAMPION_MIN_TRADES",
     "CHAMPION_MIN_WINRATE",
     "CHAMPION_MAX_MDD",
     "CHAMPION_MIN_SHARPE",
     "CHAMPION_A_RULES",
     "GOOD_ENTRY_PULLBACK_RANGE",
     "GOOD_ENTRY_MA20_RANGE",
     "GOOD_ENTRY_MAX_FROM_PEAK",
     "GOOD_ENTRY_MIN_RR",
     "GOOD_ENTRY_MIN_INTRADAY_SIG",
     "BAD_ENTRY_MAX_MA20_DIST",
     "BAD_ENTRY_MAX_PULLBACK",
     "BAD_ENTRY_MAX_BELOW_VWAP_RATIO",
     "NEUTRAL_ENTRY_SCALE",
     "ALLOW_WHEN_CLOSED",
+    "ALLOW_PYRAMID",
     "STATE_WEEKLY_PATH",
     "_this_iso_week_key",
 ]
 
diff --git a/trader/legacy_kosdaq_runner.py b/trader/legacy_kosdaq_runner.py
index e2811a07e7cb9ce18900cdaf590a571004f5d648..ecbed52a6d71f70d6cadb7cfc1034afc89583a09 100644
--- a/trader/legacy_kosdaq_runner.py
+++ b/trader/legacy_kosdaq_runner.py
@@ -1,185 +1,197 @@
 # -*- coding: utf-8 -*-
 """Í±∞Îûò Î©îÏù∏ Î£®ÌîÑ.
 
 Í∏∞Ï°¥ trader.pyÏùò ÏÑ§Ï†ï/Ïú†Ìã∏ÏùÑ Î∂ÑÎ¶¨ÌïòÍ≥†, Î©îÏù∏ ÏßÑÏûÖÏ†êÎßå ÎÇ®Í≤® Ï†ÑÎûµ Ï∂îÍ∞ÄÍ∞Ä
 Ïâ¨Ïö¥ Íµ¨Ï°∞Î°ú Î≥ÄÍ≤ΩÌñàÎã§.
 """
 from __future__ import annotations
 
 import time
 from datetime import datetime, time as dtime, timedelta
 from typing import Any, Dict, List, Tuple, TYPE_CHECKING
 
 
 try:
     from .config import (
         DAILY_CAPITAL,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         ALLOW_WHEN_CLOSED,
+        ALLOW_PYRAMID,
         KST,
         RATE_SLEEP_SEC,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         _cfg,
         logger,
     )
 except ImportError:
     # ALLOW_WHEN_CLOSEDÍ∞Ä ÎàÑÎùΩÎèºÎèÑ Îü¨ÎÑàÍ∞Ä Ï¶âÏãú Ï§ëÎã®ÎêòÏßÄ ÏïäÎèÑÎ°ù ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞íÏùÑ Ï†úÍ≥µÌïúÎã§.
     from .config import (
         DAILY_CAPITAL,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         KST,
         RATE_SLEEP_SEC,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         _cfg,
         logger,
     )
 
     ALLOW_WHEN_CLOSED = False
     logger.warning("[CONFIG] ALLOW_WHEN_CLOSED missing; defaulting to False")
+    ALLOW_PYRAMID = False
+    logger.warning("[CONFIG] ALLOW_PYRAMID missing; defaulting to False")
+from . import signals
 from trader.time_utils import MARKET_CLOSE, MARKET_OPEN, is_trading_day
 from .core import *  # noqa: F401,F403 - Ï†ÑÎûµ Ïú†Ìã∏ Ï†ÑÏ≤¥ ÎÖ∏Ï∂úÎ°ú ÌôïÏû•ÏÑ± ÌôïÎ≥¥
 
 if TYPE_CHECKING:
     # core Ï™ΩÏóê Íµ¨ÌòÑÎèº ÏûàÎäî Ìó¨ÌçºÎì§ÏùÑ ÌÉÄÏûÖÏ≤¥Ïª§ÏóêÍ≤åÎßå Î™ÖÏãúÏ†ÅÏúºÎ°ú ÏïåÎ†§Ï§ÄÎã§.
     from .core import (
         _this_iso_week_key,
         _get_effective_ord_cash,
         _to_float,
         _to_int,
         _weight_to_qty,
         _classify_champion_grade,
         _update_market_regime,
         _notional_to_qty,
         _fetch_balances,
         _init_position_state_from_balance,
         _sell_once,
         _adaptive_exit,
         _compute_daily_entry_context,
         _compute_intraday_entry_context,
         _safe_get_price,
         _round_to_tick,
         _init_position_state,
         _detect_pullback_reversal,
         _has_bullish_trend_structure,
     )
 
 
 def main(capital_override: float | None = None):
     effective_capital = int(capital_override) if capital_override is not None else DAILY_CAPITAL
     kis = KisAPI()
 
     rebalance_date = get_rebalance_anchor_date()
     logger.info(f"[‚ÑπÔ∏è Î¶¨Î∞∏Îü∞Ïã± Í∏∞Ï§ÄÏùº(KST)]: {rebalance_date} (anchor={REBALANCE_ANCHOR}, ref={WEEKLY_ANCHOR_REF})")
     logger.info(
         f"[‚è±Ô∏è Ïª§Ìä∏Ïò§ÌîÑ(KST)] SELL_FORCE_TIME={SELL_FORCE_TIME.strftime('%H:%M')} / Ï†ÑÏ≤¥ÏûîÍ≥†Îß§ÎèÑ={SELL_ALL_BALANCES_AT_CUTOFF} / "
         f"Ìå®Ïä§(Ïª§Ìä∏Ïò§ÌîÑ/ÎßàÍ∞ê)={FORCE_SELL_PASSES_CUTOFF}/{FORCE_SELL_PASSES_CLOSE}"
     )
     logger.info(f"[üí∞ CAPITAL] {effective_capital:,}Ïõê (configured DAILY_CAPITAL={DAILY_CAPITAL:,})")
     logger.info(f"[üõ°Ô∏è SLIPPAGE_ENTER_GUARD_PCT] {SLIPPAGE_ENTER_GUARD_PCT:.2f}%")
 
     # ÏÉÅÌÉú Î≥µÍµ¨
     state_loaded_at = datetime.now(KST)
     state_loaded_date = state_loaded_at.strftime("%Y-%m-%d")
     state_loaded_str = state_loaded_at.strftime("%Y-%m-%d %H:%M:%S")
     state_loaded_midnight = f"{state_loaded_date} 00:00:00"
 
     holding, traded = load_state()
+    triggered_today: set[str] = set()
+    last_price_map: dict[str, float] = {}
+    last_today_prefix: str | None = None
 
     if isinstance(traded, (set, list, tuple)):
         logger.warning(
             f"[STATE-MIGRATE] traded ÌÉÄÏûÖ {type(traded)} ‚Üí dictÎ°ú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò(Ï§ëÎ≥µ ÏßÑÏûÖ Í∞ÄÎìú Ïú†ÏßÄ)"
         )
         traded = {
             code: {"buy_time": state_loaded_midnight, "qty": 0, "price": 0.0}
             for code in traded
         }
     elif not isinstance(traded, dict):
         logger.warning(
             f"[STATE-FORMAT] traded ÌÉÄÏûÖ {type(traded)} ÏßÄÏõê Ïïà Ìï® ‚Üí Îπà dictÎ°ú Ïû¨ÏÑ§Ï†ï"
         )
         traded = {}
 
     def _traded_codes(traded_state: Any) -> List[str]:
         if isinstance(traded_state, dict):
             return list(traded_state.keys())
         return []
 
     def _traded_today(traded_state: Any, today_prefix: str) -> set:
         if not isinstance(traded_state, dict):
             return set()
 
         today_codes = set()
         for code, payload in traded_state.items():
             payload = payload or {}
             buy_time = payload.get("buy_time")
             status = payload.get("status")
             # pending/other ÏÉÅÌÉúÎäî Ïû¨ÏãúÎèÑ ÌóàÏö©, filled/Í∏∞Ï°¥(None)Îßå Ï§ëÎ≥µ Î∞©ÏßÄ
             if status not in (None, "filled"):
                 continue
             if isinstance(buy_time, str) and buy_time.startswith(today_prefix):
                 today_codes.add(code)
         return today_codes
 
     def _record_trade(traded_state: Any, code: str, payload: Dict[str, Any]) -> None:
         try:
             traded_state[code] = payload
         except Exception:
             logger.warning(f"[TRADED-STATE] tradedÏóê ÏΩîÎìú Ï∂îÍ∞Ä Ïã§Ìå®: type={type(traded_state)}")
 
-    def _cleanup_expired_pending(traded_state: dict, now_dt: datetime, ttl_sec: int = 300) -> None:
+    def _cleanup_expired_pending(
+        traded_state: dict, now_dt: datetime, ttl_sec: int = 300
+    ) -> set:
+        expired: set[str] = set()
         if not isinstance(traded_state, dict):
-            return
+            return expired
 
         for code, payload in list(traded_state.items()):
             payload = payload or {}
             if payload.get("status") != "pending":
                 continue
 
             ts = payload.get("pending_since") or payload.get("buy_time")
             if not isinstance(ts, str):
                 continue
 
             try:
                 pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(tzinfo=now_dt.tzinfo)
                 if (now_dt - pending_dt).total_seconds() > ttl_sec:
                     logger.warning(f"[PENDING-EXPIRE] {code}: {ttl_sec}s Ï¥àÍ≥º ‚Üí pending Ï†úÍ±∞")
                     traded_state.pop(code, None)
+                    expired.add(code)
             except Exception:
                 continue
+        return expired
 
     def _pending_block(traded_state: dict, code: str, now_dt: datetime, block_sec: int = 45) -> bool:
         if not isinstance(traded_state, dict):
             return False
         payload = traded_state.get(code) or {}
         if payload.get("status") != "pending":
             return False
 
         ts = payload.get("pending_since") or payload.get("buy_time")
         if not isinstance(ts, str):
             return True
 
         try:
             pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(tzinfo=now_dt.tzinfo)
             return (now_dt - pending_dt).total_seconds() <= block_sec
         except Exception:
             return True
 
     def _is_balance_reflected(code: str, prev_qty: int = 0, delay_sec: float = 1.0) -> bool:
         try:
             time.sleep(delay_sec)
             balances = _fetch_balances(kis, ttl_sec=0)
         except Exception as e:
             logger.warning(f"[BAL-REFRESH-FAIL] {code}: ÏûîÍ≥† ÌôïÏù∏ Ïã§Ìå® {e}")
             return False
@@ -530,52 +542,57 @@ def main(capital_override: float | None = None):
                     "notional": base_notional,
                 }
             logger.info(
                 f"[PULLBACK-WATCH] ÏΩîÏä§Îã• ÏãúÏ¥ù Top{PULLBACK_TOPN} {len(pullback_watch)}Ï¢ÖÎ™© Ïä§Ï∫î Ï§ÄÎπÑ"
             )
         except Exception as e:
             logger.warning(f"[PULLBACK-WATCH-FAIL] ÏãúÏ¥ù ÏÉÅÏúÑ Î°úÎìú Ïã§Ìå®: {e}")
 
     loop_sleep_sec = 2.5  # Î©îÏù∏ Î£®ÌîÑ ÎåÄÍ∏∞ ÏãúÍ∞Ñ(Ï¥à)
     max_closed_checks = 3
     closed_checks = 0
 
     try:
         while True:
             # === ÏΩîÏä§Îã• Î†àÏßê ÏóÖÎç∞Ïù¥Ìä∏ ===
             regime = _update_market_regime(kis)
             regime_state = regime
             pct_txt = f"{regime.get('pct_change'):.2f}%" if regime.get("pct_change") is not None else "N/A"
             logger.info(f"[REGIME] mode={regime['mode']} stage={regime['bear_stage']} pct={pct_txt}")
 
             # Ïû• ÏÉÅÌÉú
             now_dt_kst = datetime.now(KST)
             is_open = kis.is_market_open()
             now_str = now_dt_kst.strftime("%Y-%m-%d %H:%M:%S")
             today_prefix = now_dt_kst.strftime("%Y-%m-%d")
-            _cleanup_expired_pending(traded, now_dt_kst, ttl_sec=300)
-            traded_today = _traded_today(traded, today_prefix)
+            if last_today_prefix != today_prefix:
+                triggered_today.clear()
+                last_today_prefix = today_prefix
+            expired_pending = _cleanup_expired_pending(traded, now_dt_kst, ttl_sec=300)
+            if expired_pending:
+                triggered_today.difference_update(expired_pending)
+            traded_today: set[str] = set()
 
             if now_dt_kst.date() != pullback_buy_date:
                 pullback_buy_date = now_dt_kst.date()
                 pullback_buys_today = 0
 
             if not is_open:
                 if not is_trading_day(now_dt_kst):
                     logger.error("[CLOSED] ÎπÑÍ±∞ÎûòÏùº Í∞êÏßÄ ‚Üí Î£®ÌîÑ Ï¢ÖÎ£å")
                     break
 
                 if now_dt_kst.time() < MARKET_OPEN:
                     seconds_to_open = int(
                         (datetime.combine(now_dt_kst.date(), MARKET_OPEN, tzinfo=KST) - now_dt_kst).total_seconds()
                     )
                     sleep_for = max(1, min(seconds_to_open, 300))
                     logger.info(
                         "[PREOPEN] Ïû• ÏãúÏûëÍπåÏßÄ %ss ÎÇ®Ïùå ‚Üí %ss ÎåÄÍ∏∞ ÌõÑ Ïû¨ÌôïÏù∏", seconds_to_open, sleep_for
                     )
                     time.sleep(sleep_for)
                     closed_checks = 0
                     continue
 
                 if now_dt_kst.time() >= MARKET_CLOSE:
                     logger.error("[CLOSED] Ïû• ÎßàÍ∞ê Ïù¥ÌõÑ ‚Üí Î£®ÌîÑ Ï¢ÖÎ£å")
                     break
@@ -605,50 +622,66 @@ def main(capital_override: float | None = None):
             prev_holding = holding if isinstance(holding, dict) else {}
             balances = _fetch_balances(kis)
             holding = {}
             for bal in balances:
                 code = bal.get("code")
                 qty = int(bal.get("qty", 0))
                 if qty <= 0:
                     continue
                 price = float(bal.get("avg_price", 0.0))
                 holding[code] = {
                     "qty": qty,
                     "buy_price": price,
                     "bear_s1_done": False,
                     "bear_s2_done": False,
                 }
                 _init_position_state_from_balance(kis, holding, code, price, qty)
 
             # ÏûîÍ≥† Í∏∞Ï§ÄÏúºÎ°ú Î≥¥Ïú†Ï¢ÖÎ™© Îß§ÎèÑ Í∞ÄÎä• ÏàòÎüâ Îßµ ÏÉùÏÑ±
             ord_psbl_map = {bal.get("code"): int(bal.get("sell_psbl_qty", 0)) for bal in balances}
 
             if isinstance(traded, dict):
                 for code, payload in list(traded.items()):
                     if (payload or {}).get("status") == "pending" and code in holding:
                         traded[code]["status"] = "filled"
 
+            traded_today = _traded_today(traded, today_prefix)
+            for bal in balances:
+                code = bal.get("code")
+                raw = bal.get("raw") or {}
+                raw_l = {str(k).lower(): v for k, v in raw.items()}
+                thdt_buy_qty = _to_int(
+                    raw_l.get("thdt_buyqty")
+                    or raw_l.get("thdt_buy_qty")
+                    or raw_l.get("thdt_buy_q")
+                )
+                if thdt_buy_qty > 0:
+                    traded_today.add(code)
+
+            if not ALLOW_PYRAMID:
+                traded_today.update(holding.keys())
+
             for code, info in list(holding.items()):
                 prev_qty = int((prev_holding.get(code) or {}).get("qty", info.get("qty", 0)))
                 balance_qty = int(info.get("qty", 0))
                 # ÏûîÍ≥†Í∞Ä ÏùºÏãúÏ†ÅÏúºÎ°ú Ï§ÑÏñ¥Îì† ÏºÄÏù¥Ïä§Îßå Î≥¥Ìò∏ÌïòÍ≥†, Ï†ïÏÉÅÏ†ÅÏù∏ ÏàòÎüâ Ï¶ùÍ∞ÄÎäî Ïú†ÏßÄÌïúÎã§.
                 if prev_qty > 0 and 0 < balance_qty < prev_qty:
                     holding[code]["qty"] = prev_qty
                     logger.info(
                         f"[HOLDING-QTY-CLAMP] {code}: balance_qty={balance_qty} prev_qty={prev_qty} ‚Üí {prev_qty}"
                     )
 
             recent_keep_minutes = 5
             for code, info in prev_holding.items():
                 if code in holding:
                     continue
                 buy_time_str = None
                 if isinstance(traded, dict):
                     buy_time_str = (traded.get(code) or {}).get("buy_time")
                 if buy_time_str:
                     try:
                         buy_dt = datetime.strptime(buy_time_str, "%Y-%m-%d %H:%M:%S")
                         buy_dt = buy_dt.replace(tzinfo=now_dt_kst.tzinfo)
                         if now_dt_kst - buy_dt <= timedelta(minutes=recent_keep_minutes):
                             holding[code] = info
                             ord_psbl_map.setdefault(code, int(info.get("qty", 0)))
                             logger.info(
@@ -767,118 +800,182 @@ def main(capital_override: float | None = None):
 
                 # --- 1b) TP/SL/Ìä∏Î†àÏùºÎßÅ, VWAP Í∞ÄÎìú ---
                 try:
                     exit_reason, exec_px, exit_result, sold_qty = _adaptive_exit(
                         kis,
                         code,
                         holding[code],
                         regime_mode=mode or "neutral",
                     )
                 except Exception as e:
                     logger.error(f"[_adaptive_exit Ïã§Ìå®] {code}: {e}")
                     exit_reason = exec_px = exit_result = sold_qty = None
 
                 if sold_qty:
                     save_state(holding, traded)
                     time.sleep(RATE_SLEEP_SEC)
 
             # === (2) Ïã†Í∑ú ÏßÑÏûÖ Î°úÏßÅ (Ï±îÌîºÏñ∏) ===
             for code, info in code_to_target.items():
                 if not can_buy:
                     continue
 
                 if code in traded_today:
                     continue
 
-                if code in holding:
+                if code in holding and not ALLOW_PYRAMID:
+                    continue
+
+                if code in triggered_today:
+                    logger.info(f"[TRIGGER-SKIP] {code}: Í∏àÏùº Ïù¥ÎØ∏ Ìä∏Î¶¨Í±∞ Î∞úÏÉù")
                     continue
 
                 target_qty = int(info.get("qty", 0))
                 if target_qty <= 0:
                     logger.info(f"[REBALANCE] {code}: target_qty=0 ‚Üí Ïä§ÌÇµ")
                     continue
 
                 target_price = info.get("target_price")
                 k_value = info.get("best_k")
                 strategy = info.get("strategy")
                 weight = _to_float(info.get("weight") or 0.0)
 
                 planned_notional = int(_to_float(info.get("target_notional") or 0.0) or 0)
                 logger.info(
                     f"[TARGET] {code} qty={target_qty} tgt_px={target_price} notional={planned_notional} K={k_value}"
                 )
 
                 # [Ï§ëÎ≥µ ÏßÑÏûÖ Î∞©ÏßÄ] Ïù¥ÎØ∏ Ï£ºÎ¨∏Îêú Ï¢ÖÎ™©Ïù∏ÏßÄ ÌôïÏù∏
                 if code in traded_today:
                     logger.info(f"[SKIP] {code}: Ïù¥ÎØ∏ Í∏àÏùº Í±∞ÎûòÎê®")
                     continue
 
                 if _pending_block(traded, code, now_dt_kst, block_sec=45):
                     logger.info(f"[SKIP-PENDING] {code}: pending Ïø®Îã§Ïö¥ Ï§ë ‚Üí Ïû¨Ï£ºÎ¨∏ Î∞©ÏßÄ")
                     continue
 
+                prev_price = last_price_map.get(code)
+                if prev_price is None:
+                    try:
+                        cached = signals._LAST_PRICE_CACHE.get(code) or {}
+                        ts = cached.get("ts")
+                        if ts and (time.time() - float(ts) <= 120):
+                            prev_price = cached.get("px")
+                    except Exception:
+                        prev_price = None
+
                 price_res = _safe_get_price(kis, code, with_source=True)
                 if isinstance(price_res, tuple):
                     current_price, price_source = price_res
                 else:
                     current_price, price_source = price_res, None
 
                 if not current_price or current_price <= 0:
                     logger.warning(f"[PRICE_FAIL] {code}: ÌòÑÏû¨Í∞Ä Ï°∞Ìöå Ïã§Ìå® ‚Üí Ïä§ÌÇµ")
                     continue
 
+                try:
+                    last_price_map[code] = float(current_price)
+                except Exception:
+                    pass
+
                 # === GOOD/BAD ÌÉÄÏ†ê ÌèâÍ∞Ä ===
                 daily_ctx = _compute_daily_entry_context(kis, code, current_price, price_source)
                 intra_ctx = _compute_intraday_entry_context(kis, code, fast=MOM_FAST, slow=MOM_SLOW)
 
                 momentum_confirmed = bool(
                     daily_ctx.get("strong_trend")
                     or intra_ctx.get("vwap_reclaim")
                     or intra_ctx.get("range_break")
                 )
 
                 if mode == "neutral" and not (
                     info.get("champion_grade") in ("A", "B") or momentum_confirmed
                 ):
                     logger.info(
                         f"[ENTRY-SKIP] {code}: neutral Î†àÏßêÏóêÏÑú ÎπÑÏ±îÌîºÏñ∏/Î™®Î©òÌÖÄ ÎØ∏ÌôïÏù∏ ‚Üí Ïã†Í∑ú ÏßÑÏûÖ Î≥¥Î•ò"
                     )
                     continue
 
-                if is_bad_entry(code, daily_ctx, intra_ctx, regime_state):
-                    logger.info(f"[ENTRY-SKIP] {code}: BAD ÌÉÄÏ†ê Í∞êÏßÄ ‚Üí Ïù¥Î≤à Î£®ÌîÑ Îß§Ïàò Ïä§ÌÇµ")
+                setup_state = signals.evaluate_setup_gate(
+                    daily_ctx, intra_ctx, regime_state=regime_state
+                )
+                if not setup_state.get("ok"):
+                    logger.info(
+                        "[SETUP-BAD] %s | missing=%s reasons=%s | daily=%s intra=%s regime=%s",
+                        code,
+                        setup_state.get("missing_conditions"),
+                        setup_state.get("reasons"),
+                        daily_ctx,
+                        intra_ctx,
+                        regime_state,
+                    )
                     continue
+                logger.info(
+                    "[SETUP-OK] %s | daily=%s intra=%s regime=%s",
+                    code,
+                    daily_ctx,
+                    intra_ctx,
+                    regime_state,
+                )
 
-                if not is_good_entry(
-                    code=code, daily_ctx=daily_ctx, intraday_ctx=intra_ctx
-                ):
+                trigger_label = "breakout_cross"
+                strategy_name = str(strategy or "").lower()
+                if "pullback" in strategy_name:
+                    trigger_label = "pullback_rebound"
+                elif "close" in strategy_name:
+                    trigger_label = "close_betting"
+
+                trigger_state = signals.evaluate_trigger_gate(
+                    daily_ctx,
+                    intra_ctx,
+                    prev_price=prev_price,
+                    target_price=target_price,
+                    trigger_name=trigger_label,
+                )
+                if not trigger_state.get("ok"):
                     logger.info(
-                        f"[ENTRY-SKIP] {code}: GOOD ÌÉÄÏ†ê ÎØ∏Ï∂©Ï°± ‚Üí Îã§Ïùå Î£®ÌîÑÏóêÏÑú Ïû¨ÌôïÏù∏"
+                        "[TRIGGER-NO] %s | trigger=%s current=%s tgt_px=%s gap_pct=%s missing=%s signals=%s",
+                        code,
+                        trigger_state.get("trigger_name"),
+                        trigger_state.get("current_price"),
+                        trigger_state.get("target_price"),
+                        trigger_state.get("gap_pct"),
+                        trigger_state.get("missing_conditions"),
+                        trigger_state.get("trigger_signals"),
                     )
                     continue
-
-                logger.info(f"[ENTRY-GOOD] {code}: GOOD ÌÉÄÏ†ê ÌôïÏù∏ ‚Üí Îß§Ïàò ÏãúÎèÑ")
+                logger.info(
+                    "[TRIGGER-OK] %s | trigger=%s current=%s tgt_px=%s gap_pct=%s signals=%s rr=%.2f",
+                    code,
+                    trigger_state.get("trigger_name"),
+                    trigger_state.get("current_price"),
+                    trigger_state.get("target_price"),
+                    trigger_state.get("gap_pct"),
+                    trigger_state.get("trigger_signals"),
+                    trigger_state.get("risk_reward") or 0.0,
+                )
 
                 # === VWAP Í∞ÄÎìú(Ïä¨Î¶¨ÌîºÏßÄ Î∞©Ïñ¥) ===
                 try:
                     guard_passed = vwap_guard(kis, code, SLIPPAGE_ENTER_GUARD_PCT)
                 except Exception as e:
                     logger.warning(f"[VWAP_GUARD_FAIL] {code}: VWAP Í∞ÄÎìú Ïò§Î•ò ‚Üí ÏßÑÏûÖ Î≥¥Î•ò ({e})")
                     continue
 
                 if not guard_passed:
                     logger.info(f"[VWAP_GUARD] {code}: Ïä¨Î¶¨ÌîºÏßÄ ÏúÑÌóò ‚Üí Îß§Ïàò Ïä§ÌÇµ")
                     continue
 
                 qty = target_qty
                 if mode == "neutral":
                     scaled_qty = max(1, int(qty * NEUTRAL_ENTRY_SCALE))
                     if scaled_qty < qty:
                         logger.info(
                             f"[ENTRY-SIZE] {code}: neutral Î†àÏßê Í∞êÏ∂ï {qty}‚Üí{scaled_qty} (Ïä§ÏºÄÏùº={NEUTRAL_ENTRY_SCALE})"
                         )
                     qty = scaled_qty
                 trade_ctx = {
                     "datetime": now_str,
                     "code": code,
                     "name": info.get("name"),
                     "qty": int(qty),
@@ -887,62 +984,65 @@ def main(capital_override: float | None = None):
                     "strategy": strategy,
                     "side": "BUY",
                 }
 
                 limit_px, mo_px = compute_entry_target(kis, info)
                 if limit_px is None and mo_px is None:
                     logger.warning(f"[TARGET-PRICE] {code}: limit/mo Í∞ÄÍ≤© ÏÇ∞Ï∂ú Ïã§Ìå® ‚Üí Ïä§ÌÇµ")
                     continue
 
                 if limit_px and abs(limit_px - current_price) / current_price * 100 > SLIPPAGE_LIMIT_PCT:
                     logger.info(
                         f"[SLIPPAGE_LIMIT] {code}: Ìò∏Í∞Ä‰πñÈõ¢ {abs(limit_px - current_price) / current_price * 100:.2f}% ‚Üí Ïä§ÌÇµ"
                     )
                     continue
 
                 logger.info(
                     f"[BUY-TRY] {code}: qty={qty} limit={limit_px} mo={mo_px} target={target_price} k={k_value}"
                 )
 
                 prev_qty = int((holding.get(code) or {}).get("qty", 0))
                 result = place_buy_with_fallback(kis, code, qty, limit_px or _round_to_tick(current_price))
                 if not _is_order_success(result):
                     logger.warning(f"[BUY-FAIL] {code}: result={result}")
                     continue
 
+                triggered_today.add(code)
+
                 exec_price = _extract_fill_price(result, current_price)
                 _record_trade(
                     traded,
                     code,
                     {
                         "buy_time": now_str,
                         "qty": int(qty),
                         "price": float(exec_price),
                         "status": "pending",
                         "pending_since": now_str,
                     },
                 )
+                traded_today.add(code)
                 save_state(holding, traded)
                 if not _is_balance_reflected(code, prev_qty=prev_qty):
                     logger.warning(
                         f"[BUY-PENDING] {code}: ÏûîÍ≥†Ïóê Î∞òÏòÅÎêòÏßÄ ÏïäÏïÑ ÏÉÅÌÉú Í∏∞Î°ù Î≥¥Î•ò(result={result})"
                     )
                     continue
                 traded[code]["status"] = "filled"
                 _record_trade(
                     traded,
                     code,
                     {
                         "buy_time": now_str,
                         "qty": int(qty),
                         "price": float(exec_price),
                         "status": "filled",
                         "pending_since": None,
                     },
                 )
 
                 _init_position_state(
                     kis,
                     holding,
                     code,
                     float(exec_price),
                     int(qty),
@@ -1039,62 +1139,64 @@ def main(capital_override: float | None = None):
                             continue
 
                         current_price = _safe_get_price(kis, code)
                         if not current_price:
                             logger.warning(f"[PULLBACK-PRICE] {code}: ÌòÑÏû¨Í∞Ä Ï°∞Ìöå Ïã§Ìå®")
                             continue
 
                         if trigger_price and current_price < trigger_price * 0.98:
                             logger.info(
                                 f"[PULLBACK-DELAY] {code}: Í∞ÄÍ≤©Ïù¥ Ìä∏Î¶¨Í±∞ ÎåÄÎπÑ 2% Ïù¥ÏÉÅ ÌïòÎùΩ ‚Üí ÎåÄÍ∏∞ (cur={current_price}, trigger={trigger_price})"
                             )
                             continue
 
                         prev_qty = int((holding.get(code) or {}).get("qty", 0))
                         result = place_buy_with_fallback(
                             kis,
                             code,
                             int(qty),
                             _round_to_tick(trigger_price or current_price),
                         )
 
                         if not _is_order_success(result):
                             logger.warning(f"[PULLBACK-BUY-FAIL] {code}: result={result}")
                             continue
 
+                        triggered_today.add(code)
                         exec_price = _extract_fill_price(result, trigger_price or current_price)
                         _record_trade(
                             traded,
                             code,
                             {
                                 "buy_time": now_str,
                                 "qty": int(qty),
                                 "price": float(exec_price),
                                 "status": "pending",
                                 "pending_since": now_str,
                             },
                         )
+                        traded_today.add(code)
                         save_state(holding, traded)
                         if not _is_balance_reflected(code, prev_qty=prev_qty):
                             logger.warning(
                                 f"[PULLBACK-PENDING] {code}: ÏûîÍ≥†Ïóê Î∞òÏòÅÎêòÏßÄ ÏïäÏïÑ ÏÉÅÌÉú Í∏∞Î°ù Î≥¥Î•ò(result={result})"
                             )
                             continue
 
                         traded[code]["status"] = "filled"
                         holding[code] = {
                             "qty": int(qty),
                             "buy_price": float(exec_price),
                             "bear_s1_done": False,
                             "bear_s2_done": False,
                         }
                         _record_trade(
                             traded,
                             code,
                             {
                                 "buy_time": now_str,
                                 "qty": int(qty),
                                 "price": float(exec_price),
                                 "status": "filled",
                                 "pending_since": None,
                             },
                         )
diff --git a/trader/signals.py b/trader/signals.py
index fa50eac90b4e38a45a4367493b21fa7d29189a5d..b42a5bb1e4ac7fae00de25e0f14d67e1153000c6 100644
--- a/trader/signals.py
+++ b/trader/signals.py
@@ -30,50 +30,52 @@ from .core_constants import (
     PULLBACK_LOOKBACK,
     PULLBACK_REVERSAL_BUFFER_PCT,
     SLIPPAGE_ENTER_GUARD_PCT,
     USE_PULLBACK_ENTRY,
     VWAP_TOL,
     logger,
     DAILY_CAPITAL,
     W_MIN_ONE,
     W_MAX_ONE,
 )
 from .core_utils import _get_daily_candles_cached, _to_float, _to_int, _with_retry
 from .kis_wrapper import KisAPI, NetTemporaryError, DataEmptyError, DataShortError
 from .metrics import vwap_guard
 
 __all__ = [
     "_safe_get_price",
     "_fetch_balances",
     "_get_effective_ord_cash",
     "_get_daily_candles_cached",
     "_detect_pullback_reversal",
     "_classify_champion_grade",
     "_compute_daily_entry_context",
     "_compute_intraday_entry_context",
     "is_bad_entry",
     "is_good_entry",
+    "evaluate_setup_gate",
+    "evaluate_trigger_gate",
     "_get_intraday_1min",
     "_compute_vwap_from_1min",
     "_compute_intraday_momentum",
     "is_strong_momentum_vwap",
     "get_20d_return_pct",
     "is_strong_momentum",
     "_percentile_rank",
     "_has_bullish_trend_structure",
     "_weight_to_qty",
     "_notional_to_qty",
     "_get_atr",
 ]
 
 # === [ANCHOR: PRICE_CACHE] ÌòÑÏû¨Í∞Ä Ï∫êÏãú & ÏÑúÌÇ∑Î∏åÎ†àÏù¥Ïª§ ===
 _LAST_PRICE_CACHE: Dict[str, Dict[str, Any]] = {}  # code -> {"px": float, "ts": epoch}
 _PRICE_CB: Dict[str, Dict[str, float]] = {}          # code -> {"fail": int, "until": epoch}
 
 # === [ANCHOR: BALANCE_CACHE] ÏûîÍ≥† Ï∫êÏã± (Î£®ÌîÑ 15Ï¥à Îã®Ïùº Ìò∏Ï∂ú) ===
 _BALANCE_CACHE: Dict[str, Any] = {"ts": 0.0, "balances": []}
 
 def _safe_get_price(
     kis: KisAPI,
     code: str,
     ttl_sec: int = 5,
     stale_ok_sec: int = 30,
@@ -358,50 +360,55 @@ def _detect_pullback_reversal(
     peak_price = max(highs)
     try:
         peak_idx = max(
             i for i, c in enumerate(window) if float(c.get("high") or 0.0) == peak_price
         )
     except Exception:
         return {"setup": False, "reason": "peak_index_error"}
 
     # ÏßÅÏ†Ñ ÏùºÏûêÍπåÏßÄ Ïó∞ÏÜç ÌïòÎùΩ Íµ¨Í∞Ñ Í∏∏Ïù¥Î•º Í≥ÑÏÇ∞(Ïñ¥Ï†úÍπåÏßÄ nÏùº Ïó∞ÏÜç ÌïòÎùΩÏù∏ÏßÄ)
     down_streak_len = 0
     last_idx = len(window) - 1
     while last_idx > peak_idx:
         try:
             cur_close = float(window[last_idx].get("close") or 0.0)
             prev_close = float(window[last_idx - 1].get("close") or 0.0)
         except Exception:
             break
         if cur_close <= 0 or prev_close <= 0:
             break
         if cur_close < prev_close:
             down_streak_len += 1
             last_idx -= 1
             continue
         break
 
+    recent_closes = [float(c.get("close") or 0.0) for c in window[max(0, len(window) - (pullback_days + 4)) :]]
+    logger.debug(
+        f"[PULLBACK-STREAK] {code} closes={recent_closes} streak={down_streak_len} peak_idx={peak_idx}"
+    )
+
     # [RELAX] 2Ïùº Ïó∞ÏÜç ÌïòÎùΩÏù¥Î©¥ ÏôÑÌôî ÏßÑÏûÖ ÌóàÏö©, ÎòêÎäî VWAP ÌöåÎ≥µ Ïãú ÏòàÏô∏ ÌóàÏö©
     vwap_reclaim = False
     if current_price:
         try:
             intra = _compute_intraday_entry_context(kis, code, slow=MOM_SLOW)
             vwap_val = intra.get("vwap")
             last_close = intra.get("last_close") or current_price
             if vwap_val and last_close:
                 vwap_reclaim = float(last_close) >= float(vwap_val) * (1 - VWAP_TOL)
         except Exception:
             vwap_reclaim = False
 
     relaxed_streak_ok = down_streak_len >= pullback_days or down_streak_len >= 2
     if not relaxed_streak_ok and not vwap_reclaim:
         return {
             "setup": False,
             "peak_price": peak_price,
             "reason": "not_enough_consecutive_down",
         }
 
     if last_idx < peak_idx:
         return {
             "setup": False,
             "peak_price": peak_price,
             "reason": "down_streak_not_after_peak",
@@ -634,166 +641,293 @@ def _compute_intraday_entry_context(
     if highs:
         box_high = max(highs[-20:])
         box_low = min(lows[-20:]) if lows else None
         if last_high is not None and box_high:
             ctx["range_break"] = last_high >= box_high * 0.999
         if last_low is not None and box_low:
             ctx["box_floor"] = box_low
 
     if vols and len(vols) >= 10:
         recent_vol = sum(vols[-5:]) / 5.0
         base_vol = sum(vols[:-5]) / max(1, len(vols) - 5)
         if base_vol > 0:
             ctx["volume_spike"] = recent_vol >= base_vol * 1.5
 
     if vwap_val:
         below = sum(
             1 for c in candles if _to_float(c.get("close"), 0.0) < vwap_val
         )
         ctx["below_vwap_ratio"] = below / len(candles)
 
     if prev_high and last_high:
         ctx["prev_high_retest"] = last_high >= float(prev_high) * 0.999
 
     return ctx
 
-def is_bad_entry(
-    code: str,
+def _collect_bad_entry_reasons(
     daily_ctx: Dict[str, Any],
     intraday_ctx: Dict[str, Any],
     regime_state: Optional[Dict[str, Any]] = None,
-) -> bool:
-    reasons = []
+) -> List[str]:
+    reasons: List[str] = []
     strong_trend = bool(daily_ctx.get("strong_trend"))
 
     # 1) MA20 Í±∞Î¶¨
     mr = daily_ctx.get("ma20_ratio")
     if mr is not None:
         try:
             mr_val = float(mr)
             if abs(mr_val) > BAD_ENTRY_MAX_MA20_DIST:
                 reasons.append(f"MA20DIST {mr_val:.3f}")
-        except:
+        except Exception:
             reasons.append("MA20DIST invalid")
 
     # 2) Pullback depth
     pb = daily_ctx.get("pullback_depth_pct")
     if pb is not None:
         try:
             pb_val = float(pb)
             max_pb = float(daily_ctx.get("max_pullback_pct") or BAD_ENTRY_MAX_PULLBACK)
             if pb_val > max_pb:
                 reasons.append(f"PULLBACK {pb_val:.2f}")
-        except:
+        except Exception:
             reasons.append("PULLBACK invalid")
 
     # 3) Regime drop
     if regime_state:
         drop = _to_float(regime_state.get("pct_change"), None)
         mode = regime_state.get("mode")
         if drop is not None and drop <= -2.5 and not (strong_trend and mode == "neutral"):
             reasons.append(f"REGIME_DROP {drop:.2f}")
 
     # 4) VWAP ratio
     bvr = intraday_ctx.get("below_vwap_ratio")
     if bvr is not None:
         try:
             bvr_val = float(bvr)
             if bvr_val >= BAD_ENTRY_MAX_BELOW_VWAP_RATIO:
                 reasons.append(f"VWAP_RATIO {bvr_val:.2f}")
-        except:
+        except Exception:
             reasons.append("VWAP_RATIO invalid")
 
+    return reasons
+
+
+def is_bad_entry(
+    code: str,
+    daily_ctx: Dict[str, Any],
+    intraday_ctx: Dict[str, Any],
+    regime_state: Optional[Dict[str, Any]] = None,
+) -> bool:
+    reasons = _collect_bad_entry_reasons(daily_ctx, intraday_ctx, regime_state)
+
     if reasons:
         logger.info(
             "[ENTRY-BAD] %s | Ïù¥Ïú†: %s | daily=%s intra=%s regime=%s",
             code,
             " / ".join(reasons),
             daily_ctx,
             intraday_ctx,
             regime_state,
         )
         return True
 
     logger.info(
         "[ENTRY-OK] %s | daily=%s intra=%s regime=%s",
         code,
         daily_ctx,
         intraday_ctx,
         regime_state,
     )
     return False
 
 
-def is_good_entry(
-    code: str,
+def evaluate_setup_gate(
     daily_ctx: Dict[str, Any],
     intraday_ctx: Dict[str, Any],
-    prev_high: Optional[float] = None,
-) -> bool:
+    regime_state: Optional[Dict[str, Any]] = None,
+) -> Dict[str, Any]:
+    missing_conditions: List[str] = []
+    reasons = _collect_bad_entry_reasons(daily_ctx, intraday_ctx, regime_state)
+
     if not daily_ctx.get("setup_ok"):
-        return False
+        missing_conditions.append("setup_flag")
 
-    pullback = daily_ctx.get("pullback_depth_pct")
-    strong_trend = bool(daily_ctx.get("strong_trend"))
-    max_pb = float(daily_ctx.get("max_pullback_pct") or GOOD_ENTRY_PULLBACK_RANGE[1])
-    if not strong_trend:
-        max_pb = min(max_pb, GOOD_ENTRY_PULLBACK_RANGE[1])
-    if pullback is None or not (
-        GOOD_ENTRY_PULLBACK_RANGE[0] <= pullback <= max_pb
-    ):
-        return False
+    ok = not missing_conditions and not reasons
+    return {
+        "ok": ok,
+        "missing_conditions": missing_conditions,
+        "reasons": reasons,
+    }
 
-    ma20_ratio = daily_ctx.get("ma20_ratio")
-    if ma20_ratio is None or not (
-        GOOD_ENTRY_MA20_RANGE[0] <= ma20_ratio <= GOOD_ENTRY_MA20_RANGE[1]
-    ):
-        return False
 
-    dist_peak = daily_ctx.get("distance_to_peak")
-    if dist_peak is None or dist_peak > GOOD_ENTRY_MAX_FROM_PEAK:
-        return False
+def evaluate_trigger_gate(
+    daily_ctx: Dict[str, Any],
+    intraday_ctx: Dict[str, Any],
+    *,
+    prev_high: Optional[float] = None,
+    prev_price: Optional[float] = None,
+    target_price: Optional[float] = None,
+    trigger_name: str = "breakout_cross",
+) -> Dict[str, Any]:
+    missing_conditions: List[str] = []
+    signals: List[str] = []
 
-    cur_px = daily_ctx.get("current_price")
-    atr = daily_ctx.get("atr") or 0.0
-    ma_risk = daily_ctx.get("ma20_risk") or 0.0
+    cur_px = _to_float(daily_ctx.get("current_price"), None)
+    atr = _to_float(daily_ctx.get("atr"), 0.0)
+    ma_risk = _to_float(daily_ctx.get("ma20_risk"), 0.0)
     risk = max(atr, ma_risk, (cur_px or 0) * 0.03)
     reward = max(0.0, (daily_ctx.get("peak_price") or 0) - (cur_px or 0)) + atr
-    if risk <= 0 or reward / risk < GOOD_ENTRY_MIN_RR:
-        return False
+    risk_reward = reward / risk if risk else None
 
-    signals = []
     if intraday_ctx.get("vwap_reclaim"):
         signals.append("vwap")
     if intraday_ctx.get("range_break"):
         signals.append("range")
     if intraday_ctx.get("volume_spike"):
         signals.append("volume")
     if prev_high and intraday_ctx.get("prev_high_retest"):
         signals.append("prev_high")
+    gap_pct = None
+    require_cross = (trigger_name == "breakout_cross") and target_price is not None
+    if cur_px and target_price:
+        try:
+            gap_pct = (float(cur_px) - float(target_price)) / float(target_price) * 100.0
+        except Exception:
+            gap_pct = None
+
+    crossed = False
+    prev_ref = prev_price
+    if prev_ref is None:
+        prev_ref = _to_float(daily_ctx.get("prev_close"), None)
+        if prev_ref is None and require_cross:
+            missing_conditions.append("no_prev_price")
+    if require_cross and target_price and cur_px is not None:
+        try:
+            if prev_ref is not None:
+                crossed = (
+                    float(prev_ref) < float(target_price)
+                    and float(cur_px) >= float(target_price)
+                )
+            else:
+                crossed = False
+        except Exception:
+            crossed = False
+        if not crossed:
+            missing_conditions.append("no_cross")
+
+    ok = False
+    if trigger_name == "pullback_rebound":
+        if not daily_ctx.get("setup_ok"):
+            missing_conditions.append("setup_flag")
+
+        pullback = _to_float(daily_ctx.get("pullback_depth_pct"), None)
+        if pullback is None:
+            missing_conditions.append("pullback_depth")
+        elif not (
+            GOOD_ENTRY_PULLBACK_RANGE[0] <= pullback <= GOOD_ENTRY_PULLBACK_RANGE[1]
+        ):
+            missing_conditions.append("pullback_range")
+
+        reversal_signals = [
+            name
+            for name in ("vwap", "range", "volume", "prev_high")
+            if name in signals
+        ]
+        if not reversal_signals:
+            missing_conditions.append("reversal_signal")
+
+        ok = not missing_conditions and bool(reversal_signals)
+
+    elif trigger_name == "close_betting":
+        if not daily_ctx.get("strong_trend") and not intraday_ctx.get("vwap_reclaim"):
+            missing_conditions.append("trend_confirm")
+
+        if not signals:
+            missing_conditions.append("intraday_signal")
+
+        ok = not missing_conditions
+
+    else:
+        pullback = daily_ctx.get("pullback_depth_pct")
+        strong_trend = bool(daily_ctx.get("strong_trend"))
+        max_pb = float(daily_ctx.get("max_pullback_pct") or GOOD_ENTRY_PULLBACK_RANGE[1])
+        if not strong_trend:
+            max_pb = min(max_pb, GOOD_ENTRY_PULLBACK_RANGE[1])
+        if pullback is None or not (
+            GOOD_ENTRY_PULLBACK_RANGE[0] <= pullback <= max_pb
+        ):
+            missing_conditions.append("pullback_depth")
+
+        ma20_ratio = daily_ctx.get("ma20_ratio")
+        if ma20_ratio is None or not (
+            GOOD_ENTRY_MA20_RANGE[0] <= ma20_ratio <= GOOD_ENTRY_MA20_RANGE[1]
+        ):
+            missing_conditions.append("ma20_ratio")
+
+        dist_peak = daily_ctx.get("distance_to_peak")
+        if dist_peak is None or dist_peak > GOOD_ENTRY_MAX_FROM_PEAK:
+            missing_conditions.append("distance_to_peak")
+
+        if risk_reward is None or risk_reward < GOOD_ENTRY_MIN_RR:
+            missing_conditions.append("risk_reward")
 
-    return len(signals) >= GOOD_ENTRY_MIN_INTRADAY_SIG
+        if len(signals) < GOOD_ENTRY_MIN_INTRADAY_SIG:
+            missing_conditions.append("intraday_signals")
+
+        ok = not missing_conditions and len(signals) >= GOOD_ENTRY_MIN_INTRADAY_SIG
+
+    if require_cross and target_price is not None:
+        ok = ok and crossed
+
+    return {
+        "ok": ok,
+        "missing_conditions": missing_conditions,
+        "trigger_signals": signals,
+        "trigger_name": trigger_name,
+        "current_price": cur_px,
+        "target_price": target_price,
+        "gap_pct": gap_pct,
+        "risk_reward": risk_reward,
+    }
+
+
+def is_good_entry(
+    code: str,
+    daily_ctx: Dict[str, Any],
+    intraday_ctx: Dict[str, Any],
+    prev_high: Optional[float] = None,
+) -> bool:
+    result = evaluate_trigger_gate(
+        daily_ctx,
+        intraday_ctx,
+        prev_high=prev_high,
+        prev_price=None,
+        target_price=None,
+        trigger_name="breakout_cross",
+    )
+    return bool(result.get("ok"))
 
 # === [ANCHOR: INTRADAY_MOMENTUM] 1Î∂ÑÎ¥â VWAP + Îã®Í∏∞ Î™®Î©òÌÖÄ ===
 def _get_intraday_1min(kis: KisAPI, code: str, count: int = 60) -> List[Dict[str, Any]]:
     """
     KisAPIÏóê 1Î∂ÑÎ¥â Î©îÏÑúÎìúÍ∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©ÌïòÍ≥†, ÏóÜÏúºÎ©¥ Ìò∏Ìôò Î©îÏÑúÎìúÎ°ú fallback.
     Î∞òÌôòÏùÄ ÏµúÏÜåÌïú 'close'ÏôÄ 'volume' Ï†ïÎ≥¥Î•º Í∞ÄÏßÑ dict Î¶¨Ïä§Ìä∏ÎùºÍ≥† Í∞ÄÏ†ïÌïúÎã§.
     """
     try:
         if hasattr(kis, "get_intraday_1min"):
             return kis.get_intraday_1min(code, count=count)
         if hasattr(kis, "get_minute_candles"):
             return kis.get_minute_candles(code, unit=1, count=count)
         if hasattr(kis, "get_intraday_candles"):
             return kis.get_intraday_candles(code, unit="1", count=count)
     except Exception as e:
         logger.warning(f"[INTRADAY_1M_FAIL] {code}: {e}")
     return []
 
 def _compute_vwap_from_1min(candles: List[Dict[str, Any]]) -> Optional[float]:
     if not candles:
         return None
     pv = 0.0
     vol_sum = 0.0
     for c in candles:
         try:
