diff --git a/README.md b/README.md
index 75ed3cfa39c4eb7ee50b67c4e9e36c45370091c0..d58aac991ce259d1183b79051b9769c3d5e8a9cf 100644
--- a/README.md
+++ b/README.md
@@ -11,35 +11,43 @@ portfolio/
   portfolio_manager.py
 strategy/
   kospi/{universe.py, rebalance.py, signals.py}
   kosdaq/{universe.py, rolling_entry.py, pullback.py}
 trader/
   trader.py (entrypoint)
   state_manager.py
   legacy_kosdaq_runner.py (previous KOSDAQ loop kept intact)
 ```
 
 ## Engine responsibilities
 - **KOSPI core engine**: KOSPI market-cap Top-N universe, equal-weight targets, periodic rebalance with market orders and KIS quotes.
 - **KOSDAQ alpha engine**: delegates to the legacy rolling-K/VWAP/pullback loop unchanged, using its original state file for backward compatibility.
 - **Capital split**: `PortfolioManager` divides `DAILY_CAPITAL` (or supplied total) into KOSPI and KOSDAQ ratios (default 60/40) and runs each engine independently.
 - **Performance**: portfolio-level PnL snapshots combine KIS cash/positions with engine allocation ratios for unified reporting without coupling the two engines.
   - Engine-level PnL is an attribution estimate based on capital split ratios because positions are pooled at the account level.
 
 ## How to run
 ```
 python -m trader.trader
 ```
 This initializes the portfolio manager, runs KOSPI rebalance if due, then executes the existing KOSDAQ intraday loop without interrupting either engine on errors. The KOSDAQ loop is blocking, so the entrypoint runs a single orchestrated cycle via `run_once()` rather than a repeating scheduler.
 
 Workflow는 bot-state 브랜치에 bot_state/state.json을 커밋하여 런 간 상태를 유지합니다.
 
+## Diagnostic mode (no-order safety)
+Run a diagnostics-only pass (no KIS orders) even on non-trading days:
+```
+DIAGNOSTIC_MODE=true DIAGNOSTIC_ONLY=true python -m trader.trader
+```
+Expected log markers for grep:
+- `[DIAG][START]`, `[DIAG][RECONCILE]`, `[DIAG][DATA-HEALTH]`, `[DIAG][SETUP]`, `[DIAG][EXIT-PROBE]`, `[DIAG][END]`
+
 ## Strategy intent mode (single-account multi-strategy)
 - A new `StrategyManager` runs before engine loops and emits **order intents only** into `trader/state/strategy_intents.jsonl` with a cursor in `trader/state/strategy_intents_state.json`.
 - All five strategies (`breakout`~`volatility`) are present but **disabled by default**: `ENABLED_STRATEGIES=""` means no strategies run, and missing weights are treated as zero even when listed.
 - Enable a subset for testing, e.g. `ENABLED_STRATEGIES="momentum"` with optional weights `STRATEGY_WEIGHTS="momentum=0.10"`. Keep `STRATEGY_MODE=INTENT_ONLY` and `STRATEGY_DRY_RUN=true` (defaults) to avoid any KIS orders.
 - PortfolioManager order: strategies → KOSPI → KOSDAQ. During isolated testing use `DISABLE_KOSPI_ENGINE=true` or `DISABLE_KOSDAQ_LOOP=true` to skip respective engines.
 - State sync scripts in `scripts/state_pull_plain.sh` and `scripts/state_push_plain.sh` now copy the intent log/cursor alongside `trader/state/state.json` into the `bot-state` branch.
 
 ## CI and live-trading safeguards
 - CI (pull_request) runs set `DISABLE_LIVE_TRADING=true` so all KIS API calls are blocked and only static checks execute.
 - The live trading workflow is restricted to the `main` branch and triggers only via schedule or manual dispatch with the branch guard enabled.
diff --git a/portfolio/portfolio_manager.py b/portfolio/portfolio_manager.py
index 03c0d9eeaa9a1c2ae913f87fcfc760832ab61d1e..9193efeacf05c9c8dbd5f8b581282ebcef0a2a95 100644
--- a/portfolio/portfolio_manager.py
+++ b/portfolio/portfolio_manager.py
@@ -1,120 +1,176 @@
 from __future__ import annotations
 
 import logging
+import os
 from typing import Any, Dict
 
 from rolling_k_auto_trade_api.best_k_meta_strategy import run_rebalance
 from strategy.manager import StrategyManager
 from strategy.market_data import build_market_data
 import trader.intent_store as intent_store
 from trader.config import (
     DAILY_CAPITAL,
+    DIAGNOSTIC_MAX_SYMBOLS,
+    DIAGNOSTIC_MODE,
+    DIAGNOSTIC_ONLY,
     DISABLE_KOSDAQ_LOOP,
     DISABLE_KOSPI_ENGINE,
     STRATEGY_INTENTS_PATH,
 )
+from trader.diagnostics import run_diagnostics
 from trader.intent_executor import IntentExecutor
+from trader.kis_wrapper import KisAPI
 import trader.state_store as state_store
 from trader.core_utils import get_rebalance_anchor_date
 from trader.subject_flow import reset_flow_call_count
 from .kospi_core_engine import KospiCoreEngine
 from .kosdaq_alpha_engine import KosdaqAlphaEngine
 from .performance import PerformanceTracker
 
 logger = logging.getLogger(__name__)
 
 
 class PortfolioManager:
     def __init__(
         self,
         total_capital: float | None = None,
         kospi_ratio: float = 0.6,
         kosdaq_ratio: float = 0.4,
     ) -> None:
         self.total_capital = float(total_capital or DAILY_CAPITAL)
         if kospi_ratio + kosdaq_ratio == 0:
             kospi_ratio, kosdaq_ratio = 0.6, 0.4
         norm = kospi_ratio + kosdaq_ratio
         self.kospi_ratio = kospi_ratio / norm
         self.kosdaq_ratio = kosdaq_ratio / norm
         self.kospi_engine = KospiCoreEngine(capital=self.total_capital * self.kospi_ratio)
         self.kosdaq_engine = KosdaqAlphaEngine(capital=self.total_capital * self.kosdaq_ratio)
         self.performance = PerformanceTracker()
         self.strategy_manager = StrategyManager(total_capital=self.total_capital)
         self.intent_executor = IntentExecutor()
         logger.info(
             "[PORTFOLIO] capital=%s kospi=%.0f%% kosdaq=%.0f%%",
             int(self.total_capital),
             self.kospi_ratio * 100,
             self.kosdaq_ratio * 100,
         )
 
     def run_once(self) -> Dict[str, Any]:
         reset_flow_call_count()
         selected_by_market: Dict[str, Any] = {}
+        diag_result: Dict[str, Any] | None = None
+        holdings: list[dict[str, Any]] = []
+        kis_client: KisAPI | None = None
         try:
             rebalance_date = str(get_rebalance_anchor_date())
             rebalance_payload = run_rebalance(rebalance_date, return_by_market=True)
             selected_by_market = rebalance_payload.get("selected_by_market") or {}
             logger.info(
                 "[PORTFOLIO][REBALANCE] date=%s kospi=%d kosdaq=%d",
                 rebalance_date,
                 len(selected_by_market.get("KOSPI", [])),
                 len(selected_by_market.get("KOSDAQ", [])),
             )
         except Exception as e:
             logger.exception("[PORTFOLIO] rebalance fetch failed: %s", e)
 
         runtime_state = state_store.load_state()
+        try:
+            kis_client = KisAPI()
+            holdings = kis_client.get_positions()
+        except Exception as e:
+            logger.exception("[PORTFOLIO] failed to init KIS client for diagnostics: %s", e)
+            kis_client = None
+            holdings = []
+
+        symbols: list[str] = []
+        for rows in (selected_by_market or {}).values():
+            for row in rows or []:
+                code = str(row.get("code") or row.get("stock_code") or "").strip().lstrip("A").zfill(6)
+                if code and code != "000000":
+                    symbols.append(code)
+        for row in holdings or []:
+            code = str(row.get("pdno") or row.get("code") or "").strip().lstrip("A").zfill(6)
+            if code and code != "000000":
+                symbols.append(code)
+        if symbols:
+            symbols = sorted({c for c in symbols if c})[:DIAGNOSTIC_MAX_SYMBOLS]
+
+        logger.info(
+            "[DIAG][PM] diagnostic_mode=%s diagnostic_only=%s",
+            DIAGNOSTIC_MODE,
+            DIAGNOSTIC_ONLY,
+        )
+        if DIAGNOSTIC_MODE:
+            os.environ["DISABLE_LIVE_TRADING"] = "true"
+            logger.info("[DIAG][PM] forcing DISABLE_LIVE_TRADING=true")
+            diag_result = run_diagnostics(
+                selected_by_market=selected_by_market,
+                kis_client=kis_client,
+                pos_state=runtime_state,
+                symbols=symbols,
+            )
+            try:
+                state_store.save_state(runtime_state)
+            except Exception as e:
+                logger.exception("[DIAG][PM] failed to save diagnostic state: %s", e)
+            if DIAGNOSTIC_ONLY:
+                return {
+                    "diagnostics": diag_result,
+                    "kospi": {"status": "skipped"},
+                    "kosdaq": {"status": "skipped"},
+                }
+
         try:
             market_data = build_market_data(selected_by_market)
             strategy_result = self.strategy_manager.run_once(
                 market_data=market_data, portfolio_state=runtime_state
             )
             intents = strategy_result.get("intents") or []
         except Exception as e:
             logger.exception("[PORTFOLIO] strategy manager failure: %s", e)
             strategy_result = {"status": "error", "message": str(e), "enabled": [], "intents": []}
             intents = []
 
         try:
             STRATEGY_INTENTS_PATH.parent.mkdir(parents=True, exist_ok=True)
             STRATEGY_INTENTS_PATH.touch(exist_ok=True)
             intent_store.append_intents(intents, STRATEGY_INTENTS_PATH)
             executor_result = self.intent_executor.run_once()
         except Exception as e:
             logger.exception("[PORTFOLIO] intent executor failure: %s", e)
             executor_result = {"status": "error", "message": str(e)}
 
         try:
             if DISABLE_KOSPI_ENGINE:
                 kospi = {"status": "disabled"}
             else:
                 kospi = self.kospi_engine.rebalance_if_needed(
                     selected_stocks=selected_by_market.get("KOSPI")
                 )
         except Exception as e:
             logger.exception("[PORTFOLIO] KOSPI engine failure: %s", e)
             kospi = {"status": "error", "message": str(e)}
         try:
             if DISABLE_KOSDAQ_LOOP:
                 kosdaq = {"status": "disabled"}
             else:
                 kosdaq = self.kosdaq_engine.trade_loop(
                     selected_stocks=selected_by_market.get("KOSDAQ")
                 )
         except Exception as e:
             logger.exception("[PORTFOLIO] KOSDAQ engine failure: %s", e)
             kosdaq = {"status": "error", "message": str(e)}
         perf = self.performance.snapshot(
             {
                 "kospi_core": self.kospi_engine.capital,
                 "kosdaq_alpha": self.kosdaq_engine.capital,
             }
         )
         return {
             "strategies": {"manager": strategy_result, "executor": executor_result},
+            "diagnostics": diag_result,
             "kospi": kospi,
             "kosdaq": kosdaq,
             "performance": perf,
         }
diff --git a/scripts/state_pull_plain.sh b/scripts/state_pull_plain.sh
index ae32087f0a19bc74c401cf0f02c2425936a2eaf8..cd5da7fcbfe40c5595da5c5d7b325379ea81fbf6 100755
--- a/scripts/state_pull_plain.sh
+++ b/scripts/state_pull_plain.sh
@@ -1,58 +1,71 @@
 #!/usr/bin/env bash
 set -euo pipefail
 
 STATE_DIR="bot_state"
 JSON_PATH="${STATE_DIR}/state.json"
 REMOTE_PATH="${STATE_DIR}/state.json"
 DEFAULT_STATE='{"version": 1, "lots": [], "updated_at": null}'
 POS_STATE_DIR="trader/state"
 POS_JSON_PATH="${POS_STATE_DIR}/state.json"
 POS_REMOTE_PATH="${POS_STATE_DIR}/state.json"
-DEFAULT_POS_STATE='{"schema_version": 2, "updated_at": null, "positions": {}, "memory": {"last_price": {}, "last_seen": {}}}'
+DEFAULT_POS_STATE='{"schema_version": 2, "updated_at": null, "positions": {}, "memory": {"last_price": {}, "last_seen": {}, "last_strategy_id": {}}}'
 INTENT_LOG_PATH="${POS_STATE_DIR}/strategy_intents.jsonl"
 INTENT_REMOTE_PATH="${INTENT_LOG_PATH}"
 DEFAULT_INTENT_LOG=""
 INTENT_CURSOR_PATH="${POS_STATE_DIR}/strategy_intents_state.json"
 INTENT_CURSOR_REMOTE_PATH="${INTENT_CURSOR_PATH}"
 DEFAULT_INTENT_CURSOR='{"offset": 0, "last_intent_id": null, "last_ts": null}'
+DIAG_DIR="${POS_STATE_DIR}/diagnostics"
+DIAG_KEEP=20
 
 mkdir -p "${STATE_DIR}"
 mkdir -p "${POS_STATE_DIR}"
+mkdir -p "${DIAG_DIR}"
 
 if git ls-remote --exit-code --heads origin bot-state >/dev/null 2>&1; then
   git fetch --no-tags origin bot-state:refs/remotes/origin/bot-state >/dev/null 2>&1 || true
   if git cat-file -e "origin/bot-state:${REMOTE_PATH}" 2>/dev/null; then
     git show "origin/bot-state:${REMOTE_PATH}" > "${JSON_PATH}"
     echo "[STATE] Pulled ${REMOTE_PATH} from bot-state branch."
   else
     echo "[STATE] WARN: state.json not found in bot-state branch. Initializing."
     echo "${DEFAULT_STATE}" > "${JSON_PATH}"
   fi
   if git cat-file -e "origin/bot-state:${POS_REMOTE_PATH}" 2>/dev/null; then
     git show "origin/bot-state:${POS_REMOTE_PATH}" > "${POS_JSON_PATH}"
     echo "[STATE] Pulled ${POS_REMOTE_PATH} from bot-state branch."
   else
     echo "[STATE] WARN: position state not found in bot-state branch. Initializing."
     echo "${DEFAULT_POS_STATE}" > "${POS_JSON_PATH}"
   fi
   if git cat-file -e "origin/bot-state:${INTENT_REMOTE_PATH}" 2>/dev/null; then
     git show "origin/bot-state:${INTENT_REMOTE_PATH}" > "${INTENT_LOG_PATH}"
     echo "[STATE] Pulled ${INTENT_REMOTE_PATH} from bot-state branch."
   else
     echo "[STATE] WARN: intent log not found in bot-state branch. Initializing."
     echo -n "${DEFAULT_INTENT_LOG}" > "${INTENT_LOG_PATH}"
   fi
   if git cat-file -e "origin/bot-state:${INTENT_CURSOR_REMOTE_PATH}" 2>/dev/null; then
     git show "origin/bot-state:${INTENT_CURSOR_REMOTE_PATH}" > "${INTENT_CURSOR_PATH}"
     echo "[STATE] Pulled ${INTENT_CURSOR_REMOTE_PATH} from bot-state branch."
   else
     echo "[STATE] WARN: intent cursor not found in bot-state branch. Initializing."
     echo "${DEFAULT_INTENT_CURSOR}" > "${INTENT_CURSOR_PATH}"
   fi
+  diag_files=$(git ls-tree -r --name-only origin/bot-state "${DIAG_DIR}" 2>/dev/null | sort | tail -n "${DIAG_KEEP}")
+  if [[ -n "${diag_files}" ]]; then
+    while IFS= read -r path; do
+      mkdir -p "$(dirname "${path}")"
+      git show "origin/bot-state:${path}" > "${path}"
+    done <<< "${diag_files}"
+    echo "[STATE] Pulled trader/state/diagnostics/* (limited) from bot-state branch."
+  else
+    echo "[STATE] WARN: diagnostics dumps not found in bot-state branch."
+  fi
 else
   echo "[STATE] WARN: bot-state branch not found. Initializing."
   echo "${DEFAULT_STATE}" > "${JSON_PATH}"
   echo "${DEFAULT_POS_STATE}" > "${POS_JSON_PATH}"
   echo -n "${DEFAULT_INTENT_LOG}" > "${INTENT_LOG_PATH}"
   echo "${DEFAULT_INTENT_CURSOR}" > "${INTENT_CURSOR_PATH}"
 fi
diff --git a/scripts/state_push_plain.sh b/scripts/state_push_plain.sh
index 16671cd677009b945214eb1a09d87218000d2190..909587100705180a84e4dca00019cc8ea4fd17a3 100755
--- a/scripts/state_push_plain.sh
+++ b/scripts/state_push_plain.sh
@@ -1,63 +1,85 @@
 #!/usr/bin/env bash
 set -euo pipefail
 
 STATE_DIR="bot_state"
 JSON_PATH="${STATE_DIR}/state.json"
 POS_STATE_DIR="trader/state"
 POS_JSON_PATH="${POS_STATE_DIR}/state.json"
 INTENT_LOG_PATH="${POS_STATE_DIR}/strategy_intents.jsonl"
 INTENT_CURSOR_PATH="${POS_STATE_DIR}/strategy_intents_state.json"
+DIAG_DIR="${POS_STATE_DIR}/diagnostics"
+DIAG_KEEP=20
 
 if [[ ! -f "${JSON_PATH}" ]]; then
   echo "[STATE] WARN: ${JSON_PATH} not found. Skipping."
   exit 0
 fi
 if [[ ! -f "${POS_JSON_PATH}" ]]; then
   echo "[STATE] WARN: ${POS_JSON_PATH} not found. Skipping."
   exit 0
 fi
 
 tmp_state="$(mktemp)"
 tmp_pos_state="$(mktemp)"
 tmp_intent_log="$(mktemp)"
 tmp_intent_cursor="$(mktemp)"
-trap 'rm -f "${tmp_state}" "${tmp_pos_state}" "${tmp_intent_log}" "${tmp_intent_cursor}"' EXIT
+tmp_diag_dir="$(mktemp -d)"
+trap 'rm -f "${tmp_state}" "${tmp_pos_state}" "${tmp_intent_log}" "${tmp_intent_cursor}"; rm -rf "${tmp_diag_dir}"' EXIT
 cp -f "${JSON_PATH}" "${tmp_state}"
 cp -f "${POS_JSON_PATH}" "${tmp_pos_state}"
 cp -f "${INTENT_LOG_PATH}" "${tmp_intent_log}" 2>/dev/null || touch "${tmp_intent_log}"
 cp -f "${INTENT_CURSOR_PATH}" "${tmp_intent_cursor}" 2>/dev/null || touch "${tmp_intent_cursor}"
+if [[ -d "${DIAG_DIR}" ]]; then
+  cp -f "${DIAG_DIR}"/* "${tmp_diag_dir}/" 2>/dev/null || true
+fi
 
 # IMPORTANT: avoid "untracked would be overwritten by checkout"
 rm -f "${JSON_PATH}" || true
 rm -f "${POS_JSON_PATH}" || true
 rm -f "${INTENT_LOG_PATH}" || true
 rm -f "${INTENT_CURSOR_PATH}" || true
+rm -rf "${DIAG_DIR}" || true
 
 if git ls-remote --exit-code --heads origin bot-state >/dev/null 2>&1; then
   git fetch --no-tags origin bot-state:refs/remotes/origin/bot-state >/dev/null 2>&1 || true
   git checkout -B bot-state origin/bot-state
 else
   git checkout --orphan bot-state
   git rm -r --cached . >/dev/null 2>&1 || true
 fi
 
 mkdir -p "${STATE_DIR}"
 cp -f "${tmp_state}" "${JSON_PATH}"
 mkdir -p "${POS_STATE_DIR}"
 cp -f "${tmp_pos_state}" "${POS_JSON_PATH}"
 cp -f "${tmp_intent_log}" "${INTENT_LOG_PATH}"
 cp -f "${tmp_intent_cursor}" "${INTENT_CURSOR_PATH}"
+mkdir -p "${DIAG_DIR}"
+if [[ -d "${tmp_diag_dir}" ]]; then
+  cp -f "${tmp_diag_dir}"/* "${DIAG_DIR}/" 2>/dev/null || true
+fi
+if ls -1 "${DIAG_DIR}" >/dev/null 2>&1; then
+  # keep only the most recent DIAG_KEEP files (lexicographic order assumes timestamped names)
+  to_prune=$(ls -1 "${DIAG_DIR}" | sort | head -n -${DIAG_KEEP} 2>/dev/null || true)
+  if [[ -n "${to_prune}" ]]; then
+    while IFS= read -r f; do
+      rm -f "${DIAG_DIR}/${f}"
+    done <<< "${to_prune}"
+  fi
+fi
 
 git add -f "${JSON_PATH}"
 git add -f "${POS_JSON_PATH}"
 git add -f "${INTENT_LOG_PATH}"
 git add -f "${INTENT_CURSOR_PATH}"
+git add -f "${DIAG_DIR}"/*.json 2>/dev/null || true
 git status --porcelain
 if git diff --cached --quiet; then
   echo "[STATE] No changes to commit."
   exit 0
 fi
 
 git commit -m "Update bot state (plain) [skip ci]"
 git push --force-with-lease origin HEAD:bot-state
 echo "[STATE] Pushed ${JSON_PATH} to bot-state branch."
+echo "[STATE] Pushed trader/state/diagnostics/* (limited) to bot-state branch."
diff --git a/trader/config.py b/trader/config.py
index 9d5e05d219f38a5c631180980cdfc41e07e1dd5a..dea1da4a10a339028f5310ab922a6063dd10b1dd 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -70,50 +70,56 @@ CONFIG = {
     "CHAMPION_MIN_TRADES": "5",            # 최소 거래수
     "CHAMPION_MIN_WINRATE": "45.0",        # 최소 승률(%)
     "CHAMPION_MAX_MDD": "30.0",            # 최대 허용 MDD(%)
     "CHAMPION_MIN_SHARPE": "0.0",          # 최소 샤프 비율
     "NEUTRAL_ENTRY_SCALE": "0.6",          # 중립 레짐 신규/재진입 스케일링 비율
     # 기타
     "MARKET_DATA_WHEN_CLOSED": "false",
     "FORCE_WEEKLY_REBALANCE": "0",
     # NEW: 1분봉 VWAP 모멘텀 파라미터
     "MOM_FAST": "5",        # 1분봉 fast MA 길이
     "MOM_SLOW": "20",       # 1분봉 slow MA 길이
     "MOM_TH_PCT": "0.5",    # fast/slow 괴리 임계값(%) – 0.5% 이상이면 강세로 본다
     # Subject flow gate 기본값
     "MIN_SMART_MONEY_RATIO_KOSPI": "0.02",
     "MIN_SMART_MONEY_RATIO_KOSDAQ": "0.03",
     "SUBJECT_FLOW_TIMEOUT_SEC": "1.2",
     "SUBJECT_FLOW_RETRY": "1",
     "SUBJECT_FLOW_CACHE_TTL_SEC": "60",
     "SUBJECT_FLOW_FAIL_POLICY": "CACHE",
     "SUBJECT_FLOW_EMPTY_POLICY": "TREAT_AS_FAIL",
     "SUBJECT_FLOW_DEGRADED_TURNOVER_MULT": "1.5",
     "SUBJECT_FLOW_DEGRADED_OB_ADD": "10",
     "SUBJECT_FLOW_MAX_CALLS_PER_RUN": "200",
     "EMERGENCY_GLOBAL_SELL": "false",
     "STRATEGY_REDUCTION_PRIORITY": "5,4,3,2,1",
+    # Diagnostics
+    "DIAGNOSTIC_MODE": "false",
+    "DIAGNOSTIC_ONLY": "true",
+    "DIAGNOSTIC_FORCE_RUN": "true",
+    "DIAGNOSTIC_DUMP_PATH": "trader/state/diagnostics",
+    "DIAGNOSTIC_MAX_SYMBOLS": "200",
     # === Strategy intent/exec defaults ===
     "ENABLED_STRATEGIES": "",
     "STRATEGY_MODE": "INTENT_ONLY",  # INTENT_ONLY | LIVE
     "STRATEGY_DRY_RUN": "true",
     "STRATEGY_INTENTS_PATH": "trader/state/strategy_intents.jsonl",
     "STRATEGY_INTENTS_STATE_PATH": "trader/state/strategy_intents_state.json",
     "STRATEGY_MAX_OPEN_INTENTS": "20",
     "STRATEGY_MAX_POSITION_PCT": "0.10",
     "STRATEGY_ALLOW_SELL_ONLY": "false",
     "STRATEGY_WEIGHTS": "",
     "DISABLE_KOSDAQ_LOOP": "false",
     "DISABLE_KOSPI_ENGINE": "false",
 }
 
 
 def _cfg(key: str) -> str:
     """환경변수 > CONFIG 기본값"""
     return os.getenv(key, CONFIG.get(key, ""))
 
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 LOG_DIR = Path(__file__).parent / "logs"
 LOG_DIR.mkdir(exist_ok=True)
@@ -214,50 +220,74 @@ def _parse_strategy_weights(raw: str) -> Dict[str, float]:
 ENABLED_STRATEGIES_SET = parse_enabled_strategies(_cfg("ENABLED_STRATEGIES"))
 RAW_STRATEGY_WEIGHTS = _parse_strategy_weights(_cfg("STRATEGY_WEIGHTS"))
 
 if ENABLED_STRATEGIES_SET:
     STRATEGY_WEIGHTS = {
         name: (RAW_STRATEGY_WEIGHTS.get(name, 0.0) if name in ENABLED_STRATEGIES_SET else 0.0)
         for name in ENABLED_STRATEGIES_SET.union(RAW_STRATEGY_WEIGHTS.keys())
     }
 else:
     STRATEGY_WEIGHTS = {name: 0.0 for name in RAW_STRATEGY_WEIGHTS.keys()}
 
 STRATEGY_MODE = (_cfg("STRATEGY_MODE") or "INTENT_ONLY").upper()
 STRATEGY_DRY_RUN = (_cfg("STRATEGY_DRY_RUN") or "true").lower() in ("1", "true", "yes")
 STRATEGY_INTENTS_PATH = Path(_cfg("STRATEGY_INTENTS_PATH") or CONFIG["STRATEGY_INTENTS_PATH"])
 STRATEGY_INTENTS_STATE_PATH = Path(
     _cfg("STRATEGY_INTENTS_STATE_PATH") or CONFIG["STRATEGY_INTENTS_STATE_PATH"]
 )
 STRATEGY_MAX_OPEN_INTENTS = int(_cfg("STRATEGY_MAX_OPEN_INTENTS") or "20")
 STRATEGY_MAX_POSITION_PCT = float(_cfg("STRATEGY_MAX_POSITION_PCT") or "0.10")
 STRATEGY_ALLOW_SELL_ONLY = (_cfg("STRATEGY_ALLOW_SELL_ONLY") or "false").lower() in (
     "1",
     "true",
     "yes",
 )
 
+DIAGNOSTIC_MODE = (_cfg("DIAGNOSTIC_MODE") or "false").lower() in ("1", "true", "yes")
+DIAGNOSTIC_ONLY = (_cfg("DIAGNOSTIC_ONLY") or "false").lower() in ("1", "true", "yes")
+DIAGNOSTIC_FORCE_RUN = (_cfg("DIAGNOSTIC_FORCE_RUN") or "false").lower() in (
+    "1",
+    "true",
+    "yes",
+)
+DIAGNOSTIC_DUMP_DIR = Path(_cfg("DIAGNOSTIC_DUMP_PATH") or CONFIG["DIAGNOSTIC_DUMP_PATH"])
+DIAGNOSTIC_DUMP_DIR.mkdir(parents=True, exist_ok=True)
+DIAGNOSTIC_MAX_SYMBOLS = int(_cfg("DIAGNOSTIC_MAX_SYMBOLS") or CONFIG["DIAGNOSTIC_MAX_SYMBOLS"])
+
+if DIAGNOSTIC_MODE:
+    STRATEGY_MODE = "INTENT_ONLY"
+    STRATEGY_DRY_RUN = True
+    STRATEGY_ALLOW_SELL_ONLY = True
+
+logger.info(
+    "[DIAG][CONFIG] mode=%s only=%s force_run=%s dump_dir=%s",
+    DIAGNOSTIC_MODE,
+    DIAGNOSTIC_ONLY,
+    DIAGNOSTIC_FORCE_RUN,
+    str(DIAGNOSTIC_DUMP_DIR),
+)
+
 # 전략별 레짐 축소 우선순위
 def _parse_strategy_priority(raw: str) -> list[int]:
     priorities: list[int] = []
     for item in raw.split(","):
         item = item.strip()
         if not item:
             continue
         try:
             value = int(item)
         except ValueError:
             continue
         if 1 <= value <= 5 and value not in priorities:
             priorities.append(value)
     return priorities or [5, 4, 3, 2, 1]
 
 
 STRATEGY_REDUCTION_PRIORITY = _parse_strategy_priority(
     _cfg("STRATEGY_REDUCTION_PRIORITY")
 )
 # 신고가 → 3일 눌림 → 반등 확인 후 매수 파라미터
 USE_PULLBACK_ENTRY = _cfg("USE_PULLBACK_ENTRY").lower() != "false"
 PULLBACK_LOOKBACK = int(_cfg("PULLBACK_LOOKBACK") or "60")
 PULLBACK_DAYS = int(_cfg("PULLBACK_DAYS") or "3")
 PULLBACK_REVERSAL_BUFFER_PCT = float(_cfg("PULLBACK_REVERSAL_BUFFER_PCT") or "0.2")
 PULLBACK_TOPN = int(_cfg("PULLBACK_TOPN") or "50")
diff --git a/trader/diagnostics.py b/trader/diagnostics.py
new file mode 100644
index 0000000000000000000000000000000000000000..b7ca54db979a47f9746e986f683e38b3a4954f37
--- /dev/null
+++ b/trader/diagnostics.py
@@ -0,0 +1,308 @@
+from __future__ import annotations
+
+import json
+import logging
+from datetime import datetime
+from typing import Any, Dict, List
+
+from trader.config import (
+    DIAGNOSTIC_DUMP_DIR,
+    DIAGNOSTIC_FORCE_RUN,
+    DIAGNOSTIC_MAX_SYMBOLS,
+    KST,
+)
+from trader.state_store import upsert_position
+from trader.time_utils import is_trading_day, is_trading_window
+
+logger = logging.getLogger(__name__)
+
+
+def _now_iso(ts: str | None = None) -> str:
+    if ts:
+        return ts
+    return datetime.now(KST).isoformat()
+
+
+def _normalize_symbol(sym: str | None) -> str:
+    return str(sym or "").strip().lstrip("A").zfill(6)
+
+
+def run_diagnostics(
+    *,
+    selected_by_market: Dict[str, Any],
+    kis_client: Any,
+    now_ts: str | None = None,
+    pos_state: Dict[str, Any] | None = None,
+    symbols: List[str] | None = None,
+) -> Dict[str, Any]:
+    ts = _now_iso(now_ts)
+    now_dt = datetime.fromisoformat(ts)
+    market_open = is_trading_day(now_dt) and is_trading_window(now_dt)
+    if not is_trading_day(now_dt) and not DIAGNOSTIC_FORCE_RUN:
+        logger.info(
+            "[DIAG][START] ts=%s market_open=%s symbols=%d", ts, market_open, 0
+        )
+        logger.info("[DIAG][END] ts=%s elapsed_ms=%d", ts, 0)
+        return {"status": "skipped", "ts": ts}
+
+    pos_state = pos_state or state_store.load_state()
+    holdings = kis_client.get_positions() if kis_client else []
+
+    if symbols is None:
+        selected_symbols: List[str] = []
+        for rows in (selected_by_market or {}).values():
+            for row in rows or []:
+                code = _normalize_symbol(row.get("code") or row.get("stock_code"))
+                if code and code != "000000":
+                    selected_symbols.append(code)
+        holding_symbols = [
+            _normalize_symbol(row.get("pdno") or row.get("code")) for row in holdings or []
+        ]
+        symbols = sorted({s for s in selected_symbols + holding_symbols if s})
+    else:
+        symbols = sorted({s for s in symbols if s})
+    if len(symbols) > DIAGNOSTIC_MAX_SYMBOLS:
+        symbols = symbols[:DIAGNOSTIC_MAX_SYMBOLS]
+
+    logger.info("[DIAG][START] ts=%s market_open=%s symbols=%d", ts, market_open, len(symbols))
+
+    recon = reconcile_orphan_unknown(holdings=holdings or [], pos_state=pos_state)
+    data_health = compute_data_health(symbols=symbols, kis_client=kis_client, pos_state=pos_state)
+    setup = compute_setup_reasons(
+        symbols=symbols,
+        pos_state=pos_state,
+        market_snapshot=selected_by_market or {},
+    )
+    exit_probe = exit_check_collapse_report(holdings=holdings or [], pos_state=pos_state)
+
+    summary = {
+        "ts": ts,
+        "market_open": market_open,
+        "symbols": len(symbols),
+        "reconcile": recon,
+        "data_health": data_health,
+        "setup": setup,
+        "exit_probe": exit_probe,
+    }
+
+    dump_path = DIAGNOSTIC_DUMP_DIR / f"diag_{now_dt.strftime('%Y%m%d_%H%M%S')}.json"
+    try:
+        dump_path.parent.mkdir(parents=True, exist_ok=True)
+        with open(dump_path, "w", encoding="utf-8") as f:
+            json.dump(summary, f, ensure_ascii=False, indent=2)
+        size = dump_path.stat().st_size
+        logger.info("[DIAG][DUMP] path=%s bytes=%d", dump_path, size)
+    except Exception as e:
+        logger.warning("[DIAG][DUMP_FAIL] path=%s err=%s", dump_path, e)
+
+    elapsed_ms = int((datetime.now(KST) - now_dt).total_seconds() * 1000)
+    logger.info("[DIAG][END] ts=%s elapsed_ms=%d", ts, elapsed_ms)
+    return summary
+
+
+def reconcile_orphan_unknown(*, holdings: List[dict], pos_state: Dict[str, Any]) -> Dict[str, Any]:
+    positions = pos_state.setdefault("positions", {})
+    memory = pos_state.setdefault("memory", {})
+    last_strategy_map = memory.setdefault("last_strategy_id", {})
+    orphan_symbols: List[str] = []
+    unknown_symbols: List[str] = []
+    by_symbol: Dict[str, Any] = {}
+
+    for row in holdings or []:
+        sym = _normalize_symbol(row.get("pdno") or row.get("code"))
+        if not sym:
+            continue
+        actual_qty = int(row.get("qty") or row.get("hldg_qty") or row.get("ord_psbl_qty") or 0)
+        pos = upsert_position(pos_state, sym)
+        mapped_qty = int(pos.get("qty") or 0)
+        orphan_qty = max(actual_qty - mapped_qty, 0)
+        strategy_id = pos.get("strategy_id")
+        reason = "HAS_STRATEGY_ID"
+        unknown = False
+        if strategy_id:
+            pass
+        elif sym in last_strategy_map:
+            strategy_id = last_strategy_map.get(sym)
+            reason = "MEMORY_RESTORED"
+        else:
+            strategy_id = None
+            unknown = True
+            reason = "NO_STRATEGY_ID"
+            unknown_symbols.append(sym)
+        pos["strategy_id"] = strategy_id
+        pos.setdefault("strategy_name", None)
+        pos["reconcile"] = {
+            "ts": _now_iso(),
+            "actual_qty": actual_qty,
+            "mapped_qty": mapped_qty,
+            "orphan_qty": orphan_qty,
+            "unknown": unknown,
+            "reason": reason,
+        }
+        if orphan_qty > 0:
+            orphan_symbols.append(sym)
+            logger.info(
+                "[DIAG][ORPHAN] symbol=%s actual=%d mapped=%d orphan=%d reason=%s",
+                sym,
+                actual_qty,
+                mapped_qty,
+                orphan_qty,
+                reason,
+            )
+        if unknown:
+            logger.info("[DIAG][UNKNOWN] symbol=%s qty=%d reason=%s", sym, actual_qty, reason)
+        by_symbol[sym] = pos["reconcile"]
+
+    logger.info(
+        "[DIAG][RECONCILE] symbols=%d orphan=%d unknown=%d",
+        len(by_symbol),
+        len(orphan_symbols),
+        len(unknown_symbols),
+    )
+    return {
+        "symbols": len(by_symbol),
+        "orphan_symbols": orphan_symbols,
+        "unknown_symbols": unknown_symbols,
+        "by_symbol": by_symbol,
+    }
+
+
+def compute_data_health(*, symbols: List[str], kis_client: Any, pos_state: Dict[str, Any]) -> Dict[str, Any]:
+    results: Dict[str, Any] = {}
+    for sym in symbols:
+        reasons: List[str] = []
+        daily_n = 0
+        prev_close = None
+        intraday_n = 0
+        vwap = None
+        try:
+            daily = kis_client.safe_get_daily_candles(sym) if kis_client else []
+            daily_n = len(daily)
+            if daily_n < 21:
+                reasons.append(f"DAILY_TOO_SHORT({daily_n})")
+            prev_close = kis_client.safe_get_prev_close(sym) if kis_client else None
+            if prev_close is None:
+                reasons.append("PREV_CLOSE_MISSING")
+            intraday = kis_client.safe_get_intraday_bars(sym) if kis_client else []
+            intraday_n = len(intraday)
+            if intraday_n <= 0:
+                reasons.append("INTRADAY_EMPTY")
+            vwap = kis_client.safe_compute_vwap(intraday) if kis_client else None
+            if vwap is None:
+                reasons.append("VWAP_MISSING")
+        except Exception as e:
+            reasons.append("FETCH_ERROR")
+            logger.warning("[DIAG][FETCH] symbol=%s kind=%s error=%s", sym, "unknown", e)
+
+        ok = len(reasons) == 0
+        payload = {
+            "ts": _now_iso(),
+            "daily_n": int(daily_n),
+            "prev_close": prev_close,
+            "intraday_n": int(intraday_n),
+            "vwap": vwap,
+            "ok": ok,
+            "reasons": reasons,
+        }
+        pos = upsert_position(pos_state, sym)
+        pos["data_health"] = payload
+        results[sym] = payload
+        logger.info(
+            "[DIAG][DATA-HEALTH] symbol=%s ok=%s daily_n=%d prev_close=%s intraday_n=%d vwap=%s reasons=%s",
+            sym,
+            ok,
+            int(daily_n),
+            str(prev_close),
+            int(intraday_n),
+            str(vwap),
+            reasons,
+        )
+    return results
+
+
+def compute_setup_reasons(
+    *,
+    symbols: List[str],
+    pos_state: Dict[str, Any],
+    market_snapshot: Dict[str, Any],
+) -> Dict[str, Any]:
+    results: Dict[str, Any] = {}
+    selected_set = set()
+    for rows in (market_snapshot or {}).values():
+        for row in rows or []:
+            code = _normalize_symbol(row.get("code") or row.get("stock_code"))
+            if code:
+                selected_set.add(code)
+
+    for sym in symbols:
+        pos = upsert_position(pos_state, sym)
+        data_health = pos.get("data_health") or {}
+        reasons: List[str] = []
+        missing: List[str] = []
+        setup_ok = True
+
+        if data_health and not data_health.get("ok", False):
+            setup_ok = False
+            reasons.append("DATA_HEALTH_DEGRADED")
+            for r in data_health.get("reasons") or []:
+                if r not in reasons:
+                    reasons.append(r)
+
+        if selected_set and sym not in selected_set:
+            setup_ok = False
+            reasons.append("NOT_IN_SELECTION")
+
+        if setup_ok is False and not reasons:
+            reasons.append("NO_SETUP_REASON")
+
+        payload = {
+            "ts": _now_iso(),
+            "setup_ok": setup_ok,
+            "reasons": reasons if setup_ok or reasons else ["NO_SETUP_REASON"],
+            "missing": missing,
+        }
+        pos["setup"] = payload
+        results[sym] = payload
+        logger.info(
+            "[DIAG][SETUP] symbol=%s setup_ok=%s reasons=%s missing=%s",
+            sym,
+            setup_ok,
+            payload["reasons"],
+            missing,
+        )
+    return results
+
+
+def exit_check_collapse_report(*, holdings: List[dict], pos_state: Dict[str, Any]) -> Dict[str, Any]:
+    results: Dict[str, Any] = {}
+    for row in holdings or []:
+        sym = _normalize_symbol(row.get("pdno") or row.get("code"))
+        if not sym:
+            continue
+        pos = upsert_position(pos_state, sym)
+        reasons: List[str] = []
+        strategy_id = pos.get("strategy_id")
+        if not strategy_id:
+            reasons.append("STRATEGY_ID_MISSING")
+        if isinstance(pos.get("strategies"), dict) and len(pos.get("strategies", {})) > 1:
+            reasons.append("MULTI_STRATEGY_NOT_TRACKED")
+        reconcile_meta = pos.get("reconcile") or {}
+        if int(reconcile_meta.get("orphan_qty") or 0) > 0:
+            reasons.append("ORPHAN_QTY_PRESENT")
+        collapsed = bool(reasons)
+        payload = {
+            "ts": _now_iso(),
+            "strategy_id": strategy_id,
+            "collapsed": collapsed,
+            "reasons": reasons,
+        }
+        pos["exit_check_probe"] = payload
+        results[sym] = payload
+        logger.info(
+            "[DIAG][EXIT-PROBE] symbol=%s collapsed=%s reasons=%s strategy_id=%s",
+            sym,
+            collapsed,
+            reasons,
+            strategy_id,
+        )
+    return results
diff --git a/trader/kis_wrapper.py b/trader/kis_wrapper.py
index 9e1945c0402514e2f285d80bc5cbb4f05221c609..b1a520c758b68d81fe676ebc0df92455192bf70e 100644
--- a/trader/kis_wrapper.py
+++ b/trader/kis_wrapper.py
@@ -887,50 +887,92 @@ class KisAPI:
         total_tr = 0.0
         for c in candles:
             try:
                 v = float(c.get("volume") or 0.0)
                 p = float(c.get("price") or 0.0)
             except Exception:
                 continue
             if v <= 0 or p <= 0:
                 continue
             total_vol += v
             total_tr += v * p
 
         if total_vol <= 0:
             return None
         return total_tr / total_vol
 
     def is_market_open(self) -> bool:
         kst = pytz.timezone("Asia/Seoul")
         now = datetime.now(kst)
         if now.weekday() >= 5:
             return False
         open_time = now.replace(hour=9, minute=0, second=0, microsecond=0)
         close_time = now.replace(hour=15, minute=20, second=0, microsecond=0)
         return open_time <= now <= close_time
 
+    # ===== Diagnostics-safe fetchers =====
+    def safe_get_daily_candles(self, code: str, count: int = 60) -> List[Dict[str, Any]]:
+        try:
+            return self.get_daily_candles(code, count=count)
+        except Exception as e:
+            logger.warning("[DIAG][FETCH] symbol=%s kind=%s error=%s", code, "daily", str(e))
+            return []
+
+    def safe_get_intraday_bars(self, code: str, interval: str = "1m") -> List[Dict[str, Any]]:
+        try:
+            # interval currently unused; KIS only supports 1m intraday endpoint here
+            return self.get_intraday_candles_today(code)
+        except Exception as e:
+            logger.warning("[DIAG][FETCH] symbol=%s kind=%s error=%s", code, "intraday", str(e))
+            return []
+
+    def safe_get_prev_close(self, code: str) -> Optional[float]:
+        try:
+            candles = self.get_daily_candles(code, count=2)
+            if candles:
+                return float(candles[-1].get("close") or 0.0)
+        except Exception as e:
+            logger.warning("[DIAG][FETCH] symbol=%s kind=%s error=%s", code, "prev_close", str(e))
+        return None
+
+    def safe_compute_vwap(self, intraday_bars: List[Dict[str, Any]]) -> Optional[float]:
+        total_vol = 0.0
+        total_tr = 0.0
+        for bar in intraday_bars or []:
+            try:
+                vol = float(bar.get("volume") or bar.get("cntg_vol") or 0.0)
+                price = float(bar.get("price") or bar.get("stck_prpr") or 0.0)
+            except Exception:
+                continue
+            if vol <= 0 or price <= 0:
+                continue
+            total_vol += vol
+            total_tr += vol * price
+        if total_vol <= 0:
+            return None
+        return total_tr / total_vol
+
     # ===== 보조 시세/지수/스냅샷 =====
     def get_close_price(self, code: str) -> Optional[float]:
         """최근 일봉 종가(전일 또는 당일 종가) → 실패 시 현재가 폴백."""
         try:
             candles = self.get_daily_candles(code, count=30)
             if candles:
                 return float(candles[-1]["close"])
         except Exception as e:
             logger.warning(f"[get_close_price] fail {code}: {e}")
         try:
             return float(self.get_last_price(code))
         except Exception:
             return None
 
     def get_prev_close(self, code: str) -> Optional[float]:
         """전일 종가."""
         try:
             candles = self.get_daily_candles(code, count=30)
             if len(candles) >= 2:
                 return float(candles[-2]["close"])
         except Exception as e:
             logger.warning(f"[get_prev_close] fail {code}: {e}")
         return None
 
     def get_quote_snapshot(self, code: str) -> Dict[str, Any]:
diff --git a/trader/legacy_kosdaq_runner.py b/trader/legacy_kosdaq_runner.py
index 87cd4fe6ea27a163c26594a35af8d1d5ae8b0eb5..c06796f7a543eecc63f8618966fe327db7683631 100644
--- a/trader/legacy_kosdaq_runner.py
+++ b/trader/legacy_kosdaq_runner.py
@@ -2383,55 +2383,67 @@ def main(
                     kis, code, current_price, price_source
                 )
                 daily_ctx = normalize_daily_ctx(daily_ctx)
                 intra_ctx = _compute_intraday_entry_context(
                     kis, code, fast=MOM_FAST, slow=MOM_SLOW
                 )
                 intra_ctx = normalize_intraday_ctx(intra_ctx)
 
                 momentum_confirmed = bool(
                     daily_ctx.get("strong_trend")
                     or intra_ctx.get("vwap_reclaim")
                     or intra_ctx.get("range_break")
                 )
 
                 if mode == "neutral" and not (
                     info.get("champion_grade") in ("A", "B") or momentum_confirmed
                 ):
                     logger.info(
                         f"[ENTRY-SKIP] {code}: neutral 레짐에서 비챔피언/모멘텀 미확인 → 신규 진입 보류"
                     )
                     continue
 
                 setup_state = signals.evaluate_setup_gate(
                     daily_ctx, intra_ctx, regime_state=regime_state
                 )
+                missing = setup_state.get("missing_conditions") or []
+                reasons = setup_state.get("reasons") or []
+                data_health_ctx = setup_state.get("data_health") or daily_ctx.get("data_health") or {}
+                if data_health_ctx and not data_health_ctx.get("ok", True):
+                    if "DATA_HEALTH_DEGRADED" not in reasons:
+                        reasons.append("DATA_HEALTH_DEGRADED")
+                    for r in data_health_ctx.get("reasons") or []:
+                        if r not in reasons:
+                            reasons.append(r)
                 if not setup_state.get("ok"):
+                    if not reasons:
+                        reasons = ["NO_SETUP_REASON"]
                     logger.info(
-                        "[SETUP-BAD] %s | reasons=%s | daily=%s intra=%s regime=%s",
+                        "[SETUP-BAD] %s | missing=%s reasons=%s | daily=%s intra=%s regime=%s",
                         code,
-                        setup_state.get("reasons"),
+                        missing,
+                        reasons,
                         daily_ctx,
                         intra_ctx,
                         regime_state,
                     )
                     continue
                 logger.info(
                     "[SETUP-OK] %s | daily=%s intra=%s regime=%s",
                     code,
                     daily_ctx,
                     intra_ctx,
                     regime_state,
                 )
 
                 trigger_label = "breakout_cross"
                 strategy_name = str(strategy or "").lower()
                 if "pullback" in strategy_name:
                     trigger_label = "pullback_rebound"
                 elif "close" in strategy_name:
                     trigger_label = "close_betting"
 
                 trigger_state = signals.evaluate_trigger_gate(
                     daily_ctx,
                     intra_ctx,
                     prev_price=prev_price,
                     target_price=target_price,
diff --git a/trader/state_store.py b/trader/state_store.py
index 1c219798a04f6d6a2eafa9c0fdf1821fb9ab4180..11a17297df234747a4969fae64de9fc651f3ecfe 100644
--- a/trader/state_store.py
+++ b/trader/state_store.py
@@ -1,226 +1,255 @@
 from __future__ import annotations
 
 import json
 import logging
 import os
 from datetime import datetime
 from pathlib import Path
 from typing import Any, Dict
 
 from .config import KST
 
 logger = logging.getLogger(__name__)
 
-SCHEMA_VERSION = 1
+SCHEMA_VERSION = 2
 RUNTIME_STATE_DIR = Path(".runtime")
 RUNTIME_STATE_PATH = RUNTIME_STATE_DIR / "state.json"
 
 
 def _default_runtime_state() -> Dict[str, Any]:
     return {
         "schema_version": SCHEMA_VERSION,
         "updated_at": None,
         "positions": {},
         "orders": {},
+        "memory": {"last_price": {}, "last_seen": {}, "last_strategy_id": {}},
     }
 
 
 def load_state() -> Dict[str, Any]:
     if not RUNTIME_STATE_PATH.exists():
         return _default_runtime_state()
     try:
         with open(RUNTIME_STATE_PATH, "r", encoding="utf-8") as f:
             state = json.load(f)
         if not isinstance(state, dict):
             logger.warning("[RUNTIME_STATE] invalid state format: %s", type(state))
             return _default_runtime_state()
         state.setdefault("schema_version", SCHEMA_VERSION)
         state.setdefault("positions", {})
         state.setdefault("orders", {})
+        memory = state.get("memory")
+        if not isinstance(memory, dict):
+            memory = {}
+            state["memory"] = memory
+        memory.setdefault("last_price", {})
+        memory.setdefault("last_seen", {})
+        memory.setdefault("last_strategy_id", {})
         state.setdefault("updated_at", None)
+        positions = state.get("positions")
+        if isinstance(positions, dict):
+            for sym, payload in list(positions.items()):
+                if not isinstance(payload, dict):
+                    positions[sym] = {}
         return state
     except Exception:
         logger.exception("[RUNTIME_STATE] failed to load %s", RUNTIME_STATE_PATH)
         return _default_runtime_state()
 
 
 def save_state(state: Dict[str, Any]) -> None:
     try:
         RUNTIME_STATE_DIR.mkdir(parents=True, exist_ok=True)
         payload = dict(state)
         payload.setdefault("schema_version", SCHEMA_VERSION)
         payload.setdefault("positions", {})
         payload.setdefault("orders", {})
+        payload.setdefault("memory", {"last_price": {}, "last_seen": {}, "last_strategy_id": {}})
         payload["updated_at"] = datetime.now(KST).isoformat()
         tmp_path = RUNTIME_STATE_PATH.with_name(f"{RUNTIME_STATE_PATH.name}.tmp")
         with open(tmp_path, "w", encoding="utf-8") as f:
             json.dump(payload, f, ensure_ascii=False, indent=2)
+            f.flush()
+            os.fsync(f.fileno())
         os.replace(tmp_path, RUNTIME_STATE_PATH)
+        try:
+            size = RUNTIME_STATE_PATH.stat().st_size
+            logger.info("[STATE][SAVE] path=%s bytes=%d", RUNTIME_STATE_PATH, size)
+        except Exception:
+            logger.info("[STATE][SAVE] path=%s", RUNTIME_STATE_PATH)
     except Exception:
         logger.exception("[RUNTIME_STATE] failed to save %s", RUNTIME_STATE_PATH)
 
 
 def get_position(state: Dict[str, Any], symbol: str) -> Dict[str, Any] | None:
     positions = state.get("positions", {})
     if not isinstance(positions, dict):
         return None
     return positions.get(str(symbol).zfill(6))
 
 
-def upsert_position(state: Dict[str, Any], symbol: str, fields: Dict[str, Any]) -> None:
+def upsert_position(state: Dict[str, Any], symbol: str) -> Dict[str, Any]:
     positions = state.setdefault("positions", {})
     key = str(symbol).zfill(6)
-    pos = positions.setdefault(key, {})
+    pos = positions.get(key)
+    if not isinstance(pos, dict):
+        pos = {}
+    positions[key] = pos
+    return pos
+
+
+def update_position_fields(state: Dict[str, Any], symbol: str, fields: Dict[str, Any]) -> Dict[str, Any]:
+    pos = upsert_position(state, symbol)
     for field, value in fields.items():
         pos[field] = value
+    return pos
 
 
 def _order_bucket(state: Dict[str, Any], symbol: str, side: str) -> Dict[str, Any]:
     orders = state.setdefault("orders", {})
     symbol_key = str(symbol).zfill(6)
     symbol_bucket = orders.setdefault(symbol_key, {})
     return symbol_bucket.setdefault(side.upper(), {})
 
 
 def should_block_order(
     state: Dict[str, Any],
     symbol: str,
     side: str,
     now_ts: str,
     *,
     window_sec: int = 300,
     max_attempts: int = 2,
 ) -> bool:
     bucket = _order_bucket(state, symbol, side)
     last_ts = bucket.get("last_ts")
     attempts = int(bucket.get("attempts") or 0)
     if attempts >= max_attempts:
         return True
     if isinstance(last_ts, str):
         try:
             last_dt = datetime.fromisoformat(last_ts)
             now_dt = datetime.fromisoformat(now_ts)
             if (now_dt - last_dt).total_seconds() <= window_sec:
                 return True
         except Exception:
             return False
     return False
 
 
 def mark_order(
     state: Dict[str, Any],
     symbol: str,
     side: str,
     strategy_id: Any,
     qty: int,
     price: float,
     ts: str,
     order_id: str | None = None,
     status: str = "submitted",
 ) -> None:
     bucket = _order_bucket(state, symbol, side)
     bucket["last_ts"] = ts
     bucket["last_order_id"] = order_id
     bucket["attempts"] = int(bucket.get("attempts") or 0) + 1
-    upsert_position(
+    update_position_fields(
         state,
         symbol,
         {
             "strategy_id": strategy_id,
             "last_action": side.upper(),
             "last_action_ts": ts,
             "last_order_status": status,
             "last_order_qty": int(qty),
             "last_order_price": float(price),
         },
     )
 
 
 def mark_fill(
     state: Dict[str, Any],
     symbol: str,
     side: str,
     strategy_id: Any,
     qty: int,
     price: float,
     ts: str,
     order_id: str | None = None,
     status: str = "filled",
 ) -> None:
     pos = get_position(state, symbol) or {}
     cur_qty = int(pos.get("qty") or 0)
     cur_avg = float(pos.get("avg_price") or 0.0)
     if side.upper() == "BUY":
         total_qty = cur_qty + int(qty)
         avg_price = (
             (cur_avg * cur_qty + float(price) * int(qty)) / total_qty
             if total_qty > 0
             else 0.0
         )
         pos.update({"qty": total_qty, "avg_price": avg_price, "last_buy_ts": ts})
     else:
         pos.update({"qty": max(0, cur_qty - int(qty)), "last_sell_ts": ts})
     pos["strategy_id"] = strategy_id
     pos["last_order_id"] = order_id
     pos["last_action"] = side.upper()
     pos["last_action_ts"] = ts
     pos["last_order_status"] = status
-    upsert_position(state, symbol, pos)
+    update_position_fields(state, symbol, pos)
 
 
 def reconcile_with_kis_balance(
     state: Dict[str, Any],
     balance: Dict[str, Any],
     *,
     preferred_strategy: Dict[str, Any] | None = None,
 ) -> Dict[str, Any]:
     preferred_strategy = preferred_strategy or {}
     positions = state.setdefault("positions", {})
     balance_positions = balance.get("positions") if isinstance(balance, dict) else None
     if not isinstance(balance_positions, list):
         return state
     seen = set()
     for row in balance_positions:
         symbol = str(row.get("code") or row.get("pdno") or "").zfill(6)
         if not symbol:
             continue
         qty = int(row.get("qty") or 0)
         if qty <= 0:
             continue
         seen.add(symbol)
-        pos = positions.setdefault(symbol, {})
+        pos = upsert_position(state, symbol)
         strategy_id = pos.get("strategy_id") or preferred_strategy.get(symbol) or "UNKNOWN"
         pos.update(
             {
                 "strategy_id": strategy_id,
                 "qty": qty,
                 "avg_price": float(row.get("avg_price") or 0.0),
                 "last_action": "RECONCILE",
             }
         )
-        positions[symbol] = pos
     for symbol, pos in list(positions.items()):
         if symbol not in seen:
             pos["qty"] = 0
             pos["last_action"] = "RECONCILE"
             positions[symbol] = pos
     return state
 
 
 def _default_lot_state() -> Dict[str, Any]:
     return {"version": SCHEMA_VERSION, "lots": [], "updated_at": None}
 
 
 def load_lot_state(path_json: str) -> Dict[str, Any]:
     path = Path(path_json)
     if not path.exists():
         return _default_lot_state()
     try:
         with open(path, "r", encoding="utf-8") as f:
             state = json.load(f)
         if not isinstance(state, dict):
             logger.warning("[STATE_STORE] invalid state format: %s", type(state))
             return _default_lot_state()
         state.setdefault("version", SCHEMA_VERSION)
         state.setdefault("lots", [])
         state.setdefault("updated_at", None)
diff --git a/trader/trader.py b/trader/trader.py
index 72c94072f0348462ce6ad0d8f551bad922a307da..0b509bffb1cfe86aee2bd8d2d30fe3538788ac2f 100644
--- a/trader/trader.py
+++ b/trader/trader.py
@@ -1,39 +1,44 @@
 # -*- coding: utf-8 -*-
 """Thin entrypoint orchestrating KOSPI core + KOSDAQ alpha engines."""
 from __future__ import annotations
 
 import logging
+import os
 
 from portfolio.portfolio_manager import PortfolioManager
 from trader.kis_wrapper import KisAPI
 from trader import state_store as runtime_state_store
 from trader.time_utils import is_trading_day, now_kst
 from trader.subject_flow import get_subject_flow_with_fallback  # noqa: F401 - exported for engines
+from trader.config import DIAGNOSTIC_FORCE_RUN, DIAGNOSTIC_MODE
 
 logger = logging.getLogger(__name__)
 
 
 def main() -> None:
     now = now_kst()
-    if not is_trading_day(now):
+    if DIAGNOSTIC_MODE:
+        os.environ["DISABLE_LIVE_TRADING"] = "true"
+        logger.info("[DIAG][PM] forcing DISABLE_LIVE_TRADING=true")
+    if not is_trading_day(now) and not (DIAGNOSTIC_MODE and DIAGNOSTIC_FORCE_RUN):
         logger.warning("[TRADER] 비거래일(%s) → 즉시 종료", now.date())
         return
     try:
         runtime_state = runtime_state_store.load_state()
         kis = KisAPI()
         balance = kis.get_balance()
         runtime_state = runtime_state_store.reconcile_with_kis_balance(
             runtime_state, balance
         )
         runtime_state_store.save_state(runtime_state)
         logger.info("[TRADER] runtime state reconciled")
     except Exception:
         logger.exception("[TRADER] runtime state reconcile failed")
 
     mgr = PortfolioManager()
     result = mgr.run_once()
     logger.info("[TRADER] cycle complete %s", result)
 
 
 if __name__ == "__main__":
     main()
