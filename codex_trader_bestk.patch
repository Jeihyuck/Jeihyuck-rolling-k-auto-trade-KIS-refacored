diff --git a/rolling_k_auto_trade_api/best_k_meta_strategy.py b/rolling_k_auto_trade_api/best_k_meta_strategy.py
index 3e84144e893501076dc600868137454b46dc1ce6..b123e649a179d11a481e98f1ca5f66e5fb8a84cb 100644
--- a/rolling_k_auto_trade_api/best_k_meta_strategy.py
+++ b/rolling_k_auto_trade_api/best_k_meta_strategy.py
@@ -57,98 +57,137 @@ KEEP_HELD_BYPASS_FILTERS = os.getenv("KEEP_HELD_BYPASS_FILTERS", "true").lower()
 HELD_MIN_WEIGHT = float(os.getenv("HELD_MIN_WEIGHT", "0.01"))
 
 # -----------------------------
 # Ïú†Ìã∏
 # -----------------------------
 def _clip(v: float, lo: float, hi: float) -> float:
     return max(lo, min(hi, v))
 
 def _round2(x: float) -> float:
     return float(np.round(x, 2))
 
 def _safe_float(x: Any, default: float = 0.0) -> float:
     try:
         return float(x)
     except Exception:
         return default
 
 def _find_column(df: pd.DataFrame, keyword: str) -> Optional[str]:
     kw = keyword.replace(" ", "")
     for c in df.columns:
         if kw in str(c).replace(" ", ""):
             return c
     return None
 
 # -----------------------------
-# 1) ÏãúÍ∞ÄÏ¥ùÏï° Í∏∞Ï§Ä KOSDAQ Top-N
+# 1) ÏãúÍ∞ÄÏ¥ùÏï° Í∏∞Ï§Ä Top-N Ïú†ÎãàÎ≤ÑÏä§ (KOSDAQ/KOSPI)
 # -----------------------------
-def get_kosdaq_top_n(date_str: Optional[str] = None, n: int = TOP_N) -> pd.DataFrame:
-    """ÏãúÍ∞ÄÏ¥ùÏï° ÏÉÅÏúÑ nÍ∞ú KOSDAQ Ï¢ÖÎ™© Î∞òÌôò (Code, Name, Marcap)."""
+def _get_top_n_by_market(market: str, date_str: Optional[str] = None, n: int = TOP_N) -> pd.DataFrame:
+    """ÏãúÍ∞ÄÏ¥ùÏï° ÏÉÅÏúÑ nÍ∞ú Ï¢ÖÎ™©ÏùÑ Î∞òÌôò (Code, Name, Marcap, market)."""
     try:
         target_dt = datetime.today() if date_str is None else datetime.strptime(date_str, "%Y-%m-%d")
         from_date = get_nearest_business_day_in_a_week(target_dt.strftime("%Y%m%d"))
-        logger.info(f"üìÖ pykrx ÏãúÏ¥ù Ï°∞ÌöåÏùº ‚Üí {from_date}")
+        logger.info(f"üìÖ pykrx ÏãúÏ¥ù Ï°∞ÌöåÏùº ‚Üí {from_date} market={market}")
 
-        mktcap_df = get_market_cap_by_ticker(from_date, market="KOSDAQ")
+        mktcap_df = get_market_cap_by_ticker(from_date, market=market)
         if mktcap_df is None or len(mktcap_df) == 0:
             logger.warning("‚ö†Ô∏è  pykrx ÏãúÏ¥ù DFÍ∞Ä ÎπÑÏóàÏäµÎãàÎã§ ‚Üí Îπà DF Î∞òÌôò")
-            return pd.DataFrame(columns=["Code", "Name", "Marcap"])
+            return pd.DataFrame(columns=["Code", "Name", "Marcap", "market"])
 
         mktcap_df = mktcap_df.reset_index()
         capcol = _find_column(mktcap_df, "ÏãúÍ∞ÄÏ¥ùÏï°")
         ticcol = _find_column(mktcap_df, "Ìã∞Ïª§") or _find_column(mktcap_df, "ÏΩîÎìú")
         if capcol is None or ticcol is None:
             logger.error("‚ùå  ÏãúÏ¥ù/Ìã∞Ïª§ Ïª¨Îüº ÌÉêÏÉâ Ïã§Ìå® ‚Üí Îπà DF Î∞òÌôò")
-            return pd.DataFrame(columns=["Code", "Name", "Marcap"])
+            return pd.DataFrame(columns=["Code", "Name", "Marcap", "market"])
 
         mktcap_df = mktcap_df.rename(columns={capcol: "Marcap", ticcol: "Code"})
         mktcap_df["Code"] = mktcap_df["Code"].astype(str).str.zfill(6)
 
-        fdr_df = fdr.StockListing("KOSDAQ").rename(columns={"Symbol": "Code", "Name": "Name"})
+        fdr_df = fdr.StockListing(market).rename(columns={"Symbol": "Code", "Name": "Name"})
         fdr_df["Code"] = fdr_df["Code"].astype(str).str.zfill(6)
 
         merged = pd.merge(
             fdr_df[["Code", "Name"]],
             mktcap_df[["Code", "Marcap"]],
             on="Code",
             how="inner",
         )
         if "Marcap" not in merged.columns:
             for cand in ("Marcap_x", "Marcap_y", "MarketCap", "MarketCap_x", "MarketCap_y"):
                 if cand in merged.columns:
                     merged = merged.rename(columns={cand: "Marcap"})
                     break
         if "Marcap" not in merged.columns:
             logger.error("‚ùå  Î≥ëÌï© ÌõÑÏóêÎèÑ 'Marcap' ÏóÜÏùå ‚Üí Îπà DF Î∞òÌôò")
-            return pd.DataFrame(columns=["Code", "Name", "Marcap"])
+            return pd.DataFrame(columns=["Code", "Name", "Marcap", "market"])
 
         topn = merged.dropna(subset=["Marcap"]).sort_values("Marcap", ascending=False).head(n)
-        logger.info(f"‚úÖ  ÏãúÏ¥ù Top{n} Ï∂îÏ∂ú ÏôÑÎ£å ‚Üí {len(topn)} Ï¢ÖÎ™©")
-        return topn[["Code", "Name", "Marcap"]]
+        topn["market"] = market.upper()
+        logger.info(f"‚úÖ  {market} ÏãúÏ¥ù Top{n} Ï∂îÏ∂ú ÏôÑÎ£å ‚Üí {len(topn)} Ï¢ÖÎ™©")
+        return topn[["Code", "Name", "Marcap", "market"]]
     except Exception:
-        logger.exception("‚ùå  get_kosdaq_top_n ÏòàÏô∏:")
-        return pd.DataFrame(columns=["Code", "Name", "Marcap"])
+        logger.exception(f"‚ùå  get_{market.lower()}_top_n ÏòàÏô∏:")
+        return pd.DataFrame(columns=["Code", "Name", "Marcap", "market"])
+
+
+def get_kosdaq_top_n(date_str: Optional[str] = None, n: int = TOP_N, **kwargs) -> pd.DataFrame:
+    """ÏãúÍ∞ÄÏ¥ùÏï° ÏÉÅÏúÑ nÍ∞ú KOSDAQ Ï¢ÖÎ™© Î∞òÌôò (Code, Name, Marcap)."""
+    return _get_top_n_by_market("KOSDAQ", date_str=date_str, n=n)
+
+
+def get_kospi_top_n(
+    kis: Any = None,
+    top_n: int = TOP_N,
+    as_of: Optional[datetime] = None,
+    date_str: Optional[str] = None,
+    **kwargs,
+) -> pd.DataFrame:
+    """ÏãúÍ∞ÄÏ¥ùÏï° ÏÉÅÏúÑ top_n KOSPI Ï¢ÖÎ™© Î∞òÌôò (Code, Name, Marcap, market)."""
+    ref_date = date_str
+    if as_of:
+        ref_date = as_of.strftime("%Y-%m-%d")
+    return _get_top_n_by_market("KOSPI", date_str=ref_date, n=top_n)
+
+
+def get_kosdaq_kospi_top_n(
+    kis: Any = None,
+    top_n_kosdaq: int = 50,
+    top_n_kospi: int = 50,
+    as_of: Optional[datetime] = None,
+) -> List[Dict[str, Any]]:
+    """ÏΩîÏä§Îã•/ÏΩîÏä§Ìîº ÏÉÅÏúÑ Ï¢ÖÎ™©ÏùÑ ÌÜµÌï© Î¶¨Ïä§Ìä∏Î°ú Î∞òÌôò (ÏãúÏû• ÌïÑÎìú Ìè¨Ìï®)."""
+    ref_date = as_of.strftime("%Y-%m-%d") if as_of else None
+    kosdaq_df = _get_top_n_by_market("KOSDAQ", date_str=ref_date, n=top_n_kosdaq)
+    kospi_df = _get_top_n_by_market("KOSPI", date_str=ref_date, n=top_n_kospi)
+
+    merged: List[Dict[str, Any]] = []
+    for df in (kosdaq_df, kospi_df):
+        if df is None or len(df) == 0:
+            continue
+        merged.extend(df.to_dict(orient="records"))
+    return merged
 
 # -----------------------------
 # ATR Í≥ÑÏÇ∞(Ïõî Îç∞Ïù¥ÌÑ∞ Î†àÏΩîÎìúÏóêÏÑú)
 # -----------------------------
 def _compute_atr_from_records(records: List[Dict[str, Any]], window: int = 14) -> Optional[float]:
     """Ïõî Íµ¨Í∞Ñ Î†àÏΩîÎìú([{open,high,low,close}...])ÏóêÏÑú ATR Í≥ÑÏÇ∞."""
     if not records or len(records) < window + 1:
         return None
     df = pd.DataFrame(records).copy()
     need = {"open", "high", "low", "close"}
     if not need.issubset(set(df.columns)):
         return None
     df = df[["open", "high", "low", "close"]].astype(float)
     prev_close = df["close"].shift(1)
     tr = pd.concat(
         [
             (df["high"] - df["low"]).abs(),
             (df["high"] - prev_close).abs(),
             (df["low"] - prev_close).abs(),
         ],
         axis=1,
     ).max(axis=1)
     atr = tr.rolling(window=window, min_periods=window).mean().iloc[-1]
     try:
         return float(atr) if atr and not math.isnan(atr) else None

diff --git a/trader/trader.py b/trader/trader.py
index dab14d03a6a50937d4de124a842fb62c35424bb9..40e156187d3f0ac940c9a5c2cf677023335c8db7 100644
--- a/trader/trader.py
+++ b/trader/trader.py
@@ -1,245 +1,668 @@
 # -*- coding: utf-8 -*-
 # trader.py ‚Äî KOSDAQ Î†àÏßê(Í∞ïÏÑ∏/ÏïΩÏÑ∏) Í∏∞Î∞ò Î™®Î©òÌÖÄ Í∞ïÌôî + Îã®Í≥ÑÏ†Å Ï∂ïÏÜå, 14:40 Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± ÌõÑ Ï¢ÖÎ£å(Ï†ÑÎüâÎß§ÎèÑ ÏóÜÏùå)
 
 import logging
 import requests
 from .kis_wrapper import KisAPI, append_fill
 from datetime import datetime, time as dtime, timedelta
 from zoneinfo import ZoneInfo
 import json
 from pathlib import Path
 import time
 import os
 import random
 from typing import Optional, Dict, Any, Tuple, List
 import csv
+from dataclasses import dataclass
+
+logging.basicConfig(level=logging.INFO)
+logger = logging.getLogger(__name__)
+
 from .report_ceo import ceo_report
 from .metrics import vwap_guard   # üî∏ VWAP Í∞ÄÎìú Ìï®Ïàò
-from rolling_k_auto_trade_api.best_k_meta_strategy import get_kosdaq_top_n
+# Î™®Î©òÌÖÄ Ï≤¥ÌÅ¨ Ìï®ÏàòÍ∞Ä Ï°¥Ïû¨ÌïòÎ©¥ ÌôúÏö©ÌïòÍ≥†, ÏóÜÏúºÎ©¥ Ìï≠ÏÉÅ FalseÎ°ú Ï≤òÎ¶¨Ìï¥ Îß§ÎèÑ Î°úÏßÅÎßå Î≥¥ÏàòÏ†ÅÏúºÎ°ú ÎèôÏûë
+try:
+    from .metrics import is_strong_momentum
+except Exception:
+
+    def is_strong_momentum(*args, **kwargs):  # type: ignore
+        return False
+try:
+    from rolling_k_auto_trade_api.best_k_meta_strategy import (
+        get_kosdaq_top_n,
+        get_kospi_top_n,
+        get_kosdaq_kospi_top_n,
+    )
+except Exception as import_err:
+    logger.warning(
+        "[UNIVERSE-FALLBACK] ÏãúÏ¥ù TopN ÌÜµÌï© Ìó¨Ìçº import Ïã§Ìå®: %s ‚Üí ÏΩîÏä§Îã• Ï†ÑÏö©ÏúºÎ°ú Ìè¥Î∞±",
+        import_err,
+    )
+
+    try:
+        from rolling_k_auto_trade_api.best_k_meta_strategy import get_kosdaq_top_n
+    except Exception:
+
+        def get_kosdaq_top_n(*args, **kwargs):  # type: ignore
+            logger.warning(
+                "[UNIVERSE-FALLBACK] get_kosdaq_top_n ÎØ∏ÏßÄÏõê ‚Üí Ïú†ÎãàÎ≤ÑÏä§Í∞Ä ÎπÑÏñ¥ ÏûàÏùÑ Ïàò ÏûàÏùå"
+            )
+            return []
+
+    def get_kospi_top_n(*args, **kwargs):  # type: ignore
+        logger.warning("[UNIVERSE-FALLBACK] get_kospi_top_n ÏÇ¨Ïö© Î∂àÍ∞Ä ‚Üí ÏΩîÏä§Îã•Îßå ÏÇ¨Ïö©")
+        return []
+
+    def get_kosdaq_kospi_top_n(*args, **kwargs):  # type: ignore
+        logger.warning("[UNIVERSE-FALLBACK] ÌÜµÌï© Ïú†ÎãàÎ≤ÑÏä§ ÎØ∏ÏßÄÏõê ‚Üí ÏΩîÏä§Îã•Îßå ÏÇ¨Ïö©")
+        return []
 
 # =========================
 # [CONFIG] .env ÏóÜÏù¥ÎèÑ ÎèôÏûë
 # - ÏïÑÎûò Í∞íÏùÑ Í∏∞Î≥∏ÏúºÎ°ú ÏÇ¨Ïö©
 # - (ÏÑ†ÌÉù) ÎèôÏùº ÌÇ§Î•º ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú ÎÑòÍ∏∞Î©¥ override
 # =========================
 CONFIG = {
-    "SELL_FORCE_TIME": "14:40",
+    "SELL_FORCE_TIME": "15:25",
     "SELL_ALL_BALANCES_AT_CUTOFF": "false",  # "true"Î©¥ Ïª§Ìä∏Ïò§ÌîÑÏóê Ï†ÑÏ≤¥ ÏûîÍ≥† Ìè¨Ìï® Í∞ïÏ†úÎß§ÎèÑ Î£®Ìã¥ ÏÇ¨Ïö©
     "API_RATE_SLEEP_SEC": "0.5",
     "FORCE_SELL_PASSES_CUTOFF": "2",
     "FORCE_SELL_PASSES_CLOSE": "4",
     "PARTIAL1": "0.5",
     "PARTIAL2": "0.3",
     "TRAIL_PCT": "0.02",
     "FAST_STOP": "0.01",
     "ATR_STOP": "1.5",
     "TIME_STOP_HHMM": "13:00",
     "DEFAULT_PROFIT_PCT": "3.0",
-    "DEFAULT_LOSS_PCT": "-5.0",
+    "DEFAULT_LOSS_PCT": "5.0",
     "DAILY_CAPITAL": "250000000",
     "CAP_CAP": "0.8",
     "SLIPPAGE_LIMIT_PCT": "0.25",
     "SLIPPAGE_ENTER_GUARD_PCT": "2.5",
     "VWAP_TOL": "0.003",  # üî∏ VWAP ÌóàÏö© Ïò§Ï∞®(Í∏∞Î≥∏ 0.3%)
     "W_MAX_ONE": "0.25",
     "W_MIN_ONE": "0.03",
     "REBALANCE_ANCHOR": "weekly",             # weekly | today | monthly
     "WEEKLY_ANCHOR_REF": "last",              # NEW: 'last'(ÏßÅÏ†Ñ ÏùºÏöîÏùº) | 'next'(Îã§Ïùå ÏùºÏöîÏùº)
     "MOMENTUM_OVERRIDES_FORCE_SELL": "true",
     # Î†àÏßê(ÏΩîÏä§Îã•) ÌååÎùºÎØ∏ÌÑ∞
     "KOSDAQ_INDEX_CODE": "KOSDAQ",
     "KOSDAQ_ETF_FALLBACK": "229200",
     "REG_BULL_MIN_UP_PCT": "0.5",
     "REG_BULL_MIN_MINUTES": "10",
     "REG_BEAR_VWAP_MINUTES": "10",
     "REG_BEAR_DROP_FROM_HIGH": "0.7",
     "REG_BEAR_STAGE1_MINUTES": "20",
     "REG_BEAR_STAGE2_ADD_DROP": "0.5",
     "REG_PARTIAL_S1": "0.30",
     "REG_PARTIAL_S2": "0.30",
     "TRAIL_PCT_BULL": "0.025",
     "TRAIL_PCT_BEAR": "0.012",
     "TP_PROFIT_PCT_BULL": "3.5",
     # Ïã†Í≥†Í∞Ä ÎèåÌåå ÌõÑ 3Ïùº ÎàåÎ¶º + Î∞òÎì± Îß§ÏàòÏö© ÌååÎùºÎØ∏ÌÑ∞
     "USE_PULLBACK_ENTRY": "true",          # trueÎ©¥ 'Ïã†Í≥†Í∞Ä ‚Üí 3Ïùº Ïó∞ÏÜç ÌïòÎùΩ ‚Üí Î∞òÎì±' Ìå®ÌÑ¥ Ï∂©Ï°± ÏãúÏóêÎßå ÎàåÎ¶ºÎ™© ÏßÑÏûÖ ÌóàÏö©
     "PULLBACK_LOOKBACK": "60",             # Ïã†Í≥†Í∞Ä ÌÉêÏÉâ Î≤îÏúÑ(Í±∞ÎûòÏùº Í∏∞Ï§Ä)
     "PULLBACK_DAYS": "3",                  # Ïó∞ÏÜç ÌïòÎùΩ ÏùºÏàò
     "PULLBACK_REVERSAL_BUFFER_PCT": "0.2", # ÎêòÎèåÎ¶º ÌôïÏù∏ Ïó¨Ïú†(%): ÏßÅÏ†Ñ ÌïòÎùΩÏùº Í≥†Í∞Ä ÎåÄÎπÑ Ïó¨Ïú†Ïú®
-    "PULLBACK_TOPN": "50",                 # ÎàåÎ¶ºÎ™© Ïä§Ï∫îÏö© ÏΩîÏä§Îã• ÏãúÏ¥ù ÏÉÅÏúÑ Ï¢ÖÎ™© Ïàò
+    "PULLBACK_TOPN": "50",                 # ÎàåÎ¶ºÎ™© Ïä§Ï∫îÏö© Í∞Å ÏãúÏû•Î≥Ñ ÏãúÏ¥ù ÏÉÅÏúÑ Ï¢ÖÎ™© Ïàò
     "PULLBACK_UNIT_WEIGHT": "0.03",        # ÎàåÎ¶ºÎ™© Îß§Ïàò 1Í±¥Îãπ ÏûêÎ≥∏ Î∞∞Î∂Ñ(ÌôúÏÑ± ÏûêÎ≥∏ ÎπÑÏú®)
     # Ï±îÌîºÏñ∏ ÌõÑÎ≥¥ ÌïÑÌÑ∞
     "CHAMPION_MIN_TRADES": "5",            # ÏµúÏÜå Í±∞ÎûòÏàò
     "CHAMPION_MIN_WINRATE": "45.0",        # ÏµúÏÜå ÏäπÎ•†(%)
     "CHAMPION_MAX_MDD": "30.0",            # ÏµúÎåÄ ÌóàÏö© MDD(%)
     "CHAMPION_MIN_SHARPE": "0.0",          # ÏµúÏÜå ÏÉ§ÌîÑ ÎπÑÏú®
     # Í∏∞ÌÉÄ
     "MARKET_DATA_WHEN_CLOSED": "false",
     "FORCE_WEEKLY_REBALANCE": "0",
     # NEW: 1Î∂ÑÎ¥â VWAP Î™®Î©òÌÖÄ ÌååÎùºÎØ∏ÌÑ∞
     "MOM_FAST": "5",        # 1Î∂ÑÎ¥â fast MA Í∏∏Ïù¥
     "MOM_SLOW": "20",       # 1Î∂ÑÎ¥â slow MA Í∏∏Ïù¥
     "MOM_TH_PCT": "0.5",    # fast/slow Í¥¥Î¶¨ ÏûÑÍ≥ÑÍ∞í(%) ‚Äì 0.5% Ïù¥ÏÉÅÏù¥Î©¥ Í∞ïÏÑ∏Î°ú Î≥∏Îã§
+    # ÏãúÍ∞Ñ Íµ¨Í∞Ñ
+    "ACTIVE_START_HHMM": "09:30",
+    "FULL_ACTIVE_END_HHMM": "14:30",
+    "CLOSE_BET_PREP_START_HHMM": "14:30",
+    "CLOSE_BET_ENTRY_START_HHMM": "15:10",
+    "MARKET_CLOSE_HHMM": "15:30",
+    # Ï¢ÖÍ∞Ä Î≤†ÌåÖ
+    "CLOSE_BET_TOPN": "5",
+    "CLOSE_BET_CAP_FRACTION": "0.2",
+    "CLOSE_BET_MIN_RET_PCT": "3.0",
+    "CLOSE_BET_MAX_PULLBACK_PCT": "3.0",
+    "CLOSE_BET_MIN_VOL_SPIKE": "2.0",
+    # ÏΩîÏñ¥ Ìè¨ÏßÄÏÖò
+    "ENABLE_CORE_POSITIONS": "true",
+    "CORE_MAX_FRACTION": "0.6",
+    "CORE_W_MAX_ONE": "0.10",
+    "CORE_SCAN_TOPN": "250",
+    "CORE_BOX_RANGE_PCT": "5.0",
+    "CORE_BREAKOUT_PCT": "2.0",
+    # Ïú†ÎãàÎ≤ÑÏä§ Íµ¨ÏÑ± (ÏΩîÏä§Îã•/ÏΩîÏä§Ìîº ÎπÑÏú® Î∞è ÏÇ¨Ïö© Ïó¨Î∂Ä)
+    "UNIVERSE_INCLUDE_MARKETS": "KOSDAQ,KOSPI",  # "KOSDAQ", "KOSPI", "KOSDAQ,KOSPI"
+    "UNIVERSE_KOSDAQ_TOPN": "50",
+    "UNIVERSE_KOSPI_TOPN": "50",
 }
 
 def _cfg(key: str) -> str:
     """ÌôòÍ≤ΩÎ≥ÄÏàò > CONFIG Í∏∞Î≥∏Í∞í"""
     return os.getenv(key, CONFIG.get(key, ""))
 
 # RK-Max Ïú†Ìã∏(Í∞ÄÎä•ÌïòÎ©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ graceful fallback)
 try:
     from .rkmax_utils import blend_k, recent_features
 except Exception:
     def blend_k(k_month: float, day: int, atr20: Optional[float], atr60: Optional[float]) -> float:
         return float(k_month) if k_month is not None else 0.5
 
     def recent_features(kis, code: str) -> Dict[str, Optional[float]]:
         return {"atr20": None, "atr60": None}
 
 # === [ANCHOR: TICK_UTILS] KRX Ìò∏Í∞ÄÎã®ÏúÑ & ÎùºÏö¥Îî© ===
 def _krx_tick(price: float) -> int:
     p = float(price or 0)
     if p >= 500_000:
         return 1_000
     if p >= 100_000:
         return 500
     if p >= 50_000:
         return 100
     if p >= 10_000:
         return 50
     if p >= 5_000:
         return 10
     if p >= 1_000:
         return 5
     return 1
 
 def _round_to_tick(price: float, mode: str = "nearest") -> int:
     """mode: 'down' | 'up' | 'nearest'"""
     if price is None or price <= 0:
         return 0
     tick = _krx_tick(price)
     q = price / tick
     if mode == "down":
         q = int(q)
     elif mode == "up":
         q = int(q) if q == int(q) else int(q) + 1
     else:
         q = int(q + 0.5)
     return int(q * tick)
 
-logging.basicConfig(level=logging.INFO)
-logger = logging.getLogger(__name__)
-
 LOG_DIR = Path(__file__).parent / "logs"
 LOG_DIR.mkdir(exist_ok=True)
 STATE_FILE = Path(__file__).parent / "trade_state.json"
 
 # Ï¢ÖÎ™©Î≥Ñ ÏãúÏû•ÏΩîÎìú Í≥†Ï†ï Îßµ (Ïã§Ï†ÑÏóêÏÑúÎäî ÎßàÏä§ÌÑ∞ÌÖåÏù¥Î∏î Î°úÎìúÎ°ú ÎåÄÏ≤¥ Í∂åÏû•)
 MARKET_MAP: Dict[str, str] = {
     # ÏòàÏãú: '145020': 'J', '347850': 'J', '257720': 'U', '178320': 'J', '348370': 'U'
 }
 def get_market(code: str) -> str:
     return MARKET_MAP.get(code, "J")  # Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå
 
 # Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå 1Ï∞® Í∞êÏßÄ ÏÉÅÌÉú Ï†ÄÏû•(Ïó∞ÏÜç DATA_EMPTY ÌôïÏù∏Ïö©)
 EXCLUDE_STATE: Dict[str, Dict[str, bool]] = {}
 
 KST = ZoneInfo("Asia/Seoul")
 
+
+def _parse_markets(include: str) -> List[str]:
+    allowed = {"KOSDAQ", "KOSPI"}
+    parts = [p.strip().upper() for p in (include or "").split(",") if p.strip()]
+    parsed = [p for p in parts if p in allowed]
+    if not parsed:
+        logger.warning(
+            f"[UNIVERSE-FALLBACK] Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏãúÏû•Í∞í include={include!r} ‚Üí KOSDAQÎßå ÏÇ¨Ïö©"
+        )
+        return ["KOSDAQ"]
+    seen = set()
+    ordered: List[str] = []
+    for p in parsed:
+        if p in seen:
+            continue
+        ordered.append(p)
+        seen.add(p)
+    return ordered
+
 # ===== Îß§Í∞úÎ≥ÄÏàò(.env ÏóÜÏù¥ÎèÑ CONFIG Í∏∞Î≥∏ÏùÑ ÏÇ¨Ïö©) =====
 SELL_FORCE_TIME_STR = _cfg("SELL_FORCE_TIME").strip()
 SELL_ALL_BALANCES_AT_CUTOFF = _cfg("SELL_ALL_BALANCES_AT_CUTOFF").lower() == "true"
 RATE_SLEEP_SEC = float(_cfg("API_RATE_SLEEP_SEC"))
 FORCE_SELL_PASSES_CUTOFF = int(_cfg("FORCE_SELL_PASSES_CUTOFF"))
 FORCE_SELL_PASSES_CLOSE = int(_cfg("FORCE_SELL_PASSES_CLOSE"))
 PARTIAL1 = float(_cfg("PARTIAL1"))
 PARTIAL2 = float(_cfg("PARTIAL2"))
 TRAIL_PCT = float(_cfg("TRAIL_PCT"))
 FAST_STOP = float(_cfg("FAST_STOP"))
 ATR_STOP = float(_cfg("ATR_STOP"))
 TIME_STOP_HHMM = _cfg("TIME_STOP_HHMM")
 DEFAULT_PROFIT_PCT = float(_cfg("DEFAULT_PROFIT_PCT"))
-DEFAULT_LOSS_PCT = float(_cfg("DEFAULT_LOSS_PCT"))
+DEFAULT_LOSS_PCT = abs(float(_cfg("DEFAULT_LOSS_PCT")))  # Ìï≠ÏÉÅ ÏñëÏàò(Ï†àÎåÄÍ∞í)Î°ú ÏÇ¨Ïö©
 DAILY_CAPITAL = int(_cfg("DAILY_CAPITAL"))
 CAP_CAP = float(_cfg("CAP_CAP"))
 SLIPPAGE_LIMIT_PCT = float(_cfg("SLIPPAGE_LIMIT_PCT"))
 SLIPPAGE_ENTER_GUARD_PCT = float(_cfg("SLIPPAGE_ENTER_GUARD_PCT"))
 VWAP_TOL = float(_cfg("VWAP_TOL"))  # üî∏ VWAP ÌóàÏö© Ïò§Ï∞®(Ïòà: 0.003 = -0.3%ÍπåÏßÄ ÌóàÏö©)
 W_MAX_ONE = float(_cfg("W_MAX_ONE"))
 W_MIN_ONE = float(_cfg("W_MIN_ONE"))
 REBALANCE_ANCHOR = _cfg("REBALANCE_ANCHOR")
 WEEKLY_ANCHOR_REF = _cfg("WEEKLY_ANCHOR_REF").lower()
 MOMENTUM_OVERRIDES_FORCE_SELL = _cfg("MOMENTUM_OVERRIDES_FORCE_SELL").lower() == "true"
 
 # NEW: 1Î∂ÑÎ¥â Î™®Î©òÌÖÄ ÌååÎùºÎØ∏ÌÑ∞
 MOM_FAST = int(_cfg("MOM_FAST") or "5")
 MOM_SLOW = int(_cfg("MOM_SLOW") or "20")
 MOM_TH_PCT = float(_cfg("MOM_TH_PCT") or "0.5")
+# ÏãúÍ∞Ñ Íµ¨Í∞Ñ
+ACTIVE_START_HHMM = _cfg("ACTIVE_START_HHMM")
+FULL_ACTIVE_END_HHMM = _cfg("FULL_ACTIVE_END_HHMM")
+CLOSE_BET_PREP_START_HHMM = _cfg("CLOSE_BET_PREP_START_HHMM")
+CLOSE_BET_ENTRY_START_HHMM = _cfg("CLOSE_BET_ENTRY_START_HHMM")
+MARKET_CLOSE_HHMM = _cfg("MARKET_CLOSE_HHMM")
+# Ï¢ÖÍ∞Ä Î≤†ÌåÖ
+CLOSE_BET_TOPN = int(_cfg("CLOSE_BET_TOPN") or "5")
+CLOSE_BET_CAP_FRACTION = float(_cfg("CLOSE_BET_CAP_FRACTION") or "0.2")
+CLOSE_BET_MIN_RET_PCT = float(_cfg("CLOSE_BET_MIN_RET_PCT") or "3.0")
+CLOSE_BET_MAX_PULLBACK_PCT = float(_cfg("CLOSE_BET_MAX_PULLBACK_PCT") or "3.0")
+CLOSE_BET_MIN_VOL_SPIKE = float(_cfg("CLOSE_BET_MIN_VOL_SPIKE") or "2.0")
+# ÏΩîÏñ¥ Ìè¨ÏßÄÏÖò
+ENABLE_CORE_POSITIONS = _cfg("ENABLE_CORE_POSITIONS").lower() != "false"
+CORE_MAX_FRACTION = float(_cfg("CORE_MAX_FRACTION") or "0.6")
+CORE_W_MAX_ONE = float(_cfg("CORE_W_MAX_ONE") or "0.1")
+CORE_SCAN_TOPN = int(_cfg("CORE_SCAN_TOPN") or "250")
+CORE_BOX_RANGE_PCT = float(_cfg("CORE_BOX_RANGE_PCT") or "5.0")
+CORE_BREAKOUT_PCT = float(_cfg("CORE_BREAKOUT_PCT") or "2.0")
 # Ïã†Í≥†Í∞Ä ‚Üí 3Ïùº ÎàåÎ¶º ‚Üí Î∞òÎì± ÌôïÏù∏ ÌõÑ Îß§Ïàò ÌååÎùºÎØ∏ÌÑ∞
 USE_PULLBACK_ENTRY = _cfg("USE_PULLBACK_ENTRY").lower() != "false"
 PULLBACK_LOOKBACK = int(_cfg("PULLBACK_LOOKBACK") or "60")
 PULLBACK_DAYS = int(_cfg("PULLBACK_DAYS") or "3")
 PULLBACK_REVERSAL_BUFFER_PCT = float(_cfg("PULLBACK_REVERSAL_BUFFER_PCT") or "0.2")
 PULLBACK_TOPN = int(_cfg("PULLBACK_TOPN") or "50")
 PULLBACK_UNIT_WEIGHT = float(_cfg("PULLBACK_UNIT_WEIGHT") or "0.03")
 CHAMPION_MIN_TRADES = int(_cfg("CHAMPION_MIN_TRADES") or "5")
 CHAMPION_MIN_WINRATE = float(_cfg("CHAMPION_MIN_WINRATE") or "45.0")
 CHAMPION_MAX_MDD = float(_cfg("CHAMPION_MAX_MDD") or "30.0")
 CHAMPION_MIN_SHARPE = float(_cfg("CHAMPION_MIN_SHARPE") or "0.0")
+UNIVERSE_INCLUDE_MARKETS = _cfg("UNIVERSE_INCLUDE_MARKETS").upper()
+UNIVERSE_KOSDAQ_TOPN = int(_cfg("UNIVERSE_KOSDAQ_TOPN") or "50")
+UNIVERSE_KOSPI_TOPN = int(_cfg("UNIVERSE_KOSPI_TOPN") or "50")
+UNIVERSE_MARKETS: List[str] = _parse_markets(UNIVERSE_INCLUDE_MARKETS)
 
 # Ï±îÌîºÏñ∏ Îì±Í∏â & GOOD/BAD ÌÉÄÏ†ê ÌåêÎ≥Ñ ÌååÎùºÎØ∏ÌÑ∞
 CHAMPION_A_RULES = {
     "min_trades": 30,
     "min_cumret_pct": 40.0,
     "max_mdd_pct": 25.0,
     "min_win_pct": 50.0,
     "min_sharpe": 1.2,
     "min_turnover": 3_000_000_000,  # 30Ïñµ
 }
 
 GOOD_ENTRY_PULLBACK_RANGE = (5.0, 15.0)  # Ïã†Í≥†Í∞Ä ÎåÄÎπÑ ÎàåÎ¶ºÌè≠(%): ÏµúÏÜå~ÏµúÎåÄ
 GOOD_ENTRY_MA20_RANGE = (1.0, 1.15)  # ÌòÑÏû¨Í∞Ä/20MA ÌóàÏö© Íµ¨Í∞Ñ
 GOOD_ENTRY_MAX_FROM_PEAK = 0.97  # ÌòÑÏû¨Í∞Ä/ÏµúÍ∑ºÍ≥†Ï†ê ÏµúÎåÄÏπò(‚â§0.97)
 GOOD_ENTRY_MIN_RR = 2.0  # Í∏∞ÎåÄÏàòÏùµ/Î¶¨Ïä§ÌÅ¨ ÏµúÏÜå ÎπÑÏú®
 GOOD_ENTRY_MIN_INTRADAY_SIG = 2  # GOOD ÌÉÄÏ†êÏúºÎ°ú Ïù∏Ï†ïÌïòÍ∏∞ ÏúÑÌïú ÏµúÏÜå intraday ÏãúÍ∑∏ÎÑê Í∞úÏàò
 
 BAD_ENTRY_MAX_MA20_DIST = 1.25  # ÌòÑÏû¨Í∞Ä/20MA ÏÉÅÌïú(Ï∂îÍ≤©Îß§Ïàò Î∞©ÏßÄ)
 BAD_ENTRY_MAX_PULLBACK = 20.0  # Ïã†Í≥†Í∞Ä ÎåÄÎπÑ ÎàåÎ¶ºÌè≠ ÏÉÅÌïú(Í≥ºÎèÑÌïú Î∂ïÍ¥¥ Î∞©ÏßÄ)
 BAD_ENTRY_MAX_BELOW_VWAP_RATIO = 0.7  # Î∂ÑÎ¥âÏóêÏÑú VWAP ÏïÑÎûò Ï≤¥Î•ò ÎπÑÏ§ëÏù¥ Ïù¥ Ïù¥ÏÉÅÏù¥Î©¥ BAD
 
 def _parse_hhmm(hhmm: str) -> dtime:
     try:
         hh, mm = hhmm.split(":")
         return dtime(hour=int(hh), minute=int(mm))
     except Exception:
         logger.warning(f"[ÏÑ§Ï†ïÍ≤ΩÍ≥†] SELL_FORCE_TIME ÌòïÏãù Ïò§Î•ò ‚Üí Í∏∞Î≥∏Í∞í 14:40 Ï†ÅÏö©: {hhmm}")
         return dtime(hour=14, minute=40)
 
 SELL_FORCE_TIME = _parse_hhmm(SELL_FORCE_TIME_STR)
 TIME_STOP_TIME = _parse_hhmm(TIME_STOP_HHMM)
+ACTIVE_START_TIME = _parse_hhmm(ACTIVE_START_HHMM)
+FULL_ACTIVE_END_TIME = _parse_hhmm(FULL_ACTIVE_END_HHMM)
+CLOSE_BET_PREP_START_TIME = _parse_hhmm(CLOSE_BET_PREP_START_HHMM)
+CLOSE_BET_ENTRY_START_TIME = _parse_hhmm(CLOSE_BET_ENTRY_START_HHMM)
+MARKET_CLOSE_TIME = _parse_hhmm(MARKET_CLOSE_HHMM)
 ALLOW_WHEN_CLOSED = _cfg("MARKET_DATA_WHEN_CLOSED").lower() == "true"
 
+
+@dataclass
+class TimeModeState:
+    mode: str
+    allow_intraday_entries: bool
+    allow_close_bet_scan: bool
+    allow_close_bet_entry: bool
+
+
+class TimeModeController:
+    def __init__(
+        self,
+        active_start: dtime,
+        full_active_end: dtime,
+        close_bet_prep: dtime,
+        close_bet_entry: dtime,
+        cutoff: dtime,
+        market_close: dtime,
+    ):
+        self.active_start = active_start
+        self.full_active_end = full_active_end
+        self.close_bet_prep = close_bet_prep
+        self.close_bet_entry = close_bet_entry
+        self.cutoff = cutoff
+        self.market_close = market_close
+        self._last_mode: Optional[str] = None
+
+    def evaluate(self, now_dt: datetime) -> TimeModeState:
+        now_time = now_dt.time()
+        if now_time >= self.cutoff:
+            mode = "shutdown"
+            return TimeModeState(mode, False, False, False)
+        if now_time >= self.close_bet_entry:
+            mode = "close_bet_entry"
+            return TimeModeState(mode, False, False, True)
+        if now_time >= self.close_bet_prep:
+            mode = "light_active"
+            return TimeModeState(mode, False, True, False)
+        if now_time >= self.active_start:
+            mode = "full_active"
+            return TimeModeState(mode, True, False, False)
+        mode = "pre_open"
+        return TimeModeState(mode, False, False, False)
+
+    def log_if_changed(self, logger: logging.Logger, state: TimeModeState) -> None:
+        if state.mode != self._last_mode:
+            self._last_mode = state.mode
+            if state.mode == "full_active":
+                logger.info(
+                    f"[TIME-MODE] FULL_ACTIVE ({ACTIVE_START_TIME.strftime('%H:%M')}~{FULL_ACTIVE_END_TIME.strftime('%H:%M')})"
+                )
+            elif state.mode == "light_active":
+                logger.info(
+                    f"[TIME-MODE] LIGHT_ACTIVE ({CLOSE_BET_PREP_START_TIME.strftime('%H:%M')}~{CLOSE_BET_ENTRY_START_TIME.strftime('%H:%M')}) Ïã†Í∑ú ÏßÑÏûÖ Ï†úÌïú, Ï¢ÖÍ∞Ä Î≤†ÌåÖ Ï§ÄÎπÑ"
+                )
+            elif state.mode == "close_bet_entry":
+                logger.info(
+                    f"[TIME-MODE] CLOSE_BET_ENTRY ({CLOSE_BET_ENTRY_START_TIME.strftime('%H:%M')}~{SELL_FORCE_TIME.strftime('%H:%M')})"
+                )
+            elif state.mode == "shutdown":
+                logger.info(
+                    f"[TIME-MODE] SHUTDOWN Ï§ÄÎπÑ (Ïª§Ìä∏Ïò§ÌîÑ {SELL_FORCE_TIME.strftime('%H:%M')} ÎèÑÎã¨ ÏòàÏ†ï)"
+                )
+            else:
+                logger.info(
+                    f"[TIME-MODE] PRE_OPEN (Ïû• ÏãúÏûë Ï†Ñ Ï§ÄÎπÑ)"
+                )
+
+
+class CloseBettingEngine:
+    def __init__(self, topn: int, cap_fraction: float):
+        self.topn = topn
+        self.cap_fraction = cap_fraction
+        self.candidates: List[Dict[str, Any]] = []
+        self.entered: Dict[str, Any] = {}
+
+    def _score_candidate(self, daily_ctx: Dict[str, Any], intraday_ctx: Dict[str, Any]) -> float:
+        ret = daily_ctx.get("ret_today_pct") or 0.0
+        vol_ratio = daily_ctx.get("volume_ratio") or 0.0
+        from_high = intraday_ctx.get("from_high_pct") or 0.0
+        m5 = daily_ctx.get("ma5") or 0.0
+        m20 = daily_ctx.get("ma20") or 0.0
+        trend_bonus = 2.0 if (m5 and m20 and m5 > m20) else 0.0
+        location_score = max(0.0, 5.0 - from_high)
+        return ret * 0.6 + vol_ratio * 3.0 + location_score + trend_bonus
+
+    def scan_candidates(
+        self,
+        kis: KisAPI,
+        now_dt: datetime,
+        universe: Dict[str, Dict[str, Any]],
+        holding: Dict[str, Any],
+        traded: Dict[str, Any],
+    ) -> List[Dict[str, Any]]:
+        self.candidates = []
+        for code, info in universe.items():
+            if code in holding or code in traded:
+                continue
+            try:
+                price = _safe_get_price(kis, code)
+            except Exception:
+                price = None
+            if price is None or price <= 0:
+                continue
+            daily_ctx = _compute_daily_entry_context(kis, code, price)
+            intraday_ctx = _compute_intraday_entry_context(kis, code, prev_high=info.get("prev_high"))
+
+            ret_pct = daily_ctx.get("ret_today_pct")
+            if ret_pct is None or ret_pct < CLOSE_BET_MIN_RET_PCT:
+                continue
+            vol_ratio = daily_ctx.get("volume_ratio") or 0.0
+            if vol_ratio < CLOSE_BET_MIN_VOL_SPIKE:
+                continue
+            from_high = intraday_ctx.get("from_high_pct")
+            if from_high is not None and from_high > CLOSE_BET_MAX_PULLBACK_PCT:
+                continue
+            if intraday_ctx.get("vwap") and intraday_ctx.get("last_close"):
+                if intraday_ctx["last_close"] < intraday_ctx["vwap"]:
+                    continue
+            if daily_ctx.get("ma5") and daily_ctx.get("ma20"):
+                if daily_ctx["ma5"] <= daily_ctx["ma20"]:
+                    continue
+
+            score = self._score_candidate(daily_ctx, intraday_ctx)
+            self.candidates.append(
+                {
+                    "code": code,
+                    "name": info.get("name"),
+                    "price": price,
+                    "score": score,
+                    "daily_ctx": daily_ctx,
+                    "intraday_ctx": intraday_ctx,
+                }
+            )
+
+        self.candidates.sort(key=lambda x: x.get("score", 0.0), reverse=True)
+        picked = self.candidates[: self.topn]
+        if picked:
+            logger.info(
+                "[CLOSE-BET-SCAN] Ï¢ÖÍ∞Ä Î≤†ÌåÖ ÌõÑÎ≥¥ %dÏ¢ÖÎ™© ÌÉêÏÉâ ÏôÑÎ£å: %s",
+                len(picked),
+                ",".join([p.get("code", "") for p in picked]),
+            )
+        else:
+            logger.info("[CLOSE-BET-SCAN] Ï¢ÖÍ∞Ä Î≤†ÌåÖ ÌõÑÎ≥¥ ÏóÜÏùå")
+        return picked
+
+    def enter_close_bets(
+        self,
+        kis: KisAPI,
+        now_dt: datetime,
+        capital_active: int,
+        holding: Dict[str, Any],
+        traded: Dict[str, Any],
+        can_buy: bool,
+    ) -> None:
+        if not can_buy:
+            logger.info("[CLOSE-BET-ENTRY] ÏòàÏàòÍ∏à Î∂ÄÏ°± ‚Üí Ï¢ÖÍ∞Ä Î≤†ÌåÖ Îß§Ïàò Ïä§ÌÇµ")
+            return
+        if not self.candidates:
+            return
+        per_notional = int(max(0, capital_active * self.cap_fraction) / max(1, len(self.candidates)))
+        for cand in self.candidates[: self.topn]:
+            code = cand.get("code")
+            if not code or code in holding or code in traded:
+                continue
+            qty = _notional_to_qty(kis, code, per_notional, ref_price=cand.get("price"))
+            if qty <= 0:
+                continue
+            result = place_buy_with_fallback(kis, code, qty, limit_price=int(cand.get("price") or 0))
+            _init_position_state(
+                kis,
+                holding,
+                code,
+                float(cand.get("price") or 0.0),
+                int(qty),
+                None,
+                cand.get("price"),
+                strategy="CLOSE_BET",
+            )
+            traded[code] = {
+                "buy_time": now_dt.strftime("%Y-%m-%d %H:%M:%S"),
+                "qty": int(qty),
+                "price": float(cand.get("price") or 0.0),
+                "strategy": "CLOSE_BET",
+            }
+            logger.info(
+                "[CLOSE-BET-ENTRY] code=%s qty=%s price=%s score=%.2f",
+                code,
+                qty,
+                cand.get("price"),
+                cand.get("score", 0.0),
+            )
+            log_trade(
+                {
+                    "datetime": now_dt.strftime("%Y-%m-%d %H:%M:%S"),
+                    "code": code,
+                    "name": cand.get("name"),
+                    "qty": int(qty),
+                    "side": "BUY",
+                    "price": cand.get("price"),
+                    "amount": int(qty) * int(cand.get("price") or 0),
+                    "strategy": "Ï¢ÖÍ∞Ä Î≤†ÌåÖ",
+                    "result": result,
+                }
+            )
+
+
+class CorePositionEngine:
+    def __init__(self):
+        self.candidates: List[Dict[str, Any]] = []
+
+    def _is_core_candidate(self, kis: KisAPI, code: str) -> Tuple[bool, Dict[str, Any]]:
+        ctx: Dict[str, Any] = {}
+        try:
+            candles = _get_daily_candles_cached(kis, code, count=220)
+        except Exception as e:
+            return False, {"reason": f"fetch_fail:{e}"}
+        if not candles or len(candles) < 200:
+            return False, {"reason": "not_enough_candles"}
+        today = datetime.now(KST).strftime("%Y%m%d")
+        completed = list(candles)
+        if completed and str(completed[-1].get("date")) == today:
+            completed = completed[:-1]
+        if len(completed) < 200:
+            return False, {"reason": "not_enough_completed"}
+        closes = [float(c.get("close") or 0.0) for c in completed if c.get("close")]
+        highs = [float(c.get("high") or 0.0) for c in completed if c.get("high")]
+        opens = [float(c.get("open") or 0.0) for c in completed if c.get("open")]
+        vols = [float(c.get("volume") or 0.0) for c in completed if c.get("volume")]
+        if len(closes) < 200:
+            return False, {"reason": "close_short"}
+        ma200 = sum(closes[-200:]) / 200.0
+        ctx["ma200"] = ma200
+        last_close = closes[-1]
+        last_open = opens[-1] if opens else last_close
+        box_high = max(closes[-40:])
+        box_low = min(closes[-40:])
+        box_range_pct = (box_high - box_low) / box_low * 100.0 if box_low else 0.0
+        ctx["box_range_pct"] = box_range_pct
+        volume_ratio = 0.0
+        if vols and len(vols) >= 21:
+            volume_ratio = (vols[-1] / (sum(vols[-21:-1]) / 20.0)) if (sum(vols[-21:-1]) > 0) else 0.0
+        ctx["volume_ratio"] = volume_ratio
+        breakout = (
+            box_range_pct <= CORE_BOX_RANGE_PCT
+            and last_close >= ma200 * (1 + CORE_BREAKOUT_PCT / 100.0)
+            and last_close >= last_open * (1 + CORE_BREAKOUT_PCT / 100.0)
+            and volume_ratio >= CLOSE_BET_MIN_VOL_SPIKE
+        )
+        near_ma200 = abs(last_close - ma200) / ma200 * 100.0 <= CORE_BOX_RANGE_PCT
+        ctx["near_ma200"] = near_ma200
+        ctx["breakout"] = breakout
+        return breakout and near_ma200, ctx
+
+    def scan(self, kis: KisAPI, universe: Dict[str, Dict[str, Any]]) -> List[Dict[str, Any]]:
+        self.candidates = []
+        for code, info in universe.items():
+            ok, ctx = self._is_core_candidate(kis, code)
+            if ok:
+                self.candidates.append({"code": code, "name": info.get("name"), "ctx": ctx})
+        if self.candidates:
+            logger.info(
+                "[CORE-SCAN] ÏΩîÏñ¥ Ìè¨ÏßÄÏÖò ÌõÑÎ≥¥ %dÏ¢ÖÎ™© ÌÉêÏÉâ ÏôÑÎ£å: %s",
+                len(self.candidates),
+                ",".join([c.get("code", "") for c in self.candidates]),
+            )
+        return self.candidates
+
+    def enter(
+        self, kis: KisAPI, capital_active: int, holding: Dict[str, Any], traded: Dict[str, Any], can_buy: bool
+    ) -> None:
+        if not self.candidates or capital_active <= 0 or not can_buy:
+            if not can_buy:
+                logger.info("[CORE-ENTRY] ÏòàÏàòÍ∏à Î∂ÄÏ°± ‚Üí ÏΩîÏñ¥ Ìè¨ÏßÄÏÖò Ïã†Í∑ú Îß§Ïàò Ïä§ÌÇµ")
+            return
+        max_core_cap = int(capital_active * CORE_MAX_FRACTION)
+        per_notional = int(max_core_cap * CORE_W_MAX_ONE)
+        for cand in self.candidates:
+            code = cand.get("code")
+            if not code or code in holding or code in traded:
+                continue
+            qty = _notional_to_qty(kis, code, per_notional)
+            if qty <= 0:
+                continue
+            price = _safe_get_price(kis, code)
+            result = place_buy_with_fallback(kis, code, qty, limit_price=int(price or 0))
+            _init_position_state(
+                kis, holding, code, float(price or 0.0), int(qty), None, price, strategy="CORE"
+            )
+            traded[code] = {
+                "buy_time": datetime.now(KST).strftime("%Y-%m-%d %H:%M:%S"),
+                "qty": int(qty),
+                "price": float(price or 0.0),
+                "strategy": "CORE",
+            }
+            logger.info(
+                "[CORE-ENTRY] code=%s Í∞ÄÍ≤©=%s ÎπÑÏ§ë‚âà%.2f%%",
+                code,
+                price,
+                CORE_W_MAX_ONE * 100,
+            )
+            log_trade(
+                {
+                    "datetime": datetime.now(KST).strftime("%Y-%m-%d %H:%M:%S"),
+                    "code": code,
+                    "name": cand.get("name"),
+                    "qty": int(qty),
+                    "side": "BUY",
+                    "price": price,
+                    "amount": int(price or 0) * int(qty),
+                    "strategy": "ÏΩîÏñ¥ Ìè¨ÏßÄÏÖò",
+                    "result": result,
+                }
+            )
+
 # === [NEW] Ï£ºÍ∞Ñ Î¶¨Î∞∏Îü∞Ïã± Í∞ïÏ†ú Ìä∏Î¶¨Í±∞ ÏÉÅÌÉú ÌååÏùº ===
 STATE_WEEKLY_PATH = Path(__file__).parent / "state_weekly.json"
 
 def _this_iso_week_key(now=None):
     now = now or datetime.now(KST)
     return f"{now.year}-W{now.isocalendar().week:02d}"
 
 def _read_last_weekly():
     if not STATE_WEEKLY_PATH.exists():
         return None
     try:
         return (json.loads(STATE_WEEKLY_PATH.read_text(encoding="utf-8"))).get("weekly_rebalanced_at")
     except Exception:
         return None
 
 def _write_last_weekly(now=None):
     now = now or datetime.now(KST)
     try:
         STATE_WEEKLY_PATH.write_text(
             json.dumps({"weekly_rebalanced_at": _this_iso_week_key(now)}, ensure_ascii=False),
             encoding="utf-8",
         )
     except Exception as e:
         logger.warning(f"[STATE_WRITE_FAIL] weekly: {e}")
 
@@ -268,67 +691,109 @@ def get_rebalance_anchor_date(now: Optional[datetime] = None) -> str:
     weekly Î™®ÎìúÏóêÏÑú Í∏∞Ï§ÄÏùº ÏÇ∞Ï†ï:
       - WEEKLY_ANCHOR_REF='last'  ‚Üí ÏßÅÏ†Ñ ÏùºÏöîÏùº(Í∏∞Î≥∏)
       - WEEKLY_ANCHOR_REF='next'  ‚Üí Îã§Ïùå ÏùºÏöîÏùº
     """
     now = now or datetime.now(KST)
     today = now.date()
 
     if REBALANCE_ANCHOR == "weekly":
         ref = WEEKLY_ANCHOR_REF if WEEKLY_ANCHOR_REF in ("last", "next", "prev", "previous") else "last"
         if ref in ("last", "prev", "previous"):
             # Ïõî(0)~Ïùº(6). 'ÏùºÏöîÏùºÎ°úÎ∂ÄÌÑ∞ ÏßÄÎÇú ÏùºÏàò' = (weekday+1) % 7
             days_since_sun = (today.weekday() + 1) % 7
             anchor_date = today - timedelta(days=days_since_sun)
         else:
             # Îã§Ïùå ÏùºÏöîÏùºÍπåÏßÄ ÎÇ®ÏùÄ ÏùºÏàò
             days_to_sun = (6 - today.weekday()) % 7
             anchor_date = today + timedelta(days=days_to_sun)
         return anchor_date.strftime("%Y-%m-%d")
 
     if REBALANCE_ANCHOR == "today":
         return today.strftime("%Y-%m-%d")
 
     # monthly
     return today.replace(day=1).strftime("%Y-%m-%d")
 
-def fetch_rebalancing_targets(date: str) -> List[Dict[str, Any]]:
+def fetch_rebalancing_targets(kis: KisAPI, date: str) -> List[Dict[str, Any]]:
+    include_markets = UNIVERSE_MARKETS or ["KOSDAQ"]
+    as_of = None
+    try:
+        as_of = datetime.strptime(date, "%Y-%m-%d")
+    except Exception:
+        as_of = None
+
     REBALANCE_API_URL = f"http://localhost:8000/rebalance/run/{date}?force_order=true"
+    universe_map: Dict[str, str] = {}
+    try:
+        combined_universe = get_kosdaq_kospi_top_n(
+            kis,
+            top_n_kosdaq=UNIVERSE_KOSDAQ_TOPN,
+            top_n_kospi=UNIVERSE_KOSPI_TOPN,
+            as_of=as_of,
+        )
+        universe_map = {str(ent.get("Code") or ent.get("code") or "").zfill(6): ent.get("market") for ent in combined_universe}
+    except Exception as e:
+        logger.warning(f"[UNIVERSE-MAP-FAIL] ÌÜµÌï© Ïú†ÎãàÎ≤ÑÏä§ ÏÉùÏÑ± Ïã§Ìå®: {e}")
+
     response = requests.post(REBALANCE_API_URL)
     logger.info(f"[üõ∞Ô∏è Î¶¨Î∞∏Îü∞Ïã± API Ï†ÑÏ≤¥ ÏùëÎãµ]: {response.text}")
     if response.status_code == 200:
         data = response.json()
         selected = data.get("selected") or data.get("selected_stocks") or []
+
+        if include_markets:
+            filtered: List[Dict[str, Any]] = []
+            for ent in selected:
+                code = str(ent.get("stock_code") or ent.get("code") or "").zfill(6)
+                market = (ent.get("market") or universe_map.get(code) or "").upper()
+                if market and market not in include_markets:
+                    continue
+                if market:
+                    ent["market"] = market
+                filtered.append(ent)
+            selected = filtered
+
         logger.info(f"[üéØ Î¶¨Î∞∏Îü∞Ïã± Ï¢ÖÎ™©]: {selected}")
         # Ï±îÌîºÏñ∏ & Î†àÏßê ÏÉÅÏÑ∏ Î°úÍ∑∏
         try:
             champion = selected[0] if selected else None
             log_champion_and_regime(logger, champion, REGIME_STATE, context="rebalance_api")
         except Exception as e:
             logger.exception(f"[VWAP_CHAMPION_LOG_ERROR] {e}")
         return selected
-    else:
-        raise Exception(f"Î¶¨Î∞∏Îü∞Ïã± API Ìò∏Ï∂ú Ïã§Ìå®: {response.text}")
+
+    logger.error(f"[REBALANCE-API-FAIL] status={response.status_code} text={response.text}")
+    if universe_map:
+        fallback: List[Dict[str, Any]] = []
+        for code, market in universe_map.items():
+            if market and market.upper() not in include_markets:
+                continue
+            fallback.append({"code": code, "name": None, "market": market})
+        if fallback:
+            logger.warning("[REBALANCE-FALLBACK] API Ïã§Ìå® ‚Üí ÏãúÏ¥ù TopN Ïú†ÎãàÎ≤ÑÏä§ Î∞òÌôò")
+            return fallback
+    raise Exception(f"Î¶¨Î∞∏Îü∞Ïã± API Ìò∏Ï∂ú Ïã§Ìå®: {response.text}")
 
 def log_trade(trade: dict) -> None:
     today = datetime.now(KST).strftime("%Y-%m-%d")
     logfile = LOG_DIR / f"trades_{today}.json"
     with open(logfile, "a", encoding="utf-8") as f:
         f.write(json.dumps(trade, ensure_ascii=False) + "\n")
 
 def save_state(holding: Dict[str, Any], traded: Dict[str, Any]) -> None:
     with open(STATE_FILE, "w", encoding="utf-8") as f:
         json.dump({"holding": holding, "traded": traded}, f, ensure_ascii=False, indent=2)
 
 def load_state() -> Tuple[Dict[str, Any], Dict[str, Any]]:
     if STATE_FILE.exists():
         with open(STATE_FILE, "r", encoding="utf-8") as f:
             state = json.load(f)
         return state.get("holding", {}), state.get("traded", {})
     return {}, {}
 
 def _with_retry(func, *args, max_retries=5, base_delay=0.6, **kwargs):
     last_err = None
     for attempt in range(1, max_retries + 1):
         try:
             return func(*args, **kwargs)
         except Exception as e:
             last_err = e
@@ -644,72 +1109,127 @@ def _classify_champion_grade(info: Dict[str, Any]) -> str:
     if (
         trades >= CHAMPION_MIN_TRADES
         and win >= CHAMPION_MIN_WINRATE
         and mdd <= CHAMPION_MAX_MDD
         and sharpe >= CHAMPION_MIN_SHARPE
     ):
         return "B"
 
     return "C"
 
 
 def _compute_daily_entry_context(
     kis: KisAPI, code: str, current_price: Optional[float]
 ) -> Dict[str, Any]:
     ctx: Dict[str, Any] = {"current_price": current_price}
     try:
         candles = _get_daily_candles_cached(kis, code, count=max(PULLBACK_LOOKBACK, 60))
     except Exception:
         return ctx
 
     today = datetime.now(KST).strftime("%Y%m%d")
     completed = list(candles)
     if completed and str(completed[-1].get("date")) == today:
         completed = completed[:-1]
 
+    # intraday(Ïò§Îäò) Í∞ÄÍ≤©/Í±∞ÎûòÎüâ Î≥¥Ï†ï
+    intraday_candles: List[Dict[str, Any]] = []
+    try:
+        intraday_candles = _get_intraday_1min(kis, code, count=240)
+    except Exception:
+        intraday_candles = []
+    if intraday_candles:
+        try:
+            last_candle = intraday_candles[-1]
+            last_px = float(
+                last_candle.get("close")
+                or last_candle.get("trade_price")
+                or last_candle.get("price")
+                or 0.0
+            )
+            if (current_price is None or current_price <= 0) and last_px > 0:
+                current_price = last_px
+                ctx["current_price"] = last_px
+        except Exception:
+            pass
+
     if not completed:
         return ctx
 
     closes = [float(c.get("close") or 0.0) for c in completed if c.get("close")]
     highs = [float(c.get("high") or 0.0) for c in completed if c.get("high")]
     lows = [float(c.get("low") or 0.0) for c in completed if c.get("low")]
 
+    if len(closes) >= 5:
+        ma5 = sum(closes[-5:]) / 5.0
+        ctx["ma5"] = ma5
+    if len(closes) >= 10:
+        ma10 = sum(closes[-10:]) / 10.0
+        ctx["ma10"] = ma10
     if len(closes) >= 20:
         ma20 = sum(closes[-20:]) / 20.0
         ctx["ma20"] = ma20
         if current_price:
             ctx["ma20_ratio"] = current_price / ma20
             ctx["ma20_risk"] = max(0.0, current_price - ma20)
+    if len(closes) >= 200:
+        ma200 = sum(closes[-200:]) / 200.0
+        ctx["ma200"] = ma200
 
     if highs:
         window_60 = highs[-60:] if len(highs) >= 60 else highs
         peak_price = max(window_60)
         ctx["peak_price"] = peak_price
         if current_price and peak_price > 0:
             ctx["distance_to_peak"] = current_price / peak_price
             ctx["pullback_depth_pct"] = (peak_price - current_price) / peak_price * 100.0
 
+    if len(closes) >= 1:
+        prev_close = closes[-1]
+        ctx["prev_close"] = prev_close
+        last_price_ref = current_price or ctx.get("current_price")
+        if last_price_ref and prev_close:
+            ctx["ret_today_pct"] = (float(last_price_ref) - prev_close) / prev_close * 100.0
+
+    if lows and highs and len(lows) == len(highs) == len(closes):
+        vol = [float(c.get("volume") or 0.0) for c in completed if c.get("volume") is not None]
+        session_vol = 0.0
+        if intraday_candles:
+            try:
+                session_vol = sum(float(c.get("volume") or c.get("trade_volume") or 0.0) for c in intraday_candles)
+            except Exception:
+                session_vol = 0.0
+        if vol:
+            ctx["volume_avg20"] = sum(vol[-20:]) / min(20, len(vol))
+            if session_vol > 0:
+                ctx["volume_today"] = session_vol
+            elif vol:
+                ctx["volume_today"] = vol[-1]
+            base = ctx.get("volume_avg20") or 0.0
+            if base > 0:
+                ctx["volume_ratio"] = (ctx.get("volume_today") or 0.0) / base
+
     # Ïó∞ÏÜç ÌïòÎùΩ ÏùºÏàò Ï≤¥ÌÅ¨ (Ïã†Í≥†Í∞Ä Ïù¥ÌõÑ ÎàåÎ¶º ÌåêÎã®)
     down_streak = 0
     for idx in range(len(completed) - 1, 0, -1):
         cur = float(completed[idx].get("close") or 0.0)
         prev = float(completed[idx - 1].get("close") or 0.0)
         if cur <= 0 or prev <= 0:
             break
         if cur < prev:
             down_streak += 1
         else:
             break
     ctx["down_streak"] = down_streak
 
     try:
         atr = _get_atr(kis, code)
         if atr:
             ctx["atr"] = float(atr)
     except Exception:
         pass
 
     if closes and highs:
         recent_high = max(highs[-20:])
         ctx["recent_high_20"] = recent_high
         ctx["setup_ok"] = bool(
             down_streak >= 2
@@ -733,50 +1253,58 @@ def _compute_intraday_entry_context(
     vwap_val = _compute_vwap_from_1min(candles)
     ctx["vwap"] = vwap_val
     last = candles[-1]
     last_close = _to_float(last.get("close"), None)
     last_high = _to_float(last.get("high") or last.get("close"), None)
     last_low = _to_float(last.get("low") or last.get("close"), None)
     ctx["last_close"] = last_close
     ctx["last_high"] = last_high
     ctx["last_low"] = last_low
 
     if vwap_val and last_close:
         ctx["vwap_reclaim"] = last_close >= vwap_val
 
     highs = [
         float(c.get("high") or c.get("close") or 0.0)
         for c in candles
         if c.get("high") or c.get("close")
     ]
     lows = [
         float(c.get("low") or c.get("close") or 0.0)
         for c in candles
         if c.get("low") or c.get("close")
     ]
     vols = [float(c.get("volume") or 0.0) for c in candles]
 
+    if highs:
+        session_high = max(highs)
+        ctx["session_high"] = session_high
+        if last_close:
+            ctx["from_high_pct"] = (session_high - float(last_close)) / session_high * 100.0
+    if lows:
+        ctx["session_low"] = min(lows)
+
     if highs:
         box_high = max(highs[-20:])
         box_low = min(lows[-20:]) if lows else None
         if last_high is not None and box_high:
             ctx["range_break"] = last_high >= box_high * 0.999
         if last_low is not None and box_low:
             ctx["box_floor"] = box_low
 
     if vols and len(vols) >= 10:
         recent_vol = sum(vols[-5:]) / 5.0
         base_vol = sum(vols[:-5]) / max(1, len(vols) - 5)
         if base_vol > 0:
             ctx["volume_spike"] = recent_vol >= base_vol * 1.5
 
     if vwap_val:
         below = sum(1 for c in candles if _to_float(c.get("close"), 0.0) < vwap_val)
         ctx["below_vwap_ratio"] = below / len(candles)
 
     if prev_high and last_high:
         ctx["prev_high_retest"] = last_high >= float(prev_high) * 0.999
 
     return ctx
 
 
 def is_bad_entry(
@@ -1113,82 +1641,92 @@ def _notional_to_qty(
             if kis.is_market_open():
                 price = _safe_get_price(kis, code)
             else:
                 if hasattr(kis, "get_close_price"):
                     try:
                         price = float(kis.get_close_price(code))
                     except Exception:
                         price = None
         except Exception:
             price = None
 
     if price is None or price <= 0:
         return 0
 
     return max(0, int(notional // int(price)))
 # === ATR, ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî ===
 def _get_atr(kis: KisAPI, code: str, window: int = 14) -> Optional[float]:
     if hasattr(kis, "get_atr"):
         try:
             return kis.get_atr(code, window=window)
         except Exception as e:
             logger.warning(f"[ATR_FAIL] {code}: {e}")
             return None
     return None
 
-def _init_position_state(kis: KisAPI, holding: Dict[str, Any], code: str, entry_price: float, qty: int, k_value: Any, target_price: Optional[float]) -> None:
+def _init_position_state(
+    kis: KisAPI,
+    holding: Dict[str, Any],
+    code: str,
+    entry_price: float,
+    qty: int,
+    k_value: Any,
+    target_price: Optional[float],
+    strategy: Optional[str] = None,
+) -> None:
     try:
         _ = kis.is_market_open()
     except Exception:
         pass
     atr = _get_atr(kis, code)
     rng_eff = (atr * 1.5) if (atr and atr > 0) else max(1.0, entry_price * 0.01)
     t1 = entry_price + 0.5 * rng_eff
     t2 = entry_price + 1.0 * rng_eff
     holding[code] = {
         'qty': int(qty),
         'buy_price': float(entry_price),
         'entry_time': datetime.now(KST).isoformat(),
         'high': float(entry_price),
         'tp1': float(t1),
         'tp2': float(t2),
         'sold_p1': False,
         'sold_p2': False,
         'trail_pct': TRAIL_PCT,
         'atr': float(atr) if atr else None,
         'stop_abs': float(entry_price - ATR_STOP * atr) if atr else float(entry_price * (1 - FAST_STOP)),
         'k_value': k_value,
         'target_price_src': float(target_price) if target_price is not None else None,
         'bear_s1_done': False,
         'bear_s2_done': False,
         # ÎàåÎ¶ºÎ™© 3Îã®Í≥Ñ ÏßÑÏûÖ Í¥ÄÎ†® Í∏∞Î≥∏Í∞í (Ïã†Í∑ú Îß§Ïàò ÏßÅÌõÑ overwrite Í∞ÄÎä•)
         'entry_stage': 1,
         'max_price_after_entry': float(entry_price),
         'planned_total_qty': int(qty),
         'stage1_qty': int(qty),
         'stage2_qty': 0,
         'stage3_qty': 0,
+        'strategy': strategy,
     }
 
 def _init_position_state_from_balance(kis: KisAPI, holding: Dict[str, Any], code: str, avg_price: float, qty: int) -> None:
     if qty <= 0 or code in holding:
         return
     try:
         _ = kis.is_market_open()
     except Exception:
         pass
     atr = _get_atr(kis, code)
     rng_eff = (atr * 1.5) if (atr and atr > 0) else max(1.0, avg_price * 0.01)
     t1 = avg_price + 0.5 * rng_eff
     t2 = avg_price + 1.0 * rng_eff
     holding[code] = {
         'qty': int(qty),
         'buy_price': float(avg_price),
         'entry_time': (datetime.now(KST) - timedelta(minutes=10)).isoformat(),
         'high': float(avg_price),
         'tp1': float(t1),
         'tp2': float(t2),
         'sold_p1': False,
         'sold_p2': False,
         'trail_pct': TRAIL_PCT,
         'atr': float(atr) if atr else None,
         'stop_abs': float(avg_price - ATR_STOP * atr) if atr else float(avg_price * (1 - FAST_STOP)),
@@ -1962,98 +2500,111 @@ def _adaptive_exit(
 
     # === ÏÉÅÌÉú/Í∏∞Ï¥à Í∞í ===
     qty = _to_int(pos.get("qty"), 0)
     if qty <= 0:
         logger.warning(f"[EXIT-FAIL] {code} qty<=0")
         return None, None, None, None
 
     buy_price = float(pos.get("buy_price", 0.0)) or 0.0
     if buy_price <= 0:
         logger.warning(f"[EXIT-FAIL] {code} buy_price<=0")
         return None, None, None, None
 
     # ÏµúÍ≥†Í∞Ä(high) Í∞±Ïã†
     pos["high"] = max(float(pos.get("high", cur)), float(cur))
     max_price = float(pos["high"])
 
     # ÌòÑÏû¨ ÎàÑÏ†Å ÏàòÏùµÎ•†
     pnl_pct = (cur - buy_price) / buy_price * 100.0
 
     # Î∂ÄÎ∂Ñ ÏùµÏ†à ÌîåÎûòÍ∑∏ & ÎπÑÏú®
     sold_p1 = bool(pos.get("sold_p1", False))
     sold_p2 = bool(pos.get("sold_p2", False))
     qty_p1 = max(1, int(qty * PARTIAL1))
     qty_p2 = max(1, int(qty * PARTIAL2))
 
+    strategy = (pos.get("strategy") or "").upper()
+
     # === Î†àÏßê Í∏∞Î∞ò TP/Ìä∏Î†àÏùºÎßÅ ÏÑ§Ï†ï ===
     base_tp1 = DEFAULT_PROFIT_PCT        # Î≥¥ÌÜµ 3.0
     base_tp2 = DEFAULT_PROFIT_PCT * 2    # 6.0
     trail_down_frac = 0.018              # Í∏∞Î≥∏: Í≥†Ï†êÎåÄÎπÑ 1.8% ÎêòÎèåÎ¶¨Î©¥ Ïª∑
 
+    # Ï†ÑÎûµÎ≥Ñ Í∏∞Î≥∏Í∞í override
+    if strategy == "CLOSE_BET":
+        base_tp1 = 3.0
+        base_tp2 = 6.0
+        trail_down_frac = 0.02
+        hard_stop_pct = 4.0
+    elif strategy == "CORE":
+        base_tp1 = 20.0
+        base_tp2 = 35.0
+        trail_down_frac = 0.08
+        hard_stop_pct = 8.0
+    else:
+        hard_stop_pct = DEFAULT_LOSS_PCT
+
     # (ÏÑ†ÌÉù) Î™®Î©òÌÖÄ Ï†ïÎ≥¥Î•º Ïì∞Í≥† Ïã∂ÏúºÎ©¥ Ïó¨Í∏∞ÏÑú strong_mom Í≥ÑÏÇ∞
     strong_mom = False
     try:
         # metricsÏóê is_strong_momentumÏù¥ ÏûàÎã§Î©¥ ÏÇ¨Ïö©, ÏóÜÏúºÎ©¥ False Ïú†ÏßÄ
         strong_mom = bool(is_strong_momentum(kis, code))
     except Exception:
         strong_mom = False
 
     if regime_mode == "bull":
         # Ï¢ãÏùÄ Ïû•: Í∏∞Î≥∏ Î™©Ìëú ÏÉÅÌñ•
         tp1 = base_tp1 + 1.0      # 4%
         tp2 = base_tp2 + 2.0      # 8%
         trail_down_frac = 0.025   # 2.5%
 
         if strong_mom:
             # Ïû•ÎèÑ Ï¢ãÍ≥† Î™®Î©òÌÖÄÎèÑ Í∞ïÌïòÎ©¥ Ìïú Î≤à Îçî ÏÉÅÌñ•
             tp1 += 1.0            # 5%
             tp2 += 2.0            # 10%
             trail_down_frac = 0.03
 
     elif regime_mode == "neutral":
         tp1 = base_tp1            # 3%
         tp2 = base_tp2            # 6%
         trail_down_frac = 0.018
 
         if strong_mom:
             tp1 = base_tp1 + 1.0  # 4%
             tp2 = base_tp2 + 2.0  # 8%
             trail_down_frac = 0.02
 
     elif regime_mode == "bear":
         # ÏïΩÏÑ∏Ïû•: Î≥¥ÏàòÏ†ÅÏúºÎ°ú
         tp1 = 2.0
         tp2 = 4.0
         trail_down_frac = 0.01
     else:
         tp1 = base_tp1
         tp2 = base_tp2
         trail_down_frac = 0.018
 
-    # ÏÜêÏ†à Í∏∞Ï§Ä
-    hard_stop_pct = DEFAULT_LOSS_PCT
-
     sell_size: int = 0
 
     # === 1) ÏÜêÏ†à ===
     if pnl_pct <= -hard_stop_pct:
         reason = f"ÏÜêÏ†à {hard_stop_pct:.1f}%"
         sell_size = qty
 
     # === 2) 2Ï∞® TP (Îçî ÎÜíÏùÄ ÏàòÏùµ Íµ¨Í∞Ñ) ===
     elif (pnl_pct >= tp2) and (not sold_p2) and qty > 1:
         reason = f"2Ï∞® ÏùµÏ†à {tp2:.1f}%"
         sell_size = min(qty, qty_p2)
         pos["sold_p2"] = True
 
     # === 3) 1Ï∞® TP ===
     elif (pnl_pct >= tp1) and (not sold_p1) and qty > 1:
         reason = f"1Ï∞® ÏùµÏ†à {tp1:.1f}%"
         sell_size = min(qty, qty_p1)
         pos["sold_p1"] = True
 
     else:
         # === 4) Ìä∏Î†àÏùºÎßÅ Ïä§ÌÉë ===
         if max_price >= buy_price * (1 + tp1 / 100.0) and cur <= max_price * (1 - trail_down_frac):
             reason = f"Ìä∏Î†àÏùºÎßÅÏä§ÌÜ±({trail_down_frac*100:.1f}%)"
             sell_size = qty
         else:
@@ -2084,67 +2635,78 @@ def _adaptive_exit(
                 }
             )
         except Exception as e:
             logger.warning(f"[EXIT-LOG-FAIL] {code}: {e}")
 
     except Exception as e:
         logger.error(f"[SELL-FAIL] {code} qty={sell_size} err={e}")
         # Îß§ÎèÑ Ïã§Ìå® ÏãúÏóêÎäî ÏÉÅÌÉú ÏõêÎ≥µÌïòÏßÄ ÏïäÍ≥†, Îã§Ïùå Î£®ÌîÑÏóêÏÑú Îã§Ïãú ÌåêÎã®
         return None, None, None, None
 
     return reason, exec_px, result, sold_qty
 
 
 def main():
     kis = KisAPI()
 
     rebalance_date = get_rebalance_anchor_date()
     logger.info(f"[‚ÑπÔ∏è Î¶¨Î∞∏Îü∞Ïã± Í∏∞Ï§ÄÏùº(KST)]: {rebalance_date} (anchor={REBALANCE_ANCHOR}, ref={WEEKLY_ANCHOR_REF})")
     logger.info(
         f"[‚è±Ô∏è Ïª§Ìä∏Ïò§ÌîÑ(KST)] SELL_FORCE_TIME={SELL_FORCE_TIME.strftime('%H:%M')} / Ï†ÑÏ≤¥ÏûîÍ≥†Îß§ÎèÑ={SELL_ALL_BALANCES_AT_CUTOFF} / "
         f"Ìå®Ïä§(Ïª§Ìä∏Ïò§ÌîÑ/ÎßàÍ∞ê)={FORCE_SELL_PASSES_CUTOFF}/{FORCE_SELL_PASSES_CLOSE}"
     )
     logger.info(f"[üí∞ DAILY_CAPITAL] {DAILY_CAPITAL:,}Ïõê")
     logger.info(f"[üõ°Ô∏è SLIPPAGE_ENTER_GUARD_PCT] {SLIPPAGE_ENTER_GUARD_PCT:.2f}%")
 
+    time_controller = TimeModeController(
+        active_start=ACTIVE_START_TIME,
+        full_active_end=FULL_ACTIVE_END_TIME,
+        close_bet_prep=CLOSE_BET_PREP_START_TIME,
+        close_bet_entry=CLOSE_BET_ENTRY_START_TIME,
+        cutoff=SELL_FORCE_TIME,
+        market_close=MARKET_CLOSE_TIME,
+    )
+    close_bet_engine = CloseBettingEngine(CLOSE_BET_TOPN, CLOSE_BET_CAP_FRACTION)
+    core_engine = CorePositionEngine()
+
     # ÏÉÅÌÉú Î≥µÍµ¨
     holding, traded = load_state()
     logger.info(f"[ÏÉÅÌÉúÎ≥µÍµ¨] holding: {list(holding.keys())}, traded: {list(traded.keys())}")
 
     # === [NEW] Ï£ºÍ∞Ñ Î¶¨Î∞∏Îü∞Ïã± Í∞ïÏ†ú/Ï§ëÎ≥µ Î∞©ÏßÄ ===
     targets: List[Dict[str, Any]] = []
     if REBALANCE_ANCHOR == "weekly":
         if should_weekly_rebalance_now():
-            targets = fetch_rebalancing_targets(rebalance_date)
+            targets = fetch_rebalancing_targets(kis, rebalance_date)
             # Ï§ëÎ≥µ Ïã§Ìñâ Î∞©ÏßÄÎ•º ÏúÑÌï¥ Ï¶âÏãú Ïä§ÌÉ¨ÌîÑ(ÌïÑÏöî Ïãú FORCEÎ°ú Ïû¨Ïã§Ìñâ Í∞ÄÎä•)
             stamp_weekly_done()
             logger.info(f"[REBALANCE] Ïù¥Î≤à Ï£º Î¶¨Î∞∏Îü∞Ïã± Ïã§Ìñâ Í∏∞Î°ù Ï†ÄÏû•({_this_iso_week_key()})")
         else:
             logger.info("[REBALANCE] Ïù¥Î≤à Ï£º Ïù¥ÎØ∏ Ïã§ÌñâÎê® ‚Üí Ïã†Í∑ú Î¶¨Î∞∏Îü∞Ïã± ÏÉùÎûµ (Î≥¥Ïú† Í¥ÄÎ¶¨Îßå)")
     else:
         # today/monthly Îì± Îã§Î•∏ ÏïµÏª§ Î™®ÎìúÎäî Í∏∞Ï°¥ Î∞©ÏãùÏúºÎ°ú Î∞îÎ°ú Ìò∏Ï∂ú
-        targets = fetch_rebalancing_targets(rebalance_date)
+        targets = fetch_rebalancing_targets(kis, rebalance_date)
 
     # === [NEW] ÏòàÏÇ∞ Í∞ÄÎìú: ÏòàÏàòÍ∏àÏù¥ 0/Î∂ÄÏ°±Ïù¥Î©¥ Ïã†Í∑ú Îß§ÏàòÎßå Ïä§ÌÇµ ===
     can_buy = True
     try:
         cash = kis.get_cash_available_today()
         logger.info(f"[BUDGET] today cash available = {cash:,} KRW")
         if cash <= 0:
             can_buy = False
             logger.warning("[BUDGET] Í∞ÄÏö©ÌòÑÍ∏à 0 ‚Üí Ïã†Í∑ú Îß§Ïàò Ïä§ÌÇµ(Î≥¥Ïú† Í¥ÄÎ¶¨Îßå ÏàòÌñâ)")
     except Exception as e:
         logger.error(f"[BUDGET_FAIL] ÏòàÏàòÍ∏à Ï°∞Ìöå Ïã§Ìå®: {e}")
         # Ïã§Ìå® ÏãúÏóêÎäî ÏùºÎã® Î≥¥ÏàòÏ†ÅÏúºÎ°ú Ïã†Í∑úÎß§Ïàò Ïä§ÌÇµ
         can_buy = False
 
     # Î¶¨Î∞∏Îü∞Ïã± ÎåÄÏÉÅ ÌõÑÏ≤òÎ¶¨: qty ÏóÜÍ≥† weightÎßå ÏûàÏúºÎ©¥ DAILY_CAPITALÎ°ú ÏàòÎüâ Í≥ÑÏÇ∞
     processed_targets: Dict[str, Any] = {}
     for t in targets:
         code = t.get("stock_code") or t.get("code")
         if not code:
             continue
         name = t.get("name") or t.get("Ï¢ÖÎ™©Î™Ö")
         k_best = t.get("best_k") or t.get("K") or t.get("k")
         target_price = _to_float(t.get("Î™©ÌëúÍ∞Ä") or t.get("target_price"))
         qty = _to_int(t.get("Îß§ÏàòÏàòÎüâ") or t.get("qty"), 0)
         weight = t.get("weight")
@@ -2362,90 +2924,112 @@ def main():
 
     for code in picked:
         if code in processed_targets:
             selected_targets[code] = processed_targets[code]
 
     logger.info(
         "[REGIME-CHAMPIONS] mode=%s stage=%s n_active=%s picked=%s capital_active=%s",
         mode,
         stage,
         n_active,
         picked,
         f"{capital_active:,}",
     )
 
     logger.info(
         "[REBALANCE] Î†àÏßê=%s pct=%.2f%%, ÌõÑÎ≥¥ %dÍ∞ú Ï§ë ÏÉÅÏúÑ %dÏ¢ÖÎ™©Îßå ÏÑ†ÌÉù: %s",
         mode,
         pct_change,
         len(processed_targets),
         len(selected_targets),
         ",".join(selected_targets.keys()),
     )
 
     code_to_target: Dict[str, Any] = selected_targets
 
-    # ÎàåÎ¶ºÎ™© Ïä§Ï∫îÏö© ÏΩîÏä§Îã• ÏãúÏ¥ù ÏÉÅÏúÑ Î¶¨Ïä§Ìä∏ (Ï±îÌîºÏñ∏Í≥º Î≥ÑÎèÑÎ°ú Í¥ÄÎ¶¨)
+    # ÎàåÎ¶ºÎ™© Ïä§Ï∫îÏö© ÏãúÏ¥ù ÏÉÅÏúÑ Î¶¨Ïä§Ìä∏ (ÏãúÏû•Î≥Ñ Íµ¨ÏÑ±)
     pullback_watch: Dict[str, Dict[str, Any]] = {}
     if USE_PULLBACK_ENTRY:
         try:
             pb_weight = max(0.0, min(PULLBACK_UNIT_WEIGHT, 1.0))
             base_notional = int(round(capital_active * pb_weight))
-            pb_df = get_kosdaq_top_n(date_str=rebalance_date, n=PULLBACK_TOPN)
-            for _, row in pb_df.iterrows():
-                code = str(row.get("Code") or row.get("code") or "").zfill(6)
-                if not code:
-                    continue
-                pullback_watch[code] = {
-                    "code": code,
-                    "name": row.get("Name") or row.get("name"),
-                    "notional": base_notional,
-                }
+            try:
+                as_of_dt = datetime.strptime(rebalance_date, "%Y-%m-%d")
+            except Exception:
+                as_of_dt = None
+
+            for market in UNIVERSE_MARKETS:
+                if market == "KOSDAQ":
+                    pb_df = get_kosdaq_top_n(date_str=rebalance_date, n=PULLBACK_TOPN)
+                else:
+                    pb_df = get_kospi_top_n(kis, top_n=PULLBACK_TOPN, as_of=as_of_dt)
+
+                if hasattr(pb_df, "iterrows"):
+                    iterator = pb_df.iterrows()
+                    entries = [(row.get("Code") or row.get("code"), row) for _, row in iterator]
+                elif isinstance(pb_df, list):
+                    entries = [(ent.get("Code") or ent.get("code"), ent) for ent in pb_df]
+                else:
+                    entries = []
+
+                for code_raw, row in entries:
+                    code = str(code_raw or "").zfill(6)
+                    if not code:
+                        continue
+                    pullback_watch[code] = {
+                        "code": code,
+                        "name": row.get("Name") or row.get("name"),
+                        "market": market,
+                        "notional": base_notional,
+                    }
             logger.info(
-                f"[PULLBACK-WATCH] ÏΩîÏä§Îã• ÏãúÏ¥ù Top{PULLBACK_TOPN} {len(pullback_watch)}Ï¢ÖÎ™© Ïä§Ï∫î Ï§ÄÎπÑ"
+                f"[PULLBACK-WATCH] ÏãúÏû• {','.join(UNIVERSE_MARKETS)} Top{PULLBACK_TOPN}√óÍ∞Å ÏãúÏû• {len(pullback_watch)}Ï¢ÖÎ™© Ïä§Ï∫î Ï§ÄÎπÑ"
             )
         except Exception as e:
             logger.warning(f"[PULLBACK-WATCH-FAIL] ÏãúÏ¥ù ÏÉÅÏúÑ Î°úÎìú Ïã§Ìå®: {e}")
 
     loop_sleep_sec = 2.5  # Î©îÏù∏ Î£®ÌîÑ ÎåÄÍ∏∞ ÏãúÍ∞Ñ(Ï¥à)
 
     try:
         while True:
             # === ÏΩîÏä§Îã• Î†àÏßê ÏóÖÎç∞Ïù¥Ìä∏ ===
             regime = _update_market_regime(kis)
             pct_txt = f"{regime.get('pct_change'):.2f}%" if regime.get("pct_change") is not None else "N/A"
             logger.info(f"[REGIME] mode={regime['mode']} stage={regime['bear_stage']} pct={pct_txt}")
 
             # Ïû• ÏÉÅÌÉú
             try:
                 is_open = kis.is_market_open()
             except Exception:
                 is_open = True
             now_dt_kst = datetime.now(KST)
             now_str = now_dt_kst.strftime("%Y-%m-%d %H:%M:%S")
             logger.info(f"[‚è∞ Ïû•ÏÉÅÌÉú] {'OPEN' if is_open else 'CLOSED'} / KST={now_str}")
 
+            time_state = time_controller.evaluate(now_dt_kst)
+            time_controller.log_if_changed(logger, time_state)
+
             # ÏûîÍ≥† ÎèôÍ∏∞Ìôî & Î≥¥Ïú†Î∂Ñ Îä•ÎèôÍ¥ÄÎ¶¨ Î∂ÄÌä∏Ïä§Ìä∏Îû©
             ord_psbl_map: Dict[str, int] = {}
             name_map: Dict[str, str] = {}
             try:
                 balances = _fetch_balances(kis)
                 logger.info(f"[Î≥¥Ïú†ÏûîÍ≥† API Í≤∞Í≥º Ï¢ÖÎ™©Ïàò] {len(balances)}Í∞ú")
                 for stock in balances:
                     code_b = stock.get("pdno")
                     name_b = stock.get("prdt_name")
                     name_map[code_b] = name_b
                     logger.debug(
                         " [ÏûîÍ≥†] Ï¢ÖÎ™©:%s, ÏΩîÎìú:%s, Î≥¥Ïú†:%s, Îß§ÎèÑÍ∞ÄÎä•:%s",
                         name_b,
                         code_b,
                         stock.get("hldg_qty"),
                         stock.get("ord_psbl_qty"),
                     )
 
                 current_holding = {
                     b["pdno"]: _to_int(b.get("hldg_qty", 0))
                     for b in balances
                     if _to_int(b.get("hldg_qty", 0)) > 0
                 }
                 ord_psbl_map = {
                     b["pdno"]: _to_int(b.get("ord_psbl_qty", 0))
@@ -2473,50 +3057,75 @@ def main():
                         )
                         logger.info(
                             f"[ÏûîÍ≥†Ï¥àÍ∏∞Ìôî] code={code_b} qty={qty_b} avg={avg_b}"
                         )
 
                 # Ïã§Ï†ú ÏûîÍ≥†ÏóêÏÑú ÏÇ¨ÎùºÏßÑ Î≥¥Ïú†Ìï≠Î™©ÏùÄ Ï†ïÎ¶¨
                 for code in list(holding.keys()):
                     if code not in current_holding or current_holding[code] == 0:
                         logger.info(
                             f"[Î≥¥Ïú†Ï¢ÖÎ™© Ìï¥Ï†ú] {code} : Ïã§Ï†úÏûîÍ≥† ÏóÜÏùå ‚Üí holding Ï†úÍ±∞"
                         )
                         holding.pop(code, None)
 
             except Exception as e:
                 logger.error(f"[ÏûîÍ≥†Ï°∞Ìöå Ïò§Î•ò]{e}")
 
             # Ïû• ÎßàÍ∞ê Ïãú: Ï∫îÎì§/ATR/Î™®Î©òÌÖÄ/Îß§Îß§ Î°úÏßÅ Ïä§ÌÇµ
             if not is_open:
                 logger.info(
                     "[ÎßàÍ∞êÏÉÅÌÉú] Ï∫îÎì§/ATR/Î™®Î©òÌÖÄ/Îß§Îß§ Î°úÏßÅ Ïä§ÌÇµ ‚Üí ÏûîÍ≥†Îßå ÎèôÍ∏∞Ìôî ÌõÑ ÎåÄÍ∏∞"
                 )
                 save_state(holding, traded)
                 time.sleep(60.0)
                 continue
 
+            if ENABLE_CORE_POSITIONS and time_state.allow_intraday_entries:
+                try:
+                    core_engine.scan(kis, code_to_target)
+                    core_engine.enter(kis, capital_active, holding, traded, can_buy)
+                except Exception as e:
+                    logger.warning(f"[CORE-MODULE] Ïä§Ï∫î/ÏßÑÏûÖ Ïã§Ìå®: {e}")
+
+            if time_state.allow_close_bet_scan:
+                try:
+                    close_universe: Dict[str, Dict[str, Any]] = dict(code_to_target)
+                    close_universe.update(pullback_watch)
+                    close_bet_engine.scan_candidates(
+                        kis, now_dt_kst, close_universe, holding, traded
+                    )
+                except Exception as e:
+                    logger.warning(f"[CLOSE-BET-SCAN-FAIL] {e}")
+
+            if time_state.allow_close_bet_entry:
+                try:
+                    close_bet_engine.enter_close_bets(
+                        kis, now_dt_kst, capital_active, holding, traded, can_buy
+                    )
+                except Exception as e:
+                    logger.warning(f"[CLOSE-BET-ENTRY-FAIL] {e}")
+
             # ====== Îß§Ïàò/Îß§ÎèÑ(Ï†ÑÎûµ) LOOP ‚Äî Ïò§ÎäòÏùò ÌÉÄÍ≤ü ======
             for code, target in code_to_target.items():
                 prev_volume = _to_float(target.get("prev_volume"))
                 prev_open = _to_float(target.get("prev_open"))
                 prev_close = _to_float(target.get("prev_close"))
                 logger.debug(
                     f"[prev_volume Ï≤¥ÌÅ¨] {code} Í±∞ÎûòÎüâ:{prev_volume}, Ï†ÑÏùºÏãúÍ∞Ä:{prev_open}, Ï†ÑÏùºÏ¢ÖÍ∞Ä:{prev_close}"
                 )
 
                 planned_total_qty = _to_int(target.get("Îß§ÏàòÏàòÎüâ") or target.get("qty"), 0)
                 if planned_total_qty <= 0:
                     logger.info(f"[SKIP] {code}: Îß§ÏàòÏàòÎüâ ÏóÜÏùå/0")
                     continue
 
                 # ÎàåÎ¶ºÎ™© 3Îã®Í≥Ñ ÏßÑÏûÖ(40/35/25%)ÏùÑ ÏúÑÌïú Ïä§ÌÖåÏù¥ÏßÄÎ≥Ñ Î™©Ìëú ÏàòÎüâ
                 stage1_qty = max(1, int(planned_total_qty * ENTRY_LADDERS[0]))
                 stage2_qty = max(0, int(planned_total_qty * ENTRY_LADDERS[1]))
                 stage3_qty = max(0, int(planned_total_qty - stage1_qty - stage2_qty))
 
                 # 1Ï∞® ÏßÑÏûÖ Ïãú Ïã§Ï†ú Îß§Ïàò ÏàòÎüâÏùÄ stage1(40%)Îßå ÏÇ¨Ïö©
                 qty = stage1_qty
 
                 grade = target.get("champion_grade") or "C"
                 if grade != "A":
                     logger.info(
@@ -2558,51 +3167,56 @@ def main():
                     daily_ctx = _compute_daily_entry_context(
                         kis, code, float(current_price) if current_price else None
                     )
                     intraday_ctx = _compute_intraday_entry_context(
                         kis, code, prev_high=target.get("prev_high")
                     )
 
                     if is_bad_entry(code, daily_ctx, intraday_ctx, REGIME_STATE):
                         logger.info(
                             f"[CHAMPION-HOLD] {code}: AÍ∏âÏù¥ÏßÄÎßå BAD ÌÉÄÏ†ê ‚Üí Ïò§ÎäòÏùÄ Îß§Ïàò Î≥¥Î•ò"
                         )
                         continue
 
                     if not is_good_entry(
                         code,
                         daily_ctx,
                         intraday_ctx,
                         prev_high=target.get("prev_high"),
                     ):
                         logger.info(
                             f"[WAIT] {code}: AÍ∏âÏù¥ÎÇò GOOD ÌÉÄÏ†ê ÎØ∏Ï∂©Ï°± ‚Üí ÎàåÎ¶º ÎåÄÍ∏∞"
                         )
                         continue
 
                     # --- Îß§Ïàò --- (ÎèåÌåå ÏßÑÏûÖ + Ïä¨Î¶¨ÌîºÏßÄ Í∞ÄÎìú + ÏòàÏÇ∞ Í∞ÄÎìú)
-                    if is_open and code not in holding and code not in traded:
+                    if (
+                        is_open
+                        and time_state.allow_intraday_entries
+                        and code not in holding
+                        and code not in traded
+                    ):
                         if not can_buy:
                             logger.info(
                                 f"[BUDGET_SKIP] {code}: ÏòàÏÇ∞ ÏóÜÏùå ‚Üí Ïã†Í∑ú Îß§Ïàò Ïä§ÌÇµ"
                             )
                             continue
 
                         trigger_price = eff_target_price
                         if pullback_info.get("reversal_price"):
                             if trigger_price is None:
                                 trigger_price = float(pullback_info.get("reversal_price"))
                             else:
                                 trigger_price = max(
                                     float(trigger_price),
                                     float(pullback_info.get("reversal_price")),
                                 )
 
                         enter_cond = (
                             current_price is not None
                             and trigger_price is not None
                             and int(current_price) >= int(trigger_price)
                         )
 
                         if enter_cond:
                             guard_ok = True
 
@@ -2876,51 +3490,51 @@ def main():
                                             int(round(_profit))
                                             if _profit is not None
                                             else None
                                         ),
                                         "reason": reason,
                                     }
                                 )
                                 save_state(holding, traded)
                                 time.sleep(RATE_SLEEP_SEC)
                             else:
                                 try:
                                     if is_strong_momentum(kis, code):
                                         logger.info(
                                             f"[SELL_GUARD] {code} Î™®Î©òÌÖÄ Í∞ïÏÑ∏ ‚Üí Ìä∏Î¶¨Í±∞ Î∂ÄÏû¨, Îß§ÎèÑ Î≥¥Î•ò"
                                         )
                                 except Exception as e:
                                     logger.warning(
                                         f"[SELL_GUARD_FAIL] {code} Î™®Î©òÌÖÄ ÌèâÍ∞Ä Ïã§Ìå®: {e}"
                                     )
 
                 except Exception as e:
                     logger.error(f"[‚ùå Ï£ºÎ¨∏/Ï°∞Ìöå Ïã§Ìå®] {code} : {e}")
                     continue
 
             # ====== ÎàåÎ¶ºÎ™© Ï†ÑÏö© Îß§Ïàò (Ï±îÌîºÏñ∏Í≥º ÎèÖÎ¶ΩÏ†ÅÏúºÎ°ú Top-N ÏãúÏ¥ù Î¶¨Ïä§Ìä∏ Ïä§Ï∫î) ======
-            if USE_PULLBACK_ENTRY and is_open and pullback_watch:
+            if USE_PULLBACK_ENTRY and is_open and time_state.allow_intraday_entries and pullback_watch:
                 for code, info in pullback_watch.items():
                     if code in code_to_target:
                         continue  # Ï±îÌîºÏñ∏ Î£®ÌîÑÏôÄ Î≥ÑÎèÑÎ°úÎßå Ï≤òÎ¶¨
                     if code in holding or code in traded:
                         continue
                     if not can_buy:
                         logger.info(
                             f"[PULLBACK-BUDGET-SKIP] {code}: ÏòàÏÇ∞ ÏóÜÏùå ‚Üí ÎàåÎ¶ºÎ™© Ïã†Í∑ú Îß§Ïàò Ïä§ÌÇµ"
                         )
                         continue
 
                     try:
                         current_price = _safe_get_price(kis, code)
                     except Exception:
                         current_price = None
                     if current_price is None or current_price <= 0:
                         continue
 
                     try:
                         pullback_info = _detect_pullback_reversal(
                             kis=kis,
                             code=code,
                             current_price=float(current_price),
                         )
                     except Exception as e:
@@ -3172,54 +3786,54 @@ def main():
                         logger.warning(
                             f"[20D_TREND_TEMP_SKIP] {code}: ÎÑ§Ìä∏ÏõåÌÅ¨ ÏùºÏãú Ïã§Ìå® ‚Üí Ïù¥Î≤à Î£®ÌîÑ Ïä§ÌÇµ"
                         )
                         continue
                     except DataEmptyError:
                         logger.warning(
                             f"[DATA_EMPTY] {code}: 0Ï∫îÎì§ ‚Üí Îã§Ïùå Î£®ÌîÑÏóêÏÑú Ïû¨ÌôïÏù∏"
                         )
                         continue
                     except DataShortError:
                         logger.error(
                             f"[DATA_SHORT] {code}: 21Í∞ú ÎØ∏Îßå ‚Üí Ïù¥Î≤à Î£®ÌîÑ ÌåêÎã® Ïä§ÌÇµ"
                         )
                         continue
 
                     if momentum_intact:
                         logger.info(
                             (
                                 f"[Î™®Î©òÌÖÄ Î≥¥Ïú†] {code}: 5/10/20 Ï†ïÎ∞∞Ïó¥ & 20ÏùºÏÑ† ÏÉÅÏäπ & Ï¢ÖÍ∞Ä>20ÏùºÏÑ† Ïú†ÏßÄ "
                                 f"(close={trend_ctx.get('last_close'):.2f}, ma5={trend_ctx.get('ma5'):.2f}, "
                                 f"ma10={trend_ctx.get('ma10'):.2f}, ma20={trend_ctx.get('ma20'):.2f}‚Üí{trend_ctx.get('ma20_prev'):.2f})"
                             )
                         )
                         continue
 
-            # --- Ïû•Ï§ë Ïª§Ìä∏Ïò§ÌîÑ(KST): 14:40 ÎèÑÎã¨ Ïãú "Ï†ÑÎüâÎß§ÎèÑ ÏóÜÏù¥" Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± ÌõÑ Ï†ïÏÉÅ Ï¢ÖÎ£å ---
-            if is_open and now_dt_kst.time() >= SELL_FORCE_TIME:
+            # --- Ïª§Ìä∏Ïò§ÌîÑ/Ï¢ÖÍ∞Ä Ï¢ÖÎ£å ---
+            if now_dt_kst.time() >= SELL_FORCE_TIME or time_state.mode == "shutdown":
                 logger.info(
-                    f"[‚è∞ Ïª§Ìä∏Ïò§ÌîÑ] {SELL_FORCE_TIME.strftime('%H:%M')} ÎèÑÎã¨: Ï†ÑÎüâ Îß§ÎèÑ ÏóÜÏù¥ Î¶¨Ìè¨Ìä∏ ÏÉùÏÑ± ÌõÑ Ï¢ÖÎ£å"
+                    f"[SHUTDOWN] SELL_FORCE_TIME({SELL_FORCE_TIME.strftime('%H:%M')}) ÎèÑÎã¨ ‚Üí Î¶¨Ìè¨Ìä∏ ÏûëÏÑ± ÌõÑ ÏûêÎ∞ú Ï¢ÖÎ£å"
                 )
 
                 save_state(holding, traded)
 
                 try:
                     _report = ceo_report(datetime.now(KST), period="daily")
                     logger.info(
                         f"[üìÑ CEO Report ÏÉùÏÑ± ÏôÑÎ£å] title={_report.get('title')}"
                     )
                 except Exception as e:
                     logger.error(f"[CEO Report ÏÉùÏÑ± Ïã§Ìå®] {e}")
 
                 logger.info("[‚úÖ Ïª§Ìä∏Ïò§ÌîÑ ÏôÑÎ£å: Î£®ÌîÑ Ï†ïÏÉÅ Ï¢ÖÎ£å]")
                 break
 
             save_state(holding, traded)
             time.sleep(loop_sleep_sec)
 
     except KeyboardInterrupt:
         logger.info("[üõë ÏàòÎèô Ï¢ÖÎ£å]")
     except Exception as e:
         logger.exception(f"[FATAL] Î©îÏù∏ Î£®ÌîÑ ÏòàÏô∏ Î∞úÏÉù: {e}")
 
 # Ïã§ÌñâÎ∂Ä
 if __name__ == "__main__":
