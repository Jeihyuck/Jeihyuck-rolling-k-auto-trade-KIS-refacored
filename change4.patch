diff --git a/trader/botstate_sync.py b/trader/botstate_sync.py
index a9f7753a47558a1c0a42c29b0e2921a0c405d16f..a19b9c552c36ee889bc508ebad2fa65e0e622a4a 100644
--- a/trader/botstate_sync.py
+++ b/trader/botstate_sync.py
@@ -1,108 +1,149 @@
 from __future__ import annotations
 
 import json
 import os
 import subprocess
 import time
 import logging
 from datetime import datetime, timedelta
 from pathlib import Path
 from typing import Dict, Iterable
 from zoneinfo import ZoneInfo
 
 logger = logging.getLogger(__name__)
 
 KST = ZoneInfo("Asia/Seoul")
 
+DEFAULT_BOTSTATE_WORKTREE_DIR = "_botstate"
+BOTSTATE_WORKTREE_DIR_ENV = "BOTSTATE_WORKTREE_DIR"
+
+
+def resolve_botstate_worktree_dir() -> Path:
+    return Path(os.getenv(BOTSTATE_WORKTREE_DIR_ENV, DEFAULT_BOTSTATE_WORKTREE_DIR)).resolve()
+
 
 def _run(cmd: list[str], cwd: Path | None = None) -> subprocess.CompletedProcess:
-    return subprocess.run(cmd, cwd=cwd, check=True, text=True, capture_output=True)
+    try:
+        return subprocess.run(cmd, cwd=cwd, check=True, text=True, capture_output=True)
+    except subprocess.CalledProcessError as exc:
+        logger.error(
+            "[BOTSTATE][CMD-ERROR] cmd=%s cwd=%s returncode=%s stdout=%s stderr=%s",
+            exc.cmd,
+            cwd,
+            exc.returncode,
+            exc.stdout,
+            exc.stderr,
+        )
+        raise
+
+
+def _git(worktree_dir: Path, *args: str) -> subprocess.CompletedProcess:
+    return _run(["git", "-C", str(worktree_dir), *args])
+
+
+def _configure_safe_directories(base_dir: Path, worktree_dir: Path) -> None:
+    base_dir_resolved = base_dir.resolve()
+    worktree_dir_resolved = worktree_dir.resolve()
+    for path in {base_dir_resolved, worktree_dir_resolved}:
+        _run(["git", "config", "--global", "--add", "safe.directory", str(path)])
 
 
 def setup_worktree(base_dir: Path, worktree_dir: Path, target_branch: str = "bot-state") -> None:
+    base_dir = base_dir.resolve()
+    worktree_dir = worktree_dir.resolve()
     worktree_dir.mkdir(parents=True, exist_ok=True)
+    _configure_safe_directories(base_dir, worktree_dir)
     try:
         _run(["git", "worktree", "add", "-B", target_branch, str(worktree_dir), target_branch], cwd=base_dir)
     except subprocess.CalledProcessError:
         _run(["git", "fetch", "origin", f"{target_branch}:{target_branch}"], cwd=base_dir)
         _run(["git", "worktree", "add", "-B", target_branch, str(worktree_dir), target_branch], cwd=base_dir)
-    _run(["git", "pull", "--rebase"], cwd=worktree_dir)
+    _git(worktree_dir, "pull", "--rebase")
 
 
 def _lock_path(worktree_dir: Path) -> Path:
     return worktree_dir / "bot_state" / "locks" / "trader.lock.json"
 
 
 def acquire_lock(worktree_dir: Path, owner: str, run_id: str, ttl_sec: int = 900) -> bool:
+    worktree_dir = worktree_dir.resolve()
     lock_path = _lock_path(worktree_dir)
     lock_path.parent.mkdir(parents=True, exist_ok=True)
     now = datetime.now(tz=KST)
     if lock_path.exists():
         try:
             payload = json.loads(lock_path.read_text())
             ts = datetime.fromisoformat(payload.get("ts"))
             ttl = int(payload.get("ttl_sec") or ttl_sec)
             if ts + timedelta(seconds=ttl) > now:
                 logger.warning("[BOTSTATE][LOCKED] owner=%s run_id=%s until=%s", payload.get("owner"), payload.get("run_id"), ts + timedelta(seconds=ttl))
                 return False
         except Exception:
             pass
     lock_payload = {
         "owner": owner,
         "run_id": run_id,
         "ts": now.isoformat(),
         "ttl_sec": ttl_sec,
     }
-    lock_path.write_text(json.dumps(lock_payload))
-    _run(["git", "add", str(lock_path)], cwd=worktree_dir)
+    temp_path = lock_path.with_name(f"{lock_path.name}.tmp")
+    temp_path.write_text(json.dumps(lock_payload))
+    temp_path.replace(lock_path)
+    lock_rel_path = lock_path.relative_to(worktree_dir)
+    _git(worktree_dir, "add", str(lock_rel_path))
     push_retry(worktree_dir, message=f"lock run_id={run_id}")
     logger.info("[BOTSTATE][LOCK-ACQUIRED] owner=%s run_id=%s", owner, run_id)
     return True
 
 
 def release_lock(worktree_dir: Path, run_id: str) -> None:
+    worktree_dir = worktree_dir.resolve()
     lock_path = _lock_path(worktree_dir)
     if lock_path.exists():
         lock_path.unlink()
-        _run(["git", "add", "-u"], cwd=worktree_dir)
+        lock_rel_path = lock_path.relative_to(worktree_dir)
+        _git(worktree_dir, "add", "-u", str(lock_rel_path))
         push_retry(worktree_dir, message=f"unlock run_id={run_id}")
         logger.info("[BOTSTATE][LOCK-RELEASED] run_id=%s", run_id)
 
 
 def persist_run_files(worktree_dir: Path, new_files: Iterable[Path], message: str) -> None:
+    worktree_dir = worktree_dir.resolve()
     files = list(new_files)
     for path in files:
         try:
             if path.resolve().is_relative_to(worktree_dir.resolve()):
-                target = path
+                target = path.resolve()
             else:
                 if "bot_state" in path.parts:
                     idx = path.parts.index("bot_state")
                     rel = Path(*path.parts[idx:])
                 else:
                     rel = Path("bot_state") / Path(*path.parts[-4:])
-                target = worktree_dir / rel
+                target = (worktree_dir / rel).resolve()
                 target.parent.mkdir(parents=True, exist_ok=True)
                 target.write_bytes(path.read_bytes())
-            _run(["git", "add", str(target)], cwd=worktree_dir)
+            rel_target = target.relative_to(worktree_dir)
+            _git(worktree_dir, "add", str(rel_target))
         except Exception:
             continue
     push_retry(worktree_dir, message=message)
     logger.info("[BOTSTATE][PERSIST] files=%s message=%s", len(files), message)
 
 
 def push_retry(worktree_dir: Path, message: str, retries: int = 3) -> None:
+    worktree_dir = worktree_dir.resolve()
     for attempt in range(1, retries + 1):
         try:
-            _run(["git", "commit", "-m", message], cwd=worktree_dir)
+            _git(worktree_dir, "commit", "-m", message)
         except subprocess.CalledProcessError:
             pass
         try:
-            _run(["git", "pull", "--rebase"], cwd=worktree_dir)
-            _run(["git", "push"], cwd=worktree_dir)
+            _git(worktree_dir, "pull", "--rebase")
+            _git(worktree_dir, "push")
             logger.info("[BOTSTATE][PUSH] message=%s attempt=%s", message, attempt)
             return
         except subprocess.CalledProcessError as e:
             if attempt == retries:
                 raise
             time.sleep(2 * attempt)
diff --git a/trader/pb1_runner.py b/trader/pb1_runner.py
index 26f7cdf4e2bb919f475abeab4962eeb8c31904ce..8d6acc3f2d2f3a2ae868191df6bd7d2ee369e18b 100644
--- a/trader/pb1_runner.py
+++ b/trader/pb1_runner.py
@@ -1,51 +1,57 @@
 from __future__ import annotations
 
 import argparse
 import logging
 import os
 import time
 from datetime import datetime, timedelta
 from pathlib import Path
 
 from trader.kis_wrapper import KisAPI
 from trader.time_utils import is_trading_day, now_kst
 from trader.config import (
     BOTSTATE_LOCK_TTL_SEC,
     DIAGNOSTIC_MODE,
     DIAGNOSTIC_ONLY,
     MORNING_WINDOW_START,
     MORNING_WINDOW_END,
     MORNING_EXIT_START,
     MORNING_EXIT_END,
     AFTERNOON_WINDOW_START,
     AFTERNOON_WINDOW_END,
     CLOSE_AUCTION_START,
     CLOSE_AUCTION_END,
 )
 from trader.utils.env import env_bool, parse_env_flag, resolve_mode
-from trader.botstate_sync import acquire_lock, release_lock, setup_worktree, persist_run_files
+from trader.botstate_sync import (
+    acquire_lock,
+    release_lock,
+    setup_worktree,
+    persist_run_files,
+    resolve_botstate_worktree_dir,
+)
 from trader.pb1_engine import PB1Engine
 from trader.window_router import decide_window
 
 logger = logging.getLogger(__name__)
 
 
 def truthy(value: object) -> bool:
     return str(value).strip().lower() in {"1", "true", "yes", "y", "on"}
 
 
 def parse_args() -> argparse.Namespace:
     parser = argparse.ArgumentParser(description="PB1 close pullback runner")
     parser.add_argument("--window", default="auto", choices=["auto", "morning", "afternoon"], help="Execution window override")
     parser.add_argument("--phase", default="auto", choices=["auto", "entry", "exit", "verify"], help="Phase override")
     parser.add_argument("--target-branch", default=os.getenv("BOTSTATE_BRANCH", "bot-state"), help="Bot-state target branch")
     return parser.parse_args()
 
 
 def main() -> None:
     args = parse_args()
     now = now_kst()
     event_name = os.getenv("GITHUB_EVENT_NAME", "") or ""
     event_name_lower = event_name.lower()
     trading_day = is_trading_day(now)
     non_trading_day = not trading_day
@@ -136,51 +142,51 @@ def main() -> None:
         if delta.total_seconds() <= 0:
             return True
         if not trading_day or event_name_lower not in {"push", "workflow_dispatch"}:
             return True
         max_wait_min = int(os.getenv("MAX_WAIT_BEFORE_MORNING_MIN", "120") or "120")
         if delta > timedelta(minutes=max_wait_min):
             logger.info("[PB1][WAIT-SKIP] delta_min=%.1f max_wait_min=%s -> exit early", delta.total_seconds() / 60, max_wait_min)
             return False
         logger.info("[PB1][WAIT] waiting until morning window start delta_sec=%.0f", delta.total_seconds())
         time.sleep(delta.total_seconds())
         return True
 
     if not _sleep_until_morning_window():
         return
     now = now_kst()
 
     os.environ.setdefault("MORNING_WINDOW_START", MORNING_WINDOW_START)
     os.environ.setdefault("MORNING_WINDOW_END", MORNING_WINDOW_END)
     os.environ.setdefault("MORNING_EXIT_START", MORNING_EXIT_START)
     os.environ.setdefault("MORNING_EXIT_END", MORNING_EXIT_END)
     os.environ.setdefault("AFTERNOON_WINDOW_START", AFTERNOON_WINDOW_START)
     os.environ.setdefault("AFTERNOON_WINDOW_END", AFTERNOON_WINDOW_END)
     os.environ.setdefault("CLOSE_AUCTION_START", CLOSE_AUCTION_START)
     os.environ.setdefault("CLOSE_AUCTION_END", CLOSE_AUCTION_END)
 
-    worktree_dir = Path("_botstate")
+    worktree_dir = resolve_botstate_worktree_dir()
     setup_worktree(Path.cwd(), worktree_dir, target_branch=args.target_branch)
 
     os.environ["STATE_PATH"] = str(worktree_dir / "trader" / "state" / "state.json")
     from trader import state_store as runtime_state_store
     state_dir = Path(os.environ["STATE_PATH"]).parent
     state_dir.mkdir(parents=True, exist_ok=True)
     state_target_path = Path(os.environ["STATE_PATH"])
 
     runtime_state = {}
     kis: KisAPI | None = None
     try:
         runtime_state = runtime_state_store.load_state()
         kis = KisAPI()
         balance = kis.get_balance()
         runtime_state = runtime_state_store.reconcile_with_kis_balance(runtime_state, balance, active_strategies={1})
         runtime_state_store.save_state(runtime_state)
     except Exception:
         logger.exception("[PB1] runtime state reconcile failed")
         runtime_state = runtime_state or runtime_state_store.load_state()
         dry_run_reasons.append("kis_init_failed")
         dry_run_reason = ",".join(dry_run_reasons)
         dry_run = True
         _apply_env_flags(dry_run)
 
     if DIAGNOSTIC_ONLY:
