diff --git a/trader/config.py b/trader/config.py
index 0d9aa20792775bef49ed590cb637937ff7662cca..422be67deb716b524eac9f0c3f5b5878aabebb81 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -31,50 +31,51 @@ CONFIG = {
     "ATR_STOP": "1.5",
     "TIME_STOP_HHMM": "13:00",
     "DEFAULT_PROFIT_PCT": "3.0",
     "DEFAULT_LOSS_PCT": "-5.0",
     "DAILY_CAPITAL": "250000000",
     "CAP_CAP": "0.8",
     "SLIPPAGE_LIMIT_PCT": "0.25",
     "SLIPPAGE_ENTER_GUARD_PCT": "2.5",
     "VWAP_TOL": "0.003",  # ğŸ”¸ VWAP í—ˆìš© ì˜¤ì°¨(ê¸°ë³¸ 0.3%)
     "W_MAX_ONE": "0.25",
     "W_MIN_ONE": "0.03",
     "REBALANCE_ANCHOR": "weekly",             # weekly | today | monthly
     "WEEKLY_ANCHOR_REF": "last",              # NEW: 'last'(ì§ì „ ì¼ìš”ì¼) | 'next'(ë‹¤ìŒ ì¼ìš”ì¼)
     "MOMENTUM_OVERRIDES_FORCE_SELL": "true",
     # ë ˆì§(ì½”ìŠ¤ë‹¥) íŒŒë¼ë¯¸í„°
     "KOSDAQ_INDEX_CODE": "KOSDAQ",
     "KOSDAQ_ETF_FALLBACK": "229200",
     "REG_BULL_MIN_UP_PCT": "0.5",
     "REG_BULL_MIN_MINUTES": "10",
     "REG_BEAR_VWAP_MINUTES": "10",
     "REG_BEAR_DROP_FROM_HIGH": "0.7",
     "REG_BEAR_STAGE1_MINUTES": "20",
     "REG_BEAR_STAGE2_ADD_DROP": "0.5",
     "REG_PARTIAL_S1": "0.30",
     "REG_PARTIAL_S2": "0.30",
+    "BASE_QTY_MODE": "initial",  # initial | current
     "TRAIL_PCT_BULL": "0.025",
     "TRAIL_PCT_BEAR": "0.012",
     "TP_PROFIT_PCT_BULL": "3.5",
     # ì‹ ê³ ê°€ ëŒíŒŒ í›„ 3ì¼ ëˆŒë¦¼ + ë°˜ë“± ë§¤ìˆ˜ìš© íŒŒë¼ë¯¸í„°
     "USE_PULLBACK_ENTRY": "true",          # trueë©´ 'ì‹ ê³ ê°€ â†’ 3ì¼ ì—°ì† í•˜ë½ â†’ ë°˜ë“±' íŒ¨í„´ ì¶©ì¡± ì‹œì—ë§Œ ëˆŒë¦¼ëª© ì§„ì… í—ˆìš©
     "PULLBACK_LOOKBACK": "60",             # ì‹ ê³ ê°€ íƒìƒ‰ ë²”ìœ„(ê±°ë˜ì¼ ê¸°ì¤€)
     "PULLBACK_DAYS": "3",                  # ì—°ì† í•˜ë½ ì¼ìˆ˜
     "PULLBACK_REVERSAL_BUFFER_PCT": "0.2", # ë˜ëŒë¦¼ í™•ì¸ ì—¬ìœ (%): ì§ì „ í•˜ë½ì¼ ê³ ê°€ ëŒ€ë¹„ ì—¬ìœ ìœ¨
     "PULLBACK_TOPN": "50",                 # ëˆŒë¦¼ëª© ìŠ¤ìº”ìš© ì½”ìŠ¤ë‹¥ ì‹œì´ ìƒìœ„ ì¢…ëª© ìˆ˜
     "PULLBACK_UNIT_WEIGHT": "0.03",        # ëˆŒë¦¼ëª© ë§¤ìˆ˜ 1ê±´ë‹¹ ìë³¸ ë°°ë¶„(í™œì„± ìë³¸ ë¹„ìœ¨)
     "PULLBACK_MAX_BUYS_PER_DAY": "5",      # ëˆŒë¦¼ëª© í•˜ë£¨ ìµœëŒ€ ì‹ ê·œ ë§¤ìˆ˜ ê±´ìˆ˜
     # ì±”í”¼ì–¸ í›„ë³´ í•„í„°
     "CHAMPION_MIN_TRADES": "5",            # ìµœì†Œ ê±°ë˜ìˆ˜
     "CHAMPION_MIN_WINRATE": "45.0",        # ìµœì†Œ ìŠ¹ë¥ (%)
     "CHAMPION_MAX_MDD": "30.0",            # ìµœëŒ€ í—ˆìš© MDD(%)
     "CHAMPION_MIN_SHARPE": "0.0",          # ìµœì†Œ ìƒ¤í”„ ë¹„ìœ¨
     "NEUTRAL_ENTRY_SCALE": "0.6",          # ì¤‘ë¦½ ë ˆì§ ì‹ ê·œ/ì¬ì§„ì… ìŠ¤ì¼€ì¼ë§ ë¹„ìœ¨
     # ê¸°íƒ€
     "MARKET_DATA_WHEN_CLOSED": "false",
     "FORCE_WEEKLY_REBALANCE": "0",
     # NEW: 1ë¶„ë´‰ VWAP ëª¨ë©˜í…€ íŒŒë¼ë¯¸í„°
     "MOM_FAST": "5",        # 1ë¶„ë´‰ fast MA ê¸¸ì´
     "MOM_SLOW": "20",       # 1ë¶„ë´‰ slow MA ê¸¸ì´
     "MOM_TH_PCT": "0.5",    # fast/slow ê´´ë¦¬ ì„ê³„ê°’(%) â€“ 0.5% ì´ìƒì´ë©´ ê°•ì„¸ë¡œ ë³¸ë‹¤
     # Subject flow gate ê¸°ë³¸ê°’
@@ -115,50 +116,56 @@ KST = ZoneInfo("Asia/Seoul")
 
 SELL_FORCE_TIME_STR = _cfg("SELL_FORCE_TIME").strip()
 SELL_ALL_BALANCES_AT_CUTOFF = _cfg("SELL_ALL_BALANCES_AT_CUTOFF").lower() == "true"
 RATE_SLEEP_SEC = float(_cfg("API_RATE_SLEEP_SEC"))
 FORCE_SELL_PASSES_CUTOFF = int(_cfg("FORCE_SELL_PASSES_CUTOFF"))
 FORCE_SELL_PASSES_CLOSE = int(_cfg("FORCE_SELL_PASSES_CLOSE"))
 PARTIAL1 = float(_cfg("PARTIAL1"))
 PARTIAL2 = float(_cfg("PARTIAL2"))
 TRAIL_PCT = float(_cfg("TRAIL_PCT"))
 FAST_STOP = float(_cfg("FAST_STOP"))
 ATR_STOP = float(_cfg("ATR_STOP"))
 TIME_STOP_HHMM = _cfg("TIME_STOP_HHMM")
 DEFAULT_PROFIT_PCT = float(_cfg("DEFAULT_PROFIT_PCT"))
 DEFAULT_LOSS_PCT = float(_cfg("DEFAULT_LOSS_PCT"))
 DAILY_CAPITAL = int(_cfg("DAILY_CAPITAL"))
 CAP_CAP = float(_cfg("CAP_CAP"))
 SLIPPAGE_LIMIT_PCT = float(_cfg("SLIPPAGE_LIMIT_PCT"))
 SLIPPAGE_ENTER_GUARD_PCT = float(_cfg("SLIPPAGE_ENTER_GUARD_PCT"))
 VWAP_TOL = float(_cfg("VWAP_TOL"))  # ğŸ”¸ VWAP í—ˆìš© ì˜¤ì°¨(ì˜ˆ: 0.003 = -0.3%ê¹Œì§€ í—ˆìš©)
 W_MAX_ONE = float(_cfg("W_MAX_ONE"))
 W_MIN_ONE = float(_cfg("W_MIN_ONE"))
 ALLOW_PYRAMID = (_cfg("ALLOW_PYRAMID") or "false").lower() == "true"
 REBALANCE_ANCHOR = _cfg("REBALANCE_ANCHOR")
 WEEKLY_ANCHOR_REF = _cfg("WEEKLY_ANCHOR_REF").lower()
 MOMENTUM_OVERRIDES_FORCE_SELL = _cfg("MOMENTUM_OVERRIDES_FORCE_SELL").lower() == "true"
+BASE_QTY_MODE = (_cfg("BASE_QTY_MODE") or "initial").lower()
+if BASE_QTY_MODE not in {"initial", "current"}:
+    logging.getLogger(__name__).warning(
+        f"[CONFIG] BASE_QTY_MODE={BASE_QTY_MODE} ì§€ì› ì•ˆ í•¨ â†’ initialë¡œ ëŒ€ì²´"
+    )
+    BASE_QTY_MODE = "initial"
 
 # NEW: 1ë¶„ë´‰ ëª¨ë©˜í…€ íŒŒë¼ë¯¸í„°
 MOM_FAST = int(_cfg("MOM_FAST") or "5")
 MOM_SLOW = int(_cfg("MOM_SLOW") or "20")
 MOM_TH_PCT = float(_cfg("MOM_TH_PCT") or "0.5")
 # subject flow
 MIN_SMART_MONEY_RATIO_KOSPI = float(_cfg("MIN_SMART_MONEY_RATIO_KOSPI") or "0.02")
 MIN_SMART_MONEY_RATIO_KOSDAQ = float(_cfg("MIN_SMART_MONEY_RATIO_KOSDAQ") or "0.03")
 SUBJECT_FLOW_TIMEOUT_SEC = float(_cfg("SUBJECT_FLOW_TIMEOUT_SEC") or "1.2")
 SUBJECT_FLOW_RETRY = int(_cfg("SUBJECT_FLOW_RETRY") or "1")
 SUBJECT_FLOW_CACHE_TTL_SEC = float(_cfg("SUBJECT_FLOW_CACHE_TTL_SEC") or "60")
 SUBJECT_FLOW_FAIL_POLICY = (_cfg("SUBJECT_FLOW_FAIL_POLICY") or "CACHE").upper()
 SUBJECT_FLOW_EMPTY_POLICY = (_cfg("SUBJECT_FLOW_EMPTY_POLICY") or "TREAT_AS_FAIL").upper()
 SUBJECT_FLOW_DEGRADED_TURNOVER_MULT = float(_cfg("SUBJECT_FLOW_DEGRADED_TURNOVER_MULT") or "1.5")
 SUBJECT_FLOW_DEGRADED_OB_ADD = float(_cfg("SUBJECT_FLOW_DEGRADED_OB_ADD") or "10")
 SUBJECT_FLOW_MAX_CALLS_PER_RUN = int(_cfg("SUBJECT_FLOW_MAX_CALLS_PER_RUN") or "200")
 # ì‹ ê³ ê°€ â†’ 3ì¼ ëˆŒë¦¼ â†’ ë°˜ë“± í™•ì¸ í›„ ë§¤ìˆ˜ íŒŒë¼ë¯¸í„°
 USE_PULLBACK_ENTRY = _cfg("USE_PULLBACK_ENTRY").lower() != "false"
 PULLBACK_LOOKBACK = int(_cfg("PULLBACK_LOOKBACK") or "60")
 PULLBACK_DAYS = int(_cfg("PULLBACK_DAYS") or "3")
 PULLBACK_REVERSAL_BUFFER_PCT = float(_cfg("PULLBACK_REVERSAL_BUFFER_PCT") or "0.2")
 PULLBACK_TOPN = int(_cfg("PULLBACK_TOPN") or "50")
 PULLBACK_UNIT_WEIGHT = float(_cfg("PULLBACK_UNIT_WEIGHT") or "0.03")
 PULLBACK_MAX_BUYS_PER_DAY = int(_cfg("PULLBACK_MAX_BUYS_PER_DAY") or "5")
 CHAMPION_MIN_TRADES = int(_cfg("CHAMPION_MIN_TRADES") or "5")
diff --git a/trader/core.py b/trader/core.py
index 83af59b14fdcd8e128d6a5b8c5b036ab8436ab19..178749418cd63be5944124c7beda70fcb8ebdb3c 100644
--- a/trader/core.py
+++ b/trader/core.py
@@ -1,35 +1,36 @@
 # -*- coding: utf-8 -*-
 """trader ëª¨ë“ˆì˜ ê³µìš© ë¡œì§ ì§‘í•©ì„ ëª¨ë“ˆ ë‹¨ìœ„ë¡œ ì¬êµ¬ì„±."""
 from __future__ import annotations
 
 from typing import Dict, Optional
 
 from rolling_k_auto_trade_api.best_k_meta_strategy import get_kosdaq_top_n
 
 from . import config
-from .kis_wrapper import DataEmptyError, DataShortError, KisAPI, NetTemporaryError, append_fill
+from .kis_wrapper import DataEmptyError, DataShortError, KisAPI, NetTemporaryError
+from .fills import append_fill
 from .metrics import vwap_guard
 from .report_ceo import ceo_report
 
 from . import core_constants
 from . import core_utils
 from . import signals
 from . import execution
 from .core_constants import *  # noqa: F401,F403
 from .core_utils import *  # noqa: F401,F403
 from .execution import *  # noqa: F401,F403
 from .signals import *  # noqa: F401,F403
 
 try:
     from .rkmax_utils import blend_k, recent_features
 except Exception:
     def blend_k(k_month: float, day: int, atr20: Optional[float], atr60: Optional[float]) -> float:  # type: ignore[misc]
         return float(k_month) if k_month is not None else 0.5
 
     def recent_features(kis, code: str) -> Dict[str, Optional[float]]:  # type: ignore[misc]
         return {"atr20": None, "atr60": None}
 
 
 __all__ = (
     [
         "KisAPI",
diff --git a/trader/execution.py b/trader/execution.py
index 3ad1f762b6dd459a49dcc2dd57b66654fda07826..6b21039f911c22cff22043d830d850b2548806d1 100644
--- a/trader/execution.py
+++ b/trader/execution.py
@@ -1,51 +1,52 @@
 """í¬ì§€ì…˜ ì´ˆê¸°í™”, ì²´ê²°, ë ˆì§ ê´€ë ¨ ê¸°ëŠ¥."""
 from __future__ import annotations
 
 import logging
 
 import csv
 import json
 import os
 import time
 from datetime import datetime, time as dtime, timedelta
 from pathlib import Path
 from typing import Any, Dict, List, Optional, Tuple
 
 import requests
 
 from .core_constants import *  # noqa: F401,F403
 from .core_utils import (
     _get_daily_candles_cached,
     _log_realized_pnl,
     _round_to_tick,
     _to_float,
     _to_int,
     _with_retry,
     log_trade,
 )
-from .kis_wrapper import KisAPI, NetTemporaryError, append_fill
+from .kis_wrapper import KisAPI, NetTemporaryError
+from .fills import append_fill
 from .signals import (
     _get_atr,
     _notional_to_qty,
     _safe_get_price,
     _weight_to_qty,
     get_20d_return_pct,
     is_strong_momentum,
     _detect_pullback_reversal,
 )
 from .metrics import vwap_guard
 
 __all__ = [
     "fetch_rebalancing_targets",
     "_init_position_state",
     "_init_position_state_from_balance",
     "_maybe_scale_in_dips",
     "_sell_once",
     "ensure_fill_has_name",
     "compute_entry_target",
     "place_buy_with_fallback",
     "_get_kosdaq_snapshot",
     "_update_market_regime",
     "log_champion_and_regime",
     "_adaptive_exit",
     "REGIME_STATE",
@@ -361,51 +362,60 @@ def ensure_fill_has_name(odno: str, code: str, name: str, qty: int = 0, price: f
                 try:
                     idx_odno = header.index("ODNO")
                     idx_code = header.index("code")
                     idx_name = header.index("name")
                 except ValueError:
                     idx_odno = None
                     idx_code = None
                     idx_name = None
                 if idx_odno is not None and idx_name is not None and idx_code is not None:
                     for i in range(1, len(reader)):
                         row = reader[i]
                         if len(row) <= max(idx_odno, idx_code, idx_name):
                             continue
                         if (row[idx_odno] == str(odno) or (not row[idx_odno] and str(odno) == "")) and row[idx_code] == str(code):
                             if not row[idx_name]:
                                 row[idx_name] = name or ""
                                 reader[i] = row
                                 updated = True
                                 logger.info(f"[FILL_NAME_UPDATE] ODNO={odno} code={code} name={name}")
                                 break
         if updated:
             with open(today_path, "w", encoding="utf-8", newline="") as f:
                 writer = csv.writer(f)
                 writer.writerows(reader)
             return
-        append_fill("BUY", code, name or "", qty, price or 0.0, odno or "", note="ensure_fill_added_by_trader")
+        append_fill(
+            "BUY",
+            code,
+            name or "",
+            qty,
+            price or 0.0,
+            odno or "",
+            note="ensure_fill_added_by_trader",
+            reason="ensure_fill_name",
+        )
     except Exception as e:
         logger.warning(f"[ENSURE_FILL_FAIL] odno={odno} code={code} ex={e}")
 
 # === ì•µì»¤: ëª©í‘œê°€ ê³„ì‚° í•¨ìˆ˜ ===
 def compute_entry_target(kis: KisAPI, stk: Dict[str, Any]) -> Tuple[Optional[float], Optional[float]]:
     code = str(stk.get("code") or stk.get("stock_code") or stk.get("pdno") or "")
     if not code:
         return None, None
 
     try:
         market_open = kis.is_market_open()
     except Exception:
         market_open = True
 
     # 1) ì˜¤ëŠ˜ ì‹œì´ˆê°€
     today_open = None
     try:
         today_open = kis.get_today_open(code)
     except Exception:
         pass
     if not today_open or today_open <= 0:
         try:
             snap = kis.get_current_price(code)
             if snap and snap > 0:
                 today_open = float(snap)
diff --git a/trader/fills.py b/trader/fills.py
index 6f10daef7d6840448ae894bb453b19645c45303f..7b403976d43effbb62ecc212f3d1e9b6ee99fc57 100644
--- a/trader/fills.py
+++ b/trader/fills.py
@@ -1,33 +1,34 @@
 from datetime import datetime
 import csv, os
 
-def append_fill(side, code, name, qty, price, odno, note=""):
+def append_fill(side, code, name, qty, price, odno, note="", reason=""):
     """
     ì²´ê²° ê¸°ë¡ì„ CSVë¡œ ì €ì¥
     side: "BUY" or "SELL"
     code: ì¢…ëª© ì½”ë“œ
     name: ì¢…ëª© ì´ë¦„
     qty: ì²´ê²° ìˆ˜ëŸ‰
     price: ì²´ê²° ë‹¨ê°€
     odno: ì£¼ë¬¸ë²ˆí˜¸
     note: ì¶”ê°€ ë©”ëª¨
     """
     os.makedirs("fills", exist_ok=True)
     path = f"fills/fills_{datetime.now().strftime('%Y%m%d')}.csv"
-    header = ["ts", "side", "code", "name", "qty", "price", "ODNO", "note"]
+    header = ["ts", "side", "code", "name", "qty", "price", "ODNO", "note", "reason"]
     row = [
         datetime.now().isoformat(),
         side,
         code,
         name,
         int(qty),
         float(price),
         str(odno),
         note,
+        reason or "",
     ]
     new = not os.path.exists(path)
     with open(path, "a", newline="", encoding="utf-8") as f:
         w = csv.writer(f)
         if new:
             w.writerow(header)
         w.writerow(row)
diff --git a/trader/kis_wrapper.py b/trader/kis_wrapper.py
index 6ddf0ff09b3a23930f2fa96065ffd8b6f5976bfd..9e1945c0402514e2f285d80bc5cbb4f05221c609 100644
--- a/trader/kis_wrapper.py
+++ b/trader/kis_wrapper.py
@@ -1,55 +1,55 @@
 # -*- coding: utf-8 -*-
 # kis_wrapper.py â€” KIS OpenAPI wrapper (practice/real ê³µìš©)
 # - ì„¸ì…˜/ë¦¬íŠ¸ë¼ì´/ë ˆì´íŠ¸ë¦¬ë°‹
 # - í† í° ìºì‹œ
 # - ì‹œì„¸/ì¼ë´‰/ATR
 # - ì”ê³ /ì£¼ë¬¸
 # - âœ… ì˜ˆìˆ˜ê¸ˆ: output2.ord_psbl_cash ìš°ì„  ì‚¬ìš© (fallback: nrcvb_buy_amt â†’ dnca_tot_amt, ìµœí›„: ìµœê·¼ ìºì‹œ)
 # - âœ… SSL EOF/JSON Decode ë“± ì¼ì‹œ ì˜¤ë¥˜ ë‚´ì„± ê°•í™”
 # - âœ… ì‹œì„¸ 0ì› ë°©ì§€(Jâ†”U, Aì ‘ë‘/ë¬´ì ‘ë‘ êµì°¨, ì§€ìˆ˜ ë°±ì˜¤í”„ ì¬ì‹œë„)
 # - âœ… ì”ê³  í˜ì´ì§•(ctx_area_*) , empty ìˆœê°„ì‘ë‹µ ë””ë°”ìš´ìŠ¤
 # - âœ… [NEW] ì„¸ì…˜ ë¦¬ì…‹/ì§€ìˆ˜í˜• ë°±ì˜¤í”„ë¥¼ í¬í•¨í•œ ì•ˆì „ìš”ì²­(_safe_request), ì²´ê²° í›„ ì”ê³  ë™ê¸°í™”(refresh_after_order)
 
 import os
 import json
 import time
 import random
 import logging
 import threading
-import csv
 from datetime import datetime, timedelta
 from typing import Dict, List, Optional, Tuple, Any
 
 import requests
 import pytz
 from requests.adapters import HTTPAdapter
 from urllib3.util.retry import Retry
 
 from settings import APP_KEY, APP_SECRET, API_BASE_URL, CANO, ACNT_PRDT_CD, KIS_ENV
 from trader.time_utils import is_trading_day, is_trading_window, now_kst
 from trader.config import MARKET_MAP, SUBJECT_FLOW_TIMEOUT_SEC, SUBJECT_FLOW_RETRY
+from trader.fills import append_fill
 
 logger = logging.getLogger(__name__)
 _ORDER_BLOCK_STATE: Dict[str, Any] = {"date": None, "reason": None}
 
 
 class NetTemporaryError(Exception):
     """ë„¤íŠ¸ì›Œí¬/SSL ë“± ì¼ì‹œì  ì˜¤ë¥˜ë¥¼ ì˜ë¯¸ (ì œì™¸ ê¸ˆì§€, ë£¨í”„ ìŠ¤í‚µ)."""
     pass
 
 
 class DataEmptyError(Exception):
     """ì •ìƒì‘ë‹µì´ë‚˜ ìº”ë“¤ì´ 0ê°œ (ì‹¤ì œ ë°ì´í„° ì—†ìŒ)."""
     pass
 
 
 class DataShortError(Exception):
     """ì •ìƒì‘ë‹µì´ë‚˜ ìº”ë“¤ì´ need_n ë¯¸ë§Œ."""
     pass
 
 
 def _build_session():
     s = requests.Session()
     retry = Retry(
         total=6, connect=5, read=5, status=3,
         backoff_factor=0.6,
@@ -69,76 +69,50 @@ SESSION = _build_session()
 def _get_json(url, params=None, timeout=(3.0, 7.0)):
     try:
         r = SESSION.get(url, params=params, timeout=timeout)
         r.raise_for_status()
         return r.json()
     except requests.exceptions.SSLError as e:
         logger.warning("[NET:SSL_ERROR] %s %s", url, e)
         raise NetTemporaryError()
     except requests.exceptions.RequestException as e:
         logger.warning("[NET:REQ_ERROR] %s %s", url, e)
         raise NetTemporaryError()
 
 
 def safe_strip(val):
     if val is None:
         return ""
     if isinstance(val, str):
         return val.replace("\n", "").replace("\r", "").strip()
     return str(val).strip()
 
 
 def _json_dumps(body: dict) -> str:
     return json.dumps(body, ensure_ascii=False, separators=(",", ":"), sort_keys=False)
 
 
-def append_fill(side: str, code: str, name: str, qty: int, price: float, odno: str, note: str = ""):
-    try:
-        os.makedirs("fills", exist_ok=True)
-        path = f"fills/fills_{datetime.now().strftime('%Y%m%d')}.csv"
-        header = ["ts", "side", "code", "name", "qty", "price", "ODNO", "note"]
-        row = [
-            datetime.now().isoformat(),
-            side,
-            code,
-            name or "",
-            int(qty),
-            float(price) if price is not None else 0.0,
-            str(odno) if odno is not None else "",
-            note or "",
-        ]
-        new = not os.path.exists(path)
-        with open(path, "a", newline="", encoding="utf-8") as f:
-            w = csv.writer(f)
-            if new:
-                w.writerow(header)
-            w.writerow(row)
-        logger.info(f"[APPEND_FILL] {side} {code} qty={qty} price={price} odno={odno}")
-    except Exception as e:
-        logger.warning(f"[APPEND_FILL_FAIL] side={side} code={code} ex={e}")
-
-
 def _order_block_reason(now: datetime | None = None) -> Optional[str]:
     now = now or now_kst()
     state_date = _ORDER_BLOCK_STATE.get("date")
     state_reason = _ORDER_BLOCK_STATE.get("reason")
     if state_date and state_date != now.date():
         _ORDER_BLOCK_STATE.update({"date": None, "reason": None})
         state_date, state_reason = None, None
     if state_date == now.date() and state_reason:
         return str(state_reason)
     if not is_trading_day(now):
         _ORDER_BLOCK_STATE.update({"date": now.date(), "reason": "NON_TRADING_DAY"})
         return "NON_TRADING_DAY"
     if not is_trading_window(now):
         return "OUTSIDE_TRADING_WINDOW"
     return None
 
 
 def _mark_order_blocked(reason: str, now: datetime | None = None) -> None:
     now = now or now_kst()
     _ORDER_BLOCK_STATE.update({"date": now.date(), "reason": reason})
 
 
 def _is_order_disallowed(resp: Any) -> Optional[str]:
     if not isinstance(resp, dict):
         return None
@@ -1283,50 +1257,51 @@ class KisAPI:
                             pdno = safe_strip(body.get("PDNO", ""))
                             qty = int(float(body.get("ORD_QTY", "0")))
                             # ê°€ëŠ¥í•œ ê²½ìš° ì§€ì •ê°€ ì‚¬ìš©, ì•„ë‹ˆë©´ í˜„ì¬ê°€ë¡œ ì¶”ì •
                             price_for_fill = None
                             try:
                                 ord_unpr = body.get("ORD_UNPR")
                                 if ord_unpr and str(ord_unpr) not in ("0", "0.0", ""):
                                     price_for_fill = float(ord_unpr)
                                 else:
                                     try:
                                         price_for_fill = float(self.get_last_price(pdno))
                                     except Exception:
                                         price_for_fill = 0.0
                             except Exception:
                                 price_for_fill = 0.0
 
                             side = "SELL" if is_sell else "BUY"
                             append_fill(
                                 side=side,
                                 code=pdno,
                                 name="",
                                 qty=qty,
                                 price=price_for_fill,
                                 odno=odno,
                                 note=f"tr={tr_id},ord_dvsn={ord_dvsn}",
+                                reason="order_cash",
                             )
                         except Exception as e:
                             logger.warning(f"[APPEND_FILL_EX] ex={e} resp={data}")
                         return data
 
                     msg_cd = data.get("msg_cd", "")
                     msg1 = data.get("msg1", "")
                     # ê²Œì´íŠ¸ì›¨ì´/ì„œë²„ ì—ëŸ¬ë¥˜ëŠ” ì¬ì‹œë„
                     if msg_cd == "IGW00008" or "MCA" in msg1 or resp.status_code >= 500:
                         backoff = min(0.6 * (1.7 ** (attempt - 1)), 5.0) + random.uniform(0, 0.35)
                         logger.error(
                             f"[ORDER_FAIL_GATEWAY] tr_id={tr_id} ord_dvsn={ord_dvsn} attempt={attempt} "
                             f"resp={data} â†’ sleep {backoff:.2f}s"
                         )
                         time.sleep(backoff)
                         last_err = data
                         continue
 
                     logger.error(f"[ORDER_FAIL_BIZ] tr_id={tr_id} ord_dvsn={ord_dvsn} resp={data}")
                     blocked = _is_order_disallowed(data)
                     if blocked:
                         _mark_order_blocked(blocked, now)
                     return None
 
                 logger.warning(f"[ORDER_FALLBACK] tr_id={tr_id} ord_dvsn={ord_dvsn} ì‹¤íŒ¨ â†’ ë‹¤ìŒ ë°©ì‹ ì‹œë„")
@@ -1356,51 +1331,51 @@ class KisAPI:
             if safe_strip(r.get("pdno")) == safe_strip(pdno):
                 hldg = int(float(r.get("hldg_qty", "0")))
                 ord_psbl = int(float(r.get("ord_psbl_qty", "0")))
                 break
 
         base_qty = hldg if hldg > 0 else ord_psbl
         if base_qty <= 0:
             logger.error(f"[SELL_PRECHECK] ë³´ìœ  ì—†ìŒ/ìˆ˜ëŸ‰ 0 pdno={pdno} hldg={hldg} ord_psbl={ord_psbl}")
             return None
 
         if qty > base_qty:
             logger.warning(
                 f"[SELL_PRECHECK] ìˆ˜ëŸ‰ ë³´ì •: req={qty} -> base={base_qty} (hldg={hldg}, ord_psbl={ord_psbl})"
             )
             qty = base_qty
 
         # --- ì¤‘ë³µ ë§¤ë„ ë°©ì§€(ë©”ëª¨ë¦¬ ê¸°ë°˜) ---
         now_ts = time.time()
         with self._recent_sells_lock:
             last = self._recent_sells.get(pdno)
             if last and (now_ts - last) < self._recent_sells_cooldown:
                 logger.warning(
                     f"[SELL_DUP_BLOCK] ìµœê·¼ ë§¤ë„ ê¸°ë¡ìœ¼ë¡œ ì¤‘ë³µ ë§¤ë„ ì°¨ë‹¨ pdno={pdno} "
                     f"last={last} age={now_ts-last:.1f}s"
                 )
-                return None
+                return {"status": "SKIPPED", "skip_reason": "DUP_BLOCK"}
 
         body = {
             "CANO": self.CANO,
             "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
             "PDNO": safe_strip(pdno),
             "SLL_TYPE": "01",  # ì¼ë°˜ë§¤ë„
             "ORD_QTY": str(int(qty)),
             "ORD_DVSN": "01",
             "ORD_UNPR": "0",
             "EXCG_ID_DVSN_CD": "KRX",
         }
         resp = self._order_cash(body, is_sell=True)
         if resp and isinstance(resp, dict) and resp.get("rt_cd") == "0":
             with self._recent_sells_lock:
                 self._recent_sells[pdno] = time.time()
                 cutoff = time.time() - (self._recent_sells_cooldown * 5)
                 keys_to_del = [k for k, v in self._recent_sells.items() if v < cutoff]
                 for k in keys_to_del:
                     del self._recent_sells[k]
         return resp
 
     def buy_stock_limit(self, pdno: str, qty: int, price: int) -> Optional[dict]:
         now = now_kst()
         block_reason = _order_block_reason(now)
         if block_reason:
@@ -1472,90 +1447,91 @@ class KisAPI:
                 break
 
         base_qty = hldg if hldg > 0 else ord_psbl
         if base_qty <= 0:
             logger.error(
                 f"[SELL_LIMIT_PRECHECK] ë³´ìœ  ì—†ìŒ/ìˆ˜ëŸ‰ 0 pdno={pdno} hldg={hldg} ord_psbl={ord_psbl}"
             )
             return None
 
         if qty > base_qty:
             logger.warning(
                 f"[SELL_LIMIT_PRECHECK] ìˆ˜ëŸ‰ ë³´ì •: req={qty} -> base={base_qty} "
                 f"(hldg={hldg}, ord_psbl={ord_psbl})"
             )
             qty = base_qty
 
         # ì¤‘ë³µ ë§¤ë„ ë°©ì§€(ë©”ëª¨ë¦¬ ê¸°ë°˜)
         now_ts = time.time()
         with self._recent_sells_lock:
             last = self._recent_sells.get(pdno)
             if last and (now_ts - last) < self._recent_sells_cooldown:
                 logger.warning(
                     f"[SELL_DUP_BLOCK_LIMIT] ìµœê·¼ ë§¤ë„ ê¸°ë¡ìœ¼ë¡œ ì¤‘ë³µ ë§¤ë„ ì°¨ë‹¨ pdno={pdno} "
                     f"last={last} age={now_ts-last:.1f}s"
                 )
-                return None
+                return {"status": "SKIPPED", "skip_reason": "DUP_BLOCK"}
 
         body = {
             "CANO": self.CANO,
             "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
             "PDNO": safe_strip(pdno),
             "SLL_TYPE": "01",
             "ORD_QTY": str(int(qty)),
             "ORD_DVSN": "00",  # ì§€ì •ê°€
             "ORD_UNPR": str(int(price)),
             "EXCG_ID_DVSN_CD": "KRX",
         }
         hk = self._create_hashkey(body)
         tr_list = _pick_tr(self.env, "ORDER_SELL")
         if not tr_list:
             raise Exception("ORDER_SELL TR ë¯¸êµ¬ì„±")
         tr_id = tr_list[0]
         headers = self._headers(tr_id, hk)
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/order-cash"
         # [CHG] ì•ˆì „ìš”ì²­ ì‚¬ìš©
         resp = self._safe_request(
             "POST", url, headers=headers, data=_json_dumps(body).encode("utf-8"), timeout=(3.0, 7.0)
         )
         data = resp.json()
         if resp.status_code == 200 and data.get("rt_cd") == "0":
             logger.info(f"[SELL_LIMIT_OK] output={data.get('output')}")
             try:
                 out = data.get("output") or {}
                 odno = out.get("ODNO") or out.get("ord_no") or ""
                 pdno = safe_strip(body.get("PDNO", ""))
                 qty_int = int(float(body.get("ORD_QTY", "0")))
                 price_for_fill = float(body.get("ORD_UNPR", 0))
                 append_fill(
                     side="SELL",
                     code=pdno,
                     name="",
                     qty=qty_int,
                     price=price_for_fill,
                     odno=odno,
                     note=f"limit,tr={tr_id}",
+                    reason="sell_limit",
                 )
             except Exception as e:
                 logger.warning(f"[APPEND_FILL_LIMIT_SELL_FAIL] ex={e}")
             with self._recent_sells_lock:
                 self._recent_sells[pdno] = time.time()
             return data
         logger.error(f"[SELL_LIMIT_FAIL] {data}")
         blocked = _is_order_disallowed(data)
         if blocked:
             _mark_order_blocked(blocked, now)
         return None
 
     # -------------------------------
     # ë§¤ìˆ˜/ë§¤ë„ (ì‹ ê·œ ê°€ë“œ ì‚¬ìš© ë²„ì „)
     # -------------------------------
     def buy_stock_limit_guarded(self, code: str, qty: int, limit_price: int, **kwargs):
         """
         ì§€ì •ê°€ ë§¤ìˆ˜ ì‹œ ì˜ˆìˆ˜ê¸ˆ ë¶€ì¡±/ê³¼ë§¤ìˆ˜ ìë™ ì¶•ì†Œ ë˜ëŠ” ìŠ¤í‚µ.
         âœ… practice í™˜ê²½ì—ì„œëŠ” KISì—ê²Œ ì§ì ‘ íŒë‹¨ì„ ë§¡ê¸°ê³ , ë‚´ë¶€ ê°€ë“œëŠ” ìƒëµ.
         """
         # ğŸ”¸ ëª¨ì˜íˆ¬ì(practice) ê³„ì¢Œì—ì„œëŠ” ì˜ˆìˆ˜ê¸ˆ ê°€ë“œ ì‚¬ìš© X â†’ ë°”ë¡œ KISë¡œ ì£¼ë¬¸
         if self.env == "practice":
             logger.info(
                 f"[BUY_GUARD] practice env â†’ guard ìƒëµ, ì§ì ‘ ì§€ì •ê°€ ì£¼ë¬¸ "
                 f"(code={code}, qty={qty}, limit={limit_price})"
diff --git a/trader/legacy_kosdaq_runner.py b/trader/legacy_kosdaq_runner.py
index a6ffcbddaee428334b98f3da9de1beca12d5abea..a6582d9c89b18fb078ecff4e2f090255f1e9cbf4 100644
--- a/trader/legacy_kosdaq_runner.py
+++ b/trader/legacy_kosdaq_runner.py
@@ -1,260 +1,385 @@
 # -*- coding: utf-8 -*-
 """ê±°ë˜ ë©”ì¸ ë£¨í”„.
 
 ê¸°ì¡´ trader.pyì˜ ì„¤ì •/ìœ í‹¸ì„ ë¶„ë¦¬í•˜ê³ , ë©”ì¸ ì§„ì…ì ë§Œ ë‚¨ê²¨ ì „ëµ ì¶”ê°€ê°€
 ì‰¬ìš´ êµ¬ì¡°ë¡œ ë³€ê²½í–ˆë‹¤.
 """
 from __future__ import annotations
 
+import json
 import time
-from datetime import datetime, time as dtime, timedelta
+from datetime import date, datetime, time as dtime, timedelta
 from typing import Any, Dict, List, Tuple, TYPE_CHECKING
 
 
 try:
     from .config import (
         DAILY_CAPITAL,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         ALLOW_WHEN_CLOSED,
         ALLOW_PYRAMID,
+        BASE_QTY_MODE,
         KST,
+        LOG_DIR,
         RATE_SLEEP_SEC,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         _cfg,
         logger,
     )
 except ImportError:
     # ALLOW_WHEN_CLOSEDê°€ ëˆ„ë½ë¼ë„ ëŸ¬ë„ˆê°€ ì¦‰ì‹œ ì¤‘ë‹¨ë˜ì§€ ì•Šë„ë¡ ì•ˆì „í•œ ê¸°ë³¸ê°’ì„ ì œê³µí•œë‹¤.
     from .config import (
         DAILY_CAPITAL,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         KST,
+        LOG_DIR,
+        BASE_QTY_MODE,
         RATE_SLEEP_SEC,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         _cfg,
         logger,
     )
 
     ALLOW_WHEN_CLOSED = False
     logger.warning("[CONFIG] ALLOW_WHEN_CLOSED missing; defaulting to False")
     ALLOW_PYRAMID = False
     logger.warning("[CONFIG] ALLOW_PYRAMID missing; defaulting to False")
 from . import signals
 from trader.time_utils import MARKET_CLOSE, MARKET_OPEN, is_trading_day
 from trader.subject_flow import get_subject_flow_with_fallback, reset_flow_call_count
 from .core import *  # noqa: F401,F403 - ì „ëµ ìœ í‹¸ ì „ì²´ ë…¸ì¶œë¡œ í™•ì¥ì„± í™•ë³´
 
 if TYPE_CHECKING:
     # core ìª½ì— êµ¬í˜„ë¼ ìˆëŠ” í—¬í¼ë“¤ì„ íƒ€ì…ì²´ì»¤ì—ê²Œë§Œ ëª…ì‹œì ìœ¼ë¡œ ì•Œë ¤ì¤€ë‹¤.
     from .core import (
         _this_iso_week_key,
         _get_effective_ord_cash,
         _to_float,
         _to_int,
         _weight_to_qty,
         _classify_champion_grade,
         _update_market_regime,
         _notional_to_qty,
         _fetch_balances,
         _init_position_state_from_balance,
         _sell_once,
         _adaptive_exit,
         _compute_daily_entry_context,
         _compute_intraday_entry_context,
         _safe_get_price,
         _round_to_tick,
         _init_position_state,
         _detect_pullback_reversal,
         _has_bullish_trend_structure,
     )
 
 
-def main(capital_override: float | None = None, selected_stocks: list[dict[str, Any]] | None = None):
+def main(
+    capital_override: float | None = None,
+    selected_stocks: list[dict[str, Any]] | None = None,
+):
     reset_flow_call_count()
-    effective_capital = int(capital_override) if capital_override is not None else DAILY_CAPITAL
+    effective_capital = (
+        int(capital_override) if capital_override is not None else DAILY_CAPITAL
+    )
     kis = KisAPI()
 
     rebalance_date = get_rebalance_anchor_date()
-    logger.info(f"[â„¹ï¸ ë¦¬ë°¸ëŸ°ì‹± ê¸°ì¤€ì¼(KST)]: {rebalance_date} (anchor={REBALANCE_ANCHOR}, ref={WEEKLY_ANCHOR_REF})")
+    logger.info(
+        f"[â„¹ï¸ ë¦¬ë°¸ëŸ°ì‹± ê¸°ì¤€ì¼(KST)]: {rebalance_date} (anchor={REBALANCE_ANCHOR}, ref={WEEKLY_ANCHOR_REF})"
+    )
     logger.info(
         f"[â±ï¸ ì»¤íŠ¸ì˜¤í”„(KST)] SELL_FORCE_TIME={SELL_FORCE_TIME.strftime('%H:%M')} / ì „ì²´ì”ê³ ë§¤ë„={SELL_ALL_BALANCES_AT_CUTOFF} / "
         f"íŒ¨ìŠ¤(ì»¤íŠ¸ì˜¤í”„/ë§ˆê°)={FORCE_SELL_PASSES_CUTOFF}/{FORCE_SELL_PASSES_CLOSE}"
     )
-    logger.info(f"[ğŸ’° CAPITAL] {effective_capital:,}ì› (configured DAILY_CAPITAL={DAILY_CAPITAL:,})")
+    logger.info(
+        f"[ğŸ’° CAPITAL] {effective_capital:,}ì› (configured DAILY_CAPITAL={DAILY_CAPITAL:,})"
+    )
     logger.info(f"[ğŸ›¡ï¸ SLIPPAGE_ENTER_GUARD_PCT] {SLIPPAGE_ENTER_GUARD_PCT:.2f}%")
 
     # ìƒíƒœ ë³µêµ¬
     state_loaded_at = datetime.now(KST)
     state_loaded_date = state_loaded_at.strftime("%Y-%m-%d")
     state_loaded_str = state_loaded_at.strftime("%Y-%m-%d %H:%M:%S")
     state_loaded_midnight = f"{state_loaded_date} 00:00:00"
 
     holding, traded = load_state()
     triggered_today: set[str] = set()
+    s1_done_today: set[str] = set()
     last_price_map: dict[str, float] = {}
     last_today_prefix: str | None = None
 
     if isinstance(traded, (set, list, tuple)):
         logger.warning(
             f"[STATE-MIGRATE] traded íƒ€ì… {type(traded)} â†’ dictë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜(ì¤‘ë³µ ì§„ì… ê°€ë“œ ìœ ì§€)"
         )
         traded = {
             code: {"buy_time": state_loaded_midnight, "qty": 0, "price": 0.0}
             for code in traded
         }
     elif not isinstance(traded, dict):
         logger.warning(
             f"[STATE-FORMAT] traded íƒ€ì… {type(traded)} ì§€ì› ì•ˆ í•¨ â†’ ë¹ˆ dictë¡œ ì¬ì„¤ì •"
         )
         traded = {}
 
     def _traded_codes(traded_state: Any) -> List[str]:
         if isinstance(traded_state, dict):
             return list(traded_state.keys())
         return []
 
     def _traded_today(traded_state: Any, today_prefix: str) -> set:
         if not isinstance(traded_state, dict):
             return set()
 
         today_codes = set()
         for code, payload in traded_state.items():
             payload = payload or {}
             buy_time = payload.get("buy_time")
             status = payload.get("status")
             # pending/other ìƒíƒœëŠ” ì¬ì‹œë„ í—ˆìš©, filled/ê¸°ì¡´(None)ë§Œ ì¤‘ë³µ ë°©ì§€
             if status not in (None, "filled"):
                 continue
             if isinstance(buy_time, str) and buy_time.startswith(today_prefix):
                 today_codes.add(code)
         return today_codes
 
     def _record_trade(traded_state: Any, code: str, payload: Dict[str, Any]) -> None:
         try:
             traded_state[code] = payload
         except Exception:
-            logger.warning(f"[TRADED-STATE] tradedì— ì½”ë“œ ì¶”ê°€ ì‹¤íŒ¨: type={type(traded_state)}")
+            logger.warning(
+                f"[TRADED-STATE] tradedì— ì½”ë“œ ì¶”ê°€ ì‹¤íŒ¨: type={type(traded_state)}"
+            )
 
     def _cleanup_expired_pending(
         traded_state: dict, now_dt: datetime, ttl_sec: int = 300
     ) -> set:
         expired: set[str] = set()
         if not isinstance(traded_state, dict):
             return expired
 
         for code, payload in list(traded_state.items()):
             payload = payload or {}
             if payload.get("status") != "pending":
                 continue
 
             ts = payload.get("pending_since") or payload.get("buy_time")
             if not isinstance(ts, str):
                 continue
 
             try:
-                pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(tzinfo=now_dt.tzinfo)
+                pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(
+                    tzinfo=now_dt.tzinfo
+                )
                 if (now_dt - pending_dt).total_seconds() > ttl_sec:
-                    logger.warning(f"[PENDING-EXPIRE] {code}: {ttl_sec}s ì´ˆê³¼ â†’ pending ì œê±°")
+                    logger.warning(
+                        f"[PENDING-EXPIRE] {code}: {ttl_sec}s ì´ˆê³¼ â†’ pending ì œê±°"
+                    )
                     traded_state.pop(code, None)
                     expired.add(code)
             except Exception:
                 continue
         return expired
 
-    def _pending_block(traded_state: dict, code: str, now_dt: datetime, block_sec: int = 45) -> bool:
+    guard_state_date: date | None = None
+    guard_state: dict[str, Any] = {
+        "period": "daily",
+        "s1_target": {},
+        "s1_nontarget": {},
+        "s2_target": {},
+        "s2_nontarget": {},
+    }
+
+    def _guard_state_file(day: date):
+        return LOG_DIR / f"regime_guards_{day}.json"
+
+    def _guard_state_template() -> dict[str, Any]:
+        return {
+            "period": "daily",
+            "s1_target": {},
+            "s1_nontarget": {},
+            "s2_target": {},
+            "s2_nontarget": {},
+        }
+
+    def _load_guard_state(day: date) -> dict[str, Any]:
+        state = _guard_state_template()
+        path = _guard_state_file(day)
+        if path.exists():
+            try:
+                with open(path, "r", encoding="utf-8") as f:
+                    payload = json.load(f) or {}
+                for key in state.keys():
+                    if key == "period":
+                        state[key] = payload.get("period", "daily")
+                    else:
+                        state[key] = payload.get(key, {}) or {}
+            except Exception as e:
+                logger.warning(f"[REGIME-GUARD][LOAD] {day} ì‹¤íŒ¨: {e}")
+        return state
+
+    def _persist_guard_state(day: date) -> None:
+        try:
+            path = _guard_state_file(day)
+            path.parent.mkdir(parents=True, exist_ok=True)
+            payload = {"date": str(day), **guard_state}
+            with open(path, "w", encoding="utf-8") as f:
+                json.dump(payload, f, ensure_ascii=False, indent=2)
+        except Exception as e:
+            logger.warning(f"[REGIME-GUARD][SAVE] {day} ì‹¤íŒ¨: {e}")
+
+    def _ensure_guard_state(day: date) -> None:
+        nonlocal guard_state_date, guard_state
+        if guard_state_date != day:
+            guard_state = _load_guard_state(day)
+            guard_state_date = day
+
+    def _guard_entry(bucket: str, day: date, code: str, base_qty: int) -> dict:
+        _ensure_guard_state(day)
+        bucket_state = guard_state.setdefault(bucket, {})
+        entry = bucket_state.get(code)
+        if entry is None:
+            entry = {"base_qty": int(base_qty), "sold": 0}
+            bucket_state[code] = entry
+            _persist_guard_state(day)
+        elif BASE_QTY_MODE == "current":
+            base_int = int(base_qty)
+            if entry.get("base_qty") != base_int:
+                entry["base_qty"] = base_int
+                _persist_guard_state(day)
+        return entry
+
+    def _s1_guard_target(today_date, code: str, base_qty: int) -> dict:
+        return _guard_entry("s1_target", today_date, code, base_qty)
+
+    def _s1_guard_nontarget(today_date, code: str, base_qty: int) -> dict:
+        return _guard_entry("s1_nontarget", today_date, code, base_qty)
+
+    def _s2_guard_target(today_date, code: str, base_qty: int) -> dict:
+        return _guard_entry("s2_target", today_date, code, base_qty)
+
+    def _s2_guard_nontarget(today_date, code: str, base_qty: int) -> dict:
+        return _guard_entry("s2_nontarget", today_date, code, base_qty)
+
+    def _sell_result_status(result: Any) -> tuple[str, str | None]:
+        try:
+            if isinstance(result, dict):
+                if str(result.get("status")) == "SKIPPED":
+                    return "SKIP", str(result.get("skip_reason") or "")
+                if str(result.get("rt_cd")) == "0":
+                    return "SENT", None
+        except Exception:
+            pass
+        return "ERROR", None
+
+    def _pending_block(
+        traded_state: dict, code: str, now_dt: datetime, block_sec: int = 45
+    ) -> bool:
         if not isinstance(traded_state, dict):
             return False
         payload = traded_state.get(code) or {}
         if payload.get("status") != "pending":
             return False
 
         ts = payload.get("pending_since") or payload.get("buy_time")
         if not isinstance(ts, str):
             return True
 
         try:
-            pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(tzinfo=now_dt.tzinfo)
+            pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(
+                tzinfo=now_dt.tzinfo
+            )
             return (now_dt - pending_dt).total_seconds() <= block_sec
         except Exception:
             return True
 
-    def _is_balance_reflected(code: str, prev_qty: int = 0, delay_sec: float = 1.0) -> bool:
+    def _is_balance_reflected(
+        code: str, prev_qty: int = 0, delay_sec: float = 1.0
+    ) -> bool:
         try:
             time.sleep(delay_sec)
             balances = _fetch_balances(kis, ttl_sec=0)
         except Exception as e:
             logger.warning(f"[BAL-REFRESH-FAIL] {code}: ì”ê³  í™•ì¸ ì‹¤íŒ¨ {e}")
             return False
 
         for row in balances:
             try:
                 if str(row.get("code")).zfill(6) != str(code).zfill(6):
                     continue
                 qty_here = _to_int(row.get("qty") or 0)
-                sellable_here = _to_int((row.get("sell_psbl_qty") or row.get("ord_psbl_qty")) or 0)
+                sellable_here = _to_int(
+                    (row.get("sell_psbl_qty") or row.get("ord_psbl_qty")) or 0
+                )
                 baseline_qty = max(0, int(prev_qty))
                 if qty_here > baseline_qty or sellable_here > baseline_qty:
                     return True
             except Exception:
                 continue
 
         return False
 
     def _subject_flow_gate(
         code: str,
         info: Dict[str, Any],
         current_price: float,
         target_price: float | None,
         vwap_val: float | None,
     ) -> tuple[bool, Dict[str, Any], float]:
         day_turnover_krw = _to_float(
-            info.get("prev_turnover") or info.get("avg_turnover") or info.get("turnover"), 0.0
+            info.get("prev_turnover")
+            or info.get("avg_turnover")
+            or info.get("turnover"),
+            0.0,
         )
         market = (info.get("market") or "KOSDAQ").upper()
         flow = get_subject_flow_with_fallback(
             kis, code, market, float(day_turnover_krw or 0.0)
         )
         score = flow.get("score") or {}
 
         turnover_guard = float(CHAMPION_A_RULES.get("min_turnover") or 0.0)
         ob_guard = 0.0
         ob_strength_val: float = 0.0
         try:
-            ob_strength_val = float(_to_float(kis.get_orderbook_strength(code), 0.0) or 0.0)
+            ob_strength_val = float(
+                _to_float(kis.get_orderbook_strength(code), 0.0) or 0.0
+            )
         except Exception as e:
             logger.warning(f"[OB_STRENGTH_FAIL] {code}: {e}")
 
         if flow.get("degraded"):
             turnover_guard *= float(flow.get("turnover_guard_mult") or 1.0)
             ob_guard += float(flow.get("ob_strength_add") or 0.0)
 
         ok = bool(flow.get("flow_ok"))
         reason_tag = None
 
         if turnover_guard > 0 and float(day_turnover_krw or 0.0) < turnover_guard:
             ok = False
             reason_tag = "LOW_TURNOVER"
         if ob_guard > 0 and ob_strength_val < ob_guard:
             ok = False
             reason_tag = "OB_WEAK"
 
         if not ok:
             if reason_tag is None:
                 decision = str(flow.get("decision") or "")
                 if decision.startswith("BLOCK"):
                     reason_tag = "SUBJECT_FLOW_FAIL_BLOCK"
                 else:
                     reason_tag = "SUBJECT_FLOW_WEAK"
 
@@ -293,108 +418,119 @@ def main(capital_override: float | None = None, selected_stocks: list[dict[str,
                 for key in (
                     # ì²´ê²°ê°€/í‰ê· ê°€ í›„ë³´
                     "ccld_prc",
                     "ccld_unpr",
                     "tot_ccld_unpr",
                     "tot_ccld_prc",
                     "avg_price",
                     "avg_prvs",
                     "fill_price",
                     # ì£¼ë¬¸ê°€(í›„ìˆœìœ„)
                     "prdt_price",
                     "ord_unpr",
                     "ord_prc",
                     "order_price",
                 ):
                     val = None
                     if isinstance(payload, dict):
                         val = payload.get(key)
                     if val not in (None, ""):
                         try:
                             return float(val)
                         except Exception:
                             continue
         return float(fallback_price)
 
-    logger.info(f"[ìƒíƒœë³µêµ¬] holding: {list(holding.keys())}, traded: {_traded_codes(traded)}")
+    logger.info(
+        f"[ìƒíƒœë³µêµ¬] holding: {list(holding.keys())}, traded: {_traded_codes(traded)}"
+    )
 
     pullback_buys_today = 0
     pullback_buy_date = datetime.now(KST).date()
 
     # === [NEW] ì£¼ê°„ ë¦¬ë°¸ëŸ°ì‹± ê°•ì œ/ì¤‘ë³µ ë°©ì§€ ===
     targets: List[Dict[str, Any]] = []
     if selected_stocks is not None:
         targets = list(selected_stocks)
         logger.info(
-            "[REBALANCE] injected selected_stocks count=%d (skip API fetch)", len(targets)
+            "[REBALANCE] injected selected_stocks count=%d (skip API fetch)",
+            len(targets),
         )
     elif REBALANCE_ANCHOR == "weekly":
         if should_weekly_rebalance_now():
             targets = fetch_rebalancing_targets(rebalance_date)
             # ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ë¥¼ ìœ„í•´ ì¦‰ì‹œ ìŠ¤íƒ¬í”„(í•„ìš” ì‹œ FORCEë¡œ ì¬ì‹¤í–‰ ê°€ëŠ¥)
             stamp_weekly_done()
-            logger.info(f"[REBALANCE] ì´ë²ˆ ì£¼ ë¦¬ë°¸ëŸ°ì‹± ì‹¤í–‰ ê¸°ë¡ ì €ì¥({_this_iso_week_key()})")
+            logger.info(
+                f"[REBALANCE] ì´ë²ˆ ì£¼ ë¦¬ë°¸ëŸ°ì‹± ì‹¤í–‰ ê¸°ë¡ ì €ì¥({_this_iso_week_key()})"
+            )
         else:
-            logger.info("[REBALANCE] ì´ë²ˆ ì£¼ ì´ë¯¸ ì‹¤í–‰ë¨ â†’ ì‹ ê·œ ë¦¬ë°¸ëŸ°ì‹± ìƒëµ (ë³´ìœ  ê´€ë¦¬ë§Œ)")
+            logger.info(
+                "[REBALANCE] ì´ë²ˆ ì£¼ ì´ë¯¸ ì‹¤í–‰ë¨ â†’ ì‹ ê·œ ë¦¬ë°¸ëŸ°ì‹± ìƒëµ (ë³´ìœ  ê´€ë¦¬ë§Œ)"
+            )
     else:
         # today/monthly ë“± ë‹¤ë¥¸ ì•µì»¤ ëª¨ë“œëŠ” ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ë°”ë¡œ í˜¸ì¶œ
         targets = fetch_rebalancing_targets(rebalance_date)
 
     # === [NEW] ì˜ˆì‚° ê°€ë“œ: ì˜ˆìˆ˜ê¸ˆì´ 0/ë¶€ì¡±ì´ë©´ ì‹ ê·œ ë§¤ìˆ˜ë§Œ ìŠ¤í‚µ ===
     effective_cash = _get_effective_ord_cash(kis, soft_cap=effective_capital)
     if effective_cash <= 0:
         can_buy = False
         logger.warning("[BUDGET] ìœ íš¨ ì˜ˆì‚° 0 â†’ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ(ë³´ìœ  ê´€ë¦¬ë§Œ ìˆ˜í–‰)")
     else:
         can_buy = True
     logger.info(
         f"[BUDGET] today effective cash = {effective_cash:,} KRW (capital base={effective_capital:,})"
     )
 
     # ë¦¬ë°¸ëŸ°ì‹± ëŒ€ìƒ í›„ì²˜ë¦¬: qty ì—†ê³  weightë§Œ ìˆìœ¼ë©´ ë°°ì • ìë³¸ìœ¼ë¡œ ìˆ˜ëŸ‰ ê³„ì‚°
     processed_targets: Dict[str, Any] = {}
     for t in targets:
         code = t.get("stock_code") or t.get("code")
         if not code:
             continue
         name = t.get("name") or t.get("ì¢…ëª©ëª…")
         k_best = t.get("best_k") or t.get("K") or t.get("k")
         target_price = _to_float(t.get("ëª©í‘œê°€") or t.get("target_price"))
         qty = _to_int(t.get("ë§¤ìˆ˜ìˆ˜ëŸ‰") or t.get("qty"), 0)
         weight = t.get("weight")
         strategy = t.get("strategy") or "ì „ì›” rolling K ìµœì í™”"
         avg_return_pct = _to_float(t.get("avg_return_pct") or t.get("ìˆ˜ìµë¥ (%)"), 0.0)
         win_rate_pct = _to_float(t.get("win_rate_pct") or t.get("ìŠ¹ë¥ (%)"), 0.0)
         mdd_pct = _to_float(t.get("mdd_pct") or t.get("MDD(%)"), 0.0)
         trades = _to_int(t.get("trades"), 0)
         sharpe_m = _to_float(t.get("sharpe_m"), 0.0)
-        cumret_pct = _to_float(t.get("cumulative_return_pct") or t.get("ìˆ˜ìµë¥ (%)"), 0.0)
+        cumret_pct = _to_float(
+            t.get("cumulative_return_pct") or t.get("ìˆ˜ìµë¥ (%)"), 0.0
+        )
 
         if qty <= 0 and weight is not None:
             ref_px = _to_float(t.get("close")) or _to_float(t.get("prev_close"))
             try:
-                qty = _weight_to_qty(kis, code, float(weight), effective_capital, ref_price=ref_px)
+                qty = _weight_to_qty(
+                    kis, code, float(weight), effective_capital, ref_price=ref_px
+                )
             except Exception as e:
                 logger.warning("[REBALANCE] weightâ†’qty ë³€í™˜ ì‹¤íŒ¨ %s: %s", code, e)
                 qty = 0
 
         processed_targets[code] = {
             "code": code,
             "name": name,
             "best_k": k_best,
             "target_price": target_price,
             "qty": qty,
             "strategy": strategy,
             "avg_return_pct": avg_return_pct,
             "win_rate_pct": win_rate_pct,
             "mdd_pct": mdd_pct,
             "trades": trades,
             "sharpe_m": sharpe_m,
             "cumulative_return_pct": cumret_pct,
             "prev_open": t.get("prev_open"),
             "prev_high": t.get("prev_high"),
             "prev_low": t.get("prev_low"),
             "prev_close": t.get("prev_close"),
             "prev_volume": t.get("prev_volume"),
         }
 
     filtered_targets: Dict[str, Any] = {}
@@ -415,53 +551,51 @@ def main(capital_override: float | None = None, selected_stocks: list[dict[str,
             )
             continue
 
         filtered_targets[code] = info
 
     processed_targets = filtered_targets
 
     # ì±”í”¼ì–¸ ë“±ê¸‰í™” (A/B/C) â†’ ì‹¤ì œ ë§¤ìˆ˜ í›„ë³´ëŠ” Aê¸‰ë§Œ ì‚¬ìš©
     graded_targets: Dict[str, Any] = {}
     grade_counts = {"A": 0, "B": 0, "C": 0}
     for code, info in processed_targets.items():
         grade = _classify_champion_grade(info)
         info["champion_grade"] = grade
         graded_targets[code] = info
         grade_counts[grade] = grade_counts.get(grade, 0) + 1
 
     logger.info(
         "[CHAMPION-GRADE] A:%d / B:%d / C:%d (A/Bê¸‰ ì‹¤ì œ ë§¤ìˆ˜)",
         grade_counts.get("A", 0),
         grade_counts.get("B", 0),
         grade_counts.get("C", 0),
     )
 
     # ğŸ”½ ì—¬ê¸° í•„í„°ë¥¼ A â†’ A/B ë¡œ
     processed_targets = {
-        k: v
-        for k, v in graded_targets.items()
-        if v.get("champion_grade") in ("A", "B")
+        k: v for k, v in graded_targets.items() if v.get("champion_grade") in ("A", "B")
     }
     # === [ì±”í”¼ì–¸ & ë ˆì§ ìƒì„¸ ë¡œê·¸] ===
     try:
         if isinstance(processed_targets, dict) and len(processed_targets) > 0:
             # 1) ì±”í”¼ì–¸ 1ê°œ(1ìˆœìœ„)ë§Œ ë½‘ì•„ì„œ ë¡œê·¸ (processed_targetsê°€ dictì¼ ë•Œ)
             first_code = next(iter(processed_targets.keys()))
             champion_one = processed_targets.get(first_code)
 
             # champion dict ì•ˆì— codeê°€ ì—†ìœ¼ë©´ ë³´ê°•
             if isinstance(champion_one, dict) and "code" not in champion_one:
                 champion_one = {**champion_one, "code": first_code}
 
             # 2) regime_stateëŠ” ì´ë¯¸ ë§Œë“  regime(ë˜ëŠ” _update_market_regime(kis) ê²°ê³¼)ë¥¼ ë„£ì–´ì•¼ í•¨
             #    ì´ ë¸”ë¡ ì§ì „ì— regime = _update_market_regime(kis) ê°€ ìˆì–´ì•¼ í•¨
             #    ì—†ìœ¼ë©´ ì—¬ê¸°ì„œ í•œ ë²ˆ êµ¬í•´ë„ ë¨:
             try:
                 regime_state = regime  # regime ë³€ìˆ˜ê°€ ìœ„ì—ì„œ ë§Œë“¤ì–´ì ¸ ìˆìœ¼ë©´ ì´ê±¸ ì‚¬ìš©
             except NameError:
                 regime_state = _update_market_regime(kis)
 
             # 3) contextëŠ” ë¬¸ìì—´ë¡œ(í˜¹ì€ execution.pyë¥¼ Anyë¡œ ë°”ê¿¨ë‹¤ë©´ dictë„ ê°€ëŠ¥)
             context = "rebalance_api"
 
             log_champion_and_regime(logger, champion_one, regime_state, context)
     except Exception as e:
@@ -497,88 +631,92 @@ def main(capital_override: float | None = None, selected_stocks: list[dict[str,
         ("bull", 0): 6,
         ("neutral", 0): 5,
         ("bear", 0): 4,
         ("bear", 1): 3,
         ("bear", 2): 2,
     }
 
     REG_PARTIAL_S1 = float(_cfg("REG_PARTIAL_S1") or "0.3")
     REG_PARTIAL_S2 = float(_cfg("REG_PARTIAL_S2") or "0.3")
     TRAIL_PCT_BULL = float(_cfg("TRAIL_PCT_BULL") or "0.025")
     TRAIL_PCT_BEAR = float(_cfg("TRAIL_PCT_BEAR") or "0.012")
     TP_PROFIT_PCT_BULL = float(_cfg("TP_PROFIT_PCT_BULL") or "3.5")
 
     cap_scale = REGIME_CAP_TABLE.get(regime.get("key"), 0.8)
     ord_cash = _get_effective_ord_cash(kis, soft_cap=effective_capital)
     capital_base = min(ord_cash, int(CAP_CAP * effective_capital))
     capital_active = int(min(capital_base * cap_scale, effective_capital))
     logger.info(
         f"[REGIME-CAP] mode={mode} stage={stage} R20={R20 if R20 is not None else 'N/A'} "
         f"D1={D1 if D1 is not None else 'N/A'} "
         f"ord_cash(effective)={ord_cash:,} base={capital_base:,} active={capital_active:,} "
         f"scale={cap_scale:.2f}"
     )
 
     # ë ˆì§ë³„ ìµœëŒ€ ë³´ìœ  ì¢…ëª© ìˆ˜
-    n_active = REGIME_MAX_ACTIVE.get(regime_key, REGIME_MAX_ACTIVE.get(("neutral", 0), 3))
+    n_active = REGIME_MAX_ACTIVE.get(
+        regime_key, REGIME_MAX_ACTIVE.get(("neutral", 0), 3)
+    )
 
     scored: List[Tuple[str, float, bool]] = []
 
     for code, info in processed_targets.items():
         score = _to_float(info.get("composite_score"), 0.0) or 0.0
 
         # ë‹¨ê¸° ëª¨ë©˜í…€ ê°•ì„¸ ì—¬ë¶€ (is_strong_momentum)ë¡œ ë²„í‚· êµ¬ë¶„
         try:
             strong = is_strong_momentum(kis, code)
         except Exception as e:
             logger.warning("[REBALANCE] ëª¨ë©˜í…€ íŒë³„ ì‹¤íŒ¨ %s: %s", code, e)
             strong = False
 
         scored.append((code, score, strong))
 
     # ëª¨ë©˜í…€ strong ë²„í‚· ìš°ì„ , ê·¸ ë‹¤ìŒ ë‚˜ë¨¸ì§€ ì¤‘ì—ì„œ ì ìˆ˜ ìˆœìœ¼ë¡œ ì±„ìš°ê¸°
     strong_bucket = [x for x in scored if x[2]]
     weak_bucket = [x for x in scored if not x[2]]
 
     strong_bucket.sort(key=lambda x: x[1], reverse=True)
     weak_bucket.sort(key=lambda x: x[1], reverse=True)
 
     picked: List[str] = []
 
     # ëª¨ë©˜í…€ ê°• ë²„í‚·ì„ ìš°ì„  ì‚¬ìš©í•˜ë˜, ì „ì²´ ë³´ìœ  ì¢…ëª© ìˆ˜ëŠ” ë ˆì§ë³„ n_activeë¡œ ì œí•œ
     for code, score, _ in strong_bucket:
         if len(picked) >= n_active:
             break
         picked.append(code)
 
     for code, score, _ in weak_bucket:
         if len(picked) >= n_active:
             break
         picked.append(code)
 
     # === [NEW] ë ˆì§ë³„ ì±”í”¼ì–¸ ë¹„ì¤‘ & Target Notional ê³„ì‚° ===
-    regime_weights = REGIME_WEIGHTS.get(regime_key, REGIME_WEIGHTS.get(("neutral", 0), [1.0]))
+    regime_weights = REGIME_WEIGHTS.get(
+        regime_key, REGIME_WEIGHTS.get(("neutral", 0), [1.0])
+    )
     # ì„ íƒëœ ì¢…ëª© ìˆ˜ë§Œí¼ ë¹„ì¤‘ ìŠ¬ë¼ì´ìŠ¤
     weights_for_picked: List[float] = list(regime_weights[: len(picked)])
 
     for idx, code in enumerate(picked):
         if code not in processed_targets:
             continue
         w = weights_for_picked[idx] if idx < len(weights_for_picked) else 0.0
         t = processed_targets[code]
         t["regime_weight"] = float(w)
         t["capital_active"] = int(capital_active)
         target_notional = int(round(capital_active * w))
         t["target_notional"] = target_notional
 
         ref_px = _to_float(t.get("close")) or _to_float(t.get("prev_close"))
         planned_qty = _notional_to_qty(kis, code, target_notional, ref_price=ref_px)
         t["qty"] = int(planned_qty)
         t["ë§¤ìˆ˜ìˆ˜ëŸ‰"] = int(planned_qty)
         processed_targets[code] = t
 
     for code in picked:
         if code in processed_targets:
             selected_targets[code] = processed_targets[code]
 
     logger.info(
         "[REGIME-CHAMPIONS] mode=%s stage=%s n_active=%s picked=%s capital_active=%s",
@@ -609,176 +747,268 @@ def main(capital_override: float | None = None, selected_stocks: list[dict[str,
             pb_df = get_kosdaq_top_n(date_str=rebalance_date, n=PULLBACK_TOPN)
             for _, row in pb_df.iterrows():
                 code = str(row.get("Code") or row.get("code") or "").zfill(6)
                 if not code:
                     continue
                 pullback_watch[code] = {
                     "code": code,
                     "name": row.get("Name") or row.get("name"),
                     "notional": base_notional,
                 }
             logger.info(
                 f"[PULLBACK-WATCH] ì½”ìŠ¤ë‹¥ ì‹œì´ Top{PULLBACK_TOPN} {len(pullback_watch)}ì¢…ëª© ìŠ¤ìº” ì¤€ë¹„"
             )
         except Exception as e:
             logger.warning(f"[PULLBACK-WATCH-FAIL] ì‹œì´ ìƒìœ„ ë¡œë“œ ì‹¤íŒ¨: {e}")
 
     loop_sleep_sec = 2.5  # ë©”ì¸ ë£¨í”„ ëŒ€ê¸° ì‹œê°„(ì´ˆ)
     max_closed_checks = 3
     closed_checks = 0
 
     try:
         while True:
             # === ì½”ìŠ¤ë‹¥ ë ˆì§ ì—…ë°ì´íŠ¸ ===
             regime = _update_market_regime(kis)
             regime_state = regime
-            pct_txt = f"{regime.get('pct_change'):.2f}%" if regime.get("pct_change") is not None else "N/A"
-            logger.info(f"[REGIME] mode={regime['mode']} stage={regime['bear_stage']} pct={pct_txt}")
+            pct_txt = (
+                f"{regime.get('pct_change'):.2f}%"
+                if regime.get("pct_change") is not None
+                else "N/A"
+            )
+            logger.info(
+                f"[REGIME] mode={regime['mode']} stage={regime['bear_stage']} pct={pct_txt}"
+            )
 
             # ì¥ ìƒíƒœ
             now_dt_kst = datetime.now(KST)
             is_open = kis.is_market_open()
             now_str = now_dt_kst.strftime("%Y-%m-%d %H:%M:%S")
             today_prefix = now_dt_kst.strftime("%Y-%m-%d")
+            _ensure_guard_state(now_dt_kst.date())
             if last_today_prefix != today_prefix:
                 triggered_today.clear()
+                s1_done_today.clear()
                 last_today_prefix = today_prefix
             expired_pending = _cleanup_expired_pending(traded, now_dt_kst, ttl_sec=300)
             if expired_pending:
                 triggered_today.difference_update(expired_pending)
             traded_today: set[str] = set()
+            regime_s1_summary = {
+                "sent_qty": 0,
+                "sent_orders": 0,
+                "skipped": 0,
+                "total_qty": 0,
+                "by_stock": {},
+            }
+
+            def _log_s1_action(
+                code: str,
+                status: str,
+                base_qty: int,
+                target_qty: int,
+                sold_today: int,
+                remaining: int,
+                sell_qty: int,
+                reason_msg: str | None = None,
+            ) -> None:
+                regime_s1_summary["by_stock"][code] = {
+                    "status": status,
+                    "base_qty": int(base_qty),
+                    "target": int(target_qty),
+                    "sold_today": int(sold_today),
+                    "remaining": int(remaining),
+                    "sell_qty": int(sell_qty),
+                    "reason": reason_msg or None,
+                }
+                prefix = (
+                    "[SELL][SENT]"
+                    if status == "SENT"
+                    else "[SELL][SKIP]" if status == "SKIP" else "[SELL][ERROR]"
+                )
+                msg = (
+                    f"{prefix} [REGIME_S1] {code} base_qty={base_qty} target={target_qty} "
+                    f"sold={sold_today} remaining={remaining} sell_qty={sell_qty}"
+                )
+                if reason_msg:
+                    msg += f" reason={reason_msg}"
+                if status == "ERROR":
+                    logger.error(msg)
+                else:
+                    logger.info(msg)
+
+            def _log_s2_action(
+                code: str,
+                status: str,
+                base_qty: int,
+                target_qty: int,
+                sold_today: int,
+                remaining: int,
+                sell_qty: int,
+                reason_msg: str | None = None,
+            ) -> None:
+                prefix = (
+                    "[SELL][SENT]"
+                    if status == "SENT"
+                    else "[SELL][SKIP]" if status == "SKIP" else "[SELL][ERROR]"
+                )
+                msg = (
+                    f"{prefix} [REGIME_S2] {code} base_qty={base_qty} target={target_qty} "
+                    f"sold={sold_today} remaining={remaining} sell_qty={sell_qty}"
+                )
+                if reason_msg:
+                    msg += f" reason={reason_msg}"
+                if status == "ERROR":
+                    logger.error(msg)
+                else:
+                    logger.info(msg)
 
             if now_dt_kst.date() != pullback_buy_date:
                 pullback_buy_date = now_dt_kst.date()
                 pullback_buys_today = 0
 
             if not is_open:
                 if not is_trading_day(now_dt_kst):
                     logger.error("[CLOSED] ë¹„ê±°ë˜ì¼ ê°ì§€ â†’ ë£¨í”„ ì¢…ë£Œ")
                     break
 
                 if now_dt_kst.time() < MARKET_OPEN:
                     seconds_to_open = int(
-                        (datetime.combine(now_dt_kst.date(), MARKET_OPEN, tzinfo=KST) - now_dt_kst).total_seconds()
+                        (
+                            datetime.combine(now_dt_kst.date(), MARKET_OPEN, tzinfo=KST)
+                            - now_dt_kst
+                        ).total_seconds()
                     )
                     sleep_for = max(1, min(seconds_to_open, 300))
                     logger.info(
-                        "[PREOPEN] ì¥ ì‹œì‘ê¹Œì§€ %ss ë‚¨ìŒ â†’ %ss ëŒ€ê¸° í›„ ì¬í™•ì¸", seconds_to_open, sleep_for
+                        "[PREOPEN] ì¥ ì‹œì‘ê¹Œì§€ %ss ë‚¨ìŒ â†’ %ss ëŒ€ê¸° í›„ ì¬í™•ì¸",
+                        seconds_to_open,
+                        sleep_for,
                     )
                     time.sleep(sleep_for)
                     closed_checks = 0
                     continue
 
                 if now_dt_kst.time() >= MARKET_CLOSE:
                     logger.error("[CLOSED] ì¥ ë§ˆê° ì´í›„ â†’ ë£¨í”„ ì¢…ë£Œ")
                     break
 
                 closed_checks += 1
                 if not ALLOW_WHEN_CLOSED:
                     if closed_checks > max_closed_checks:
-                        logger.error("[CLOSED] ì¥ ì¢…ë£Œ ë°˜ë³µ %síšŒ ì´ˆê³¼ â†’ ë£¨í”„ ì¢…ë£Œ", max_closed_checks)
+                        logger.error(
+                            "[CLOSED] ì¥ ì¢…ë£Œ ë°˜ë³µ %síšŒ ì´ˆê³¼ â†’ ë£¨í”„ ì¢…ë£Œ",
+                            max_closed_checks,
+                        )
                         break
                     logger.info(
                         "[CLOSED] ì¥ì¤‘ì¸ë° APIê°€ ë‹«í˜ ì‘ë‹µ â†’ 10ì´ˆ ëŒ€ê¸° í›„ ì¬í™•ì¸ (%s/%s)",
                         closed_checks,
                         max_closed_checks,
                     )
                     time.sleep(10)
                     continue
                 else:
-                    logger.warning("[CLOSED-DATA] ì¥ ì¢…ë£Œì§€ë§Œ í™˜ê²½ì„¤ì • í—ˆìš© â†’ ì‹œì„¸ ì¡°íšŒ í›„ ì§„í–‰")
+                    logger.warning(
+                        "[CLOSED-DATA] ì¥ ì¢…ë£Œì§€ë§Œ í™˜ê²½ì„¤ì • í—ˆìš© â†’ ì‹œì„¸ ì¡°íšŒ í›„ ì§„í–‰"
+                    )
             else:
                 closed_checks = 0
 
             if kis.should_cooldown(now_dt_kst):
                 logger.warning("[COOLDOWN] 2ì´ˆê°„ ëŒ€ê¸° (API ì œí•œ ë³´í˜¸)")
                 time.sleep(2)
 
             # ì”ê³  ê°€ì ¸ì˜¤ê¸°
             prev_holding = holding if isinstance(holding, dict) else {}
             balances = _fetch_balances(kis)
             holding = {}
             for bal in balances:
                 code = bal.get("code")
                 qty = int(bal.get("qty", 0))
                 if qty <= 0:
                     continue
                 price = float(bal.get("avg_price", 0.0))
                 holding[code] = {
                     "qty": qty,
                     "buy_price": price,
                     "bear_s1_done": False,
                     "bear_s2_done": False,
                 }
                 _init_position_state_from_balance(kis, holding, code, price, qty)
 
             # ì”ê³  ê¸°ì¤€ìœ¼ë¡œ ë³´ìœ ì¢…ëª© ë§¤ë„ ê°€ëŠ¥ ìˆ˜ëŸ‰ ë§µ ìƒì„±
-            ord_psbl_map = {bal.get("code"): int(bal.get("sell_psbl_qty", 0)) for bal in balances}
+            ord_psbl_map = {
+                bal.get("code"): int(bal.get("sell_psbl_qty", 0)) for bal in balances
+            }
 
             if isinstance(traded, dict):
                 for code, payload in list(traded.items()):
                     if (payload or {}).get("status") == "pending" and code in holding:
                         traded[code]["status"] = "filled"
 
             traded_today = _traded_today(traded, today_prefix)
             for bal in balances:
                 code = bal.get("code")
                 raw = bal.get("raw") or {}
                 raw_l = {str(k).lower(): v for k, v in raw.items()}
                 thdt_buy_qty = _to_int(
                     raw_l.get("thdt_buyqty")
                     or raw_l.get("thdt_buy_qty")
                     or raw_l.get("thdt_buy_q")
                 )
                 if thdt_buy_qty > 0:
                     traded_today.add(code)
 
             if not ALLOW_PYRAMID:
                 traded_today.update(holding.keys())
 
             for code, info in list(holding.items()):
-                prev_qty = int((prev_holding.get(code) or {}).get("qty", info.get("qty", 0)))
+                prev_qty = int(
+                    (prev_holding.get(code) or {}).get("qty", info.get("qty", 0))
+                )
                 balance_qty = int(info.get("qty", 0))
                 # ì”ê³ ê°€ ì¼ì‹œì ìœ¼ë¡œ ì¤„ì–´ë“  ì¼€ì´ìŠ¤ë§Œ ë³´í˜¸í•˜ê³ , ì •ìƒì ì¸ ìˆ˜ëŸ‰ ì¦ê°€ëŠ” ìœ ì§€í•œë‹¤.
                 if prev_qty > 0 and 0 < balance_qty < prev_qty:
                     holding[code]["qty"] = prev_qty
                     logger.info(
                         f"[HOLDING-QTY-CLAMP] {code}: balance_qty={balance_qty} prev_qty={prev_qty} â†’ {prev_qty}"
                     )
 
             recent_keep_minutes = 5
             for code, info in prev_holding.items():
                 if code in holding:
                     continue
                 buy_time_str = None
                 if isinstance(traded, dict):
                     buy_time_str = (traded.get(code) or {}).get("buy_time")
                 if buy_time_str:
                     try:
                         buy_dt = datetime.strptime(buy_time_str, "%Y-%m-%d %H:%M:%S")
                         buy_dt = buy_dt.replace(tzinfo=now_dt_kst.tzinfo)
-                        if now_dt_kst - buy_dt <= timedelta(minutes=recent_keep_minutes):
+                        if now_dt_kst - buy_dt <= timedelta(
+                            minutes=recent_keep_minutes
+                        ):
                             holding[code] = info
                             ord_psbl_map.setdefault(code, int(info.get("qty", 0)))
                             logger.info(
                                 f"[HOLDING-MERGE] {code} ìµœê·¼ ë§¤ìˆ˜({buy_time_str}) ë°˜ì˜ â†’ ì”ê³  ë¯¸ë°˜ì˜ ë³´í˜¸"
                             )
                     except Exception as e:
                         logger.warning(f"[HOLDING-MERGE-FAIL] {code}: {e}")
 
             logger.info(
                 f"[STATUS] holdings={holding} traded_today={sorted(traded_today)} ord_psbl={ord_psbl_map}"
             )
 
             # ì»¤íŠ¸ì˜¤í”„ íƒ€ì„ ë„ë‹¬ ì‹œ ê°•ì œë§¤ë„ ë£¨í‹´
             if now_dt_kst.time() >= SELL_FORCE_TIME and SELL_ALL_BALANCES_AT_CUTOFF:
                 logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ë„ë‹¬: ì „ëŸ‰ë§¤ë„ ë£¨í‹´ ì‹¤í–‰]")
                 pass_count = FORCE_SELL_PASSES_CUTOFF
                 if now_dt_kst.time() >= dtime(hour=15, minute=0):
                     pass_count = FORCE_SELL_PASSES_CLOSE
                 for code, qty in ord_psbl_map.items():
                     if qty <= 0:
                         continue
                     exec_px, result = _sell_once(kis, code, qty, prefer_market=True)
                     log_trade(
                         {
                             "datetime": now_str,
@@ -797,187 +1027,356 @@ def main(capital_override: float | None = None, selected_stocks: list[dict[str,
                     )
                     time.sleep(RATE_SLEEP_SEC)
                 for _ in range(pass_count - 1):
                     logger.info(
                         f"[ì»¤íŠ¸ì˜¤í”„ ì¶”ê°€íŒ¨ìŠ¤] {pass_count}íšŒ ì¤‘ ë‚¨ì€ íŒ¨ìŠ¤ ì‹¤í–‰ (ì”ê³ ë³€ë™ ê°ì§€ìš©)"
                     )
                     time.sleep(loop_sleep_sec)
                     continue
                 logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ì¢…ë£Œ] ë£¨í”„ ì¢…ë£Œ")
                 break
 
             # === (1) ì”ì—¬ ë¬¼ëŸ‰ ëŒ€ìƒ ìŠ¤íƒ‘/ë¦¬ë°¸ëŸ°ìŠ¤ ê´€ë¦¬ ===
             for code in list(holding.keys()):
                 # ì‹ ê·œ ì§„ì… ê¸ˆì§€ ëª¨ë“œ
                 if code not in code_to_target:
                     continue
 
                 # --- 1a) ê°•ì œ ë ˆì§ë³„ ì¶•ì†Œ ë¡œì§ ---
                 sellable_qty = ord_psbl_map.get(code, 0)
                 if sellable_qty <= 0:
                     continue
 
                 regime_key = regime.get("key")
                 mode = regime.get("mode")
                 if regime_key and regime_key[0] == "bear":
-                    if regime["bear_stage"] >= 1 and not holding[code].get("bear_s1_done"):
-                        cut_qty = max(1, int(holding[code]["qty"] * REG_PARTIAL_S1))
-                        logger.info(
-                            f"[REGIME-REDUCE-S1] {code} ì•½ì„¸1ë‹¨ê³„ {REG_PARTIAL_S1 * 100:.0f}% ì¶•ì†Œ â†’ {cut_qty}"
-                        )
-                        exec_px, result = _sell_once(kis, code, cut_qty, prefer_market=True)
-                        holding[code]["qty"] -= int(cut_qty)
-                        holding[code]["bear_s1_done"] = True
-                        log_trade(
-                            {
-                                "datetime": now_str,
-                                "code": code,
-                                "name": None,
-                                "qty": int(cut_qty),
-                                "K": holding[code].get("k_value"),
-                                "target_price": holding[code].get("target_price_src"),
-                                "strategy": "ë ˆì§ì¶•ì†Œ",  # ì‹ ê·œ ì „ëµ êµ¬ë¶„ì„ ìœ„í•´ strategy í•„ë“œ í™œìš©
-                                "side": "SELL",
-                                "price": exec_px,
-                                "amount": int((exec_px or 0)) * int(cut_qty),
-                                "result": result,
-                                "reason": "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ",
-                            }
+                    if regime["bear_stage"] >= 1:
+                        sellable_qty = ord_psbl_map.get(code, 0)
+                        guard = _s1_guard_target(
+                            now_dt_kst.date(), code, holding[code].get("qty", 0)
                         )
-                        save_state(holding, traded)
-                        time.sleep(RATE_SLEEP_SEC)
+                        base_qty = int(guard.get("base_qty") or 0)
+                        if base_qty <= 0:
+                            regime_s1_summary["skipped"] += 1
+                            _log_s1_action(
+                                code,
+                                "SKIP",
+                                base_qty,
+                                0,
+                                int(guard.get("sold", 0)),
+                                0,
+                                0,
+                                "base_qty_zero",
+                            )
+                        else:
+                            target_qty = max(1, int(base_qty * REG_PARTIAL_S1))
+                            sold_today = int(guard.get("sold", 0))
+                            remaining = max(0, target_qty - sold_today)
+
+                            if remaining <= 0 or sellable_qty <= 0:
+                                if remaining <= 0:
+                                    holding[code]["bear_s1_done"] = True
+                                    s1_done_today.add(code)
+                                regime_s1_summary["skipped"] += 1
+                                _log_s1_action(
+                                    code,
+                                    "SKIP",
+                                    base_qty,
+                                    target_qty,
+                                    sold_today,
+                                    remaining,
+                                    0,
+                                    (
+                                        "target_met"
+                                        if remaining <= 0
+                                        else "no_sellable_qty"
+                                    ),
+                                )
+                            else:
+                                sell_qty = min(remaining, sellable_qty)
+                                regime_s1_summary["total_qty"] += int(sell_qty)
+                                try:
+                                    exec_px, result = _sell_once(
+                                        kis, code, sell_qty, prefer_market=True
+                                    )
+                                    status, skip_reason = _sell_result_status(result)
+                                except Exception as e:
+                                    exec_px, result = None, None
+                                    status, skip_reason = "ERROR", str(e)
+
+                                reason_msg = skip_reason or "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ"
+
+                                if status == "SENT":
+                                    guard["sold"] = sold_today + int(sell_qty)
+                                    holding[code]["qty"] = max(
+                                        0, holding[code]["qty"] - int(sell_qty)
+                                    )
+                                    if guard["sold"] >= target_qty:
+                                        holding[code]["bear_s1_done"] = True
+                                        s1_done_today.add(code)
+                                    _persist_guard_state(now_dt_kst.date())
+                                    regime_s1_summary["sent_qty"] += int(sell_qty)
+                                    regime_s1_summary["sent_orders"] += 1
+                                    trade_payload = {
+                                        "datetime": now_str,
+                                        "code": code,
+                                        "name": None,
+                                        "qty": int(sell_qty),
+                                        "K": holding[code].get("k_value"),
+                                        "target_price": holding[code].get(
+                                            "target_price_src"
+                                        ),
+                                        "strategy": "ë ˆì§ì¶•ì†Œ",  # ì‹ ê·œ ì „ëµ êµ¬ë¶„ì„ ìœ„í•´ strategy í•„ë“œ í™œìš©
+                                        "side": "SELL",
+                                        "price": exec_px,
+                                        "amount": int((exec_px or 0)) * int(sell_qty),
+                                        "reason": reason_msg,
+                                    }
+                                    if result is not None:
+                                        trade_payload["result"] = result
+                                    log_trade(trade_payload)
+                                    save_state(holding, traded)
+                                    time.sleep(RATE_SLEEP_SEC)
+                                elif status == "SKIP":
+                                    regime_s1_summary["skipped"] += 1
+                                else:
+                                    regime_s1_summary["skipped"] += 1
+
+                                _log_s1_action(
+                                    code,
+                                    status,
+                                    base_qty,
+                                    target_qty,
+                                    sold_today,
+                                    remaining,
+                                    sell_qty,
+                                    reason_msg,
+                                )
 
-                    if regime["bear_stage"] >= 2 and not holding[code].get("bear_s2_done"):
-                        cut_qty = max(1, int(holding[code]["qty"] * REG_PARTIAL_S2))
-                        logger.info(
-                            f"[REGIME-REDUCE-S2] {code} ì•½ì„¸2ë‹¨ê³„ {REG_PARTIAL_S2 * 100:.0f}% ì¶•ì†Œ â†’ {cut_qty}"
-                        )
-                        exec_px, result = _sell_once(kis, code, cut_qty, prefer_market=True)
-                        holding[code]["qty"] -= int(cut_qty)
-                        holding[code]["bear_s2_done"] = True
-                        log_trade(
-                            {
-                                "datetime": now_str,
-                                "code": code,
-                                "name": None,
-                                "qty": int(cut_qty),
-                                "K": holding[code].get("k_value"),
-                                "target_price": holding[code].get("target_price_src"),
-                                "strategy": "ë ˆì§ì¶•ì†Œ",
-                                "side": "SELL",
-                                "price": exec_px,
-                                "amount": int((exec_px or 0)) * int(cut_qty),
-                                "result": result,
-                                "reason": "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ",
-                            }
+                    if regime["bear_stage"] >= 2 and not holding[code].get(
+                        "bear_s2_done"
+                    ):
+                        if not holding[code].get("bear_s1_done"):
+                            _log_s2_action(
+                                code,
+                                "SKIP",
+                                int(holding[code].get("qty", 0)),
+                                0,
+                                0,
+                                0,
+                                0,
+                                "s1_not_done",
+                            )
+                            continue
+                        if code in s1_done_today:
+                            logger.warning(
+                                f"[REGIME_S2][SEQ] {code}: ë™ì¼ ì¼ì S1 ì™„ë£Œ ì§í›„ S2 ì§„ì…"
+                            )
+                        sellable_qty = ord_psbl_map.get(code, 0)
+                        guard = _s2_guard_target(
+                            now_dt_kst.date(), code, holding[code].get("qty", 0)
                         )
-                        save_state(holding, traded)
-                        time.sleep(RATE_SLEEP_SEC)
+                        base_qty = int(guard.get("base_qty") or 0)
+                        if base_qty <= 0:
+                            _log_s2_action(
+                                code,
+                                "SKIP",
+                                base_qty,
+                                0,
+                                int(guard.get("sold", 0)),
+                                0,
+                                0,
+                                "base_qty_zero",
+                            )
+                        else:
+                            target_qty = max(1, int(base_qty * REG_PARTIAL_S2))
+                            sold_today = int(guard.get("sold", 0))
+                            remaining = max(0, target_qty - sold_today)
+
+                            if remaining <= 0 or sellable_qty <= 0:
+                                if remaining <= 0:
+                                    holding[code]["bear_s2_done"] = True
+                                _log_s2_action(
+                                    code,
+                                    "SKIP",
+                                    base_qty,
+                                    target_qty,
+                                    sold_today,
+                                    remaining,
+                                    0,
+                                    (
+                                        "target_met"
+                                        if remaining <= 0
+                                        else "no_sellable_qty"
+                                    ),
+                                )
+                            else:
+                                sell_qty = min(remaining, sellable_qty)
+                                try:
+                                    exec_px, result = _sell_once(
+                                        kis, code, sell_qty, prefer_market=True
+                                    )
+                                    status, skip_reason = _sell_result_status(result)
+                                except Exception as e:
+                                    exec_px, result = None, None
+                                    status, skip_reason = "ERROR", str(e)
+
+                                reason_msg = skip_reason or "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ"
+
+                                if status == "SENT":
+                                    guard["sold"] = sold_today + int(sell_qty)
+                                    holding[code]["qty"] = max(
+                                        0, holding[code]["qty"] - int(sell_qty)
+                                    )
+                                    if guard["sold"] >= target_qty:
+                                        holding[code]["bear_s2_done"] = True
+                                    _persist_guard_state(now_dt_kst.date())
+                                    log_trade(
+                                        {
+                                            "datetime": now_str,
+                                            "code": code,
+                                            "name": None,
+                                            "qty": int(sell_qty),
+                                            "K": holding[code].get("k_value"),
+                                            "target_price": holding[code].get(
+                                                "target_price_src"
+                                            ),
+                                            "strategy": "ë ˆì§ì¶•ì†Œ",
+                                            "side": "SELL",
+                                            "price": exec_px,
+                                            "amount": int((exec_px or 0))
+                                            * int(sell_qty),
+                                            "result": result,
+                                            "reason": reason_msg,
+                                        }
+                                    )
+                                    save_state(holding, traded)
+                                    time.sleep(RATE_SLEEP_SEC)
+                                elif status == "SKIP":
+                                    pass
+                                _log_s2_action(
+                                    code,
+                                    status,
+                                    base_qty,
+                                    target_qty,
+                                    sold_today,
+                                    remaining,
+                                    sell_qty,
+                                    reason_msg,
+                                )
 
                 # --- 1b) TP/SL/íŠ¸ë ˆì¼ë§, VWAP ê°€ë“œ ---
                 try:
                     exit_reason, exec_px, exit_result, sold_qty = _adaptive_exit(
                         kis,
                         code,
                         holding[code],
                         regime_mode=mode or "neutral",
                     )
                 except Exception as e:
                     logger.error(f"[_adaptive_exit ì‹¤íŒ¨] {code}: {e}")
                     exit_reason = exec_px = exit_result = sold_qty = None
 
                 if sold_qty:
                     save_state(holding, traded)
                     time.sleep(RATE_SLEEP_SEC)
 
             # === (2) ì‹ ê·œ ì§„ì… ë¡œì§ (ì±”í”¼ì–¸) ===
             for code, info in code_to_target.items():
                 if not can_buy:
                     continue
 
                 if code in traded_today:
                     continue
 
                 if code in holding and not ALLOW_PYRAMID:
                     continue
 
                 if code in triggered_today:
                     logger.info(f"[TRIGGER-SKIP] {code}: ê¸ˆì¼ ì´ë¯¸ íŠ¸ë¦¬ê±° ë°œìƒ")
                     continue
 
                 target_qty = int(info.get("qty", 0))
                 if target_qty <= 0:
                     logger.info(f"[REBALANCE] {code}: target_qty=0 â†’ ìŠ¤í‚µ")
                     continue
 
                 target_price = info.get("target_price")
                 k_value = info.get("best_k")
                 strategy = info.get("strategy")
                 weight = _to_float(info.get("weight") or 0.0)
 
-                planned_notional = int(_to_float(info.get("target_notional") or 0.0) or 0)
+                planned_notional = int(
+                    _to_float(info.get("target_notional") or 0.0) or 0
+                )
                 logger.info(
                     f"[TARGET] {code} qty={target_qty} tgt_px={target_price} notional={planned_notional} K={k_value}"
                 )
 
                 # [ì¤‘ë³µ ì§„ì… ë°©ì§€] ì´ë¯¸ ì£¼ë¬¸ëœ ì¢…ëª©ì¸ì§€ í™•ì¸
                 if code in traded_today:
                     logger.info(f"[SKIP] {code}: ì´ë¯¸ ê¸ˆì¼ ê±°ë˜ë¨")
                     continue
 
                 if _pending_block(traded, code, now_dt_kst, block_sec=45):
-                    logger.info(f"[SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘ â†’ ì¬ì£¼ë¬¸ ë°©ì§€")
+                    logger.info(
+                        f"[SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘ â†’ ì¬ì£¼ë¬¸ ë°©ì§€"
+                    )
                     continue
 
                 prev_price = last_price_map.get(code)
                 if prev_price is None:
                     try:
                         cached = signals._LAST_PRICE_CACHE.get(code) or {}
                         ts = cached.get("ts")
                         if ts and (time.time() - float(ts) <= 120):
                             prev_price = cached.get("px")
                     except Exception:
                         prev_price = None
 
                 price_res = _safe_get_price(kis, code, with_source=True)
                 if isinstance(price_res, tuple):
                     current_price, price_source = price_res
                 else:
                     current_price, price_source = price_res, None
 
                 if not current_price or current_price <= 0:
                     logger.warning(f"[PRICE_FAIL] {code}: í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ")
                     continue
 
                 try:
                     last_price_map[code] = float(current_price)
                 except Exception:
                     pass
 
                 # === GOOD/BAD íƒ€ì  í‰ê°€ ===
-                daily_ctx = _compute_daily_entry_context(kis, code, current_price, price_source)
-                intra_ctx = _compute_intraday_entry_context(kis, code, fast=MOM_FAST, slow=MOM_SLOW)
+                daily_ctx = _compute_daily_entry_context(
+                    kis, code, current_price, price_source
+                )
+                intra_ctx = _compute_intraday_entry_context(
+                    kis, code, fast=MOM_FAST, slow=MOM_SLOW
+                )
 
                 momentum_confirmed = bool(
                     daily_ctx.get("strong_trend")
                     or intra_ctx.get("vwap_reclaim")
                     or intra_ctx.get("range_break")
                 )
 
                 if mode == "neutral" and not (
                     info.get("champion_grade") in ("A", "B") or momentum_confirmed
                 ):
                     logger.info(
                         f"[ENTRY-SKIP] {code}: neutral ë ˆì§ì—ì„œ ë¹„ì±”í”¼ì–¸/ëª¨ë©˜í…€ ë¯¸í™•ì¸ â†’ ì‹ ê·œ ì§„ì… ë³´ë¥˜"
                     )
                     continue
 
                 setup_state = signals.evaluate_setup_gate(
                     daily_ctx, intra_ctx, regime_state=regime_state
                 )
                 if not setup_state.get("ok"):
                     logger.info(
                         "[SETUP-BAD] %s | missing=%s reasons=%s | daily=%s intra=%s regime=%s",
                         code,
                         setup_state.get("missing_conditions"),
                         setup_state.get("reasons"),
                         daily_ctx,
@@ -1022,93 +1421,103 @@ def main(capital_override: float | None = None, selected_stocks: list[dict[str,
                 logger.info(
                     "[TRIGGER-OK] %s | trigger=%s current=%s tgt_px=%s gap_pct=%s signals=%s rr=%.2f",
                     code,
                     trigger_state.get("trigger_name"),
                     trigger_state.get("current_price"),
                     trigger_state.get("target_price"),
                     trigger_state.get("gap_pct"),
                     trigger_state.get("trigger_signals"),
                     trigger_state.get("risk_reward") or 0.0,
                 )
 
                 flow_ok, flow_ctx, ob_strength = _subject_flow_gate(
                     code,
                     info,
                     float(current_price),
                     target_price,
                     intraday_ctx.get("vwap"),
                 )
                 if not flow_ok:
                     continue
 
                 # === VWAP ê°€ë“œ(ìŠ¬ë¦¬í”¼ì§€ ë°©ì–´) ===
                 try:
                     guard_passed = vwap_guard(kis, code, SLIPPAGE_ENTER_GUARD_PCT)
                 except Exception as e:
-                    logger.warning(f"[VWAP_GUARD_FAIL] {code}: VWAP ê°€ë“œ ì˜¤ë¥˜ â†’ ì§„ì… ë³´ë¥˜ ({e})")
+                    logger.warning(
+                        f"[VWAP_GUARD_FAIL] {code}: VWAP ê°€ë“œ ì˜¤ë¥˜ â†’ ì§„ì… ë³´ë¥˜ ({e})"
+                    )
                     continue
 
                 if not guard_passed:
                     logger.info(f"[VWAP_GUARD] {code}: ìŠ¬ë¦¬í”¼ì§€ ìœ„í—˜ â†’ ë§¤ìˆ˜ ìŠ¤í‚µ")
                     continue
 
                 qty = target_qty
                 if mode == "neutral":
                     scaled_qty = max(1, int(qty * NEUTRAL_ENTRY_SCALE))
                     if scaled_qty < qty:
                         logger.info(
                             f"[ENTRY-SIZE] {code}: neutral ë ˆì§ ê°ì¶• {qty}â†’{scaled_qty} (ìŠ¤ì¼€ì¼={NEUTRAL_ENTRY_SCALE})"
                         )
                     qty = scaled_qty
                 trade_ctx = {
                     "datetime": now_str,
                     "code": code,
                     "name": info.get("name"),
                     "qty": int(qty),
                     "K": k_value,
                     "target_price": target_price,
                     "strategy": strategy,
                     "side": "BUY",
                 }
 
                 limit_px, mo_px = compute_entry_target(kis, info)
                 if limit_px is None and mo_px is None:
-                    logger.warning(f"[TARGET-PRICE] {code}: limit/mo ê°€ê²© ì‚°ì¶œ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ")
+                    logger.warning(
+                        f"[TARGET-PRICE] {code}: limit/mo ê°€ê²© ì‚°ì¶œ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ"
+                    )
                     continue
 
-                if limit_px and abs(limit_px - current_price) / current_price * 100 > SLIPPAGE_LIMIT_PCT:
+                if (
+                    limit_px
+                    and abs(limit_px - current_price) / current_price * 100
+                    > SLIPPAGE_LIMIT_PCT
+                ):
                     logger.info(
                         f"[SLIPPAGE_LIMIT] {code}: í˜¸ê°€ä¹–é›¢ {abs(limit_px - current_price) / current_price * 100:.2f}% â†’ ìŠ¤í‚µ"
                     )
                     continue
 
                 logger.info(
                     f"[BUY-TRY] {code}: qty={qty} limit={limit_px} mo={mo_px} target={target_price} k={k_value}"
                 )
 
                 prev_qty = int((holding.get(code) or {}).get("qty", 0))
-                result = place_buy_with_fallback(kis, code, qty, limit_px or _round_to_tick(current_price))
+                result = place_buy_with_fallback(
+                    kis, code, qty, limit_px or _round_to_tick(current_price)
+                )
                 if not _is_order_success(result):
                     logger.warning(f"[BUY-FAIL] {code}: result={result}")
                     continue
 
                 triggered_today.add(code)
 
                 exec_price = _extract_fill_price(result, current_price)
                 _record_trade(
                     traded,
                     code,
                     {
                         "buy_time": now_str,
                         "qty": int(qty),
                         "price": float(exec_price),
                         "status": "pending",
                         "pending_since": now_str,
                     },
                 )
                 traded_today.add(code)
                 save_state(holding, traded)
                 if not _is_balance_reflected(code, prev_qty=prev_qty):
                     logger.warning(
                         f"[BUY-PENDING] {code}: ì”ê³ ì— ë°˜ì˜ë˜ì§€ ì•Šì•„ ìƒíƒœ ê¸°ë¡ ë³´ë¥˜(result={result})"
                     )
                     continue
@@ -1121,76 +1530,80 @@ def main(capital_override: float | None = None, selected_stocks: list[dict[str,
                         "qty": int(qty),
                         "price": float(exec_price),
                         "status": "filled",
                         "pending_since": None,
                     },
                 )
 
                 _init_position_state(
                     kis,
                     holding,
                     code,
                     float(exec_price),
                     int(qty),
                     k_value,
                     target_price,
                 )
 
                 log_trade(
                     {
                         **trade_ctx,
                         "price": float(exec_price),
                         "amount": int(float(exec_price) * int(qty)),
                         "result": result,
                     }
                 )
-                effective_cash = _get_effective_ord_cash(kis, soft_cap=effective_capital)
+                effective_cash = _get_effective_ord_cash(
+                    kis, soft_cap=effective_capital
+                )
                 if effective_cash <= 0:
                     can_buy = False
                 save_state(holding, traded)
                 time.sleep(RATE_SLEEP_SEC)
 
             # ====== ëˆŒë¦¼ëª© ì „ìš© ë§¤ìˆ˜ (ì±”í”¼ì–¸ê³¼ ë…ë¦½ì ìœ¼ë¡œ Top-N ì‹œì´ ë¦¬ìŠ¤íŠ¸ ìŠ¤ìº”) ======
             if USE_PULLBACK_ENTRY and is_open:
                 if not can_buy:
                     logger.info("[PULLBACK-SKIP] can_buy=False â†’ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ")
                 else:
                     if pullback_watch:
                         logger.info(f"[PULLBACK-SCAN] {len(pullback_watch)}ì¢…ëª© ê²€ì‚¬")
 
                     for code, info in list(pullback_watch.items()):
                         if pullback_buys_today >= PULLBACK_MAX_BUYS_PER_DAY:
                             logger.info(
                                 f"[PULLBACK-LIMIT] í•˜ë£¨ ìµœëŒ€ {PULLBACK_MAX_BUYS_PER_DAY}ê±´ ë„ë‹¬ â†’ ìŠ¤ìº” ì¤‘ë‹¨"
                             )
                             break
 
                         if code in traded_today or code in holding:
                             continue  # ì±”í”¼ì–¸ ë£¨í”„ì™€ ë³„ë„ë¡œë§Œ ì²˜ë¦¬
 
                         if _pending_block(traded, code, now_dt_kst, block_sec=45):
-                            logger.info(f"[PULLBACK-SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘")
+                            logger.info(
+                                f"[PULLBACK-SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘"
+                            )
                             continue
 
                         base_notional = int(info.get("notional") or 0)
                         if base_notional <= 0:
                             logger.info(f"[PULLBACK-SKIP] {code}: ì˜ˆì‚° 0")
                             continue
 
                         try:
                             resp = _detect_pullback_reversal(
                                 kis,
                                 code,
                                 lookback=PULLBACK_LOOKBACK,
                                 pullback_days=PULLBACK_DAYS,
                                 reversal_buffer_pct=PULLBACK_REVERSAL_BUFFER_PCT,
                             )
 
                             pullback_ok = False
                             trigger_price = None
 
                             if isinstance(resp, dict):
                                 pullback_ok = bool(resp.get("setup")) and bool(
                                     resp.get("reversing")
                                 )
                                 trigger_price = resp.get("reversal_price")
                                 if not pullback_ok:
@@ -1231,55 +1644,59 @@ def main(capital_override: float | None = None, selected_stocks: list[dict[str,
                         if trigger_price and current_price < trigger_price * 0.98:
                             logger.info(
                                 f"[PULLBACK-DELAY] {code}: ê°€ê²©ì´ íŠ¸ë¦¬ê±° ëŒ€ë¹„ 2% ì´ìƒ í•˜ë½ â†’ ëŒ€ê¸° (cur={current_price}, trigger={trigger_price})"
                             )
                             continue
 
                         flow_ok, flow_ctx, ob_strength = _subject_flow_gate(
                             code,
                             info,
                             float(current_price),
                             trigger_price,
                             None,
                         )
                         if not flow_ok:
                             continue
 
                         prev_qty = int((holding.get(code) or {}).get("qty", 0))
                         result = place_buy_with_fallback(
                             kis,
                             code,
                             int(qty),
                             _round_to_tick(trigger_price or current_price),
                         )
 
                         if not _is_order_success(result):
-                            logger.warning(f"[PULLBACK-BUY-FAIL] {code}: result={result}")
+                            logger.warning(
+                                f"[PULLBACK-BUY-FAIL] {code}: result={result}"
+                            )
                             continue
 
                         triggered_today.add(code)
-                        exec_price = _extract_fill_price(result, trigger_price or current_price)
+                        exec_price = _extract_fill_price(
+                            result, trigger_price or current_price
+                        )
                         _record_trade(
                             traded,
                             code,
                             {
                                 "buy_time": now_str,
                                 "qty": int(qty),
                                 "price": float(exec_price),
                                 "status": "pending",
                                 "pending_since": now_str,
                             },
                         )
                         traded_today.add(code)
                         save_state(holding, traded)
                         if not _is_balance_reflected(code, prev_qty=prev_qty):
                             logger.warning(
                                 f"[PULLBACK-PENDING] {code}: ì”ê³ ì— ë°˜ì˜ë˜ì§€ ì•Šì•„ ìƒíƒœ ê¸°ë¡ ë³´ë¥˜(result={result})"
                             )
                             continue
 
                         traded[code]["status"] = "filled"
                         holding[code] = {
                             "qty": int(qty),
                             "buy_price": float(exec_price),
                             "bear_s1_done": False,
                             "bear_s2_done": False,
@@ -1307,168 +1724,336 @@ def main(capital_override: float | None = None, selected_stocks: list[dict[str,
                                 None,
                                 trigger_price,
                             )
                         except Exception as e:
                             logger.warning(f"[PULLBACK-INIT-FAIL] {code}: {e}")
 
                         logger.info(
                             f"[âœ… ëˆŒë¦¼ëª© ë§¤ìˆ˜] {code}, qty={qty}, price={exec_price}, trigger={trigger_price}, result={result}"
                         )
 
                         log_trade(
                             {
                                 "datetime": now_str,
                                 "code": code,
                                 "name": info.get("name"),
                                 "qty": int(qty),
                                 "K": None,
                                 "target_price": trigger_price,
                                 "strategy": f"ì½”ìŠ¤ë‹¥ Top{PULLBACK_TOPN} ëˆŒë¦¼ëª©",
                                 "side": "BUY",
                                 "price": float(exec_price),
                                 "amount": int(float(exec_price) * int(qty)),
                                 "result": result,
                             }
                         )
-                        effective_cash = _get_effective_ord_cash(kis, soft_cap=effective_capital)
+                        effective_cash = _get_effective_ord_cash(
+                            kis, soft_cap=effective_capital
+                        )
                         if effective_cash <= 0:
                             can_buy = False
                         save_state(holding, traded)
                         time.sleep(RATE_SLEEP_SEC)
 
             # ====== (A) ë¹„íƒ€ê²Ÿ ë³´ìœ ë¶„ë„ ì¥ì¤‘ ëŠ¥ë™ê´€ë¦¬ ======
             if is_open:
                 for code in list(holding.keys()):
                     if code in code_to_target:
                         continue  # ìœ„ ë£¨í”„ì—ì„œ ì´ë¯¸ ì²˜ë¦¬
 
                     # ì•½ì„¸ ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)
                     if regime["mode"] == "bear":
                         sellable_here = ord_psbl_map.get(code, 0)
                         if sellable_here > 0:
-                            if (
-                                regime["bear_stage"] >= 1
-                                and not holding[code].get("bear_s1_done")
-                            ):
-                                cut_qty = max(
-                                    1, int(holding[code]["qty"] * REG_PARTIAL_S1)
+                            if regime["bear_stage"] >= 1:
+                                guard = _s1_guard_nontarget(
+                                    now_dt_kst.date(),
+                                    code,
+                                    holding[code].get("qty", 0),
                                 )
-                                logger.info(
-                                    f"[REGIME-REDUCE-S1/ë¹„íƒ€ê²Ÿ] {code} ì•½ì„¸1ë‹¨ê³„ {REG_PARTIAL_S1 * 100:.0f}% ì¶•ì†Œ â†’ {cut_qty}"
-                                )
-                                exec_px, result = _sell_once(
-                                    kis, code, cut_qty, prefer_market=True
-                                )
-                                holding[code]["qty"] -= int(cut_qty)
-                                holding[code]["bear_s1_done"] = True
-                                log_trade(
-                                    {
-                                        "datetime": now_str,
-                                        "code": code,
-                                        "name": None,
-                                        "qty": int(cut_qty),
-                                        "K": holding[code].get("k_value"),
-                                        "target_price": holding[code].get(
-                                            "target_price_src"
-                                        ),
-                                        "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
-                                        "side": "SELL",
-                                        "price": exec_px,
-                                        "amount": int((exec_px or 0))
-                                        * int(cut_qty),
-                                        "result": result,
-                                        "reason": "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)",
-                                    }
-                                )
-                                save_state(holding, traded)
-                                time.sleep(RATE_SLEEP_SEC)
+                                base_qty = int(guard.get("base_qty") or 0)
+                                if base_qty <= 0:
+                                    regime_s1_summary["skipped"] += 1
+                                    _log_s1_action(
+                                        code,
+                                        "SKIP",
+                                        base_qty,
+                                        0,
+                                        int(guard.get("sold", 0)),
+                                        0,
+                                        0,
+                                        "base_qty_zero",
+                                    )
+                                else:
+                                    target_qty = max(1, int(base_qty * REG_PARTIAL_S1))
+                                    sold_today = int(guard.get("sold", 0))
+                                    remaining = max(0, target_qty - sold_today)
+
+                                    if remaining <= 0 or sellable_here <= 0:
+                                        if remaining <= 0:
+                                            holding[code]["bear_s1_done"] = True
+                                            s1_done_today.add(code)
+                                        regime_s1_summary["skipped"] += 1
+                                        _log_s1_action(
+                                            code,
+                                            "SKIP",
+                                            base_qty,
+                                            target_qty,
+                                            sold_today,
+                                            remaining,
+                                            0,
+                                            (
+                                                "target_met"
+                                                if remaining <= 0
+                                                else "no_sellable_qty"
+                                            ),
+                                        )
+                                    else:
+                                        sell_qty = min(remaining, sellable_here)
+                                        regime_s1_summary["total_qty"] += int(sell_qty)
+                                        try:
+                                            exec_px, result = _sell_once(
+                                                kis, code, sell_qty, prefer_market=True
+                                            )
+                                            status, skip_reason = _sell_result_status(
+                                                result
+                                            )
+                                        except Exception as e:
+                                            exec_px, result = None, None
+                                            status, skip_reason = "ERROR", str(e)
+
+                                        reason_msg = (
+                                            skip_reason or "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)"
+                                        )
 
-                            if (
-                                regime["bear_stage"] >= 2
-                                and not holding[code].get("bear_s2_done")
+                                        if status == "SENT":
+                                            guard["sold"] = sold_today + int(sell_qty)
+                                            holding[code]["qty"] = max(
+                                                0, holding[code]["qty"] - int(sell_qty)
+                                            )
+                                            if guard["sold"] >= target_qty:
+                                                holding[code]["bear_s1_done"] = True
+                                                s1_done_today.add(code)
+                                            _persist_guard_state(now_dt_kst.date())
+                                            regime_s1_summary["sent_qty"] += int(
+                                                sell_qty
+                                            )
+                                            regime_s1_summary["sent_orders"] += 1
+                                            trade_payload = {
+                                                "datetime": now_str,
+                                                "code": code,
+                                                "name": None,
+                                                "qty": int(sell_qty),
+                                                "K": holding[code].get("k_value"),
+                                                "target_price": holding[code].get(
+                                                    "target_price_src"
+                                                ),
+                                                "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
+                                                "side": "SELL",
+                                                "price": exec_px,
+                                                "amount": int((exec_px or 0))
+                                                * int(sell_qty),
+                                                "reason": reason_msg,
+                                            }
+                                            if result is not None:
+                                                trade_payload["result"] = result
+                                            log_trade(trade_payload)
+                                            save_state(holding, traded)
+                                            time.sleep(RATE_SLEEP_SEC)
+                                        elif status == "SKIP":
+                                            regime_s1_summary["skipped"] += 1
+                                        else:
+                                            regime_s1_summary["skipped"] += 1
+
+                                        _log_s1_action(
+                                            code,
+                                            status,
+                                            base_qty,
+                                            target_qty,
+                                            sold_today,
+                                            remaining,
+                                            sell_qty,
+                                            reason_msg,
+                                        )
+
+                            if regime["bear_stage"] >= 2 and not holding[code].get(
+                                "bear_s2_done"
                             ):
-                                cut_qty = max(
-                                    1, int(holding[code]["qty"] * REG_PARTIAL_S2)
-                                )
-                                logger.info(
-                                    f"[REGIME-REDUCE-S2/ë¹„íƒ€ê²Ÿ] {code} ì•½ì„¸2ë‹¨ê³„ {REG_PARTIAL_S2 * 100:.0f}% ì¶•ì†Œ â†’ {cut_qty}"
-                                )
-                                exec_px, result = _sell_once(
-                                    kis, code, cut_qty, prefer_market=True
+                                if not holding[code].get("bear_s1_done"):
+                                    _log_s2_action(
+                                        code,
+                                        "SKIP",
+                                        int(holding[code].get("qty", 0)),
+                                        0,
+                                        0,
+                                        0,
+                                        0,
+                                        "s1_not_done",
+                                    )
+                                    continue
+                                if code in s1_done_today:
+                                    logger.warning(
+                                        f"[REGIME_S2][SEQ] {code}: ë™ì¼ ì¼ì S1 ì™„ë£Œ ì§í›„ S2 ì§„ì…"
+                                    )
+                                sellable_here = ord_psbl_map.get(code, 0)
+                                guard = _s2_guard_nontarget(
+                                    now_dt_kst.date(),
+                                    code,
+                                    holding[code].get("qty", 0),
                                 )
-                                holding[code]["qty"] -= int(cut_qty)
-                                holding[code]["bear_s2_done"] = True
-                                log_trade(
-                                    {
-                                        "datetime": now_str,
-                                        "code": code,
-                                        "name": None,
-                                        "qty": int(cut_qty),
-                                        "K": holding[code].get("k_value"),
-                                        "target_price": holding[code].get(
-                                            "target_price_src"
-                                        ),
-                                        "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
-                                        "side": "SELL",
-                                        "price": exec_px,
-                                        "amount": int((exec_px or 0))
-                                        * int(cut_qty),
-                                        "result": result,
-                                        "reason": "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ(íƒ€ê²Ÿ)",
-                                    }
-                                )
-                                save_state(holding, traded)
-                                time.sleep(RATE_SLEEP_SEC)
+                                base_qty = int(guard.get("base_qty") or 0)
+                                if base_qty <= 0:
+                                    _log_s2_action(
+                                        code,
+                                        "SKIP",
+                                        base_qty,
+                                        0,
+                                        int(guard.get("sold", 0)),
+                                        0,
+                                        0,
+                                        "base_qty_zero",
+                                    )
+                                else:
+                                    target_qty = max(1, int(base_qty * REG_PARTIAL_S2))
+                                    sold_today = int(guard.get("sold", 0))
+                                    remaining = max(0, target_qty - sold_today)
+
+                                    if remaining <= 0 or sellable_here <= 0:
+                                        if remaining <= 0:
+                                            holding[code]["bear_s2_done"] = True
+                                        _log_s2_action(
+                                            code,
+                                            "SKIP",
+                                            base_qty,
+                                            target_qty,
+                                            sold_today,
+                                            remaining,
+                                            0,
+                                            (
+                                                "target_met"
+                                                if remaining <= 0
+                                                else "no_sellable_qty"
+                                            ),
+                                        )
+                                    else:
+                                        sell_qty = min(remaining, sellable_here)
+                                        try:
+                                            exec_px, result = _sell_once(
+                                                kis, code, sell_qty, prefer_market=True
+                                            )
+                                            status, skip_reason = _sell_result_status(
+                                                result
+                                            )
+                                        except Exception as e:
+                                            exec_px, result = None, None
+                                            status, skip_reason = "ERROR", str(e)
+
+                                        reason_msg = (
+                                            skip_reason or "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)"
+                                        )
+
+                                        if status == "SENT":
+                                            guard["sold"] = sold_today + int(sell_qty)
+                                            holding[code]["qty"] = max(
+                                                0, holding[code]["qty"] - int(sell_qty)
+                                            )
+                                            if guard["sold"] >= target_qty:
+                                                holding[code]["bear_s2_done"] = True
+                                            _persist_guard_state(now_dt_kst.date())
+                                            log_trade(
+                                                {
+                                                    "datetime": now_str,
+                                                    "code": code,
+                                                    "name": None,
+                                                    "qty": int(sell_qty),
+                                                    "K": holding[code].get("k_value"),
+                                                    "target_price": holding[code].get(
+                                                        "target_price_src"
+                                                    ),
+                                                    "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
+                                                    "side": "SELL",
+                                                    "price": exec_px,
+                                                    "amount": int((exec_px or 0))
+                                                    * int(sell_qty),
+                                                    "result": result,
+                                                    "reason": reason_msg,
+                                                }
+                                            )
+                                            save_state(holding, traded)
+                                            time.sleep(RATE_SLEEP_SEC)
+                                        elif status == "SKIP":
+                                            pass
+
+                                        _log_s2_action(
+                                            code,
+                                            status,
+                                            base_qty,
+                                            target_qty,
+                                            sold_today,
+                                            remaining,
+                                            sell_qty,
+                                            reason_msg,
+                                        )
 
                     try:
-                        momentum_intact, trend_ctx = _has_bullish_trend_structure(kis, code)
+                        momentum_intact, trend_ctx = _has_bullish_trend_structure(
+                            kis, code
+                        )
                     except NetTemporaryError:
                         logger.warning(
                             f"[20D_TREND_TEMP_SKIP] {code}: ë„¤íŠ¸ì›Œí¬ ì¼ì‹œ ì‹¤íŒ¨ â†’ ì´ë²ˆ ë£¨í”„ ìŠ¤í‚µ"
                         )
                         continue
                     except DataEmptyError:
                         logger.warning(
                             f"[DATA_EMPTY] {code}: 0ìº”ë“¤ â†’ ë‹¤ìŒ ë£¨í”„ì—ì„œ ì¬í™•ì¸"
                         )
                         continue
                     except DataShortError:
                         logger.error(
                             f"[DATA_SHORT] {code}: 21ê°œ ë¯¸ë§Œ â†’ ì´ë²ˆ ë£¨í”„ íŒë‹¨ ìŠ¤í‚µ"
                         )
                         continue
 
                     if momentum_intact:
                         logger.info(
                             (
                                 f"[ëª¨ë©˜í…€ ë³´ìœ ] {code}: 5/10/20 ì •ë°°ì—´ & 20ì¼ì„  ìƒìŠ¹ & ì¢…ê°€>20ì¼ì„  ìœ ì§€ "
                                 f"(close={trend_ctx.get('last_close'):.2f}, ma5={trend_ctx.get('ma5'):.2f}, "
                                 f"ma10={trend_ctx.get('ma10'):.2f}, ma20={trend_ctx.get('ma20'):.2f}â†’{trend_ctx.get('ma20_prev'):.2f})"
                             )
                         )
                         continue
 
+            if regime_s1_summary.get("by_stock"):
+                logger.info(
+                    f"[REGIME_S1][SUMMARY] sent_qty={regime_s1_summary['sent_qty']} "
+                    f"sent_orders={regime_s1_summary['sent_orders']} "
+                    f"skipped={regime_s1_summary['skipped']} total_qty={regime_s1_summary['total_qty']} "
+                    f"by_stock={regime_s1_summary['by_stock']}"
+                )
+
             # --- ì¥ì¤‘ ì»¤íŠ¸ì˜¤í”„(KST): 14:40 ë„ë‹¬ ì‹œ "ì „ëŸ‰ë§¤ë„ ì—†ì´" ë¦¬í¬íŠ¸ ìƒì„± í›„ ì •ìƒ ì¢…ë£Œ ---
             if is_open and now_dt_kst.time() >= SELL_FORCE_TIME:
                 logger.info(
                     f"[â° ì»¤íŠ¸ì˜¤í”„] {SELL_FORCE_TIME.strftime('%H:%M')} ë„ë‹¬: ì „ëŸ‰ ë§¤ë„ ì—†ì´ ë¦¬í¬íŠ¸ ìƒì„± í›„ ì¢…ë£Œ"
                 )
 
                 save_state(holding, traded)
 
                 try:
                     _report = ceo_report(datetime.now(KST), period="daily")
                     logger.info(
                         f"[ğŸ“„ CEO Report ìƒì„± ì™„ë£Œ] title={_report.get('title')}"
                     )
                 except Exception as e:
                     logger.error(f"[CEO Report ìƒì„± ì‹¤íŒ¨] {e}")
 
                 logger.info("[âœ… ì»¤íŠ¸ì˜¤í”„ ì™„ë£Œ: ë£¨í”„ ì •ìƒ ì¢…ë£Œ]")
                 break
 
             save_state(holding, traded)
             time.sleep(loop_sleep_sec)
 
     except KeyboardInterrupt:
         logger.info("[ğŸ›‘ ìˆ˜ë™ ì¢…ë£Œ]")
     except Exception as e:
