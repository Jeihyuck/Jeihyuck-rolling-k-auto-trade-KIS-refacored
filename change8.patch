diff --git a/README.md b/README.md
index 8d133c309b2c59198d9eed4e2a624803e18e4bec..f90135ca11fccf603f586737e85be5d1e0bb30d0 100644
--- a/README.md
+++ b/README.md
@@ -14,25 +14,49 @@ strategy/
   kosdaq/{universe.py, rolling_entry.py, pullback.py}
 trader/
   trader.py (entrypoint)
   state_manager.py
   legacy_kosdaq_runner.py (previous KOSDAQ loop kept intact)
 ```
 
 ## Engine responsibilities
 - **KOSPI core engine**: KOSPI market-cap Top-N universe, equal-weight targets, periodic rebalance with market orders and KIS quotes.
 - **KOSDAQ alpha engine**: delegates to the legacy rolling-K/VWAP/pullback loop unchanged, using its original state file for backward compatibility.
 - **Capital split**: `PortfolioManager` divides `DAILY_CAPITAL` (or supplied total) into KOSPI and KOSDAQ ratios (default 60/40) and runs each engine independently.
 - **Performance**: portfolio-level PnL snapshots combine KIS cash/positions with engine allocation ratios for unified reporting without coupling the two engines.
   - Engine-level PnL is an attribution estimate based on capital split ratios because positions are pooled at the account level.
 
 ## How to run
 ```
 python -m trader.trader
 ```
 This initializes the portfolio manager, runs KOSPI rebalance if due, then executes the existing KOSDAQ intraday loop without interrupting either engine on errors. The KOSDAQ loop is blocking, so the entrypoint runs a single orchestrated cycle via `run_once()` rather than a repeating scheduler.
 
 WorkflowÎäî bot-state Î∏åÎûúÏπòÏóê bot_state/state.jsonÏùÑ Ïª§Î∞ãÌïòÏó¨ Îü∞ Í∞Ñ ÏÉÅÌÉúÎ•º Ïú†ÏßÄÌï©ÎãàÎã§.
 
 ## CI and live-trading safeguards
 - CI (pull_request) runs set `DISABLE_LIVE_TRADING=true` so all KIS API calls are blocked and only static checks execute.
 - The live trading workflow is restricted to the `main` branch and triggers only via schedule or manual dispatch with the branch guard enabled.
+
+## How ORPHAN recovery works
+The KOSDAQ loop reconciles broker holdings into the position state each cycle. If a holding is missing from the state, the bot:
+1. Searches the recent trade logs for the latest BUY fill of the same code to recover the strategy ID and engine.
+2. Falls back to a rebalance bucket (`REB_YYYYMMDD`) if the code is in today‚Äôs targets.
+3. Otherwise assigns the holding to `MANUAL`.
+
+This avoids ORPHAN/UNKNOWN mappings and ensures every holding has an explicit sid bucket.
+
+## State schema
+Position state is stored in `trader/state/state.json` and normalized on load. Each strategy entry is guaranteed to include:
+```
+{
+  "code": "<6-digit code>",
+  "sid": "<strategy or bucket id>",
+  "engine": "<entry engine>",
+  "qty": <int>,
+  "avg_price": <float>,
+  "entry_ts": "<ISO timestamp>",
+  "high_watermark": <float>,
+  "flags": { ... },
+  "last_update_ts": "<ISO timestamp>"
+}
+```
diff --git a/trader/code_utils.py b/trader/code_utils.py
new file mode 100644
index 0000000000000000000000000000000000000000..f1c83e095bdd5ac779050354a853a33859885a32
--- /dev/null
+++ b/trader/code_utils.py
@@ -0,0 +1,16 @@
+from __future__ import annotations
+
+from typing import Any
+
+
+def normalize_code(raw: Any) -> str:
+    text = str(raw or "").strip()
+    if not text:
+        return ""
+    if text.startswith("A"):
+        text = text[1:]
+    digits = "".join(ch for ch in text if ch.isdigit())
+    if not digits:
+        return ""
+    digits = digits[-6:]
+    return digits.zfill(6)
diff --git a/trader/config.py b/trader/config.py
index 644e3fd23b620d66abf9b86043303e5ff7137b99..1cb5e4a1d3b75e79f6ab76af4a358ca89d781a01 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -11,50 +11,53 @@ import os
 from datetime import datetime, time as dtime
 from pathlib import Path
 from typing import Dict
 from zoneinfo import ZoneInfo
 
 # =========================
 # [CONFIG] .env ÏóÜÏù¥ÎèÑ ÎèôÏûë
 # - ÏïÑÎûò Í∞íÏùÑ Í∏∞Î≥∏ÏúºÎ°ú ÏÇ¨Ïö©
 # - (ÏÑ†ÌÉù) ÎèôÏùº ÌÇ§Î•º ÌôòÍ≤ΩÎ≥ÄÏàòÎ°ú ÎÑòÍ∏∞Î©¥ override
 # =========================
 CONFIG = {
     "SELL_FORCE_TIME": "14:40",
     "SELL_ALL_BALANCES_AT_CUTOFF": "false",  # "true"Î©¥ Ïª§Ìä∏Ïò§ÌîÑÏóê Ï†ÑÏ≤¥ ÏûîÍ≥† Ìè¨Ìï® Í∞ïÏ†úÎß§ÎèÑ Î£®Ìã¥ ÏÇ¨Ïö©
     "API_RATE_SLEEP_SEC": "0.5",
     "FORCE_SELL_PASSES_CUTOFF": "2",
     "FORCE_SELL_PASSES_CLOSE": "4",
     "FORCE_SELL_BLOCKED_LOTS": "0",
     "PARTIAL1": "0.5",
     "PARTIAL2": "0.3",
     "TRAIL_PCT": "0.02",
     "FAST_STOP": "0.01",
     "ATR_STOP": "1.5",
     "TIME_STOP_HHMM": "13:00",
     "DEFAULT_PROFIT_PCT": "3.0",
     "DEFAULT_LOSS_PCT": "-5.0",
+    "MANUAL_HARD_STOP_LOSS_PCT": "5.0",
+    "MANUAL_TRAILING_STOP_PCT": "2.0",
+    "MANUAL_MAX_HOLDING_DAYS": "5",
     "DAILY_CAPITAL": "250000000",
     "CAP_CAP": "0.8",
     "SLIPPAGE_LIMIT_PCT": "0.25",
     "SLIPPAGE_ENTER_GUARD_PCT": "2.5",
     "VWAP_TOL": "0.003",  # üî∏ VWAP ÌóàÏö© Ïò§Ï∞®(Í∏∞Î≥∏ 0.3%)
     "W_MAX_ONE": "0.25",
     "W_MIN_ONE": "0.03",
     "REBALANCE_ANCHOR": "weekly",             # weekly | today | monthly
     "WEEKLY_ANCHOR_REF": "last",              # NEW: 'last'(ÏßÅÏ†Ñ ÏùºÏöîÏùº) | 'next'(Îã§Ïùå ÏùºÏöîÏùº)
     "MOMENTUM_OVERRIDES_FORCE_SELL": "true",
     # Î†àÏßê(ÏΩîÏä§Îã•) ÌååÎùºÎØ∏ÌÑ∞
     "KOSDAQ_INDEX_CODE": "KOSDAQ",
     "KOSDAQ_ETF_FALLBACK": "229200",
     "REG_BULL_MIN_UP_PCT": "0.5",
     "REG_BULL_MIN_MINUTES": "10",
     "REG_BEAR_VWAP_MINUTES": "10",
     "REG_BEAR_DROP_FROM_HIGH": "0.7",
     "REG_BEAR_STAGE1_MINUTES": "20",
     "REG_BEAR_STAGE2_ADD_DROP": "0.5",
     "REG_PARTIAL_S1": "0.30",
     "REG_PARTIAL_S2": "0.30",
     "BASE_QTY_MODE": "initial",  # initial | current
     "TRAIL_PCT_BULL": "0.025",
     "TRAIL_PCT_BEAR": "0.012",
     "TP_PROFIT_PCT_BULL": "3.5",
@@ -120,50 +123,53 @@ STATE_DIR.mkdir(parents=True, exist_ok=True)
 # Ï¢ÖÎ™©Î≥Ñ ÏãúÏû•ÏΩîÎìú Í≥†Ï†ï Îßµ (Ïã§Ï†ÑÏóêÏÑúÎäî ÎßàÏä§ÌÑ∞ÌÖåÏù¥Î∏î Î°úÎìúÎ°ú ÎåÄÏ≤¥ Í∂åÏû•)
 MARKET_MAP: Dict[str, str] = {
     # ÏòàÏãú: '145020': 'J', '347850': 'J', '257720': 'U', '178320': 'J', '348370': 'U'
 }
 
 # Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå 1Ï∞® Í∞êÏßÄ ÏÉÅÌÉú Ï†ÄÏû•(Ïó∞ÏÜç DATA_EMPTY ÌôïÏù∏Ïö©)
 EXCLUDE_STATE: Dict[str, Dict[str, bool]] = {}
 
 KST = ZoneInfo("Asia/Seoul")
 
 SELL_FORCE_TIME_STR = _cfg("SELL_FORCE_TIME").strip()
 SELL_ALL_BALANCES_AT_CUTOFF = _cfg("SELL_ALL_BALANCES_AT_CUTOFF").lower() == "true"
 EMERGENCY_GLOBAL_SELL = _cfg("EMERGENCY_GLOBAL_SELL").lower() in ("1", "true", "yes")
 RATE_SLEEP_SEC = float(_cfg("API_RATE_SLEEP_SEC"))
 FORCE_SELL_PASSES_CUTOFF = int(_cfg("FORCE_SELL_PASSES_CUTOFF"))
 FORCE_SELL_PASSES_CLOSE = int(_cfg("FORCE_SELL_PASSES_CLOSE"))
 FORCE_SELL_BLOCKED_LOTS = _cfg("FORCE_SELL_BLOCKED_LOTS").lower() in ("1", "true", "yes")
 PARTIAL1 = float(_cfg("PARTIAL1"))
 PARTIAL2 = float(_cfg("PARTIAL2"))
 TRAIL_PCT = float(_cfg("TRAIL_PCT"))
 FAST_STOP = float(_cfg("FAST_STOP"))
 ATR_STOP = float(_cfg("ATR_STOP"))
 TIME_STOP_HHMM = _cfg("TIME_STOP_HHMM")
 DEFAULT_PROFIT_PCT = float(_cfg("DEFAULT_PROFIT_PCT"))
 DEFAULT_LOSS_PCT = float(_cfg("DEFAULT_LOSS_PCT"))
+MANUAL_HARD_STOP_LOSS_PCT = float(_cfg("MANUAL_HARD_STOP_LOSS_PCT"))
+MANUAL_TRAILING_STOP_PCT = float(_cfg("MANUAL_TRAILING_STOP_PCT"))
+MANUAL_MAX_HOLDING_DAYS = int(_cfg("MANUAL_MAX_HOLDING_DAYS") or "5")
 DAILY_CAPITAL = int(_cfg("DAILY_CAPITAL"))
 CAP_CAP = float(_cfg("CAP_CAP"))
 SLIPPAGE_LIMIT_PCT = float(_cfg("SLIPPAGE_LIMIT_PCT"))
 SLIPPAGE_ENTER_GUARD_PCT = float(_cfg("SLIPPAGE_ENTER_GUARD_PCT"))
 VWAP_TOL = float(_cfg("VWAP_TOL"))  # üî∏ VWAP ÌóàÏö© Ïò§Ï∞®(Ïòà: 0.003 = -0.3%ÍπåÏßÄ ÌóàÏö©)
 W_MAX_ONE = float(_cfg("W_MAX_ONE"))
 W_MIN_ONE = float(_cfg("W_MIN_ONE"))
 ALLOW_PYRAMID = (_cfg("ALLOW_PYRAMID") or "false").lower() == "true"
 REBALANCE_ANCHOR = _cfg("REBALANCE_ANCHOR")
 WEEKLY_ANCHOR_REF = _cfg("WEEKLY_ANCHOR_REF").lower()
 MOMENTUM_OVERRIDES_FORCE_SELL = _cfg("MOMENTUM_OVERRIDES_FORCE_SELL").lower() == "true"
 BASE_QTY_MODE = (_cfg("BASE_QTY_MODE") or "initial").lower()
 if BASE_QTY_MODE not in {"initial", "current"}:
     logging.getLogger(__name__).warning(
         f"[CONFIG] BASE_QTY_MODE={BASE_QTY_MODE} ÏßÄÏõê Ïïà Ìï® ‚Üí initialÎ°ú ÎåÄÏ≤¥"
     )
     BASE_QTY_MODE = "initial"
 
 # NEW: 1Î∂ÑÎ¥â Î™®Î©òÌÖÄ ÌååÎùºÎØ∏ÌÑ∞
 MOM_FAST = int(_cfg("MOM_FAST") or "5")
 MOM_SLOW = int(_cfg("MOM_SLOW") or "20")
 MOM_TH_PCT = float(_cfg("MOM_TH_PCT") or "0.5")
 # subject flow
 MIN_SMART_MONEY_RATIO_KOSPI = float(_cfg("MIN_SMART_MONEY_RATIO_KOSPI") or "0.02")
 MIN_SMART_MONEY_RATIO_KOSDAQ = float(_cfg("MIN_SMART_MONEY_RATIO_KOSDAQ") or "0.03")
diff --git a/trader/core_utils.py b/trader/core_utils.py
index 7e1cd4ab7e3a7fe16e06b814c1ed4a4e9a616a12..90fd298f5e797a4a46b53aa29503e28da7831bd1 100644
--- a/trader/core_utils.py
+++ b/trader/core_utils.py
@@ -1,59 +1,62 @@
 # -*- coding: utf-8 -*-
 """Í∏∞Ï¥à Ïú†Ìã∏Î¶¨Ìã∞ÏôÄ ÏÉÅÌÉú Í¥ÄÎ¶¨ Ìï®Ïàò Î™®Ïùå."""
 from __future__ import annotations
 
 import json
+import os
 import random
 import time
 from datetime import datetime, timedelta
 from typing import Any, Dict, List, Optional, Tuple
 
 from .core_constants import (
     LOG_DIR,
     STATE_FILE,
     STATE_WEEKLY_PATH,
     WEEKLY_ANCHOR_REF,
     _cfg,
     _this_iso_week_key,
     KST,
     REBALANCE_ANCHOR,
     logger,
 )
 from .kis_wrapper import KisAPI
+from .code_utils import normalize_code
 
 __all__ = [
     "_krx_tick",
     "_round_to_tick",
     "get_market",
     "_read_last_weekly",
     "_write_last_weekly",
     "should_weekly_rebalance_now",
     "stamp_weekly_done",
     "get_rebalance_anchor_date",
     "log_trade",
     "save_state",
+    "save_state_atomic",
     "load_state",
     "_with_retry",
     "_to_int",
     "_to_float",
     "_log_realized_pnl",
     "_get_daily_candles_cached",
 ]
 
 
 def _krx_tick(price: float) -> int:
     p = float(price or 0)
     if p >= 500_000:
         return 1_000
     if p >= 100_000:
         return 500
     if p >= 50_000:
         return 100
     if p >= 10_000:
         return 50
     if p >= 5_000:
         return 10
     if p >= 1_000:
         return 5
     return 1
 
@@ -69,57 +72,60 @@ def _round_to_tick(price: float, mode: str = "nearest") -> int:
     elif mode == "up":
         q = int(q) if q == int(q) else int(q) + 1
     else:
         q = int(q + 0.5)
     return int(q * tick)
 
 
 def get_market(code: str) -> str:
     from .core_constants import MARKET_MAP
 
     return MARKET_MAP.get(code, "J")
 
 
 # === [ANCHOR: DAILY_CANDLE_CACHE] ÏùºÎ¥â ÏôÑÏ†Ñ Ï∫êÏã± ===
 _DAILY_CANDLE_CACHE: Dict[str, Dict[str, Any]] = {}
 
 
 def _get_daily_candles_cached(kis: KisAPI, code: str, count: int) -> List[Dict[str, Any]]:
     """
     ÏΩîÎìúÎ≥Ñ ÏùºÎ¥âÏùÑ ÎãπÏùº Í∏∞Ï§ÄÏúºÎ°ú Ï∫êÏã±.
     - ÎèôÏùº ÏΩîÎìú/Í±∞ÎûòÏùºÏóêÏÑúÎäî ÏµúÏ¥à ÏöîÏ≤≠ ÏãúÏóêÎßå API Ìò∏Ï∂ú
     - Ïù¥ÌõÑ Îçî Í∏¥ countÍ∞Ä Îì§Ïñ¥Ïò§Î©¥ Ìïú Î≤à Îçî Ìò∏Ï∂úÌï¥ÏÑú Ï∫êÏãú Í∞±Ïã†
     """
 
     today = datetime.now(KST).date()
-    entry = _DAILY_CANDLE_CACHE.get(code)
+    code_key = normalize_code(code)
+    if not code_key:
+        return []
+    entry = _DAILY_CANDLE_CACHE.get(code_key)
     if entry and entry.get("date") == today and len(entry.get("candles") or []) >= count:
         return entry["candles"]
 
-    candles = kis.get_daily_candles(code, count=count)
+    candles = kis.get_daily_candles(code_key, count=count)
     if candles:
-        _DAILY_CANDLE_CACHE[code] = {"date": today, "candles": candles}
+        _DAILY_CANDLE_CACHE[code_key] = {"date": today, "candles": candles}
     return candles or []
 
 
 def _read_last_weekly():
     if not STATE_WEEKLY_PATH.exists():
         return None
     try:
         return (json.loads(STATE_WEEKLY_PATH.read_text(encoding="utf-8"))).get(
             "weekly_rebalanced_at"
         )
     except Exception:
         return None
 
 
 def _write_last_weekly(now=None):
     now = now or datetime.now(KST)
     try:
         STATE_WEEKLY_PATH.write_text(
             json.dumps({"weekly_rebalanced_at": _this_iso_week_key(now)}, ensure_ascii=False),
             encoding="utf-8",
         )
     except Exception as e:
         logger.warning(f"[STATE_WRITE_FAIL] weekly: {e}")
 
 
@@ -152,56 +158,67 @@ def get_rebalance_anchor_date(now: Optional[datetime] = None) -> str:
       - WEEKLY_ANCHOR_REF='next'  ‚Üí Îã§Ïùå ÏùºÏöîÏùº
     """
     now = now or datetime.now(KST)
     today = now.date()
 
     if REBALANCE_ANCHOR == "weekly":
         ref = WEEKLY_ANCHOR_REF if WEEKLY_ANCHOR_REF in ("last", "next", "prev", "previous") else "last"
         if ref in ("last", "prev", "previous"):
             days_since_sun = (today.weekday() + 1) % 7
             anchor_date = today - timedelta(days=days_since_sun)
         else:
             days_to_sun = (6 - today.weekday()) % 7
             anchor_date = today + timedelta(days=days_to_sun)
         return anchor_date.strftime("%Y-%m-%d")
 
     if REBALANCE_ANCHOR == "today":
         return today.strftime("%Y-%m-%d")
 
     return today.replace(day=1).strftime("%Y-%m-%d")
 
 
 def log_trade(trade: dict) -> None:
     today = datetime.now(KST).strftime("%Y-%m-%d")
     logfile = LOG_DIR / f"trades_{today}.json"
     with open(logfile, "a", encoding="utf-8") as f:
-        f.write(json.dumps(trade, ensure_ascii=False) + "\n")
+        payload = dict(trade)
+        if "code" in payload:
+            payload["code"] = normalize_code(payload.get("code"))
+        f.write(json.dumps(payload, ensure_ascii=False) + "\n")
+
+
+def save_state_atomic(holding: Dict[str, Any], traded: Dict[str, Any]) -> None:
+    STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
+    payload = {"holding": holding, "traded": traded}
+    tmp_path = STATE_FILE.with_name(f"{STATE_FILE.name}.tmp")
+    with open(tmp_path, "w", encoding="utf-8") as f:
+        json.dump(payload, f, ensure_ascii=False, indent=2)
+    os.replace(tmp_path, STATE_FILE)
 
 
 def save_state(holding: Dict[str, Any], traded: Dict[str, Any]) -> None:
-    with open(STATE_FILE, "w", encoding="utf-8") as f:
-        json.dump({"holding": holding, "traded": traded}, f, ensure_ascii=False, indent=2)
+    save_state_atomic(holding, traded)
 
 
 def load_state() -> Tuple[Dict[str, Any], Dict[str, Any]]:
     if STATE_FILE.exists():
         with open(STATE_FILE, "r", encoding="utf-8") as f:
             state = json.load(f)
         return state.get("holding", {}), state.get("traded", {})
     return {}, {}
 
 
 def _with_retry(func, *args, max_retries=5, base_delay=0.6, **kwargs):
     last_err = None
     for attempt in range(1, max_retries + 1):
         try:
             return func(*args, **kwargs)
         except Exception as e:
             last_err = e
             sleep_sec = base_delay * (1.6 ** (attempt - 1)) + random.uniform(0, 0.25)
             logger.error(
                 f"[Ïû¨ÏãúÎèÑ {attempt}/{max_retries}] {func.__name__} Ïã§Ìå®: {e} ‚Üí {sleep_sec:.2f}s ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÎèÑ"
             )
             time.sleep(sleep_sec)
     raise last_err
 
 
@@ -218,26 +235,25 @@ def _to_float(val, default=None) -> Optional[float]:
     except Exception:
         return default
 
 
 def _log_realized_pnl(
     code: str,
     exec_px: Optional[float],
     sell_qty: int,
     buy_price: Optional[float],
     reason: str = "",
 ) -> None:
     try:
         if exec_px is None or sell_qty <= 0 or not buy_price or buy_price <= 0:
             return
         pnl_pct = ((float(exec_px) - float(buy_price)) / float(buy_price)) * 100.0
         profit = (float(exec_px) - float(buy_price)) * int(sell_qty)
         msg = (
             f"[P&L] {code} SELL {int(sell_qty)}@{float(exec_px):.2f} / BUY={float(buy_price):.2f} "
             f"‚Üí PnL={pnl_pct:.2f}% (‚Ç©{int(round(profit)):,.0f})"
         )
         if reason:
             msg += f" / REASON={reason}"
         logger.info(msg)
     except Exception as e:
         logger.warning(f"[P&L_LOG_FAIL] {code} err={e}")
-
diff --git a/trader/execution.py b/trader/execution.py
index 7a281e4f3f22c93c42a16c0191ccb1321f493bbd..6ca2dec4b0358b688d9872830f9934a25819d233 100644
--- a/trader/execution.py
+++ b/trader/execution.py
@@ -1,42 +1,43 @@
 """Ìè¨ÏßÄÏÖò Ï¥àÍ∏∞Ìôî, Ï≤¥Í≤∞, Î†àÏßê Í¥ÄÎ†® Í∏∞Îä•."""
 from __future__ import annotations
 
 import logging
 
 import csv
 import json
 import os
 import time
 from datetime import datetime, time as dtime, timedelta
 from pathlib import Path
 from typing import Any, Dict, List, Optional, Tuple
 
 import requests
 
 from .core_constants import *  # noqa: F401,F403
 from .config import KST, STATE_PATH
+from .code_utils import normalize_code
 from .core_utils import (
     _get_daily_candles_cached,
     _log_realized_pnl,
     _round_to_tick,
     _to_float,
     _to_int,
     _with_retry,
     log_trade,
 )
 from .kis_wrapper import KisAPI, NetTemporaryError
 from .fills import append_fill
 from .signals import (
     _get_atr,
     _notional_to_qty,
     _safe_get_price,
     _weight_to_qty,
     get_20d_return_pct,
     is_strong_momentum,
     _detect_pullback_reversal,
 )
 from .metrics import vwap_guard
 
 __all__ = [
     "fetch_rebalancing_targets",
     "_init_position_state",
@@ -93,394 +94,418 @@ def _normalize_meta(payload: Dict[str, Any] | None) -> Dict[str, Any]:
 def _normalize_flags(payload: Dict[str, Any] | None) -> Dict[str, Any]:
     payload = payload or {}
     return {
         "bear_s1_done": bool(payload.get("bear_s1_done", False)),
         "bear_s2_done": bool(payload.get("bear_s2_done", False)),
     }
 
 
 def record_entry_state(
     *,
     state: Dict[str, Any],
     code: str,
     qty: int,
     avg_price: float,
     strategy_id: Any,
     engine: str,
     entry_reason: str,
     order_type: str | None,
     best_k: Any,
     tgt_px: Any,
     gap_pct_at_entry: Any,
     meta: Dict[str, Any] | None = None,
     flags: Dict[str, Any] | None = None,
     entry_time: str | None = None,
 ) -> Dict[str, Any]:
-    code_key = str(code).zfill(6)
+    code_key = normalize_code(code)
     sid_key = str(strategy_id)
     pos = state.setdefault("positions", {}).setdefault(
         code_key,
         {
             "strategies": {},
         },
     )
     strategies = pos.setdefault("strategies", {})
     existing = strategies.get(sid_key)
     if not isinstance(existing, dict):
         entry_flags = {
             "bear_s1_done": False,
             "bear_s2_done": False,
             "sold_p1": False,
             "sold_p2": False,
         }
         if flags:
             entry_flags.update(
                 {k: bool(flags.get(k)) for k in entry_flags.keys() if k in flags}
             )
         entry_meta = _normalize_meta(meta)
         entry_meta.setdefault("high", float(avg_price))
         entry_meta["high"] = max(float(entry_meta.get("high") or 0.0), float(avg_price))
+        now_ts = entry_time or datetime.now(KST).isoformat()
         strategies[sid_key] = {
             "qty": int(qty),
             "avg_price": float(avg_price),
             "entry": _normalize_entry_meta(
                 code=str(code),
                 strategy_id=strategy_id,
                 engine=engine,
                 entry_reason=entry_reason,
                 order_type=order_type,
                 best_k=best_k,
                 tgt_px=tgt_px,
                 gap_pct_at_entry=gap_pct_at_entry,
-                entry_time=entry_time,
+                entry_time=now_ts,
             ),
             "meta": entry_meta,
             "flags": entry_flags,
+            "code": code_key,
+            "sid": str(strategy_id),
+            "engine": engine,
+            "entry_ts": now_ts,
+            "high_watermark": float(entry_meta.get("high") or avg_price),
+            "last_update_ts": now_ts,
         }
     else:
         prev_qty = int(existing.get("qty") or 0)
         add_qty = int(qty)
         total_qty = prev_qty + add_qty
         prev_avg = float(existing.get("avg_price") or 0.0)
         new_avg = (
             (prev_avg * prev_qty + float(avg_price) * add_qty) / total_qty
             if total_qty > 0
             else 0.0
         )
         existing["qty"] = int(total_qty)
         existing["avg_price"] = float(new_avg)
         entry = existing.setdefault("entry", {})
         entry_time_value = entry_time or datetime.now(KST).isoformat()
         entry["last_entry_time"] = entry_time_value
         entry["strategy_id"] = entry.get("strategy_id") or str(strategy_id)
         entry_meta = existing.setdefault("meta", {})
         if not entry_meta.get("high") or float(entry_meta.get("high") or 0.0) <= 0:
             entry_meta["high"] = float(new_avg)
         entry_meta["high"] = max(float(entry_meta.get("high") or 0.0), float(new_avg))
+        existing["code"] = code_key
+        existing["sid"] = str(strategy_id)
+        existing["engine"] = engine
+        existing["entry_ts"] = entry.get("time") or entry_time_value
+        existing["high_watermark"] = max(
+            float(existing.get("high_watermark") or 0.0),
+            float(entry_meta.get("high") or 0.0),
+            float(new_avg),
+        )
+        existing["last_update_ts"] = entry_time_value
         entry_flags = existing.setdefault(
             "flags",
             {
                 "bear_s1_done": False,
                 "bear_s2_done": False,
                 "sold_p1": False,
                 "sold_p2": False,
             },
         )
         if flags:
             for key, value in flags.items():
                 if key in entry_flags:
                     entry_flags[key] = bool(value)
     logger.info(
         "[ENTRY] code=%s strategy=%s engine=%s best_k=%s tgt_px=%s saved_state=OK",
         code_key,
         strategy_id,
         engine,
         best_k,
         tgt_px,
     )
     return state
 
 
 def update_position_meta(
     state: Dict[str, Any],
     code: str,
     strategy_id: Any,
     meta_updates: Dict[str, Any] | None = None,
 ) -> Dict[str, Any]:
-    code_key = str(code).zfill(6)
+    code_key = normalize_code(code)
     sid_key = str(strategy_id)
     pos = state.get("positions", {}).get(code_key)
     if not isinstance(pos, dict):
         return state
     strategies = pos.get("strategies", {})
     entry = strategies.get(sid_key)
     if not isinstance(entry, dict):
         return state
     meta = entry.setdefault(
         "meta",
         {
             "pullback_peak_price": None,
             "pullback_reversal_price": None,
             "pullback_reason": None,
         },
     )
     if meta_updates:
         for key in ("pullback_peak_price", "pullback_reversal_price", "pullback_reason"):
             if key in meta_updates:
                 meta[key] = meta_updates.get(key)
+    entry["last_update_ts"] = datetime.now(KST).isoformat()
     return state
 
 
 def update_position_flags(
     state: Dict[str, Any],
     code: str,
     strategy_id: Any,
     flag_updates: Dict[str, Any],
 ) -> Dict[str, Any]:
     assert strategy_id is not None, "strategy_id required for update_position_flags"
-    code_key = str(code).zfill(6)
+    code_key = normalize_code(code)
     pos = state.get("positions", {}).get(code_key)
     if not isinstance(pos, dict):
         return state
     strategies = pos.setdefault("strategies", {})
     entry = strategies.get(str(strategy_id))
     if not isinstance(entry, dict):
         return state
     flags = entry.setdefault(
         "flags",
         {"bear_s1_done": False, "bear_s2_done": False, "sold_p1": False, "sold_p2": False},
     )
     before_flags = dict(flags)
     for key in ("bear_s1_done", "bear_s2_done", "sold_p1", "sold_p2"):
         if key in flag_updates:
             flags[key] = bool(flag_updates.get(key))
     logger.info(
         "[FLAGS] code=%s flags_before=%s flags_after=%s",
         code_key,
         before_flags,
         flags,
     )
+    entry["last_update_ts"] = datetime.now(KST).isoformat()
     return state
 
 def fetch_rebalancing_targets(date: str) -> list[dict[str, Any]]:
     REBALANCE_API_URL = f"http://localhost:8000/rebalance/run/{date}?force_order=true"
     response = requests.post(REBALANCE_API_URL)
     logger.info(f"[üõ∞Ô∏è Î¶¨Î∞∏Îü∞Ïã± API Ï†ÑÏ≤¥ ÏùëÎãµ]: {response.text}")
     if response.status_code == 200:
         data = response.json()
         selected = data.get("selected") or data.get("selected_stocks") or []
         logger.info(f"[üéØ Î¶¨Î∞∏Îü∞Ïã± Ï¢ÖÎ™©]: {selected}")
         try:
             champion = selected[0] if selected else None
             log_champion_and_regime(logger, champion, REGIME_STATE, context="rebalance_api")
         except Exception as e:
             logger.exception(f"[VWAP_CHAMPION_LOG_ERROR] {e}")
         return selected
     raise Exception(f"Î¶¨Î∞∏Îü∞Ïã± API Ìò∏Ï∂ú Ïã§Ìå®: {response.text}")
 
 def _init_position_state(kis: KisAPI, holding: Dict[str, Any], code: str, entry_price: float, qty: int, k_value: Any, target_price: Optional[float]) -> None:
+    code = normalize_code(code)
     try:
         _ = kis.is_market_open()
     except Exception:
         pass
     atr = _get_atr(kis, code)
     rng_eff = (atr * 1.5) if (atr and atr > 0) else max(1.0, entry_price * 0.01)
     t1 = entry_price + 0.5 * rng_eff
     t2 = entry_price + 1.0 * rng_eff
     holding[code] = {
         'qty': int(qty),
         'buy_price': float(entry_price),
         'entry_time': datetime.now(KST).isoformat(),
         'high': float(entry_price),
         'tp1': float(t1),
         'tp2': float(t2),
         'sold_p1': False,
         'sold_p2': False,
         'trail_pct': TRAIL_PCT,
         'atr': float(atr) if atr else None,
         'stop_abs': float(entry_price - ATR_STOP * atr) if atr else float(entry_price * (1 - FAST_STOP)),
         'k_value': k_value,
         'target_price_src': float(target_price) if target_price is not None else None,
         'bear_s1_done': False,
         'bear_s2_done': False,
         # ÎàåÎ¶ºÎ™© 3Îã®Í≥Ñ ÏßÑÏûÖ Í¥ÄÎ†® Í∏∞Î≥∏Í∞í (Ïã†Í∑ú Îß§Ïàò ÏßÅÌõÑ overwrite Í∞ÄÎä•)
         'entry_stage': 1,
         'max_price_after_entry': float(entry_price),
         'planned_total_qty': int(qty),
         'stage1_qty': int(qty),
         'stage2_qty': 0,
         'stage3_qty': 0,
     }
 
 def _init_position_state_from_balance(kis: KisAPI, holding: Dict[str, Any], code: str, avg_price: float, qty: int) -> None:
+    code = normalize_code(code)
     if qty <= 0 or code in holding:
         return
     try:
         _ = kis.is_market_open()
     except Exception:
         pass
     atr = _get_atr(kis, code)
     rng_eff = (atr * 1.5) if (atr and atr > 0) else max(1.0, avg_price * 0.01)
     t1 = avg_price + 0.5 * rng_eff
     t2 = avg_price + 1.0 * rng_eff
     holding[code] = {
         'qty': int(qty),
         'buy_price': float(avg_price),
         'entry_time': (datetime.now(KST) - timedelta(minutes=10)).isoformat(),
         'high': float(avg_price),
         'tp1': float(t1),
         'tp2': float(t2),
         'sold_p1': False,
         'sold_p2': False,
         'trail_pct': TRAIL_PCT,
         'atr': float(atr) if atr else None,
         'stop_abs': float(avg_price - ATR_STOP * atr) if atr else float(avg_price * (1 - FAST_STOP)),
         'k_value': None,
         'target_price_src': None,
         'bear_s1_done': False,
         'bear_s2_done': False,
         # Í∏∞Ï°¥ Î≥¥Ïú†Î∂ÑÏùÄ Ï∂îÍ∞Ä ÏßÑÏûÖ(stage 3 ÏôÑÎ£å ÏÉÅÌÉú)ÏúºÎ°ú Í∞ÑÏ£º
         'entry_stage': 3,
         'max_price_after_entry': float(avg_price),
         'planned_total_qty': int(qty),
         'stage1_qty': int(qty),
         'stage2_qty': 0,
         'stage3_qty': 0,
     }
 
 
 def _maybe_scale_in_dips(
     kis: KisAPI,
     holding: Dict[str, Any],
     code: str,
     target: Dict[str, Any],
     now_str: str,
     regime_mode: str,
     position_state: Dict[str, Any] | None = None,
 ) -> None:
     """
     Ïã†Í≥†Í∞Ä ‚Üí 3Ïùº Ïó∞ÏÜç ÌïòÎùΩ ‚Üí Î∞òÎì± ÌôïÏù∏ Ïãú Îã®Í≥ÑÏ†Å Ï∂îÍ∞Ä Îß§Ïàò Î°úÏßÅ.
     - entry_stage: 1 ‚Üí 2Ï∞® ÏßÑÏûÖ ÌõÑÎ≥¥(Î∞òÎì± ÌôïÏù∏ÏÑ† ÎèåÌåå), 2 ‚Üí 3Ï∞® ÏßÑÏûÖ ÌõÑÎ≥¥(Ïã†Í≥†Í∞Ä ÌöåÎ≥µ)
     - bull / neutral Î™®ÎìúÏóêÏÑúÎßå ÎèôÏûë, bear Î™®ÎìúÏóêÏÑúÎäî Ï∂îÍ∞Ä ÏßÑÏûÖ Í∏àÏßÄ
     """
-    pos = holding.get(code)
+    code_key = normalize_code(code)
+    if not code_key:
+        return
+    pos = holding.get(code_key)
     if not pos:
         return
 
     # ÏïΩÏÑ∏ Î†àÏßêÏóêÏÑúÎäî Ï∂îÍ∞Ä ÏßÑÏûÖ Í∏àÏßÄ
     if regime_mode not in ("bull", "neutral"):
         return
 
     entry_stage = int(pos.get("entry_stage") or 1)
     if entry_stage >= 3:
         return
 
     # ÌòÑÏû¨Í∞Ä Ï°∞Ìöå
     try:
-        cur_price = _safe_get_price(kis, code)
+        cur_price = _safe_get_price(kis, code_key)
     except Exception:
         cur_price = None
     if cur_price is None or cur_price <= 0:
         return
 
     # ÏÜêÏ†àÏÑ† Ïù¥ÌïòÎ©¥ Ï∂îÍ∞Ä ÏßÑÏûÖ Í∏àÏßÄ
     try:
         stop_abs = pos.get("stop_abs")
         if stop_abs is not None and cur_price <= float(stop_abs):
             logger.info(
-                f"[SCALE-IN-GUARD] {code}: ÌòÑÏû¨Í∞Ä({cur_price}) <= stop_abs({stop_abs}) ‚Üí Ï∂îÍ∞Ä ÏßÑÏûÖ Í∏àÏßÄ"
+                f"[SCALE-IN-GUARD] {code_key}: ÌòÑÏû¨Í∞Ä({cur_price}) <= stop_abs({stop_abs}) ‚Üí Ï∂îÍ∞Ä ÏßÑÏûÖ Í∏àÏßÄ"
             )
             return
     except Exception:
         pass
 
     # VWAP Í∞ÄÎìú: Í≥ºÎèÑÌïú Ï∂îÏÑ∏ Î∂ïÍ¥¥ Íµ¨Í∞ÑÏóêÏÑúÎäî Ï∂îÍ∞Ä ÏßÑÏûÖÌïòÏßÄ ÏïäÏùå
     try:
-        vwap_val = kis.get_vwap_today(code)
+        vwap_val = kis.get_vwap_today(code_key)
     except Exception:
         vwap_val = None
     if vwap_val is None or vwap_val <= 0:
-        logger.debug(f"[SCALE-IN-VWAP-SKIP] {code}: VWAP Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå ‚Üí VWAP Í∞ÄÎìú ÏÉùÎûµ")
+        logger.debug(f"[SCALE-IN-VWAP-SKIP] {code_key}: VWAP Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå ‚Üí VWAP Í∞ÄÎìú ÏÉùÎûµ")
     else:
         if not vwap_guard(float(cur_price), float(vwap_val), VWAP_TOL):
             logger.info(
-                f"[SCALE-IN-VWAP-GUARD] {code}: ÌòÑÏû¨Í∞Ä({cur_price}) < VWAP*(1 - {VWAP_TOL:.4f}) "
+                f"[SCALE-IN-VWAP-GUARD] {code_key}: ÌòÑÏû¨Í∞Ä({cur_price}) < VWAP*(1 - {VWAP_TOL:.4f}) "
                 f"‚Üí ÎàåÎ¶ºÎ™© Ï∂îÍ∞Ä ÏßÑÏûÖ Ïä§ÌÇµ (VWAP={vwap_val:.2f})"
             )
             return
 
     # Í≥ÑÌöç ÏàòÎüâ Í≥ÑÏÇ∞
     planned_total_qty = int(
         pos.get("planned_total_qty")
         or _to_int(target.get("Îß§ÏàòÏàòÎüâ") or target.get("qty"), 0)
     )
     if planned_total_qty <= 0:
         return
 
     # Ïä§ÌÖåÏù¥ÏßÄÎ≥Ñ Î™©Ìëú ÏàòÎüâ(Î∂ÄÏ°± Ïãú Ïû¨Í≥ÑÏÇ∞)
     s1 = int(pos.get("stage1_qty") or max(1, int(planned_total_qty * ENTRY_LADDERS[0])))
     s2 = int(pos.get("stage2_qty") or max(0, int(planned_total_qty * ENTRY_LADDERS[1])))
     s3 = int(pos.get("stage3_qty") or max(0, planned_total_qty - s1 - s2))
 
     pos["planned_total_qty"] = int(planned_total_qty)
     pos["stage1_qty"] = int(s1)
     pos["stage2_qty"] = int(s2)
     pos["stage3_qty"] = int(s3)
 
     current_qty = int(pos.get("qty") or 0)
     if current_qty <= 0:
         return
 
     # Ïã†Í≥†Í∞Ä ‚Üí 3Ïùº ÎàåÎ¶º ‚Üí Î∞òÎì± Ïó¨Î∂Ä ÌôïÏù∏
     pullback = _detect_pullback_reversal(
         kis=kis,
-        code=code,
+        code=code_key,
         current_price=float(cur_price),
     )
     if USE_PULLBACK_ENTRY and not pullback.get("setup"):
         logger.info(
-            f"[PULLBACK-SKIP] {code}: Ïã†Í≥†Í∞Ä ÎàåÎ¶º Ìå®ÌÑ¥ ÎØ∏Ï∂©Ï°± ‚Üí reason={pullback.get('reason')}"
+            f"[PULLBACK-SKIP] {code_key}: Ïã†Í≥†Í∞Ä ÎàåÎ¶º Ìå®ÌÑ¥ ÎØ∏Ï∂©Ï°± ‚Üí reason={pullback.get('reason')}"
         )
         return
 
     if USE_PULLBACK_ENTRY and not pullback.get("reversing"):
         rev_px = pullback.get("reversal_price")
         logger.info(
-            f"[PULLBACK-WAIT] {code}: ÌòÑÏû¨Í∞Ä({cur_price}) < Î∞òÎì±ÌôïÏù∏ÏÑ†({rev_px}) ‚Üí ÎåÄÍ∏∞"
+            f"[PULLBACK-WAIT] {code_key}: ÌòÑÏû¨Í∞Ä({cur_price}) < Î∞òÎì±ÌôïÏù∏ÏÑ†({rev_px}) ‚Üí ÎåÄÍ∏∞"
         )
         return
 
     reversal_price = pullback.get("reversal_price") or float(cur_price)
     peak_price = pullback.get("peak_price") or reversal_price
 
     # Ï∞∏Í≥†Ïö© ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
     pos["pullback_peak_price"] = float(peak_price)
     pos["pullback_reversal_price"] = float(reversal_price)
     if position_state is not None:
         update_position_meta(
             position_state,
-            code,
+            code_key,
             pos.get("strategy_id") or 1,
             {
                 "pullback_peak_price": float(peak_price),
                 "pullback_reversal_price": float(reversal_price),
                 "pullback_reason": pullback.get("reason"),
             },
         )
 
     add_qty = 0
     next_stage = entry_stage
 
     if entry_stage == 1:
         # 2Ï∞® ÏßÑÏûÖ: 3Ïùº ÎàåÎ¶º ÌõÑ Î∞òÎì± ÌôïÏù∏ÏÑ† ÎèåÌåå ‚Üí s1+s2ÍπåÏßÄ ÌôïÎåÄ
         if cur_price >= reversal_price and current_qty < (s1 + s2):
             add_qty = max(0, (s1 + s2) - current_qty)
             next_stage = 2
     elif entry_stage == 2:
         # 3Ï∞® ÏßÑÏûÖ: Ïã†Í≥†Í∞Ä ÌöåÎ≥µ(peak_price ÎèåÌåå) Ïãú Ï†ÑÏ≤¥ planned_total_qtyÍπåÏßÄ ÌôïÎåÄ
         if cur_price >= peak_price and current_qty < planned_total_qty:
             add_qty = max(0, planned_total_qty - current_qty)
             next_stage = 3
     else:
         return
 
     if add_qty <= 0:
@@ -527,122 +552,124 @@ def _maybe_scale_in_dips(
     holding[code] = pos
 
     # Îß§Ïàò Î°úÍ∑∏ Í∏∞Î°ù
     try:
         log_trade(
             {
                 "datetime": now_str,
                 "code": code,
                 "name": target.get("name") or target.get("Ï¢ÖÎ™©Î™Ö"),
                 "qty": int(add_qty),
                 "K": pos.get("k_value"),
                 "target_price": pos.get("target_price_src"),
                 "strategy": "ÎàåÎ¶ºÎ™© 3Îã®Í≥Ñ ÏßÑÏûÖ",
                 "side": "BUY",
                 "price": float(cur_price),
                 "amount": int(float(cur_price)) * int(add_qty),
                 "result": result,
                 "reason": f"scale_in_stage_{entry_stage}_to_{next_stage}",
             }
         )
     except Exception as e:
         logger.warning(f"[SCALE-IN-LOG-FAIL] {code}: {e}")
 
 
 def _sell_once(kis: KisAPI, code: str, qty: int, prefer_market=True) -> Tuple[Optional[float], Any]:
+    code = normalize_code(code)
     cur_price = _safe_get_price(kis, code)
     try:
         if prefer_market and hasattr(kis, "sell_stock_market"):
             result = _with_retry(kis.sell_stock_market, code, qty)
         else:
             result = _with_retry(kis.sell_stock, code, qty)
     except Exception as e:
         logger.warning(f"[Îß§ÎèÑ Ïû¨ÏãúÎèÑ: ÌÜ†ÌÅ∞ Í∞±Ïã† ÌõÑ 1Ìöå] {code} qty={qty} err={e}")
         try:
             if hasattr(kis, "refresh_token"):
                 kis.refresh_token()
         except Exception:
             pass
         if prefer_market and hasattr(kis, "sell_stock_market"):
             result = _with_retry(kis.sell_stock_market, code, qty)
         else:
             result = _with_retry(kis.sell_stock, code, qty)
     logger.info(f"[Îß§ÎèÑÌò∏Ï∂ú] {code}, qty={qty}, price(log)={cur_price}, result={result}")
     return cur_price, result
 
 def ensure_fill_has_name(odno: str, code: str, name: str, qty: int = 0, price: float = 0.0) -> None:
+    code = normalize_code(code)
     try:
         fills_dir = Path("fills")
         fills_dir.mkdir(exist_ok=True)
         today_path = fills_dir / f"fills_{datetime.now().strftime('%Y%m%d')}.csv"
         updated = False
         if today_path.exists():
             with open(today_path, "r", encoding="utf-8", newline="") as f:
                 reader = list(csv.reader(f))
             if reader:
                 header = reader[0]
                 try:
                     idx_odno = header.index("ODNO")
                     idx_code = header.index("code")
                     idx_name = header.index("name")
                 except ValueError:
                     idx_odno = None
                     idx_code = None
                     idx_name = None
                 if idx_odno is not None and idx_name is not None and idx_code is not None:
                     for i in range(1, len(reader)):
                         row = reader[i]
                         if len(row) <= max(idx_odno, idx_code, idx_name):
                             continue
                         if (row[idx_odno] == str(odno) or (not row[idx_odno] and str(odno) == "")) and row[idx_code] == str(code):
                             if not row[idx_name]:
                                 row[idx_name] = name or ""
                                 reader[i] = row
                                 updated = True
                                 logger.info(f"[FILL_NAME_UPDATE] ODNO={odno} code={code} name={name}")
                                 break
         if updated:
             with open(today_path, "w", encoding="utf-8", newline="") as f:
                 writer = csv.writer(f)
                 writer.writerows(reader)
             return
         append_fill(
             "BUY",
             code,
             name or "",
             qty,
             price or 0.0,
             odno or "",
             note="ensure_fill_added_by_trader",
             reason="ensure_fill_name",
         )
     except Exception as e:
         logger.warning(f"[ENSURE_FILL_FAIL] odno={odno} code={code} ex={e}")
 
 # === ÏïµÏª§: Î™©ÌëúÍ∞Ä Í≥ÑÏÇ∞ Ìï®Ïàò ===
 def compute_entry_target(kis: KisAPI, stk: Dict[str, Any]) -> Tuple[Optional[float], Optional[float]]:
-    code = str(stk.get("code") or stk.get("stock_code") or stk.get("pdno") or "")
+    code = normalize_code(stk.get("code") or stk.get("stock_code") or stk.get("pdno") or "")
     if not code:
         return None, None
 
     try:
         market_open = kis.is_market_open()
     except Exception:
         market_open = True
 
     # 1) Ïò§Îäò ÏãúÏ¥àÍ∞Ä
     today_open = None
     try:
         today_open = kis.get_today_open(code)
     except Exception:
         pass
     if not today_open or today_open <= 0:
         try:
             snap = kis.get_current_price(code)
             if snap and snap > 0:
                 today_open = float(snap)
         except Exception:
             pass
     if not today_open or today_open <= 0:
         logger.info(f"[TARGET/wait_open] {code} Ïò§Îäò ÏãúÏ¥àÍ∞Ä ÎØ∏ÌôïÏ†ï ‚Üí Î™©ÌëúÍ∞Ä Í≥ÑÏÇ∞ Î≥¥Î•ò")
         return None, None
 
@@ -664,50 +691,51 @@ def compute_entry_target(kis: KisAPI, stk: Dict[str, Any]) -> Tuple[Optional[flo
             if prev_candles and len(prev_candles) >= 2:
                 prev = prev_candles[-2]
                 prev_high = _to_float(prev.get("high"))
                 prev_low  = _to_float(prev.get("low"))
         except Exception:
             pass
 
     if prev_high is None or prev_low is None:
         prev_high = _to_float(stk.get("prev_high"))
         prev_low  = _to_float(stk.get("prev_low"))
         if prev_high is None or prev_low is None:
             logger.warning(f"[TARGET/prev_candle_fail] {code} Ï†ÑÏùº Ï∫îÎì§/Î∞±ÏóÖ Î™®Îëê Î∂ÄÏû¨")
             return None, None
 
     rng = max(0.0, float(prev_high) - float(prev_low))
     k_used = float(stk.get("best_k") or stk.get("K") or stk.get("k") or 0.5)
     raw_target = float(today_open) + rng * k_used
 
     eff_target_price = float(_round_to_tick(raw_target, mode="up"))
     return float(eff_target_price), float(k_used)
 
 def place_buy_with_fallback(kis: KisAPI, code: str, qty: int, limit_price: int) -> Dict[str, Any]:
     """
     Îß§Ïàò Ï£ºÎ¨∏(ÏßÄÏ†ïÍ∞Ä Ïö∞ÏÑ†, Ïã§Ìå®Ïãú ÏãúÏû•Í∞Ä Fallback) + Ï≤¥Í≤∞Í∞Ä/Ïä¨Î¶¨ÌîºÏßÄ/ÎÑ§Ìä∏ÏõåÌÅ¨ Ïû•Ïï†/Ïã§Ìå® ÏÉÅÏÑ∏ Î°úÍπÖ
     """
+    code = normalize_code(code)
     result_limit: Optional[Dict[str, Any]] = None
     order_price = _round_to_tick(limit_price, mode="up") if (limit_price and limit_price > 0) else 0
     fill_price = None
     trade_logged = False
 
     try:
         # [PATCH] ÏòàÏàòÍ∏à/Í≥ºÎß§Ïàò Î∞©ÏßÄ: Í∞ÄÎìúÌòï ÏßÄÏ†ïÍ∞Ä ÏÇ¨Ïö©
         if hasattr(kis, "buy_stock_limit_guarded") and order_price and order_price > 0:  # [PATCH]
             result_limit = _with_retry(kis.buy_stock_limit_guarded, code, qty, int(order_price))  # [PATCH]
             logger.info("[BUY-LIMIT] %s qty=%s limit=%s -> %s", code, qty, order_price, result_limit)
             time.sleep(2.0)
             filled = False
             if hasattr(kis, "check_filled"):
                 try:
                     filled = bool(_with_retry(kis.check_filled, result_limit))
                 except Exception:
                     filled = False
             if filled:
                 try:
                     fill_price = float(result_limit.get("output", {}).get("prdt_price", 0)) or None
                 except Exception:
                     fill_price = None
                 if fill_price is None:
                     try:
                         fill_price = kis.get_current_price(code)
diff --git a/trader/exit_allocation.py b/trader/exit_allocation.py
index 965183cc2efc541a0670913c0f77ff71e94bd3e9..bf008ab8b4954409dc15e3b50374de59bb4cbc2f 100644
--- a/trader/exit_allocation.py
+++ b/trader/exit_allocation.py
@@ -1,102 +1,103 @@
 from __future__ import annotations
 
 from typing import Any, Dict, List, Optional
 
+from trader.code_utils import normalize_code
 from trader.ledger import apply_sell_fill_fifo, dominant_strategy_for
 
 def _strategy_qty_map(lot_state: Dict[str, Any], code: str) -> Dict[str, int]:
     lots = lot_state.get("lots", [])
-    code_key = str(code).zfill(6)
+    code_key = normalize_code(code)
     totals: Dict[str, int] = {}
     if not isinstance(lots, list):
         return totals
     for lot in lots:
-        if str(lot.get("pdno") or "").zfill(6) != code_key:
+        if normalize_code(lot.get("pdno")) != code_key:
             continue
         remaining = int(lot.get("remaining_qty") or 0)
         if remaining <= 0:
             continue
         sid = lot.get("strategy_id")
         if sid is None:
             continue
         sid_key = str(sid)
         totals[sid_key] = totals.get(sid_key, 0) + remaining
     return totals
 
 
 def allocate_sell_qty(
     lot_state: Dict[str, Any],
     code: str,
     requested_qty: int,
     *,
     scope: str,
     trigger_strategy_id: Optional[Any] = None,
 ) -> List[Dict[str, Any]]:
-    code = str(code).zfill(6)
+    code = normalize_code(code)
     requested_qty = int(requested_qty)
     if requested_qty <= 0:
         return []
 
     if scope == "strategy":
         if trigger_strategy_id is None:
             return []
         totals = _strategy_qty_map(lot_state, code)
         trigger_key = str(trigger_strategy_id)
         qty = min(requested_qty, int(totals.get(trigger_key, 0)))
         return (
             [{"strategy_id": trigger_key, "qty": int(qty)}]
             if qty > 0
             else []
         )
 
     totals = _strategy_qty_map(lot_state, code)
     if not totals:
         return []
 
     if scope == "dominant":
         dominant = dominant_strategy_for(lot_state, code)
         if dominant is None:
             return []
         dominant_key = str(dominant)
         qty = min(requested_qty, totals.get(dominant_key, 0))
         return [{"strategy_id": dominant_key, "qty": int(qty)}] if qty > 0 else []
 
     if scope == "global":
         totals = _strategy_qty_map(lot_state, code)
         if not totals:
             return []
-        orphan_qty = int(totals.get("ORPHAN", 0))
+        orphan_qty = int(totals.get("MANUAL", 0))
         allocations: List[Dict[str, Any]] = []
         remaining_qty = min(requested_qty, sum(totals.values()))
         if orphan_qty > 0 and remaining_qty > 0:
             take = min(orphan_qty, remaining_qty)
-            allocations.append({"strategy_id": "ORPHAN", "qty": int(take)})
+            allocations.append({"strategy_id": "MANUAL", "qty": int(take)})
             remaining_qty -= take
         if remaining_qty <= 0:
             return allocations
-        non_orphan_totals = {k: v for k, v in totals.items() if k != "ORPHAN"}
+        non_orphan_totals = {k: v for k, v in totals.items() if k != "MANUAL"}
         if not non_orphan_totals:
             return allocations
         total_qty = sum(non_orphan_totals.values())
         remaining_qty = min(remaining_qty, total_qty)
         strategy_ids = sorted(non_orphan_totals.keys())
         for sid in strategy_ids[:-1]:
             ratio_qty = int(remaining_qty * (non_orphan_totals[sid] / total_qty))
             qty = min(ratio_qty, non_orphan_totals[sid], remaining_qty)
             if qty > 0:
                 allocations.append({"strategy_id": sid, "qty": int(qty)})
                 remaining_qty -= qty
         if remaining_qty > 0:
             last_sid = strategy_ids[-1]
             qty = min(remaining_qty, non_orphan_totals[last_sid])
             if qty > 0:
                 allocations.append({"strategy_id": last_sid, "qty": int(qty)})
         return allocations
 
     if scope != "proportional":
         return []
 
     total_qty = sum(totals.values())
     if total_qty <= 0:
         return []
     requested_qty = min(requested_qty, total_qty)
@@ -111,60 +112,60 @@ def allocate_sell_qty(
             remaining -= qty
     if remaining > 0:
         last_sid = strategy_ids[-1]
         qty = min(remaining, totals[last_sid])
         if qty > 0:
             allocations.append({"strategy_id": last_sid, "qty": int(qty)})
     return allocations
 
 
 def apply_sell_allocation(
     lot_state: Dict[str, Any],
     code: str,
     allocations: List[Dict[str, Any]],
     sell_ts: str,
     *,
     allow_blocked: bool = False,
 ) -> int:
     sold_total = 0
     for alloc in allocations:
         qty = int(alloc.get("qty") or 0)
         sid = alloc.get("strategy_id", None)
         if qty <= 0:
             continue
         apply_sell_fill_fifo(
             lot_state,
-            pdno=str(code).zfill(6),
+            pdno=normalize_code(code),
             qty_filled=qty,
             sell_ts=sell_ts,
             strategy_id=sid,
             allow_blocked=allow_blocked,
         )
         sold_total += qty
     return sold_total
 
 
 def run_allocation_self_checks() -> None:
     lot_state = {
         "lots": [
             {"pdno": "000001", "strategy_id": 1, "remaining_qty": 7},
             {"pdno": "000001", "strategy_id": 5, "remaining_qty": 3},
-            {"pdno": "000001", "strategy_id": "ORPHAN", "remaining_qty": 5},
+            {"pdno": "000001", "strategy_id": "MANUAL", "remaining_qty": 5},
         ]
     }
     allocations = allocate_sell_qty(
         lot_state, "000001", 10, scope="proportional", trigger_strategy_id=None
     )
     assert sum(a["qty"] for a in allocations) == 10
     allocations = allocate_sell_qty(
         lot_state, "000001", 5, scope="strategy", trigger_strategy_id=1
     )
     assert allocations and all(a["strategy_id"] == "1" for a in allocations)
     allocations = allocate_sell_qty(
         lot_state, "000001", 10, scope="proportional", trigger_strategy_id=None
     )
     allocated_strategies = {a["strategy_id"] for a in allocations}
-    assert "ORPHAN" in allocated_strategies
+    assert "MANUAL" in allocated_strategies
 
 
 if __name__ == "__main__":
     run_allocation_self_checks()
diff --git a/trader/kis_wrapper.py b/trader/kis_wrapper.py
index 9e1945c0402514e2f285d80bc5cbb4f05221c609..e607bd4565f95c72d48867461b8b7e8216dd6566 100644
--- a/trader/kis_wrapper.py
+++ b/trader/kis_wrapper.py
@@ -6,50 +6,51 @@
 # - ÏûîÍ≥†/Ï£ºÎ¨∏
 # - ‚úÖ ÏòàÏàòÍ∏à: output2.ord_psbl_cash Ïö∞ÏÑ† ÏÇ¨Ïö© (fallback: nrcvb_buy_amt ‚Üí dnca_tot_amt, ÏµúÌõÑ: ÏµúÍ∑º Ï∫êÏãú)
 # - ‚úÖ SSL EOF/JSON Decode Îì± ÏùºÏãú Ïò§Î•ò ÎÇ¥ÏÑ± Í∞ïÌôî
 # - ‚úÖ ÏãúÏÑ∏ 0Ïõê Î∞©ÏßÄ(J‚ÜîU, AÏ†ëÎëê/Î¨¥Ï†ëÎëê ÍµêÏ∞®, ÏßÄÏàò Î∞±Ïò§ÌîÑ Ïû¨ÏãúÎèÑ)
 # - ‚úÖ ÏûîÍ≥† ÌéòÏù¥Ïßï(ctx_area_*) , empty ÏàúÍ∞ÑÏùëÎãµ ÎîîÎ∞îÏö¥Ïä§
 # - ‚úÖ [NEW] ÏÑ∏ÏÖò Î¶¨ÏÖã/ÏßÄÏàòÌòï Î∞±Ïò§ÌîÑÎ•º Ìè¨Ìï®Ìïú ÏïàÏ†ÑÏöîÏ≤≠(_safe_request), Ï≤¥Í≤∞ ÌõÑ ÏûîÍ≥† ÎèôÍ∏∞Ìôî(refresh_after_order)
 
 import os
 import json
 import time
 import random
 import logging
 import threading
 from datetime import datetime, timedelta
 from typing import Dict, List, Optional, Tuple, Any
 
 import requests
 import pytz
 from requests.adapters import HTTPAdapter
 from urllib3.util.retry import Retry
 
 from settings import APP_KEY, APP_SECRET, API_BASE_URL, CANO, ACNT_PRDT_CD, KIS_ENV
 from trader.time_utils import is_trading_day, is_trading_window, now_kst
 from trader.config import MARKET_MAP, SUBJECT_FLOW_TIMEOUT_SEC, SUBJECT_FLOW_RETRY
 from trader.fills import append_fill
+from trader.code_utils import normalize_code
 
 logger = logging.getLogger(__name__)
 _ORDER_BLOCK_STATE: Dict[str, Any] = {"date": None, "reason": None}
 
 
 class NetTemporaryError(Exception):
     """ÎÑ§Ìä∏ÏõåÌÅ¨/SSL Îì± ÏùºÏãúÏ†Å Ïò§Î•òÎ•º ÏùòÎØ∏ (Ï†úÏô∏ Í∏àÏßÄ, Î£®ÌîÑ Ïä§ÌÇµ)."""
     pass
 
 
 class DataEmptyError(Exception):
     """Ï†ïÏÉÅÏùëÎãµÏù¥ÎÇò Ï∫îÎì§Ïù¥ 0Í∞ú (Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå)."""
     pass
 
 
 class DataShortError(Exception):
     """Ï†ïÏÉÅÏùëÎãµÏù¥ÎÇò Ï∫îÎì§Ïù¥ need_n ÎØ∏Îßå."""
     pass
 
 
 def _build_session():
     s = requests.Session()
     retry = Retry(
         total=6, connect=5, read=5, status=3,
         backoff_factor=0.6,
@@ -531,93 +532,97 @@ class KisAPI:
                         # [CHG] ÏïàÏ†ÑÏöîÏ≤≠ ÏÇ¨Ïö©
                         resp = self._safe_request("GET", url, headers=headers, params=params, timeout=(3.0, 5.0))
                         data = resp.json()
                     except Exception:
                         continue
                     if "Ï¥àÎãπ Í±∞ÎûòÍ±¥Ïàò" in (data.get("msg1") or ""):
                         time.sleep(0.35 + random.uniform(0, 0.15))
                         continue
                     if resp.status_code == 200 and data.get("rt_cd") == "0" and data.get("output"):
                         op_str = data["output"].get("stck_oprc")
                         try:
                             op = float(op_str) if op_str is not None else 0.0
                             if op > 0:
                                 self._set_cached_today_open(code, op)
                                 return op
                         except Exception:
                             pass
         return None
 
     def get_orderbook_strength(self, code: str) -> Optional[float]:
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-askprice"
         self._limiter.wait("orderbook")
         for tr in _pick_tr(self.env, "ORDERBOOK"):
             headers = self._headers(tr)
             markets = ["J", "U"]
-            c = code.strip()
+            c = normalize_code(code)
+            if not c:
+                return None
             codes = [c, f"A{c}"] if not c.startswith("A") else [c, c[1:]]
             for market_div in markets:
                 for code_fmt in codes:
                     params = {"fid_cond_mrkt_div_code": market_div, "fid_input_iscd": code_fmt}
                     try:
                         # [CHG] ÏïàÏ†ÑÏöîÏ≤≠ ÏÇ¨Ïö©
                         resp = self._safe_request("GET", url, headers=headers, params=params, timeout=(3.0, 5.0))
                         data = resp.json()
                     except Exception:
                         continue
                     if resp.status_code == 200 and data.get("rt_cd") == "0" and data.get("output"):
                         out = data["output"]
                         bid = sum(float(out.get(f"bidp_rsqn{i}") or 0) for i in range(1, 6))
                         ask = sum(float(out.get(f"askp_rsqn{i}") or 0) for i in range(1, 6))
                         if (bid + ask) > 0:
                             return 100.0 * bid / max(1.0, ask)
         return None
 
     # === ÏùºÎ¥â ===
     def get_daily_candles(self, code: str, count: int = 30) -> List[Dict[str, Any]]:
         """
         KIS ÏùºÎ¥â Ï°∞Ìöå (FHKST03010100)
         - ÎÇ†Ïßú ÌååÎùºÎØ∏ÌÑ∞(fid_input_date_1, fid_input_date_2) ÌïÑÏàò
         - ÏãúÏû•ÏΩîÎìú J Í≥†Ï†ï
         - Ï¢ÖÎ™©ÏΩîÎìú 'A' Ï†ëÎëêÏÇ¨ Ï†úÍ±∞(6ÏûêÎ¶¨)
         - 0Í∞ú ‚Üí DataEmptyError, 21Í∞ú ÎØ∏Îßå ‚Üí DataShortError, ÎÑ§Ìä∏ÏõåÌÅ¨/Í≤åÏù¥Ìä∏Ïõ®Ïù¥ ‚Üí NetTemporaryError
         """
         # ---- (A) .env Ï†êÍ≤Ä: DAILY_CAPITAL ÎØ∏ÏÑ§Ï†ï Í≤ΩÍ≥† (Ìï®Ïàò ÏµúÏ¥à 1ÌöåÎßå) ----
         try:
             if not getattr(self, "_env_checked_daily_capital", False):
                 if os.getenv("DAILY_CAPITAL") in (None, ""):
                     logger.warning(
                         "[ENV] DAILY_CAPITAL Ïù¥ .envÏóê ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. "
                         "settingsÏùò Í∏∞Î≥∏Í∞í(10,000,000)Ïù¥ ÏÇ¨Ïö©Îê† Ïàò ÏûàÏäµÎãàÎã§."
                     )
                 self._env_checked_daily_capital = True
         except Exception:
             pass
 
         # ---- (1) ÌååÎùºÎØ∏ÌÑ∞ Íµ¨ÏÑ± ----
         market_code = "J"                         # ÏãúÏû•ÏΩîÎìú: J Í≥†Ï†ï
-        iscd = code.strip().lstrip("A")          # Ï¢ÖÎ™©ÏΩîÎìú: 'A' Ï†úÍ±∞(6ÏûêÎ¶¨)
+        iscd = normalize_code(code)              # Ï¢ÖÎ™©ÏΩîÎìú: 'A' Ï†úÍ±∞(6ÏûêÎ¶¨)
+        if not iscd:
+            raise ValueError("invalid code for daily candles")
 
         # Í∏∞Í∞Ñ: Ï∂©Î∂ÑÌûà ÎÑâÎÑâÌïòÍ≤å(Ìú¥Ïû•/Í≤∞Ï∏° ÎåÄÎπÑ)
         kst = pytz.timezone("Asia/Seoul")
         now_kst = datetime.now(kst)
         to_ymd = now_kst.strftime("%Y%m%d")
         back_days = max(200, count * 4 + 100)
         from_ymd = (now_kst - timedelta(days=back_days)).strftime("%Y%m%d")
 
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-daily-itemchartprice"
         self._limiter.wait("daily")
 
         last_err = None
 
         for tr in _pick_tr(self.env, "DAILY_CHART"):   # TR ÌõÑÎ≥¥Î•º ÏàúÏ∞®Ï†ÅÏúºÎ°ú ÏãúÎèÑ
             headers = self._headers(tr)
             headers.setdefault("accept", "*/*")
             headers.setdefault("tr_cont", "N")
             headers.setdefault("Connection", "keep-alive")
 
             params = {
                 "fid_cond_mrkt_div_code": market_code,  # Î∞òÎìúÏãú 'J'
                 "fid_input_iscd": iscd,                 # 'A' ÏóÜÏù¥ 6ÏûêÎ¶¨
                 "fid_input_date_1": from_ymd,           # ÏãúÏûëÏùº(YYYYMMDD)
                 "fid_input_date_2": to_ymd,             # Ï¢ÖÎ£åÏùº(YYYYMMDD)
                 "fid_org_adj_prc": "0",
@@ -680,51 +685,51 @@ class KisAPI:
                         except Exception as e:
                             logger.debug("[DAILY_ROW_SKIP] %s rec=%s err=%s", iscd, r, e)
 
                     rows.sort(key=lambda x: x["date"])
 
                     if len(rows) == 0:
                         raise DataEmptyError(f"A{iscd} 0 candles")
                     if len(rows) < 21:
                         raise DataShortError(f"A{iscd} {len(rows)} candles (<21)")
 
                     need = max(count, 21)
                     return rows[-need:][-count:]
 
                 last_err = RuntimeError(
                     f"BAD_RESP rt_cd={data.get('rt_cd')} msg={data.get('msg1')} arr=None"
                 )
                 logger.warning("[DAILY_FAIL] A%s: %s | raw=%s", iscd, last_err, data)
                 time.sleep(0.35 + random.uniform(0, 0.15))
 
         if last_err:
             logger.warning("[DAILY_FAIL] A%s: %s", iscd, last_err)
         raise NetTemporaryError(f"DAILY A{iscd} net fail")
 
     def inquire_investor(self, code: str, market: str = "KOSDAQ") -> dict:
         """Ï£ºÏ≤¥ÏàòÍ∏â Ï°∞Ìöå(inquire-investor) ‚Äî Ïã§Ìå® ÏãúÏóêÎèÑ ÏòàÏô∏Î•º ÎçòÏßÄÏßÄ ÏïäÎäîÎã§."""
-        iscd = code.strip().lstrip("A")
+        iscd = normalize_code(code)
         # FID_COND_MRKT_DIV_CODEÎäî ÏãúÏû•(KOSPI/KOSDAQ) ÏΩîÎìúÍ∞Ä ÏïÑÎãàÎùº ÏÉÅÌíàÍµ∞ ÏΩîÎìú(J=Ï£ºÏãù/ETF/ETN, W=ELW Îì±)Î°ú
         # Ïì∞Ïù¥Îäî ÏÇ¨Î°ÄÍ∞Ä ÎßéÎã§. Ï£ºÏãù/ETF/ETN Í∏∞Î≥∏Í∞í "J"Î•º ÏÇ¨Ïö©ÌïòÍ≥†, Îß§ÌïëÏóê WÍ∞Ä Î™ÖÏãúÎêú Í≤ΩÏö∞ÏóêÎßå WÎ°ú Ï†ÑÏÜ°ÌïúÎã§.
         mapped = MARKET_MAP.get(iscd)
         market_code = mapped if mapped in ("J", "W") else "J"
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-investor"
         headers = self._headers("FHKST01010900")
         params = {"FID_COND_MRKT_DIV_CODE": market_code, "FID_INPUT_ISCD": iscd}
 
         def _safe_num(val: Any) -> int:
             try:
                 if val is None:
                     return 0
                 if isinstance(val, (int, float)):
                     return int(val)
                 return int(str(val).replace(",", ""))
             except Exception:
                 return 0
 
         attempts = max(1, int(SUBJECT_FLOW_RETRY) + 1)
         timeout = (SUBJECT_FLOW_TIMEOUT_SEC, SUBJECT_FLOW_TIMEOUT_SEC + 0.5)
 
         for attempt in range(1, attempts + 1):
             try:
                 self._limiter.wait("investor")
                 resp = self._safe_request(
@@ -765,51 +770,53 @@ class KisAPI:
             if len(candles) < window + 1:
                 return None
             trs: List[float] = []
             for i in range(1, len(candles)):
                 h = candles[i]["high"]
                 l = candles[i]["low"]
                 c_prev = candles[i - 1]["close"]
                 tr = max(h - l, abs(h - c_prev), abs(l - c_prev))
                 trs.append(tr)
             if not trs:
                 return None
             return sum(trs[-window:]) / float(window)
         except Exception as e:
             logger.warning(f"[ATR] Í≥ÑÏÇ∞ Ïã§Ìå® code={code}: {e}")
             return None
 
     def get_intraday_candles_today(self, code: str, start_hhmm: str = "090000") -> List[Dict[str, Any]]:
         """KIS Ï£ºÏãùÎãπÏùºÎ∂ÑÎ¥âÏ°∞Ìöå (FHKST03010200 / inquire-time-itemchartprice)
         - FID_COND_MRKT_DIV_CODE: 'J'
         - FID_INPUT_ISCD: 6ÏûêÎ¶¨ Ï¢ÖÎ™©ÏΩîÎìú('A' Ï†úÍ±∞)
         - FID_INPUT_HOUR_1: ÏãúÏûë ÏãúÍ∞Ñ(HHMMSS), Ïòà: '090000'
         - FID_PW_DATA_INCU_YN: 'Y'
         - FID_ETC_CLS_CODE: ''
         """
         market_code = "J"
-        iscd = code.strip().lstrip("A")
+        iscd = normalize_code(code)
+        if not iscd:
+            return []
 
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-time-itemchartprice"
         self._limiter.wait("intraday")
 
         last_err = None
 
         for tr in _pick_tr(self.env, "INTRADAY_CHART"):
             headers = self._headers(tr)
             headers.setdefault("accept", "*/*")
             headers.setdefault("tr_cont", "N")
             headers.setdefault("Connection", "keep-alive")
 
             params = {
                 "fid_cond_mrkt_div_code": market_code,
                 "fid_input_iscd": iscd,
                 "fid_input_hour_1": start_hhmm,
                 "fid_pw_data_incu_yn": "Y",
                 "fid_etc_cls_code": "",
             }
 
             for attempt in range(1, 4):
                 try:
                     resp = self._safe_request(
                         "GET", url, headers=headers, params=params, timeout=(3.0, 7.0)
                     )
@@ -1290,114 +1297,117 @@ class KisAPI:
                     # Í≤åÏù¥Ìä∏Ïõ®Ïù¥/ÏÑúÎ≤Ñ ÏóêÎü¨Î•òÎäî Ïû¨ÏãúÎèÑ
                     if msg_cd == "IGW00008" or "MCA" in msg1 or resp.status_code >= 500:
                         backoff = min(0.6 * (1.7 ** (attempt - 1)), 5.0) + random.uniform(0, 0.35)
                         logger.error(
                             f"[ORDER_FAIL_GATEWAY] tr_id={tr_id} ord_dvsn={ord_dvsn} attempt={attempt} "
                             f"resp={data} ‚Üí sleep {backoff:.2f}s"
                         )
                         time.sleep(backoff)
                         last_err = data
                         continue
 
                     logger.error(f"[ORDER_FAIL_BIZ] tr_id={tr_id} ord_dvsn={ord_dvsn} resp={data}")
                     blocked = _is_order_disallowed(data)
                     if blocked:
                         _mark_order_blocked(blocked, now)
                     return None
 
                 logger.warning(f"[ORDER_FALLBACK] tr_id={tr_id} ord_dvsn={ord_dvsn} Ïã§Ìå® ‚Üí Îã§Ïùå Î∞©Ïãù ÏãúÎèÑ")
 
         raise Exception(f"Ï£ºÎ¨∏ Ïã§Ìå®: {last_err}")
 
     # -------------------------------
     # Îß§Ïàò/Îß§ÎèÑ (Í∏∞Î≥∏)
     # -------------------------------
     def buy_stock_market(self, pdno: str, qty: int) -> Optional[dict]:
+        pdno = normalize_code(pdno)
         body = {
             "CANO": self.CANO,
             "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
             "PDNO": safe_strip(pdno),
             "ORD_QTY": str(int(qty)),
             "ORD_DVSN": "01",  # ÏãúÏû•Í∞Ä
             "ORD_UNPR": "0",
         }
         return self._order_cash(body, is_sell=False)
 
     def sell_stock_market(self, pdno: str, qty: int) -> Optional[dict]:
+        pdno = normalize_code(pdno)
         # --- Í∞ïÌôîÎêú ÏÇ¨Ï†ÑÏ†êÍ≤Ä: Î≥¥Ïú†ÏàòÎüâ Ïö∞ÏÑ† ---
         pos = self.get_positions() or []
         hldg = 0
         ord_psbl = 0
         for r in pos:
-            if safe_strip(r.get("pdno")) == safe_strip(pdno):
+            if normalize_code(r.get("pdno")) == pdno:
                 hldg = int(float(r.get("hldg_qty", "0")))
                 ord_psbl = int(float(r.get("ord_psbl_qty", "0")))
                 break
 
         base_qty = hldg if hldg > 0 else ord_psbl
         if base_qty <= 0:
             logger.error(f"[SELL_PRECHECK] Î≥¥Ïú† ÏóÜÏùå/ÏàòÎüâ 0 pdno={pdno} hldg={hldg} ord_psbl={ord_psbl}")
             return None
 
         if qty > base_qty:
             logger.warning(
                 f"[SELL_PRECHECK] ÏàòÎüâ Î≥¥Ï†ï: req={qty} -> base={base_qty} (hldg={hldg}, ord_psbl={ord_psbl})"
             )
             qty = base_qty
 
         # --- Ï§ëÎ≥µ Îß§ÎèÑ Î∞©ÏßÄ(Î©îÎ™®Î¶¨ Í∏∞Î∞ò) ---
         now_ts = time.time()
         with self._recent_sells_lock:
             last = self._recent_sells.get(pdno)
             if last and (now_ts - last) < self._recent_sells_cooldown:
                 logger.warning(
                     f"[SELL_DUP_BLOCK] ÏµúÍ∑º Îß§ÎèÑ Í∏∞Î°ùÏúºÎ°ú Ï§ëÎ≥µ Îß§ÎèÑ Ï∞®Îã® pdno={pdno} "
                     f"last={last} age={now_ts-last:.1f}s"
                 )
                 return {"status": "SKIPPED", "skip_reason": "DUP_BLOCK"}
 
         body = {
             "CANO": self.CANO,
             "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
             "PDNO": safe_strip(pdno),
             "SLL_TYPE": "01",  # ÏùºÎ∞òÎß§ÎèÑ
             "ORD_QTY": str(int(qty)),
             "ORD_DVSN": "01",
             "ORD_UNPR": "0",
             "EXCG_ID_DVSN_CD": "KRX",
         }
         resp = self._order_cash(body, is_sell=True)
         if resp and isinstance(resp, dict) and resp.get("rt_cd") == "0":
             with self._recent_sells_lock:
                 self._recent_sells[pdno] = time.time()
                 cutoff = time.time() - (self._recent_sells_cooldown * 5)
                 keys_to_del = [k for k, v in self._recent_sells.items() if v < cutoff]
                 for k in keys_to_del:
                     del self._recent_sells[k]
         return resp
 
     def buy_stock_limit(self, pdno: str, qty: int, price: int) -> Optional[dict]:
+        pdno = normalize_code(pdno)
         now = now_kst()
         block_reason = _order_block_reason(now)
         if block_reason:
             logger.warning("[ORDER_BLOCK] %s code=%s qty=%s", block_reason, pdno, qty)
             return {"rt_cd": "1", "msg_cd": "ORDER_BLOCK", "msg1": block_reason, "output": {}}
 
         body = {
             "CANO": self.CANO,
             "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
             "PDNO": safe_strip(pdno),
             "ORD_QTY": str(int(qty)),
             "ORD_DVSN": "00",  # ÏßÄÏ†ïÍ∞Ä
             "ORD_UNPR": str(int(price)),
             "EXCG_ID_DVSN_CD": "KRX",
         }
         hk = self._create_hashkey(body)
         tr_list = _pick_tr(self.env, "ORDER_BUY")
         if not tr_list:
             raise Exception("ORDER_BUY TR ÎØ∏Íµ¨ÏÑ±")
         tr_id = tr_list[0]
         headers = self._headers(tr_id, hk)
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/order-cash"
         # [CHG] ÏïàÏ†ÑÏöîÏ≤≠ ÏÇ¨Ïö©
         resp = self._safe_request(
             "POST", url, headers=headers, data=_json_dumps(body).encode("utf-8"), timeout=(3.0, 7.0)
@@ -1408,50 +1418,51 @@ class KisAPI:
             try:
                 out = data.get("output") or {}
                 odno = out.get("ODNO") or out.get("ord_no") or ""
                 pdno = safe_strip(body.get("PDNO", ""))
                 qty_int = int(float(body.get("ORD_QTY", "0")))
                 price_for_fill = float(body.get("ORD_UNPR", 0))
                 append_fill(
                     side="BUY",
                     code=pdno,
                     name="",
                     qty=qty_int,
                     price=price_for_fill,
                     odno=odno,
                     note=f"limit,tr={tr_id}",
                 )
             except Exception as e:
                 logger.warning(f"[APPEND_FILL_LIMIT_BUY_FAIL] ex={e}")
             return data
         logger.error(f"[BUY_LIMIT_FAIL] {data}")
         blocked = _is_order_disallowed(data)
         if blocked:
             _mark_order_blocked(blocked, now)
         return None
 
     def sell_stock_limit(self, pdno: str, qty: int, price: int) -> Optional[dict]:
+        pdno = normalize_code(pdno)
         now = now_kst()
         block_reason = _order_block_reason(now)
         if block_reason:
             logger.warning("[ORDER_BLOCK] %s code=%s qty=%s", block_reason, pdno, qty)
             return {"rt_cd": "1", "msg_cd": "ORDER_BLOCK", "msg1": block_reason, "output": {}}
 
         # --- Í∞ïÌôîÎêú ÏÇ¨Ï†ÑÏ†êÍ≤Ä: Î≥¥Ïú†ÏàòÎüâ Ïö∞ÏÑ† ---
         pos = self.get_positions() or []
         hldg = 0
         ord_psbl = 0
         for r in pos:
             if safe_strip(r.get("pdno")) == safe_strip(pdno):
                 hldg = int(float(r.get("hldg_qty", "0")))
                 ord_psbl = int(float(r.get("ord_psbl_qty", "0")))
                 break
 
         base_qty = hldg if hldg > 0 else ord_psbl
         if base_qty <= 0:
             logger.error(
                 f"[SELL_LIMIT_PRECHECK] Î≥¥Ïú† ÏóÜÏùå/ÏàòÎüâ 0 pdno={pdno} hldg={hldg} ord_psbl={ord_psbl}"
             )
             return None
 
         if qty > base_qty:
             logger.warning(
@@ -1508,130 +1519,134 @@ class KisAPI:
                     qty=qty_int,
                     price=price_for_fill,
                     odno=odno,
                     note=f"limit,tr={tr_id}",
                     reason="sell_limit",
                 )
             except Exception as e:
                 logger.warning(f"[APPEND_FILL_LIMIT_SELL_FAIL] ex={e}")
             with self._recent_sells_lock:
                 self._recent_sells[pdno] = time.time()
             return data
         logger.error(f"[SELL_LIMIT_FAIL] {data}")
         blocked = _is_order_disallowed(data)
         if blocked:
             _mark_order_blocked(blocked, now)
         return None
 
     # -------------------------------
     # Îß§Ïàò/Îß§ÎèÑ (Ïã†Í∑ú Í∞ÄÎìú ÏÇ¨Ïö© Î≤ÑÏ†Ñ)
     # -------------------------------
     def buy_stock_limit_guarded(self, code: str, qty: int, limit_price: int, **kwargs):
         """
         ÏßÄÏ†ïÍ∞Ä Îß§Ïàò Ïãú ÏòàÏàòÍ∏à Î∂ÄÏ°±/Í≥ºÎß§Ïàò ÏûêÎèô Ï∂ïÏÜå ÎòêÎäî Ïä§ÌÇµ.
         ‚úÖ practice ÌôòÍ≤ΩÏóêÏÑúÎäî KISÏóêÍ≤å ÏßÅÏ†ë ÌåêÎã®ÏùÑ Îß°Í∏∞Í≥†, ÎÇ¥Î∂Ä Í∞ÄÎìúÎäî ÏÉùÎûµ.
         """
+        code = normalize_code(code)
         # üî∏ Î™®ÏùòÌà¨Ïûê(practice) Í≥ÑÏ¢åÏóêÏÑúÎäî ÏòàÏàòÍ∏à Í∞ÄÎìú ÏÇ¨Ïö© X ‚Üí Î∞îÎ°ú KISÎ°ú Ï£ºÎ¨∏
         if self.env == "practice":
             logger.info(
                 f"[BUY_GUARD] practice env ‚Üí guard ÏÉùÎûµ, ÏßÅÏ†ë ÏßÄÏ†ïÍ∞Ä Ï£ºÎ¨∏ "
                 f"(code={code}, qty={qty}, limit={limit_price})"
             )
             return self.buy_stock_limit(code, qty, limit_price)
 
         try:
             limit_price = int(limit_price)
         except Exception:
             limit_price = 0
         if limit_price <= 0 or int(qty) <= 0:
             raise ValueError("invalid limit buy params")
 
         # Í∏∞Ï§ÄÍ∞ÄÍ≤©: ÏßÄÏ†ïÍ∞ÄÏôÄ ÌòÑÏû¨Í∞Ä Ï§ë Îçî Î≥¥ÏàòÏ†ÅÏù∏ Í∞í ÏÇ¨Ïö©(Îçî ÎÜíÏùÄ Í∞í)
         try:
             cur = self.get_last_price(code)
             ref_px = float(cur) if cur is not None else None
         except Exception:
             ref_px = None
         ref_px = float(limit_price) if ref_px is None else max(float(limit_price), float(ref_px))
 
         adj_qty = self.affordable_qty(code, ref_px, qty)
         if adj_qty <= 0:
             logger.warning(f"[BUY_GUARD] {code} ÏòàÏàòÍ∏à Î∂ÄÏ°± ‚Üí Îß§Ïàò Ïä§ÌÇµ (req={qty}, px={ref_px})")
             return {"rt_cd": "1", "msg1": "INSUFFICIENT_CASH", "output": {}}
 
         if adj_qty < qty:
             logger.info(f"[BUY_GUARD] {code} ÏöîÏ≤≠ {qty} ‚Üí Í∞ÄÎä•Ìïú {adj_qty}Î°ú Ï∂ïÏÜå (px={ref_px})")
 
         # Í∏∞Ï°¥ ÏßÄÏ†ïÍ∞Ä Îß§Ïàò Ìò∏Ï∂ú
         return self.buy_stock_limit(code, adj_qty, limit_price)
 
     def buy_stock_market_guarded(self, code: str, qty: int, **kwargs):
         """
         ÏãúÏû•Í∞Ä Îß§Ïàò Ïãú ÏòàÏàòÍ∏à Î∂ÄÏ°±/Í≥ºÎß§Ïàò ÏûêÎèô Ï∂ïÏÜå ÎòêÎäî Ïä§ÌÇµ.
         ‚úÖ practice ÌôòÍ≤ΩÏóêÏÑúÎäî KISÏóêÍ≤å ÏßÅÏ†ë ÌåêÎã®ÏùÑ Îß°Í∏∞Í≥†, ÎÇ¥Î∂Ä Í∞ÄÎìúÎäî ÏÉùÎûµ.
         """
+        code = normalize_code(code)
         # üî∏ Î™®ÏùòÌà¨Ïûê(practice) Í≥ÑÏ¢åÏóêÏÑúÎäî ÏòàÏàòÍ∏à Í∞ÄÎìú ÏÇ¨Ïö© X ‚Üí Î∞îÎ°ú KISÎ°ú Ï£ºÎ¨∏
         if self.env == "practice":
             logger.info(
                 f"[BUY_GUARD] practice env ‚Üí guard ÏÉùÎûµ, ÏßÅÏ†ë ÏãúÏû•Í∞Ä Ï£ºÎ¨∏ "
                 f"(code={code}, qty={qty})"
             )
             return self.buy_stock_market(code, qty)
 
         try:
             cur = self.get_last_price(code)
             ref_px = float(cur) if cur is not None else 0.0
         except Exception:
             ref_px = 0.0
 
         if ref_px <= 0:
             snap = self.get_quote_snapshot(code)
             ref_px = float(snap.get("tp") or 0.0)
 
         adj_qty = self.affordable_qty(code, ref_px, qty)
         if adj_qty <= 0:
             logger.warning(
                 f"[BUY_GUARD] {code} ÏòàÏàòÍ∏à Î∂ÄÏ°± ‚Üí Îß§Ïàò Ïä§ÌÇµ (req={qty}, px‚âà{ref_px})"
             )
             return {"rt_cd": "1", "msg1": "INSUFFICIENT_CASH", "output": {}}
 
         if adj_qty < qty:
             logger.info(
                 f"[BUY_GUARD] {code} ÏöîÏ≤≠ {qty} ‚Üí Í∞ÄÎä•Ìïú {adj_qty}Î°ú Ï∂ïÏÜå (px‚âà{ref_px})"
             )
 
         return self.buy_stock_market(code, adj_qty)
 
     # --- Ìò∏Ìôò ÏÖîÏûÑ(Í∏∞Ï°¥ trader.py Ìò∏Ï∂ú ÎåÄÏùë) ---
     def buy_stock(self, code: str, qty: int, price: Optional[int] = None):
         """Í∏∞Ï°¥ ÏΩîÎìú Ìò∏ÌôòÏö©."""
+        code = normalize_code(code)
         if price is None:
             return self.buy_stock_market(code, qty)
         return self.buy_stock_limit(code, qty, price)
 
     def sell_stock(self, code: str, qty: int, price: Optional[int] = None):
         """Í∏∞Ï°¥ ÏΩîÎìú Ìò∏ÌôòÏö©."""
+        code = normalize_code(code)
         if price is None:
             return self.sell_stock_market(code, qty)
         return self.sell_stock_limit(code, qty, price)
 
     # ===== [NEW] Ï£ºÎ¨∏ ÌõÑ ÌôïÏù∏/Î≥¥Ï°∞: Ï≤¥Í≤∞ ÌõÑ ÏûîÍ≥† ÎèôÍ∏∞Ìôî =====
     def refresh_after_order(self, wait_sec: float = 3.0, max_tries: int = 5) -> dict:
         """
         Ï≤¥Í≤∞ ÏßÅÌõÑ ÏûîÍ≥†/ÌòÑÍ∏à Ïû¨Ï°∞Ìöå (ÎÑ§Ìä∏ÏõåÌÅ¨/ÏßÄÏó∞ ÎÇ¥ÏÑ±).
         - Ïó¨Îü¨ Î≤à(Í∏∞Î≥∏ 5Ìöå) ÏßßÍ≤å ÏãúÎèÑÌïòÏó¨ output1/2Í∞Ä Ï±ÑÏõåÏßÑ ÏãúÏ†êÏóê Î∞òÌôò
         - Ïã§Ìå® Ïãú ÎßàÏßÄÎßâ ÏÑ±Í≥µ Ïä§ÎÉÖÏÉ∑ ÎòêÎäî Îπà dict
         """
         snap: dict = {}
         tries = max(1, int(max_tries))
         delay = max(0.2, float(wait_sec) / tries)
         for i in range(tries):
             try:
                 j = self.inquire_balance_all()
                 if j and (j.get("output1") or j.get("output2")):
                     snap = j
                     logger.info("[SYNC] balance refreshed (try=%s)", i + 1)
                     break
             except Exception as e:
                 logger.warning("[SYNC] balance refresh failed: %s", e)
             time.sleep(delay)
         return snap
diff --git a/trader/ledger.py b/trader/ledger.py
index a76a83216120d7abe0d0df1221f64e484ce2f491..0cd035c62d3af22dfb9ead47486d0a5d6a374c05 100644
--- a/trader/ledger.py
+++ b/trader/ledger.py
@@ -1,226 +1,227 @@
 from __future__ import annotations
 
 from datetime import datetime
 from typing import Any, Dict, List
 
 from .config import KST
-
-
-def _normalize_code(pdno: str) -> str:
-    return str(pdno).zfill(6)
+from .code_utils import normalize_code
 
 
 def _ensure_state(state: Dict[str, Any]) -> List[Dict[str, Any]]:
     lots = state.get("lots")
     if not isinstance(lots, list):
         lots = []
         state["lots"] = lots
     return lots
 
 
 def _norm_sid(value: int | str | None) -> int | str | None:
     if value is None:
         return None
     text = str(value)
     return int(text) if text.isdigit() else text
 
 
 def record_buy_fill(
     state: Dict[str, Any],
     *,
     lot_id: str,
     pdno: str,
     strategy_id: int | str,
     engine: str,
     entry_ts: str,
     entry_price: float,
     qty: int,
     meta: Dict[str, Any] | None,
 ) -> None:
     lots = _ensure_state(state)
     if any(lot.get("lot_id") == lot_id for lot in lots):
         return
     lots.append(
         {
             "lot_id": lot_id,
-            "pdno": _normalize_code(pdno),
+            "pdno": normalize_code(pdno),
             "strategy_id": strategy_id,
             "engine": engine,
             "entry_ts": entry_ts,
             "entry_price": float(entry_price),
             "qty": int(qty),
             "remaining_qty": int(qty),
             "meta": meta or {},
         }
     )
 
 
 def apply_sell_fill_fifo(
     state: Dict[str, Any],
     *,
     pdno: str,
     qty_filled: int,
     sell_ts: str,
     strategy_id: int | str | None = None,
     allow_blocked: bool = False,
 ) -> None:
     lots = _ensure_state(state)
     remaining = int(qty_filled)
     if remaining <= 0:
         return
 
     req_sid = _norm_sid(strategy_id)
 
     def _consume(remaining_qty: int, sid_filter: int | str | None) -> int:
         for lot in lots:
-            if _normalize_code(lot.get("pdno")) != _normalize_code(pdno):
+            if normalize_code(lot.get("pdno")) != normalize_code(pdno):
                 continue
             if not allow_blocked and lot.get("meta", {}).get("sell_blocked") is True:
                 continue
 
             lot_sid = _norm_sid(lot.get("strategy_id"))
             if sid_filter is not None and lot_sid != sid_filter:
                 continue
 
             lot_remaining = int(lot.get("remaining_qty") or 0)
             if lot_remaining <= 0:
                 continue
 
             delta = min(lot_remaining, remaining_qty)
             lot["remaining_qty"] = int(lot_remaining - delta)
             if delta > 0:
                 lot["last_sell_ts"] = sell_ts
 
             remaining_qty -= delta
             if remaining_qty <= 0:
                 break
         return remaining_qty
 
     _consume(remaining, req_sid)
 
 
 def owned_lots_by_strategy(state: Dict[str, Any], strategy_id: int | str) -> List[Dict[str, Any]]:
     lots = _ensure_state(state)
     return [
         lot
         for lot in lots
         if int(lot.get("remaining_qty") or 0) > 0
         and _norm_sid(lot.get("strategy_id")) == _norm_sid(strategy_id)
     ]
 
 
 def remaining_qty_for_strategy(state: Dict[str, Any], pdno: str, strategy_id: int | str) -> int:
     lots = _ensure_state(state)
     total = 0
     for lot in lots:
-        if _normalize_code(lot.get("pdno")) != _normalize_code(pdno):
+        if normalize_code(lot.get("pdno")) != normalize_code(pdno):
             continue
         if int(lot.get("remaining_qty") or 0) <= 0:
             continue
         if _norm_sid(lot.get("strategy_id")) != _norm_sid(strategy_id):
             continue
         total += int(lot.get("remaining_qty") or 0)
     return total
 
 
 def dominant_strategy_for(state: Dict[str, Any], pdno: str) -> int | None:
     lots = _ensure_state(state)
     totals: Dict[int, int] = {}
     for lot in lots:
-        if _normalize_code(lot.get("pdno")) != _normalize_code(pdno):
+        if normalize_code(lot.get("pdno")) != normalize_code(pdno):
             continue
         remaining = int(lot.get("remaining_qty") or 0)
         if remaining <= 0:
             continue
         sid = _norm_sid(lot.get("strategy_id"))
         if isinstance(sid, int) and 1 <= sid <= 5:
             totals[sid] = totals.get(sid, 0) + remaining
     if not totals:
         return None
     return max(totals.items(), key=lambda item: item[1])[0]
 
 
 def strategy_avg_price(
     state: Dict[str, Any], pdno: str, strategy_id: int | str
 ) -> float | None:
     lots = _ensure_state(state)
     total_qty = 0
     total_cost = 0.0
     for lot in lots:
-        if _normalize_code(lot.get("pdno")) != _normalize_code(pdno):
+        if normalize_code(lot.get("pdno")) != normalize_code(pdno):
             continue
         if _norm_sid(lot.get("strategy_id")) != _norm_sid(strategy_id):
             continue
         remaining = int(lot.get("remaining_qty") or 0)
         if remaining <= 0:
             continue
         entry_price = float(lot.get("entry_price") or 0.0)
         total_qty += remaining
         total_cost += entry_price * remaining
     if total_qty <= 0:
         return None
     return total_cost / total_qty
 
 
 def reconcile_with_broker_holdings(state: Dict[str, Any], holdings: List[Dict[str, Any]]) -> None:
     lots = _ensure_state(state)
     holdings_map: Dict[str, Dict[str, Any]] = {}
     for row in holdings:
-        code = _normalize_code(row.get("code") or row.get("pdno") or "")
+        code = normalize_code(row.get("code") or row.get("pdno") or "")
         if not code:
             continue
         qty = int(row.get("qty") or 0)
         avg_price = row.get("avg_price")
         existing = holdings_map.get(code)
         if existing:
             existing["qty"] += qty
             if existing.get("avg_price") is None:
                 existing["avg_price"] = avg_price
         else:
             holdings_map[code] = {"qty": qty, "avg_price": avg_price}
 
     now_ts = datetime.now(KST).isoformat()
 
     for lot in lots:
-        pdno = _normalize_code(lot.get("pdno"))
+        if str(lot.get("strategy_id")) in {"ORPHAN", "UNKNOWN"}:
+            lot["strategy_id"] = "MANUAL"
+
+    for lot in lots:
+        pdno = normalize_code(lot.get("pdno"))
         if pdno not in holdings_map or holdings_map[pdno]["qty"] <= 0:
             if int(lot.get("remaining_qty") or 0) > 0:
                 lot["remaining_qty"] = 0
 
     for pdno, payload in holdings_map.items():
         hold_qty = int(payload.get("qty") or 0)
         if hold_qty <= 0:
             continue
         total_remaining = sum(
             int(lot.get("remaining_qty") or 0)
             for lot in lots
-            if _normalize_code(lot.get("pdno")) == pdno
+            if normalize_code(lot.get("pdno")) == pdno
         )
         if total_remaining < hold_qty:
             diff = hold_qty - total_remaining
             lots.append(
                 {
                     "lot_id": f"{pdno}-RECON-{now_ts}",
                     "pdno": pdno,
-                    "strategy_id": "ORPHAN",
+                    "strategy_id": "MANUAL",
                     "engine": "reconcile",
                     "entry_ts": now_ts,
                     "entry_price": float(payload.get("avg_price") or 0.0),
                     "qty": int(diff),
                     "remaining_qty": int(diff),
-                    "meta": {"reconciled": True, "orphan": True},
+                    "meta": {"reconciled": True, "manual": True},
                 }
             )
         elif total_remaining > hold_qty:
             extra = total_remaining - hold_qty
             for lot in reversed(lots):
-                if _normalize_code(lot.get("pdno")) != pdno:
+                if normalize_code(lot.get("pdno")) != pdno:
                     continue
                 lot_remaining = int(lot.get("remaining_qty") or 0)
                 if lot_remaining <= 0:
                     continue
                 delta = min(lot_remaining, extra)
                 lot["remaining_qty"] = int(lot_remaining - delta)
                 extra -= delta
                 if extra <= 0:
                     break
diff --git a/trader/ledger_test.py b/trader/ledger_test.py
index 0dfbd740de7c3250ab53acfa31f572589967c8e8..b63c85bded7da7c1e5b5b5abdb981c33106ada03 100644
--- a/trader/ledger_test.py
+++ b/trader/ledger_test.py
@@ -1,33 +1,34 @@
 from __future__ import annotations
 
 from trader.exit_allocation import allocate_sell_qty, apply_sell_allocation
 from trader.ctx_schema import normalize_daily_ctx
 from trader.execution import record_entry_state
 from trader.ledger import apply_sell_fill_fifo, record_buy_fill, remaining_qty_for_strategy
 from trader.position_state_store import migrate_position_state
 from trader import state_store as runtime_state_store
+from trader.code_utils import normalize_code
 
 
 def _sample_state() -> dict:
     return {"version": 1, "lots": [], "updated_at": None}
 
 
 def test_fifo_and_fallback() -> None:
     state = _sample_state()
     record_buy_fill(
         state,
         lot_id="L1",
         pdno="005930",
         strategy_id=1,
         engine="test",
         entry_ts="2025-01-01T09:00:00+09:00",
         entry_price=70000.0,
         qty=5,
         meta={},
     )
     record_buy_fill(
         state,
         lot_id="L2",
         pdno="005930",
         strategy_id=2,
         engine="test",
@@ -132,81 +133,87 @@ def test_migrate_position_state_v1() -> None:
                 "entries": {
                     "1": {
                         "qty": 3,
                         "avg_price": 100.0,
                         "entry": {"time": "t1"},
                         "meta": {},
                     }
                 },
                 "flags": {"bear_s1_done": True, "bear_s2_done": False},
             }
         },
         "memory": {"last_price": {}, "last_seen": {}},
     }
     migrated = migrate_position_state(legacy_state)
     assert migrated["schema_version"] == 2
     strategies = migrated["positions"]["000001"]["strategies"]
     assert "1" in strategies
     assert strategies["1"]["qty"] == 3
     assert strategies["1"]["avg_price"] == 100.0
     assert strategies["1"]["flags"]["bear_s1_done"] is True
 
 
 def test_global_liquidation_orphan_priority() -> None:
     lot_state = {
         "lots": [
-            {"pdno": "000001", "strategy_id": "ORPHAN", "remaining_qty": 2, "entry_price": 90.0},
+            {"pdno": "000001", "strategy_id": "MANUAL", "remaining_qty": 2, "entry_price": 90.0},
             {"pdno": "000001", "strategy_id": 1, "remaining_qty": 4, "entry_price": 100.0},
             {"pdno": "000001", "strategy_id": 2, "remaining_qty": 3, "entry_price": 105.0},
         ]
     }
     allocations = allocate_sell_qty(
         lot_state,
         "000001",
         9,
         scope="global",
         trigger_strategy_id=None,
     )
-    assert allocations[0]["strategy_id"] == "ORPHAN"
+    assert allocations[0]["strategy_id"] == "MANUAL"
     sold_total = apply_sell_allocation(
         lot_state,
         "000001",
         allocations,
         sell_ts="2025-01-01T10:00:00+09:00",
     )
     assert sold_total == 9
-    assert remaining_qty_for_strategy(lot_state, "000001", "ORPHAN") == 0
+    assert remaining_qty_for_strategy(lot_state, "000001", "MANUAL") == 0
     assert remaining_qty_for_strategy(lot_state, "000001", 1) == 0
     assert remaining_qty_for_strategy(lot_state, "000001", 2) == 0
 
 
 def test_normalize_ctx_missing_setup_flag() -> None:
     ctx = normalize_daily_ctx({"strong_trend": True})
     assert ctx.get("setup_flag") is False
     assert ctx.get("setup_ok") is False
 
 
+def test_normalize_code() -> None:
+    assert normalize_code("A476830") == "476830"
+    assert normalize_code("123") == "000123"
+    assert normalize_code("00123456") == "123456"
+
+
 def test_idempotent_order_block() -> None:
     state = runtime_state_store.load_state()
     ts = "2025-01-01T10:00:00+09:00"
     runtime_state_store.mark_order(
         state,
         "000001",
         "BUY",
         1,
         1,
         100.0,
         ts,
         status="submitted",
     )
     assert runtime_state_store.should_block_order(
         state, "000001", "BUY", "2025-01-01T10:01:00+09:00"
     )
 
 
 def main() -> None:
     test_fifo_and_fallback()
     test_record_entry_state_accumulates()
     test_strategy_scoped_sell()
     test_migrate_position_state_v1()
     test_global_liquidation_orphan_priority()
     test_normalize_ctx_missing_setup_flag()
diff --git a/trader/legacy_kosdaq_runner.py b/trader/legacy_kosdaq_runner.py
index c90517b9b361030b4c30dd29c6309c91229a7b10..649fe24483164daf1faa61872be4524299ce2973 100644
--- a/trader/legacy_kosdaq_runner.py
+++ b/trader/legacy_kosdaq_runner.py
@@ -14,100 +14,108 @@ from datetime import date, datetime, time as dtime, timedelta
 from typing import Any, Dict, List, Tuple, TYPE_CHECKING
 
 
 try:
     from .config import (
         DAILY_CAPITAL,
         FAST_STOP,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         FORCE_SELL_BLOCKED_LOTS,
         ALLOW_WHEN_CLOSED,
         ALLOW_PYRAMID,
         BASE_QTY_MODE,
         KST,
         LOG_DIR,
         RATE_SLEEP_SEC,
         EMERGENCY_GLOBAL_SELL,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
         STATE_PATH,
         STRATEGY_REDUCTION_PRIORITY,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
+        MANUAL_HARD_STOP_LOSS_PCT,
+        MANUAL_TRAILING_STOP_PCT,
+        MANUAL_MAX_HOLDING_DAYS,
         _cfg,
         logger,
     )
 except ImportError:
     # ALLOW_WHEN_CLOSEDÍ∞Ä ÎàÑÎùΩÎèºÎèÑ Îü¨ÎÑàÍ∞Ä Ï¶âÏãú Ï§ëÎã®ÎêòÏßÄ ÏïäÎèÑÎ°ù ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞íÏùÑ Ï†úÍ≥µÌïúÎã§.
     from .config import (
         DAILY_CAPITAL,
         FAST_STOP,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         FORCE_SELL_BLOCKED_LOTS,
         KST,
         LOG_DIR,
         BASE_QTY_MODE,
         RATE_SLEEP_SEC,
         EMERGENCY_GLOBAL_SELL,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
         STATE_PATH,
         STRATEGY_REDUCTION_PRIORITY,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
+        MANUAL_HARD_STOP_LOSS_PCT,
+        MANUAL_TRAILING_STOP_PCT,
+        MANUAL_MAX_HOLDING_DAYS,
         _cfg,
         logger,
     )
 
     ALLOW_WHEN_CLOSED = False
     logger.warning("[CONFIG] ALLOW_WHEN_CLOSED missing; defaulting to False")
     ALLOW_PYRAMID = False
     logger.warning("[CONFIG] ALLOW_PYRAMID missing; defaulting to False")
 from . import signals
 from trader.time_utils import MARKET_CLOSE, MARKET_OPEN, is_trading_day
 from trader.subject_flow import get_subject_flow_with_fallback, reset_flow_call_count
 from trader.execution import record_entry_state
 from trader.strategy_rules import strategy_entry_gate, strategy_trigger_label
 from trader.exit_allocation import allocate_sell_qty, apply_sell_allocation
+from trader.code_utils import normalize_code
 from trader.ledger import (
     record_buy_fill,
     remaining_qty_for_strategy,
     reconcile_with_broker_holdings,
     strategy_avg_price,
 )
 from trader.ctx_schema import normalize_daily_ctx, normalize_intraday_ctx
 from trader import state_store as runtime_state_store
 from trader.lot_state_store import load_lot_state, save_lot_state
 from trader.position_state_store import (
     load_position_state,
     reconcile_with_broker,
+    reconcile_positions,
     save_position_state,
 )
 from .core import *  # noqa: F401,F403 - Ï†ÑÎûµ Ïú†Ìã∏ Ï†ÑÏ≤¥ ÎÖ∏Ï∂úÎ°ú ÌôïÏû•ÏÑ± ÌôïÎ≥¥
 
 if TYPE_CHECKING:
     # core Ï™ΩÏóê Íµ¨ÌòÑÎèº ÏûàÎäî Ìó¨ÌçºÎì§ÏùÑ ÌÉÄÏûÖÏ≤¥Ïª§ÏóêÍ≤åÎßå Î™ÖÏãúÏ†ÅÏúºÎ°ú ÏïåÎ†§Ï§ÄÎã§.
     from .core import (
         _this_iso_week_key,
         _get_effective_ord_cash,
         _to_float,
         _to_int,
         _weight_to_qty,
         _classify_champion_grade,
         _update_market_regime,
         _notional_to_qty,
         _fetch_balances,
         _init_position_state_from_balance,
         _sell_once,
         _adaptive_exit,
         _compute_daily_entry_context,
         _compute_intraday_entry_context,
         _safe_get_price,
         _round_to_tick,
         _init_position_state,
         _detect_pullback_reversal,
@@ -147,270 +155,361 @@ def main(
 
     holding, traded = load_state()
     lot_state_path = "bot_state/state.json"
     lot_state = load_lot_state(lot_state_path)
     position_state_path = str(STATE_PATH)
     position_state = load_position_state(position_state_path)
     position_state_dirty = False
     runtime_state = runtime_state_store.load_state()
     triggered_today: set[str] = set()
     s1_done_today: set[tuple[str, str]] = set()
     last_today_prefix: str | None = None
 
     if isinstance(traded, (set, list, tuple)):
         logger.warning(
             f"[STATE-MIGRATE] traded ÌÉÄÏûÖ {type(traded)} ‚Üí dictÎ°ú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò(Ï§ëÎ≥µ ÏßÑÏûÖ Í∞ÄÎìú Ïú†ÏßÄ)"
         )
         traded = {
             code: {"buy_time": state_loaded_midnight, "qty": 0, "price": 0.0}
             for code in traded
         }
     elif not isinstance(traded, dict):
         logger.warning(
             f"[STATE-FORMAT] traded ÌÉÄÏûÖ {type(traded)} ÏßÄÏõê Ïïà Ìï® ‚Üí Îπà dictÎ°ú Ïû¨ÏÑ§Ï†ï"
         )
         traded = {}
+    if isinstance(traded, dict):
+        traded = {normalize_code(k): v for k, v in traded.items() if normalize_code(k)}
+    if isinstance(holding, dict):
+        holding = {normalize_code(k): v for k, v in holding.items() if normalize_code(k)}
 
     def _traded_codes(traded_state: Any) -> List[str]:
         if isinstance(traded_state, dict):
             return list(traded_state.keys())
         return []
 
     def _traded_today(traded_state: Any, today_prefix: str) -> set:
         if not isinstance(traded_state, dict):
             return set()
 
         today_codes = set()
         for code, payload in traded_state.items():
             payload = payload or {}
             buy_time = payload.get("buy_time")
             status = payload.get("status")
             # pending/other ÏÉÅÌÉúÎäî Ïû¨ÏãúÎèÑ ÌóàÏö©, filled/Í∏∞Ï°¥(None)Îßå Ï§ëÎ≥µ Î∞©ÏßÄ
             if status not in (None, "filled"):
                 continue
             if isinstance(buy_time, str) and buy_time.startswith(today_prefix):
                 today_codes.add(code)
         return today_codes
 
     def _record_trade(traded_state: Any, code: str, payload: Dict[str, Any]) -> None:
         try:
-            traded_state[code] = payload
+            traded_state[normalize_code(code)] = payload
         except Exception:
             logger.warning(
                 f"[TRADED-STATE] tradedÏóê ÏΩîÎìú Ï∂îÍ∞Ä Ïã§Ìå®: type={type(traded_state)}"
             )
 
+    def _load_trade_log(days: int = 7) -> List[Dict[str, Any]]:
+        logs: List[Dict[str, Any]] = []
+        today = datetime.now(KST).date()
+        for offset in range(days):
+            day = today - timedelta(days=offset)
+            path = LOG_DIR / f"trades_{day.strftime('%Y-%m-%d')}.json"
+            if not path.exists():
+                continue
+            try:
+                with open(path, "r", encoding="utf-8") as f:
+                    for line in f:
+                        line = line.strip()
+                        if not line:
+                            continue
+                        try:
+                            logs.append(json.loads(line))
+                        except json.JSONDecodeError:
+                            continue
+            except Exception:
+                logger.exception("[TRADE_LOG] failed to read %s", path)
+        return logs
+
     def _save_runtime_state() -> None:
         try:
             runtime_state_store.save_state(runtime_state)
         except Exception:
             logger.exception("[RUNTIME_STATE] save failed")
 
+    def _save_position_state_now() -> None:
+        nonlocal position_state_dirty
+        if position_state_dirty:
+            save_position_state(position_state_path, position_state)
+            position_state_dirty = False
+
     def _lot_state_signature(state: dict) -> tuple:
         lots = state.get("lots")
         if not isinstance(lots, list):
             return tuple()
         return tuple(
             (
                 str(lot.get("lot_id")),
                 str(lot.get("pdno")),
                 int(lot.get("remaining_qty") or 0),
             )
             for lot in lots
         )
 
     def _maybe_save_lot_state(before_signature: tuple) -> None:
         after_signature = _lot_state_signature(lot_state)
         if after_signature != before_signature:
             save_lot_state(lot_state_path, lot_state)
 
     def _ensure_position_entry(
         code: str, strategy_id: int | str
     ) -> Dict[str, Any]:
-        code_key = str(code).zfill(6)
+        code_key = normalize_code(code)
         sid_key = str(strategy_id)
         pos = position_state.setdefault("positions", {}).setdefault(
             code_key,
             {
                 "strategies": {},
             },
         )
         entries = pos.setdefault("strategies", {})
         entry = entries.get(sid_key)
         if isinstance(entry, dict):
             return entry
         now_ts = datetime.now(KST).isoformat()
         entry = {
             "qty": int(remaining_qty_for_strategy(lot_state, code_key, sid_key)),
             "avg_price": float((holding.get(code) or {}).get("buy_price") or 0.0),
             "entry": {
                 "time": now_ts,
                 "strategy_id": sid_key,
                 "engine": "unknown",
                 "entry_reason": "RECONCILE",
                 "order_type": "unknown",
                 "best_k": None,
                 "tgt_px": None,
                 "gap_pct_at_entry": None,
             },
             "meta": {
                 "pullback_peak_price": None,
                 "pullback_reversal_price": None,
                 "pullback_reason": None,
             },
             "flags": {
                 "bear_s1_done": False,
                 "bear_s2_done": False,
                 "sold_p1": False,
                 "sold_p2": False,
             },
         }
         entries[sid_key] = entry
         return entry
 
     def _set_position_flags(code: str, strategy_id: int | str, **flags: bool) -> None:
         nonlocal position_state_dirty
         pos = position_state.setdefault("positions", {}).setdefault(
-            str(code).zfill(6),
+            normalize_code(code),
             {
                 "strategies": {},
             },
         )
         entries = pos.setdefault("strategies", {})
         entry = entries.setdefault(str(strategy_id), {})
         entry_flags = entry.setdefault(
             "flags",
             {"bear_s1_done": False, "bear_s2_done": False, "sold_p1": False, "sold_p2": False},
         )
         flags_before = dict(entry_flags)
         for key, value in flags.items():
             entry_flags[key] = bool(value)
         logger.info(
             "[FLAGS] code=%s flags_before=%s flags_after=%s",
-            str(code).zfill(6),
+            normalize_code(code),
             flags_before,
             entry_flags,
         )
         position_state_dirty = True
 
     def _update_last_price_memory(code: str, current_price: float, now_ts: str) -> None:
         nonlocal position_state_dirty
         memory = position_state.setdefault("memory", {})
-        memory.setdefault("last_price", {})[str(code).zfill(6)] = float(current_price)
-        memory.setdefault("last_seen", {})[str(code).zfill(6)] = now_ts
+        code_key = normalize_code(code)
+        memory.setdefault("last_price", {})[code_key] = float(current_price)
+        memory.setdefault("last_seen", {})[code_key] = now_ts
         position_state_dirty = True
 
     def _pullback_stop_hit(
         code: str, current_price: float, strategy_id: int | str = 5
     ) -> bool:
-        pos = position_state.get("positions", {}).get(str(code).zfill(6))
+        pos = position_state.get("positions", {}).get(normalize_code(code))
         if not isinstance(pos, dict):
             return False
         entries = pos.get("strategies", {})
         entry = entries.get(str(strategy_id))
         if not isinstance(entry, dict):
             return False
         meta = entry.get("meta", {}) or {}
         reversal_price = meta.get("pullback_reversal_price")
         if reversal_price is None:
             return False
         try:
             return float(current_price) < float(reversal_price) * (1 - FAST_STOP)
         except Exception:
             return False
 
+    def _manual_exit_intent(
+        code_key: str,
+        entry: Dict[str, Any],
+        available_qty: int,
+        avg_price: float,
+        now_dt: datetime,
+        rebalance_anchor: str,
+    ) -> Tuple[str | None, int]:
+        cur_price = _safe_get_price(kis, code_key)
+        if cur_price is None or cur_price <= 0:
+            return None, 0
+        high_val = float(entry.get("high_watermark") or entry.get("meta", {}).get("high") or avg_price)
+        high_val = max(high_val, float(cur_price))
+        entry["high_watermark"] = high_val
+        entry.setdefault("meta", {})["high"] = high_val
+        entry["last_update_ts"] = now_dt.isoformat()
+
+        pnl_pct = (float(cur_price) - float(avg_price)) / float(avg_price) * 100.0
+        if MANUAL_HARD_STOP_LOSS_PCT and pnl_pct <= -abs(MANUAL_HARD_STOP_LOSS_PCT):
+            return "manual_hard_stop", int(available_qty)
+
+        trail_pct = abs(MANUAL_TRAILING_STOP_PCT or 0.0)
+        if trail_pct and float(cur_price) <= high_val * (1 - trail_pct / 100.0):
+            return "manual_trailing_stop", int(available_qty)
+
+        if MANUAL_MAX_HOLDING_DAYS:
+            try:
+                entry_ts = entry.get("entry_ts") or entry.get("entry", {}).get("time")
+                entry_dt = datetime.fromisoformat(entry_ts) if entry_ts else None
+            except Exception:
+                entry_dt = None
+            if entry_dt:
+                if (now_dt.date() - entry_dt.date()).days >= MANUAL_MAX_HOLDING_DAYS:
+                    return "manual_time_cut", int(available_qty)
+                try:
+                    rebalance_dt = date.fromisoformat(rebalance_anchor)
+                    if entry_dt.date() < rebalance_dt:
+                        return "manual_rebalance_cut", int(available_qty)
+                except Exception:
+                    pass
+
+        return None, 0
+
     def _build_exit_intents(code: str, regime_mode: str) -> list[dict[str, Any]]:
         nonlocal position_state_dirty
         intents: list[dict[str, Any]] = []
-        code_key = str(code).zfill(6)
+        code_key = normalize_code(code)
         pos_state = position_state.get("positions", {}).get(code_key)
         if not isinstance(pos_state, dict):
             return intents
         strategies = pos_state.get("strategies", {})
         if not isinstance(strategies, dict):
             return intents
         for sid, entry in strategies.items():
             if not isinstance(entry, dict):
                 continue
             available_qty = remaining_qty_for_strategy(lot_state, code_key, sid)
             if available_qty <= 0:
                 continue
             avg_price = strategy_avg_price(lot_state, code_key, sid)
             if avg_price is None:
                 continue
             flags = entry.get("flags", {}) or {}
             meta = entry.get("meta", {}) or {}
             high_value = float(meta.get("high") or 0.0)
             if not high_value or high_value <= 0:
                 high_value = float(avg_price)
             high_value = max(high_value, float(avg_price))
             meta["high"] = high_value
+            entry["high_watermark"] = max(float(entry.get("high_watermark") or 0.0), high_value)
+            entry["last_update_ts"] = datetime.now(KST).isoformat()
             pos_view = {
                 "qty": int(available_qty),
                 "buy_price": float(avg_price),
                 "high": high_value,
                 "sold_p1": bool(flags.get("sold_p1", False)),
                 "sold_p2": bool(flags.get("sold_p2", False)),
                 "name": entry.get("entry", {}).get("name"),
                 "k_value": entry.get("entry", {}).get("best_k"),
                 "target_price_src": entry.get("entry", {}).get("tgt_px"),
             }
-            reason, sell_qty = _adaptive_exit(
-                kis,
-                code_key,
-                pos_view,
-                regime_mode=regime_mode,
-            )
+            if str(sid) in {"MANUAL", "LEGACY"}:
+                reason, sell_qty = _manual_exit_intent(
+                    code_key,
+                    entry,
+                    int(available_qty),
+                    float(avg_price),
+                    datetime.now(KST),
+                    str(rebalance_date),
+                )
+            else:
+                reason, sell_qty = _adaptive_exit(
+                    kis,
+                    code_key,
+                    pos_view,
+                    regime_mode=regime_mode,
+                )
             if sell_qty:
                 intents.append(
                     {
                         "code": code_key,
                         "strategy_id": sid,
                         "sell_qty": int(sell_qty),
                         "reason": reason or "adaptive_exit",
                     }
                 )
             meta["high"] = float(pos_view.get("high") or meta.get("high") or 0.0)
+            entry["high_watermark"] = max(
+                float(entry.get("high_watermark") or 0.0), float(meta.get("high") or 0.0)
+            )
             entry["meta"] = meta
             flags["sold_p1"] = bool(pos_view.get("sold_p1", flags.get("sold_p1")))
             flags["sold_p2"] = bool(pos_view.get("sold_p2", flags.get("sold_p2")))
             entry["flags"] = flags
             position_state_dirty = True
         return intents
 
     def _remaining_qty_for(pdno: str) -> int:
         return sum(
             int(lot.get("remaining_qty") or 0)
             for lot in lot_state.get("lots", [])
-            if str(lot.get("pdno")).zfill(6) == str(pdno).zfill(6)
+            if normalize_code(lot.get("pdno")) == normalize_code(pdno)
         )
 
     def _ledger_total_available_qty(code: str) -> int:
         return sum(
             int(lot.get("remaining_qty") or 0)
             for lot in lot_state.get("lots", [])
-            if str(lot.get("pdno")).zfill(6) == str(code).zfill(6)
+            if normalize_code(lot.get("pdno")) == normalize_code(code)
         )
 
     def _cap_sell_qty(code: str, requested_qty: int) -> int:
         return min(int(requested_qty), int(_ledger_total_available_qty(code)))
 
     def _normalize_strategy_id(value: Any) -> int:
         try:
             strategy_num = int(value)
         except Exception:
             return 1
         if 1 <= strategy_num <= 5:
             return strategy_num
         return 1
 
     def _derive_strategy_id(payload: Dict[str, Any]) -> int:
         raw = (
             payload.get("strategy_id")
             or payload.get("strategyId")
             or payload.get("strategy_no")
             or payload.get("strategyNo")
         )
         if raw is not None and str(raw).isdigit():
             strategy_id = _normalize_strategy_id(raw)
             if strategy_id != int(raw):
                 logger.info(
@@ -437,81 +536,81 @@ def main(
         return 1
 
     def _build_lot_id(result: Any, fallback_ts: str, pdno: str) -> str:
         order_no = ""
         fill_seq = ""
         if isinstance(result, dict):
             out = result.get("output") or {}
             order_no = (
                 out.get("ODNO")
                 or out.get("ord_no")
                 or out.get("order_no")
                 or result.get("ODNO")
                 or result.get("ord_no")
                 or result.get("order_no")
                 or ""
             )
             fill_seq = (
                 out.get("CCLD_SQ")
                 or out.get("ccld_sq")
                 or out.get("fill_seq")
                 or out.get("CCLD_NO")
                 or out.get("ccld_no")
                 or ""
             )
         if not order_no:
-            order_no = f"NOORDER-{str(pdno).zfill(6)}-{fallback_ts}"
+            order_no = f"NOORDER-{normalize_code(pdno)}-{fallback_ts}"
         if not fill_seq:
             fill_seq = "0"
         return f"{kis.CANO}-{kis.ACNT_PRDT_CD}-{order_no}-{fill_seq}"
 
     def _estimate_sold_qty(
         code: str, requested_qty: int, prev_qty: int, delay_sec: float = 1.0
     ) -> int:
         if requested_qty <= 0:
             return 0
         try:
             time.sleep(delay_sec)
             try:
                 balances = _fetch_balances(kis, ttl_sec=0)
             except TypeError:
                 balances = _fetch_balances(kis)
         except Exception:
             return int(requested_qty)
         for row in balances:
-            if str(row.get("code")).zfill(6) != str(code).zfill(6):
+            if normalize_code(row.get("code")) != normalize_code(code):
                 continue
             new_qty = int(row.get("qty") or 0)
             sold = max(0, int(prev_qty) - int(new_qty))
             if sold <= 0:
                 return 0
             return min(int(requested_qty), int(sold))
         return int(requested_qty)
 
     def _sync_position_state_qty(code: str) -> None:
         nonlocal position_state_dirty
-        code_key = str(code).zfill(6)
+        code_key = normalize_code(code)
         pos = position_state.get("positions", {}).get(code_key)
         if not isinstance(pos, dict):
             return
         strategies = pos.get("strategies", {})
         if not isinstance(strategies, dict):
             return
         for sid in list(strategies.keys()):
             remaining = remaining_qty_for_strategy(lot_state, code_key, sid)
             if remaining <= 0:
                 strategies.pop(sid, None)
                 continue
             entry = strategies.get(sid)
             if not isinstance(entry, dict):
                 strategies.pop(sid, None)
                 continue
             if int(entry.get("qty") or 0) > int(remaining):
                 logger.warning(
                     "[STATE] qty exceeds ledger after sell: code=%s sid=%s state=%s ledger=%s",
                     code_key,
                     sid,
                     entry.get("qty"),
                     remaining,
                 )
             entry["qty"] = int(remaining)
         if not strategies:
@@ -527,161 +626,162 @@ def main(
         trigger_strategy_id: int | None = None,
         prev_qty_before: int | None = None,
         allow_blocked: bool = False,
     ) -> None:
         if not _is_order_success(result):
             return
         if scope != "strategy" and not (SELL_ALL_BALANCES_AT_CUTOFF or EMERGENCY_GLOBAL_SELL):
             raise RuntimeError(
                 f"[SELL-ALLOC] global scope used without force sell: code={code} scope={scope}"
             )
         prev_qty = int(
             prev_qty_before
             if prev_qty_before is not None
             else (holding.get(code) or {}).get("qty") or requested_qty
         )
         sold_qty = 0
         for delay_sec in (0.5, 1.0, 2.0):
             sold_qty = _estimate_sold_qty(
                 code, requested_qty, prev_qty, delay_sec=delay_sec
             )
             if sold_qty > 0:
                 break
         if sold_qty <= 0:
             logger.warning(
                 "[SELL-ALLOC] sold_qty unresolved: code=%s requested=%s prev_qty=%s",
-                str(code).zfill(6),
+                normalize_code(code),
                 requested_qty,
                 prev_qty,
             )
             try:
                 balances = _fetch_balances(kis, ttl_sec=0)
             except TypeError:
                 balances = _fetch_balances(kis)
             reconcile_with_broker_holdings(lot_state, balances)
             return
         if scope == "strategy" and trigger_strategy_id is None:
             raise RuntimeError(
                 f"[SELL-ALLOC] strategy scope requires trigger_strategy_id: code={code}"
             )
         if scope == "strategy":
             available_qty = remaining_qty_for_strategy(
                 lot_state, code, trigger_strategy_id
             )
             if available_qty < int(requested_qty):
                 raise RuntimeError(
                     "[SELL-ALLOC] insufficient strategy qty: code=%s sid=%s available=%s requested=%s"
-                    % (str(code).zfill(6), trigger_strategy_id, available_qty, requested_qty)
+                    % (normalize_code(code), trigger_strategy_id, available_qty, requested_qty)
                 )
         before_lot_signature = _lot_state_signature(lot_state)
         before_qty_total = _ledger_total_available_qty(code)
         before_qty_strategy = (
             remaining_qty_for_strategy(lot_state, code, trigger_strategy_id)
             if scope == "strategy"
             else before_qty_total
         )
         allocations = allocate_sell_qty(
             lot_state,
             code,
             int(sold_qty),
             scope=scope,
             trigger_strategy_id=trigger_strategy_id,
         )
         if not allocations:
             if sold_qty > 0 and scope != "strategy":
                 now_ts = datetime.now(KST).isoformat()
                 lot_state.setdefault("lots", []).append(
                     {
-                        "lot_id": f"{str(code).zfill(6)}-ORPHAN-{now_ts}",
-                        "pdno": str(code).zfill(6),
-                        "strategy_id": "ORPHAN",
-                        "engine": "orphan",
+                        "lot_id": f"{normalize_code(code)}-MANUAL-{now_ts}",
+                        "pdno": normalize_code(code),
+                        "strategy_id": "MANUAL",
+                        "engine": "reconcile",
                         "entry_ts": now_ts,
                         "entry_price": 0.0,
                         "qty": int(sold_qty),
                         "remaining_qty": int(sold_qty),
-                        "meta": {"reconciled": True, "orphan": True},
+                        "meta": {"reconciled": True, "manual": True},
                     }
                 )
-                allocations = [{"strategy_id": "ORPHAN", "qty": int(sold_qty)}]
+                allocations = [{"strategy_id": "MANUAL", "qty": int(sold_qty)}]
             else:
                 raise RuntimeError(
                     f"[SELL-ALLOC] no allocations for strategy sell: code={code} sid={trigger_strategy_id}"
                 )
         broker_qty_after = max(0, int(prev_qty) - int(sold_qty))
         logger.info(
             "[SELL-ALLOC] code=%s requested_qty=%s scope=%s allocations=%s sold_qty=%s broker_qty_before=%s broker_qty_after=%s",
-            str(code).zfill(6),
+            normalize_code(code),
             int(requested_qty),
             scope,
             allocations,
             int(sold_qty),
             int(prev_qty),
             int(broker_qty_after),
         )
         sold_total = apply_sell_allocation(
             lot_state,
             code,
             allocations,
             sell_ts,
             allow_blocked=allow_blocked,
         )
         after_qty_total = _ledger_total_available_qty(code)
         after_qty_strategy = (
             remaining_qty_for_strategy(lot_state, code, trigger_strategy_id)
             if scope == "strategy"
             else after_qty_total
         )
         expected_before = before_qty_strategy
         expected_after = max(0, int(expected_before) - int(sold_total))
         if after_qty_strategy != expected_after:
             resolved = False
             for delay_sec in (0.5, 1.0, 2.0):
                 time.sleep(delay_sec)
                 retry_sold = _estimate_sold_qty(code, requested_qty, prev_qty, delay_sec=0)
                 retry_expected = max(0, int(expected_before) - int(retry_sold))
                 if after_qty_strategy == retry_expected:
                     resolved = True
                     break
             if not resolved:
                 logger.warning(
                     "[SELL-ALLOC] ledger mismatch: code=%s sid=%s before=%s sold=%s after=%s"
                     % (
-                        str(code).zfill(6),
+                        normalize_code(code),
                         trigger_strategy_id,
                         expected_before,
                         sold_total,
                         after_qty_strategy,
                     )
                 )
                 try:
                     balances = _fetch_balances(kis, ttl_sec=0)
                 except TypeError:
                     balances = _fetch_balances(kis)
                 reconcile_with_broker_holdings(lot_state, balances)
         _maybe_save_lot_state(before_lot_signature)
         _sync_position_state_qty(code)
+        _save_position_state_now()
 
     def _cleanup_expired_pending(
         traded_state: dict, now_dt: datetime, ttl_sec: int = 300
     ) -> set:
         expired: set[str] = set()
         if not isinstance(traded_state, dict):
             return expired
 
         for code, payload in list(traded_state.items()):
             payload = payload or {}
             if payload.get("status") != "pending":
                 continue
 
             ts = payload.get("pending_since") or payload.get("buy_time")
             if not isinstance(ts, str):
                 continue
 
             try:
                 pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(
                     tzinfo=now_dt.tzinfo
                 )
                 if (now_dt - pending_dt).total_seconds() > ttl_sec:
                     logger.warning(
                         f"[PENDING-EXPIRE] {code}: {ttl_sec}s Ï¥àÍ≥º ‚Üí pending Ï†úÍ±∞"
                     )
@@ -727,51 +827,51 @@ def main(
             except Exception as e:
                 logger.warning(f"[REGIME-GUARD][LOAD] {day} Ïã§Ìå®: {e}")
         return state
 
     def _persist_guard_state(day: date) -> None:
         try:
             path = _guard_state_file(day)
             path.parent.mkdir(parents=True, exist_ok=True)
             payload = {"date": str(day), **guard_state}
             with open(path, "w", encoding="utf-8") as f:
                 json.dump(payload, f, ensure_ascii=False, indent=2)
         except Exception as e:
             logger.warning(f"[REGIME-GUARD][SAVE] {day} Ïã§Ìå®: {e}")
 
     def _ensure_guard_state(day: date) -> None:
         nonlocal guard_state_date, guard_state
         if guard_state_date != day:
             guard_state = _load_guard_state(day)
             guard_state_date = day
 
     def _guard_entry(
         bucket: str, day: date, code: str, strategy_id: int | str, base_qty: int
     ) -> dict:
         _ensure_guard_state(day)
         bucket_state = guard_state.setdefault(bucket, {})
-        key = f"{str(code).zfill(6)}:{strategy_id}"
+        key = f"{normalize_code(code)}:{strategy_id}"
         entry = bucket_state.get(key)
         if entry is None:
             entry = {"base_qty": int(base_qty), "sold": 0}
             bucket_state[key] = entry
             _persist_guard_state(day)
         elif BASE_QTY_MODE == "current":
             base_int = int(base_qty)
             if entry.get("base_qty") != base_int:
                 entry["base_qty"] = base_int
                 _persist_guard_state(day)
         return entry
 
     def _s1_guard_target(
         today_date, code: str, strategy_id: int | str, base_qty: int
     ) -> dict:
         return _guard_entry("s1_target", today_date, code, strategy_id, base_qty)
 
     def _s1_guard_nontarget(
         today_date, code: str, strategy_id: int | str, base_qty: int
     ) -> dict:
         return _guard_entry("s1_nontarget", today_date, code, strategy_id, base_qty)
 
     def _s2_guard_target(
         today_date, code: str, strategy_id: int | str, base_qty: int
     ) -> dict:
@@ -804,51 +904,51 @@ def main(
 
         ts = payload.get("pending_since") or payload.get("buy_time")
         if not isinstance(ts, str):
             return True
 
         try:
             pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(
                 tzinfo=now_dt.tzinfo
             )
             return (now_dt - pending_dt).total_seconds() <= block_sec
         except Exception:
             return True
 
     def _is_balance_reflected(
         code: str, prev_qty: int = 0, delay_sec: float = 1.0
     ) -> bool:
         try:
             time.sleep(delay_sec)
             balances = _fetch_balances(kis, ttl_sec=0)
         except Exception as e:
             logger.warning(f"[BAL-REFRESH-FAIL] {code}: ÏûîÍ≥† ÌôïÏù∏ Ïã§Ìå® {e}")
             return False
 
         for row in balances:
             try:
-                if str(row.get("code")).zfill(6) != str(code).zfill(6):
+                if normalize_code(row.get("code")) != normalize_code(code):
                     continue
                 qty_here = _to_int(row.get("qty") or 0)
                 sellable_here = _to_int(
                     (row.get("sell_psbl_qty") or row.get("ord_psbl_qty")) or 0
                 )
                 baseline_qty = max(0, int(prev_qty))
                 if qty_here > baseline_qty or sellable_here > baseline_qty:
                     return True
             except Exception:
                 continue
 
         return False
 
     def _subject_flow_gate(
         code: str,
         info: Dict[str, Any],
         current_price: float,
         target_price: float | None,
         vwap_val: float | None,
     ) -> tuple[bool, Dict[str, Any], float]:
         day_turnover_krw = _to_float(
             info.get("prev_turnover")
             or info.get("avg_turnover")
             or info.get("turnover"),
             0.0,
@@ -971,51 +1071,51 @@ def main(
             logger.info(
                 f"[REBALANCE] Ïù¥Î≤à Ï£º Î¶¨Î∞∏Îü∞Ïã± Ïã§Ìñâ Í∏∞Î°ù Ï†ÄÏû•({_this_iso_week_key()})"
             )
         else:
             logger.info(
                 "[REBALANCE] Ïù¥Î≤à Ï£º Ïù¥ÎØ∏ Ïã§ÌñâÎê® ‚Üí Ïã†Í∑ú Î¶¨Î∞∏Îü∞Ïã± ÏÉùÎûµ (Î≥¥Ïú† Í¥ÄÎ¶¨Îßå)"
             )
     else:
         # today/monthly Îì± Îã§Î•∏ ÏïµÏª§ Î™®ÎìúÎäî Í∏∞Ï°¥ Î∞©ÏãùÏúºÎ°ú Î∞îÎ°ú Ìò∏Ï∂ú
         targets = fetch_rebalancing_targets(rebalance_date)
 
     # === [NEW] ÏòàÏÇ∞ Í∞ÄÎìú: ÏòàÏàòÍ∏àÏù¥ 0/Î∂ÄÏ°±Ïù¥Î©¥ Ïã†Í∑ú Îß§ÏàòÎßå Ïä§ÌÇµ ===
     effective_cash = _get_effective_ord_cash(kis, soft_cap=effective_capital)
     if effective_cash <= 0:
         can_buy = False
         logger.warning("[BUDGET] Ïú†Ìö® ÏòàÏÇ∞ 0 ‚Üí Ïã†Í∑ú Îß§Ïàò Ïä§ÌÇµ(Î≥¥Ïú† Í¥ÄÎ¶¨Îßå ÏàòÌñâ)")
     else:
         can_buy = True
     logger.info(
         f"[BUDGET] today effective cash = {effective_cash:,} KRW (capital base={effective_capital:,})"
     )
 
     # Î¶¨Î∞∏Îü∞Ïã± ÎåÄÏÉÅ ÌõÑÏ≤òÎ¶¨: qty ÏóÜÍ≥† weightÎßå ÏûàÏúºÎ©¥ Î∞∞Ï†ï ÏûêÎ≥∏ÏúºÎ°ú ÏàòÎüâ Í≥ÑÏÇ∞
     processed_targets: Dict[str, Any] = {}
     for t in targets:
-        code = t.get("stock_code") or t.get("code")
+        code = normalize_code(t.get("stock_code") or t.get("code"))
         if not code:
             continue
         name = t.get("name") or t.get("Ï¢ÖÎ™©Î™Ö")
         k_best = t.get("best_k") or t.get("K") or t.get("k")
         target_price = _to_float(t.get("Î™©ÌëúÍ∞Ä") or t.get("target_price"))
         qty = _to_int(t.get("Îß§ÏàòÏàòÎüâ") or t.get("qty"), 0)
         weight = t.get("weight")
         strategy = t.get("strategy") or "Ï†ÑÏõî rolling K ÏµúÏ†ÅÌôî"
         strategy_id = _normalize_strategy_id(_derive_strategy_id(t))
         logger.info(
             "[STRATEGY_ID_TARGET] code=%s strategy=%s strategy_id=%s",
             code,
             strategy,
             strategy_id,
         )
         avg_return_pct = _to_float(t.get("avg_return_pct") or t.get("ÏàòÏùµÎ•†(%)"), 0.0)
         win_rate_pct = _to_float(t.get("win_rate_pct") or t.get("ÏäπÎ•†(%)"), 0.0)
         mdd_pct = _to_float(t.get("mdd_pct") or t.get("MDD(%)"), 0.0)
         trades = _to_int(t.get("trades"), 0)
         sharpe_m = _to_float(t.get("sharpe_m"), 0.0)
         cumret_pct = _to_float(
             t.get("cumulative_return_pct") or t.get("ÏàòÏùµÎ•†(%)"), 0.0
         )
 
         if qty <= 0 and weight is not None:
@@ -1259,51 +1359,51 @@ def main(
             stage,
             n_active,
             picked,
             f"{capital_active:,}",
         )
 
         logger.info(
             "[REBALANCE] Î†àÏßê=%s pct=%.2f%%, ÌõÑÎ≥¥ %dÍ∞ú Ï§ë ÏÉÅÏúÑ %dÏ¢ÖÎ™©Îßå ÏÑ†ÌÉù: %s",
             mode,
             pct_change,
             len(processed_targets),
             len(selected_targets),
             ",".join(selected_targets.keys()),
         )
 
         code_to_target: Dict[str, Any] = selected_targets
 
         # ÎàåÎ¶ºÎ™© Ïä§Ï∫îÏö© ÏΩîÏä§Îã• ÏãúÏ¥ù ÏÉÅÏúÑ Î¶¨Ïä§Ìä∏ (Ï±îÌîºÏñ∏Í≥º Î≥ÑÎèÑÎ°ú Í¥ÄÎ¶¨)
         pullback_watch: Dict[str, Dict[str, Any]] = {}
         if USE_PULLBACK_ENTRY:
             try:
                 pb_weight = max(0.0, min(PULLBACK_UNIT_WEIGHT, 1.0))
                 base_notional = int(round(capital_active * pb_weight))
                 pb_df = get_kosdaq_top_n(date_str=rebalance_date, n=PULLBACK_TOPN)
                 for _, row in pb_df.iterrows():
-                    code = str(row.get("Code") or row.get("code") or "").zfill(6)
+                    code = normalize_code(row.get("Code") or row.get("code") or "")
                     if not code:
                         continue
                     pullback_watch[code] = {
                         "code": code,
                         "name": row.get("Name") or row.get("name"),
                         "notional": base_notional,
                     }
                 logger.info(
                     f"[PULLBACK-WATCH] ÏΩîÏä§Îã• ÏãúÏ¥ù Top{PULLBACK_TOPN} {len(pullback_watch)}Ï¢ÖÎ™© Ïä§Ï∫î Ï§ÄÎπÑ"
                 )
             except Exception as e:
                 logger.warning(f"[PULLBACK-WATCH-FAIL] ÏãúÏ¥ù ÏÉÅÏúÑ Î°úÎìú Ïã§Ìå®: {e}")
 
         loop_sleep_sec = 2.5  # Î©îÏù∏ Î£®ÌîÑ ÎåÄÍ∏∞ ÏãúÍ∞Ñ(Ï¥à)
         max_closed_checks = 3
         closed_checks = 0
 
         try:
             while True:
                 # === ÏΩîÏä§Îã• Î†àÏßê ÏóÖÎç∞Ïù¥Ìä∏ ===
                 regime = _update_market_regime(kis)
                 regime_state = regime
                 pct_txt = (
                     f"{regime.get('pct_change'):.2f}%"
                     if regime.get("pct_change") is not None
@@ -1324,51 +1424,51 @@ def main(
                     s1_done_today.clear()
                     last_today_prefix = today_prefix
                 expired_pending = _cleanup_expired_pending(traded, now_dt_kst, ttl_sec=300)
                 if expired_pending:
                     triggered_today.difference_update(expired_pending)
                 traded_today: set[str] = set()
                 regime_s1_summary = {
                     "sent_qty": 0,
                     "sent_orders": 0,
                     "skipped": 0,
                     "total_qty": 0,
                     "by_stock": {},
                 }
 
                 def _log_s1_action(
                     code: str,
                     strategy_id: int | str,
                     status: str,
                     base_qty: int,
                     target_qty: int,
                     sold_today: int,
                     remaining: int,
                     sell_qty: int,
                     reason_msg: str | None = None,
                 ) -> None:
-                    key = f"{str(code).zfill(6)}:{strategy_id}"
+                    key = f"{normalize_code(code)}:{strategy_id}"
                     regime_s1_summary["by_stock"][key] = {
                         "status": status,
                         "base_qty": int(base_qty),
                         "target": int(target_qty),
                         "sold_today": int(sold_today),
                         "remaining": int(remaining),
                         "sell_qty": int(sell_qty),
                         "reason": reason_msg or None,
                     }
                     prefix = (
                         "[SELL][SENT]"
                         if status == "SENT"
                         else "[SELL][SKIP]" if status == "SKIP" else "[SELL][ERROR]"
                     )
                     msg = (
                         f"{prefix} [REGIME_S1] {code}:{strategy_id} base_qty={base_qty} target={target_qty} "
                         f"sold={sold_today} remaining={remaining} sell_qty={sell_qty}"
                     )
                     if reason_msg:
                         msg += f" reason={reason_msg}"
                     if status == "ERROR":
                         logger.error(msg)
                     else:
                         logger.info(msg)
 
@@ -1378,56 +1478,56 @@ def main(
                     status: str,
                     base_qty: int,
                     target_qty: int,
                     sold_today: int,
                     remaining: int,
                     sell_qty: int,
                     reason_msg: str | None = None,
                 ) -> None:
                     prefix = (
                         "[SELL][SENT]"
                         if status == "SENT"
                         else "[SELL][SKIP]" if status == "SKIP" else "[SELL][ERROR]"
                     )
                     msg = (
                         f"{prefix} [REGIME_S2] {code}:{strategy_id} base_qty={base_qty} target={target_qty} "
                         f"sold={sold_today} remaining={remaining} sell_qty={sell_qty}"
                     )
                     if reason_msg:
                         msg += f" reason={reason_msg}"
                     if status == "ERROR":
                         logger.error(msg)
                     else:
                         logger.info(msg)
 
                 def _strategy_ids_for_code(code: str) -> list[str]:
-                    code_key = str(code).zfill(6)
+                    code_key = normalize_code(code)
                     totals: dict[str, int] = {}
                     lots = lot_state.get("lots", [])
                     if isinstance(lots, list):
                         for lot in lots:
-                            if str(lot.get("pdno")).zfill(6) != code_key:
+                            if normalize_code(lot.get("pdno")) != code_key:
                                 continue
                             remaining = int(lot.get("remaining_qty") or 0)
                             if remaining <= 0:
                                 continue
                             sid = lot.get("strategy_id")
                             if sid is None:
                                 continue
                             if str(sid).isdigit():
                                 sid_int = int(sid)
                                 if 1 <= sid_int <= 5:
                                     totals[str(sid_int)] = totals.get(str(sid_int), 0) + remaining
                     ordered: list[str] = []
                     for sid in STRATEGY_REDUCTION_PRIORITY:
                         key = str(sid)
                         if key in totals:
                             ordered.append(key)
                     for sid in sorted(totals.keys()):
                         if sid not in ordered:
                             ordered.append(sid)
                     return ordered
 
                 def _run_bear_reduction(
                     code: str,
                     *,
                     is_target: bool,
@@ -1453,51 +1553,51 @@ def main(
                                 if is_target
                                 else _s1_guard_nontarget(now_dt_kst.date(), code, sid, remaining_strategy)
                             )
                             base_qty = int(guard.get("base_qty") or 0)
                             if base_qty <= 0:
                                 regime_s1_summary["skipped"] += 1
                                 _log_s1_action(
                                     code,
                                     sid,
                                     "SKIP",
                                     base_qty,
                                     0,
                                     int(guard.get("sold", 0)),
                                     0,
                                     0,
                                     "base_qty_zero",
                                 )
                             else:
                                 target_qty = max(1, int(base_qty * REG_PARTIAL_S1))
                                 sold_today = int(guard.get("sold", 0))
                                 remaining = max(0, target_qty - sold_today)
 
                                 if remaining <= 0 or sellable_qty <= 0:
                                     if remaining <= 0:
                                         _set_position_flags(code, sid, bear_s1_done=True)
-                                        s1_done_today.add((str(code).zfill(6), str(sid)))
+                                        s1_done_today.add((normalize_code(code), str(sid)))
                                     regime_s1_summary["skipped"] += 1
                                     _log_s1_action(
                                         code,
                                         sid,
                                         "SKIP",
                                         base_qty,
                                         target_qty,
                                         sold_today,
                                         remaining,
                                         0,
                                         "target_met" if remaining <= 0 else "no_sellable_qty",
                                     )
                                 else:
                                     sell_qty = min(remaining, sellable_qty, remaining_strategy)
                                     sell_qty = _cap_sell_qty(code, sell_qty)
                                     if sell_qty <= 0:
                                         regime_s1_summary["skipped"] += 1
                                         _log_s1_action(
                                             code,
                                             sid,
                                             "SKIP",
                                             base_qty,
                                             target_qty,
                                             sold_today,
                                             remaining,
@@ -1542,51 +1642,51 @@ def main(
                                                 sid,
                                                 int(sell_qty),
                                                 float(exec_px or 0.0),
                                                 now_dt_kst.isoformat(),
                                                 status="submitted",
                                             )
                                             _save_runtime_state()
                                         status, skip_reason = _sell_result_status(result)
                                     except Exception as e:
                                         exec_px, result = None, None
                                         status, skip_reason = "ERROR", str(e)
 
                                     reason_msg = skip_reason or (
                                         "ÏãúÏû•ÏïΩÏÑ∏ 1Îã®Í≥Ñ Ï∂ïÏÜå"
                                         if is_target
                                         else "ÏãúÏû•ÏïΩÏÑ∏ 1Îã®Í≥Ñ Ï∂ïÏÜå(ÎπÑÌÉÄÍ≤ü)"
                                     )
 
                                     if status == "SENT":
                                         guard["sold"] = sold_today + int(sell_qty)
                                         holding[code]["qty"] = max(
                                             0, holding[code]["qty"] - int(sell_qty)
                                         )
                                         if guard["sold"] >= target_qty:
                                             _set_position_flags(code, sid, bear_s1_done=True)
-                                            s1_done_today.add((str(code).zfill(6), str(sid)))
+                                            s1_done_today.add((normalize_code(code), str(sid)))
                                         _persist_guard_state(now_dt_kst.date())
                                         regime_s1_summary["sent_qty"] += int(sell_qty)
                                         regime_s1_summary["sent_orders"] += 1
                                         trade_payload = {
                                             "datetime": now_str,
                                             "code": code,
                                             "name": None,
                                             "qty": int(sell_qty),
                                             "K": holding[code].get("k_value"),
                                             "target_price": holding[code].get("target_price_src"),
                                             "strategy": "Î†àÏßêÏ∂ïÏÜå" if is_target else "Í∏∞Ï°¥Î≥¥Ïú† Îä•ÎèôÍ¥ÄÎ¶¨",
                                             "side": "SELL",
                                             "price": exec_px,
                                             "amount": int((exec_px or 0)) * int(sell_qty),
                                             "reason": reason_msg,
                                         }
                                         if result is not None:
                                             trade_payload["result"] = result
                                         log_trade(trade_payload)
                                         _apply_sell_to_ledger_with_balance(
                                             code,
                                             int(sell_qty),
                                             now_dt_kst.isoformat(),
                                             result,
                                             scope="strategy",
@@ -1618,54 +1718,54 @@ def main(
                                         status,
                                         base_qty,
                                         target_qty,
                                         sold_today,
                                         remaining,
                                         sell_qty,
                                         reason_msg,
                                     )
 
                         if regime.get("bear_stage", 0) >= 2:
                             if flags.get("bear_s2_done"):
                                 continue
                             if not flags.get("bear_s1_done"):
                                 _log_s2_action(
                                     code,
                                     sid,
                                     "SKIP",
                                     int(remaining_strategy),
                                     0,
                                     0,
                                     0,
                                     0,
                                     "s1_not_done",
                                 )
                                 continue
-                            if (str(code).zfill(6), str(sid)) in s1_done_today:
+                            if (normalize_code(code), str(sid)) in s1_done_today:
                                 logger.warning(
                                     "[REGIME_S2][SEQ] %s:%s ÎèôÏùº ÏùºÏûê S1 ÏôÑÎ£å ÏßÅÌõÑ S2 ÏßÑÏûÖ",
-                                    str(code).zfill(6),
+                                    normalize_code(code),
                                     sid,
                                 )
                             sellable_qty = ord_psbl_map.get(code, 0)
                             remaining_strategy_stage2 = remaining_qty_for_strategy(
                                 lot_state, code, sid
                             )
                             guard = (
                                 _s2_guard_target(
                                     now_dt_kst.date(), code, sid, remaining_strategy_stage2
                                 )
                                 if is_target
                                 else _s2_guard_nontarget(
                                     now_dt_kst.date(), code, sid, remaining_strategy_stage2
                                 )
                             )
                             base_qty = int(guard.get("base_qty") or 0)
                             if base_qty <= 0:
                                 _log_s2_action(
                                     code,
                                     sid,
                                     "SKIP",
                                     base_qty,
                                     0,
                                     int(guard.get("sold", 0)),
                                     0,
@@ -1861,102 +1961,108 @@ def main(
                             )
                             break
                         logger.info(
                             "[CLOSED] Ïû•Ï§ëÏù∏Îç∞ APIÍ∞Ä Îã´Ìûò ÏùëÎãµ ‚Üí 10Ï¥à ÎåÄÍ∏∞ ÌõÑ Ïû¨ÌôïÏù∏ (%s/%s)",
                             closed_checks,
                             max_closed_checks,
                         )
                         time.sleep(10)
                         continue
                     else:
                         logger.warning(
                             "[CLOSED-DATA] Ïû• Ï¢ÖÎ£åÏßÄÎßå ÌôòÍ≤ΩÏÑ§Ï†ï ÌóàÏö© ‚Üí ÏãúÏÑ∏ Ï°∞Ìöå ÌõÑ ÏßÑÌñâ"
                         )
                 else:
                     closed_checks = 0
 
                 if kis.should_cooldown(now_dt_kst):
                     logger.warning("[COOLDOWN] 2Ï¥àÍ∞Ñ ÎåÄÍ∏∞ (API Ï†úÌïú Î≥¥Ìò∏)")
                     time.sleep(2)
 
                 # ÏûîÍ≥† Í∞ÄÏ†∏Ïò§Í∏∞
                 prev_holding = holding if isinstance(holding, dict) else {}
                 balances = _fetch_balances(kis)
                 holding = {}
                 for bal in balances:
-                    code = bal.get("code")
+                    code = normalize_code(bal.get("code") or bal.get("pdno"))
                     qty = int(bal.get("qty", 0))
                     if qty <= 0:
                         continue
                     price = float(bal.get("avg_price", 0.0))
                     holding[code] = {
                         "qty": qty,
                         "buy_price": price,
                         "bear_s1_done": False,
                         "bear_s2_done": False,
                     }
                     _init_position_state_from_balance(kis, holding, code, price, qty)
 
                 before_lot_signature = _lot_state_signature(lot_state)
                 reconcile_with_broker_holdings(lot_state, balances)
                 _maybe_save_lot_state(before_lot_signature)
 
                 position_state = reconcile_with_broker(
                     position_state, balances, lot_state=lot_state
                 )
+                position_state = reconcile_positions(
+                    balances, position_state, _load_trade_log(), processed_targets.keys()
+                )
                 position_state_dirty = True
 
                 for code, info in holding.items():
-                    pos_state = position_state.get("positions", {}).get(str(code).zfill(6))
+                    pos_state = position_state.get("positions", {}).get(normalize_code(code))
                     if not isinstance(pos_state, dict):
                         continue
                     strategies = pos_state.get("strategies", {})
                     if not strategies:
-                        _ensure_position_entry(code, "ORPHAN")
+                        _ensure_position_entry(code, "MANUAL")
                         position_state_dirty = True
                         strategies = pos_state.get("strategies", {})
                     entry = next(iter(strategies.values()), None)
                     if not isinstance(entry, dict):
                         continue
                     meta = entry.get("meta", {})
                     info["engine"] = entry.get("entry", {}).get("engine") or info.get("engine")
                     info["pullback_peak_price"] = meta.get("pullback_peak_price")
                     info["pullback_reversal_price"] = meta.get("pullback_reversal_price")
 
                 # ÏûîÍ≥† Í∏∞Ï§ÄÏúºÎ°ú Î≥¥Ïú†Ï¢ÖÎ™© Îß§ÎèÑ Í∞ÄÎä• ÏàòÎüâ Îßµ ÏÉùÏÑ±
                 ord_psbl_map = {
-                    bal.get("code"): int(bal.get("sell_psbl_qty", 0)) for bal in balances
+                    normalize_code(bal.get("code") or bal.get("pdno")): int(
+                        bal.get("sell_psbl_qty", 0)
+                    )
+                    for bal in balances
                 }
 
                 if isinstance(traded, dict):
                     for code, payload in list(traded.items()):
                         if (payload or {}).get("status") == "pending" and code in holding:
                             traded[code]["status"] = "filled"
 
                 traded_today = _traded_today(traded, today_prefix)
                 for bal in balances:
-                    code = bal.get("code")
+                    code = normalize_code(bal.get("code") or bal.get("pdno"))
                     raw = bal.get("raw") or {}
                     raw_l = {str(k).lower(): v for k, v in raw.items()}
                     thdt_buy_qty = _to_int(
                         raw_l.get("thdt_buyqty")
                         or raw_l.get("thdt_buy_qty")
                         or raw_l.get("thdt_buy_q")
                     )
                     if thdt_buy_qty > 0:
                         traded_today.add(code)
 
                 if not ALLOW_PYRAMID:
                     traded_today.update(holding.keys())
 
                 for code, info in list(holding.items()):
                     prev_qty = int(
                         (prev_holding.get(code) or {}).get("qty", info.get("qty", 0))
                     )
                     balance_qty = int(info.get("qty", 0))
                     # ÏûîÍ≥†Í∞Ä ÏùºÏãúÏ†ÅÏúºÎ°ú Ï§ÑÏñ¥Îì† ÏºÄÏù¥Ïä§Îßå Î≥¥Ìò∏ÌïòÍ≥†, Ï†ïÏÉÅÏ†ÅÏù∏ ÏàòÎüâ Ï¶ùÍ∞ÄÎäî Ïú†ÏßÄÌïúÎã§.
                     if prev_qty > 0 and 0 < balance_qty < prev_qty:
                         holding[code]["qty"] = prev_qty
                         logger.info(
                             f"[HOLDING-QTY-CLAMP] {code}: balance_qty={balance_qty} prev_qty={prev_qty} ‚Üí {prev_qty}"
                         )
 
@@ -2060,83 +2166,83 @@ def main(
                             allow_blocked=FORCE_SELL_BLOCKED_LOTS,
                         )
                         runtime_state_store.mark_fill(
                             runtime_state,
                             code,
                             "SELL",
                             "GLOBAL",
                             int(qty),
                             float(exec_px or 0.0),
                             now_dt_kst.isoformat(),
                             status="filled",
                         )
                         _save_runtime_state()
                         time.sleep(RATE_SLEEP_SEC)
                     for _ in range(pass_count - 1):
                         logger.info(
                             f"[Ïª§Ìä∏Ïò§ÌîÑ Ï∂îÍ∞ÄÌå®Ïä§] {pass_count}Ìöå Ï§ë ÎÇ®ÏùÄ Ìå®Ïä§ Ïã§Ìñâ (ÏûîÍ≥†Î≥ÄÎèô Í∞êÏßÄÏö©)"
                         )
                         time.sleep(loop_sleep_sec)
                         continue
                     logger.info("[‚è∞ Ïª§Ìä∏Ïò§ÌîÑ Ï¢ÖÎ£å] Î£®ÌîÑ Ï¢ÖÎ£å")
                     break
 
                 # === (1) ÏûîÏó¨ Î¨ºÎüâ ÎåÄÏÉÅ Ïä§ÌÉë/Î¶¨Î∞∏Îü∞Ïä§ Í¥ÄÎ¶¨ ===
                 for code in list(holding.keys()):
-                    pos_state = position_state.get("positions", {}).get(str(code).zfill(6))
-                    if isinstance(pos_state, dict):
-                        entries = pos_state.get("strategies", {})
-                        entry_ids = ",".join(sorted(entries.keys())) if entries else "ORPHAN"
-                        logger.info(
-                            "[EXIT-CHECK] code=%s strategies=%s",
-                            str(code).zfill(6),
-                            len(entries),
-                        )
-                        if entries:
-                            for sid, entry in entries.items():
-                                if not isinstance(entry, dict):
-                                    continue
-                                avg_price = strategy_avg_price(lot_state, code, sid)
-                                entry_meta = entry.get("meta", {}) or {}
-                                high = float(entry_meta.get("high") or 0.0)
-                                if avg_price is not None:
-                                    high = max(high, float(avg_price))
-                                flags = entry.get("flags", {}) or {}
-                                avg_label = f"{avg_price:.2f}" if avg_price is not None else None
-                                high_label = f"{high:.2f}" if high else None
-                                logger.info(
-                                    "  - sid=%s qty=%s avg=%s high=%s flags=%s",
-                                    sid,
-                                    entry.get("qty"),
-                                    avg_label,
-                                    high_label,
-                                    flags,
-                                )
-                    else:
+                    code_key = normalize_code(code)
+                    pos_state = position_state.get("positions", {}).get(code_key)
+                    entries = pos_state.get("strategies", {}) if isinstance(pos_state, dict) else {}
+                    logger.info(
+                        "[EXIT-CHECK] code=%s positions=%s",
+                        code_key,
+                        len(entries),
+                    )
+                    cur_price = _safe_get_price(kis, code_key)
+                    for sid, entry in entries.items():
+                        if not isinstance(entry, dict):
+                            continue
+                        avg_price = strategy_avg_price(lot_state, code_key, sid)
+                        entry_meta = entry.get("meta", {}) or {}
+                        high = float(entry.get("high_watermark") or entry_meta.get("high") or 0.0)
+                        if avg_price is not None:
+                            high = max(high, float(avg_price))
+                        flags = entry.get("flags", {}) or {}
+                        avg_label = f"{avg_price:.2f}" if avg_price is not None else None
+                        high_label = f"{high:.2f}" if high else None
+                        pnl_pct = None
+                        if cur_price and avg_price:
+                            pnl_pct = (float(cur_price) - float(avg_price)) / float(avg_price) * 100.0
+                        pnl_label = f"{pnl_pct:.2f}" if pnl_pct is not None else None
                         logger.info(
-                            "[EXIT-CHECK] code=%s strategy=ORPHAN engine=unknown flags=bear_s1_done=False bear_s2_done=False source=ORPHAN_POSITION",
-                            str(code).zfill(6),
+                            "  - sid=%s qty=%s avg=%s high=%s pnl%%=%s flags=%s engine=%s",
+                            sid,
+                            entry.get("qty"),
+                            avg_label,
+                            high_label,
+                            pnl_label,
+                            flags,
+                            entry.get("engine") or entry.get("entry", {}).get("engine"),
                         )
                     # Ïã†Í∑ú ÏßÑÏûÖ Í∏àÏßÄ Î™®Îìú
                     if code not in code_to_target:
                         continue
 
                     # --- 1a) Í∞ïÏ†ú Î†àÏßêÎ≥Ñ Ï∂ïÏÜå Î°úÏßÅ ---
                     sellable_qty = ord_psbl_map.get(code, 0)
                     if sellable_qty <= 0:
                         continue
 
                     regime_key = regime.get("key")
                     mode = regime.get("mode")
                     if regime_key and regime_key[0] == "bear":
                         _run_bear_reduction(code, is_target=True, regime=regime)
 
                     # --- 1b) TP/SL/Ìä∏Î†àÏùºÎßÅ, VWAP Í∞ÄÎìú ---
                     try:
                         exit_intents = _build_exit_intents(
                             code, mode or "neutral"
                         )
                     except Exception as e:
                         logger.error(f"[_adaptive_exit Ïã§Ìå®] {code}: {e}")
                         exit_intents = []
 
                     for intent in exit_intents:
@@ -2353,51 +2459,51 @@ def main(
                     ) > 0:
                         logger.info(
                             "[ENTRY-SKIP] already owned in ledger: code=%s sid=%s",
                             code,
                             strategy_id,
                         )
                         continue
 
                     if _pending_block(traded, code, now_dt_kst, block_sec=45):
                         logger.info(
                             f"[SKIP-PENDING] {code}: pending Ïø®Îã§Ïö¥ Ï§ë ‚Üí Ïû¨Ï£ºÎ¨∏ Î∞©ÏßÄ"
                         )
                         continue
                     if runtime_state_store.should_block_order(
                         runtime_state, code, "BUY", now_dt_kst.isoformat()
                     ):
                         logger.info(
                             "[IDEMPOTENT-SKIP] %s BUY blocked within window",
                             code,
                         )
                         continue
 
                     prev_price = (
                         position_state.get("memory", {})
                         .get("last_price", {})
-                        .get(str(code).zfill(6))
+                        .get(normalize_code(code))
                     )
                     if prev_price is None:
                         try:
                             cached = signals._LAST_PRICE_CACHE.get(code) or {}
                             ts = cached.get("ts")
                             if ts and (time.time() - float(ts) <= 120):
                                 prev_price = cached.get("px")
                         except Exception:
                             prev_price = None
 
                     price_res = _safe_get_price(kis, code, with_source=True)
                     if isinstance(price_res, tuple):
                         current_price, price_source = price_res
                     else:
                         current_price, price_source = price_res, None
 
                     if not current_price or current_price <= 0:
                         logger.warning(f"[PRICE_FAIL] {code}: ÌòÑÏû¨Í∞Ä Ï°∞Ìöå Ïã§Ìå® ‚Üí Ïä§ÌÇµ")
                         continue
 
                     _update_last_price_memory(code, float(current_price), now_dt_kst.isoformat())
 
                     # === GOOD/BAD ÌÉÄÏ†ê ÌèâÍ∞Ä ===
                     daily_ctx = _compute_daily_entry_context(
                         kis, code, current_price, price_source
@@ -2663,50 +2769,51 @@ def main(
 
                     _init_position_state(
                         kis,
                         holding,
                         code,
                         float(exec_price),
                         int(qty),
                         k_value,
                         target_price,
                     )
                     position_state = record_entry_state(
                         state=position_state,
                         code=code,
                         qty=int(qty),
                         avg_price=float(exec_price),
                         strategy_id=strategy_id,
                         engine=trigger_label,
                         entry_reason="SETUP-OK + TRIGGER-YES",
                         order_type="marketable_limit",
                         best_k=k_value,
                         tgt_px=target_price,
                         gap_pct_at_entry=trigger_state.get("gap_pct"),
                         entry_time=now_dt_kst.isoformat(),
                     )
                     position_state_dirty = True
+                    _save_position_state_now()
 
                     lot_id = _build_lot_id(
                         result,
                         now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
                         code,
                     )
                     before_lot_signature = _lot_state_signature(lot_state)
                     record_buy_fill(
                         lot_state,
                         lot_id=lot_id,
                         pdno=code,
                         strategy_id=strategy_id,
                         engine=f"legacy_kosdaq_runner:sid{strategy_id}",
                         entry_ts=now_dt_kst.isoformat(),
                         entry_price=float(exec_price),
                         qty=int(qty),
                         meta={
                             "strategy_name": strategy,
                             "entry_reason": str(gate.get("entry_reason") or "SETUP-OK") + " + TRIGGER-YES",
                             "strategy_gate": gate,
                             "k": k_value,
                             "target_price": target_price,
                             "best_k": k_value,
                             "tgt_px": target_price,
                             "engine": "legacy_kosdaq_runner",
@@ -2966,50 +3073,51 @@ def main(
                                 logger.warning(f"[PULLBACK-INIT-FAIL] {code}: {e}")
 
                             pullback_meta = {}
                             if isinstance(resp, dict):
                                 pullback_meta = {
                                     "pullback_peak_price": resp.get("peak_price"),
                                     "pullback_reversal_price": resp.get("reversal_price"),
                                     "pullback_reason": resp.get("reason"),
                                 }
                             position_state = record_entry_state(
                                 state=position_state,
                                 code=code,
                                 qty=int(qty),
                                 avg_price=float(exec_price),
                                 strategy_id=5,
                                 engine="pullback",
                                 entry_reason="PULLBACK-SETUP + REVERSAL",
                                 order_type="marketable_limit",
                                 best_k=None,
                                 tgt_px=trigger_price,
                                 gap_pct_at_entry=None,
                                 meta=pullback_meta,
                                 entry_time=now_dt_kst.isoformat(),
                             )
                             position_state_dirty = True
+                            _save_position_state_now()
 
                             lot_id = _build_lot_id(
                                 result,
                                 now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
                                 code,
                             )
                             before_lot_signature = _lot_state_signature(lot_state)
                             record_buy_fill(
                                 lot_state,
                                 lot_id=lot_id,
                                 pdno=code,
                                 strategy_id=5,
                                 engine=f"legacy_kosdaq_runner:sid{strategy_id}",
                                 entry_ts=now_dt_kst.isoformat(),
                                 entry_price=float(exec_price),
                                 qty=int(qty),
                                 meta={
                                     "strategy_name": f"ÏΩîÏä§Îã• Top{PULLBACK_TOPN} ÎàåÎ¶ºÎ™©",
                                     "entry_reason": "PULLBACK-SETUP + REVERSAL",
                                     "k": None,
                                     "target_price": trigger_price,
                                     "best_k": None,
                                     "tgt_px": trigger_price,
                                     "pullback_peak_price": resp.get("peak_price")
                                     if isinstance(resp, dict)
diff --git a/trader/position_state_store.py b/trader/position_state_store.py
index 650ec9a33134bee89c1c4c20ba63b81511d36b1c..40eea91801b5e681a7a4bc3a114f09298a698873 100644
--- a/trader/position_state_store.py
+++ b/trader/position_state_store.py
@@ -1,109 +1,133 @@
 from __future__ import annotations
 
 import json
 import logging
 import os
 from datetime import datetime
 from pathlib import Path
+import re
 from typing import Any, Dict, Iterable
 
 from .config import KST
+from .code_utils import normalize_code
 
 logger = logging.getLogger(__name__)
 
 SCHEMA_VERSION = 2
 
 
 def _empty_state() -> Dict[str, Any]:
     return {
         "schema_version": SCHEMA_VERSION,
         "updated_at": None,
         "positions": {},
         "memory": {"last_price": {}, "last_seen": {}},
     }
 
 
 def _coerce_state(state: Dict[str, Any]) -> Dict[str, Any]:
     if not isinstance(state, dict):
         return _empty_state()
     state["schema_version"] = SCHEMA_VERSION
     state.setdefault("updated_at", None)
     positions = state.get("positions")
     if not isinstance(positions, dict):
         positions = {}
         state["positions"] = positions
     memory = state.get("memory")
     if not isinstance(memory, dict):
         memory = {}
         state["memory"] = memory
     memory.setdefault("last_price", {})
     memory.setdefault("last_seen", {})
     for code, payload in list(positions.items()):
+        code_key = normalize_code(code)
+        if code_key and code_key != code:
+            positions.pop(code, None)
+            positions[code_key] = payload
+        elif not code_key:
+            positions.pop(code, None)
+            continue
         if not isinstance(payload, dict):
-            positions[code] = {"strategies": {}}
+            positions[code_key] = {"strategies": {}}
             continue
         if "strategies" not in payload and "entries" in payload:
             entries = payload.get("entries") or {}
             flags = payload.get("flags") or {}
             strategies: Dict[str, Any] = {}
             if isinstance(entries, dict):
                 for sid, entry in entries.items():
                     if not isinstance(entry, dict):
                         continue
                     strategies[str(sid)] = {
                         "qty": int(entry.get("qty") or 0),
                         "avg_price": float(entry.get("avg_price") or 0.0),
                         "entry": entry.get("entry") or {},
                         "meta": entry.get("meta") or {},
                         "flags": {
                             "bear_s1_done": bool(flags.get("bear_s1_done", False)),
                             "bear_s2_done": bool(flags.get("bear_s2_done", False)),
                             "sold_p1": bool(entry.get("sold_p1", False)),
                             "sold_p2": bool(entry.get("sold_p2", False)),
                         },
                     }
-            positions[code] = {"strategies": strategies}
+            positions[code_key] = {"strategies": strategies}
         else:
             payload.setdefault("strategies", {})
-        strategies = positions[code].get("strategies")
+        strategies = positions[code_key].get("strategies")
         if not isinstance(strategies, dict):
-            positions[code]["strategies"] = {}
-            strategies = positions[code]["strategies"]
+            positions[code_key]["strategies"] = {}
+            strategies = positions[code_key]["strategies"]
         for sid, entry in list(strategies.items()):
             if not isinstance(entry, dict):
                 strategies.pop(sid, None)
                 continue
+            if sid in {"ORPHAN", "UNKNOWN"}:
+                strategies.pop(sid, None)
+                sid = "MANUAL"
+                strategies.setdefault(sid, entry)
             entry.setdefault("qty", 0)
             entry.setdefault("avg_price", 0.0)
             entry.setdefault("entry", {})
             entry.setdefault("meta", {})
             meta = entry["meta"]
             avg_price = float(entry.get("avg_price") or 0.0)
             if not meta.get("high") or float(meta.get("high") or 0.0) <= 0:
                 meta["high"] = avg_price
             meta["high"] = max(float(meta.get("high") or 0.0), avg_price)
+            entry.setdefault("code", code_key)
+            entry.setdefault("sid", str(sid))
+            entry.setdefault("engine", entry.get("entry", {}).get("engine"))
+            entry.setdefault("entry_ts", entry.get("entry", {}).get("time"))
+            entry.setdefault("high_watermark", float(meta.get("high") or avg_price))
+            entry["high_watermark"] = max(
+                float(entry.get("high_watermark") or 0.0),
+                float(meta.get("high") or 0.0),
+                avg_price,
+            )
+            entry.setdefault("last_update_ts", entry.get("entry", {}).get("time"))
             entry.setdefault(
                 "flags",
                 {"bear_s1_done": False, "bear_s2_done": False, "sold_p1": False, "sold_p2": False},
             )
     return state
 
 
 def migrate_position_state(state: Dict[str, Any]) -> Dict[str, Any]:
     if not isinstance(state, dict):
         return _empty_state()
     schema_version = int(state.get("schema_version") or 1)
     if schema_version >= SCHEMA_VERSION:
         return state
     positions = state.get("positions")
     if not isinstance(positions, dict):
         state["positions"] = {}
         state["schema_version"] = SCHEMA_VERSION
         return state
     for code, payload in list(positions.items()):
         if not isinstance(payload, dict):
             positions[code] = {"strategies": {}}
             continue
         if "strategies" in payload:
             continue
         entries = payload.get("entries") or {}
@@ -176,202 +200,388 @@ def load_position_state(path: str) -> Dict[str, Any]:
         )
         return state
     except json.JSONDecodeError:
         logger.warning("[STATE] corrupted json, backing up: %s", path_obj)
         _backup_corrupt(path_obj)
         return _empty_state()
     except Exception:
         logger.exception("[STATE] failed to load %s", path_obj)
         return _empty_state()
 
 
 def save_position_state(path: str, state: Dict[str, Any]) -> None:
     path_obj = Path(path)
     try:
         path_obj.parent.mkdir(parents=True, exist_ok=True)
         payload = _coerce_state(dict(state))
         payload["updated_at"] = datetime.now(KST).isoformat()
         tmp_path = path_obj.with_name(f"{path_obj.name}.tmp")
         with open(tmp_path, "w", encoding="utf-8") as f:
             json.dump(payload, f, ensure_ascii=False, indent=2)
         os.replace(tmp_path, path_obj)
     except Exception:
         logger.exception("[STATE] failed to save %s", path_obj)
 
 
-def _normalize_code(value: Any) -> str:
-    text = str(value or "").strip()
-    return text.zfill(6) if text else ""
-
-
 def _orphan_entry(code: str, qty: int, avg_price: float | None) -> Dict[str, Any]:
     now_ts = datetime.now(KST).isoformat()
     return {
         "qty": int(qty),
         "avg_price": float(avg_price or 0.0),
         "entry": {
             "time": now_ts,
-            "strategy_id": "ORPHAN",
+            "strategy_id": "MANUAL",
             "engine": "unknown",
             "entry_reason": "RECONCILE",
             "order_type": "unknown",
             "best_k": None,
             "tgt_px": None,
             "gap_pct_at_entry": None,
         },
         "meta": {
             "pullback_peak_price": None,
             "pullback_reversal_price": None,
             "pullback_reason": None,
         },
+        "code": code,
+        "sid": "MANUAL",
+        "engine": "unknown",
+        "entry_ts": now_ts,
+        "high_watermark": float(avg_price or 0.0),
+        "last_update_ts": now_ts,
     }
 
 
 def reconcile_with_broker(
     state: Dict[str, Any],
     broker_positions: Iterable[Dict[str, Any]],
     *,
     lot_state: Dict[str, Any],
 ) -> Dict[str, Any]:
     from .ledger import remaining_qty_for_strategy
 
     state = _coerce_state(state)
     positions = state["positions"]
     memory = state["memory"]
 
     broker_map: Dict[str, Dict[str, Any]] = {}
     for row in broker_positions:
-        code = _normalize_code(row.get("code") or row.get("pdno") or "")
+        code = normalize_code(row.get("code") or row.get("pdno") or "")
         if not code:
             continue
         qty = int(row.get("qty") or 0)
         if qty <= 0:
             continue
         broker_map[code] = {
             "qty": qty,
             "avg_price": row.get("avg_price"),
         }
 
     def _strategies_for_code(code: str) -> Dict[str, int]:
         strategies: Dict[str, int] = {}
         lots = lot_state.get("lots", [])
         if not isinstance(lots, list):
             return strategies
         for lot in lots:
-            if _normalize_code(lot.get("pdno")) != code:
+            if normalize_code(lot.get("pdno")) != code:
                 continue
             remaining = int(lot.get("remaining_qty") or 0)
             if remaining <= 0:
                 continue
             sid = lot.get("strategy_id")
             if sid is None:
                 continue
             key = str(sid)
             strategies[key] = strategies.get(key, 0) + remaining
         return strategies
 
     active_codes = set()
     for code in set(list(broker_map.keys()) + list(positions.keys())):
-        code_key = _normalize_code(code)
+        code_key = normalize_code(code)
         strategies = _strategies_for_code(code_key)
         if not strategies and broker_map.get(code_key):
             orphan_qty = int(broker_map[code_key].get("qty") or 0)
             if orphan_qty > 0:
-                strategies = {"ORPHAN": orphan_qty}
+                strategies = {"MANUAL": orphan_qty}
                 logger.warning(
-                    "[STATE] broker has qty but ledger empty: code=%s qty=%s -> ORPHAN",
+                    "[STATE] broker has qty but ledger empty: code=%s qty=%s -> MANUAL",
                     code_key,
                     orphan_qty,
                 )
         if not strategies:
             positions.pop(code_key, None)
             memory.get("last_price", {}).pop(code_key, None)
             memory.get("last_seen", {}).pop(code_key, None)
             continue
 
         pos = positions.setdefault(code_key, {"strategies": {}})
         entries = pos.setdefault("strategies", {})
         for sid, entry in list(entries.items()):
             if sid not in strategies:
                 entries.pop(sid, None)
                 continue
             if not isinstance(entry, dict):
                 entries.pop(sid, None)
                 continue
             ledger_qty = int(remaining_qty_for_strategy(lot_state, code_key, sid))
             if int(entry.get("qty") or 0) > ledger_qty:
                 logger.warning(
                     "[STATE] qty exceeds ledger: code=%s sid=%s state=%s ledger=%s",
                     code_key,
                     sid,
                     entry.get("qty"),
                     ledger_qty,
                 )
                 entry["qty"] = int(ledger_qty)
 
         for sid, qty in strategies.items():
             entry = entries.get(sid)
             if not isinstance(entry, dict):
-                if sid == "ORPHAN":
+                if sid == "MANUAL":
                     entry = _orphan_entry(
                         code_key, qty, broker_map.get(code_key, {}).get("avg_price")
                     )
                 else:
                     now_ts = datetime.now(KST).isoformat()
                     entry = {
                         "qty": int(qty),
                         "avg_price": float(
                             broker_map.get(code_key, {}).get("avg_price") or 0.0
                         ),
                         "entry": {
                             "time": now_ts,
                             "strategy_id": sid,
                             "engine": "reconcile",
                             "entry_reason": "RECONCILE",
                             "order_type": "unknown",
                             "best_k": None,
                             "tgt_px": None,
                             "gap_pct_at_entry": None,
                         },
                         "meta": {},
+                        "code": code_key,
+                        "sid": str(sid),
+                        "engine": "reconcile",
+                        "entry_ts": now_ts,
+                        "high_watermark": float(
+                            broker_map.get(code_key, {}).get("avg_price") or 0.0
+                        ),
+                        "last_update_ts": now_ts,
                     }
                 entry["flags"] = {
                     "bear_s1_done": False,
                     "bear_s2_done": False,
                     "sold_p1": False,
                     "sold_p2": False,
                 }
                 entries[sid] = entry
             entry["qty"] = int(qty)
+            entry.setdefault("code", code_key)
+            entry.setdefault("sid", str(sid))
+            entry.setdefault("engine", entry.get("entry", {}).get("engine"))
+            entry.setdefault("entry_ts", entry.get("entry", {}).get("time"))
+            entry.setdefault("high_watermark", float(entry.get("avg_price") or 0.0))
+            entry["last_update_ts"] = datetime.now(KST).isoformat()
         active_codes.add(code_key)
 
     for code in list(positions.keys()):
         if code not in active_codes:
             positions.pop(code, None)
             memory.get("last_price", {}).pop(code, None)
             memory.get("last_seen", {}).pop(code, None)
 
     return state
 
 
+def _normalize_strategy_id(value: Any) -> str | None:
+    if value is None:
+        return None
+    try:
+        num = int(value)
+    except Exception:
+        num = None
+    if num is not None and 1 <= num <= 5:
+        return str(num)
+    text = str(value).strip()
+    if text.upper().startswith("STRAT_"):
+        text = text.split("_", 1)[-1]
+    match = re.search(r"([1-5])", text)
+    if match:
+        return match.group(1)
+    return None
+
+
+def _latest_trade_sid(
+    trade_log: Iterable[Dict[str, Any]], code: str
+) -> tuple[str | None, str | None]:
+    code_key = normalize_code(code)
+    for entry in reversed(list(trade_log)):
+        if normalize_code(entry.get("code")) != code_key:
+            continue
+        if str(entry.get("side") or "").upper() != "BUY":
+            continue
+        status = str(entry.get("status") or "").lower()
+        result = entry.get("result") or {}
+        if status not in ("", "filled") and not (
+            isinstance(result, dict) and result.get("rt_cd") == "0"
+        ):
+            continue
+        sid = _normalize_strategy_id(entry.get("strategy_id"))
+        engine = entry.get("engine") or "trade_log"
+        return sid, str(engine)
+    return None, None
+
+
+def reconcile_positions(
+    kis_holdings: Iterable[Dict[str, Any]],
+    state: Dict[str, Any],
+    trade_log: Iterable[Dict[str, Any]],
+    todays_targets: Iterable[str],
+) -> Dict[str, Any]:
+    state = _coerce_state(state)
+    positions = state["positions"]
+    today_tag = datetime.now(KST).strftime("%Y%m%d")
+    targets = {normalize_code(code) for code in todays_targets if normalize_code(code)}
+
+    for row in kis_holdings:
+        code_key = normalize_code(row.get("code") or row.get("pdno") or "")
+        if not code_key:
+            continue
+        qty = int(row.get("qty") or row.get("hldg_qty") or 0)
+        if qty <= 0:
+            continue
+        avg_price = float(row.get("avg_price") or row.get("pchs_avg_pric") or 0.0)
+        pos = positions.setdefault(code_key, {"strategies": {}})
+        strategies = pos.setdefault("strategies", {})
+
+        def _fallback_sid() -> tuple[str, str]:
+            sid, engine = _latest_trade_sid(trade_log, code_key)
+            if sid:
+                return sid, engine or "trade_log"
+            if code_key in targets:
+                return f"REB_{today_tag}", "reconcile"
+            return "MANUAL", "reconcile"
+
+        if not strategies:
+            sid_key, engine = _fallback_sid()
+            now_ts = datetime.now(KST).isoformat()
+            strategies[sid_key] = {
+                "qty": int(qty),
+                "avg_price": float(avg_price),
+                "entry": {
+                    "time": now_ts,
+                    "strategy_id": sid_key,
+                    "engine": engine,
+                    "entry_reason": "RECONCILE",
+                    "order_type": "unknown",
+                    "best_k": None,
+                    "tgt_px": None,
+                    "gap_pct_at_entry": None,
+                },
+                "meta": {},
+                "flags": {
+                    "bear_s1_done": False,
+                    "bear_s2_done": False,
+                    "sold_p1": False,
+                    "sold_p2": False,
+                },
+                "code": code_key,
+                "sid": sid_key,
+                "engine": engine,
+                "entry_ts": now_ts,
+                "high_watermark": float(avg_price),
+                "last_update_ts": now_ts,
+            }
+
+        for sid in list(strategies.keys()):
+            if sid in {"ORPHAN", "UNKNOWN"}:
+                strategies.pop(sid, None)
+                sid_key, engine = _fallback_sid()
+                now_ts = datetime.now(KST).isoformat()
+                strategies[sid_key] = {
+                    "qty": int(qty),
+                    "avg_price": float(avg_price),
+                    "entry": {
+                        "time": now_ts,
+                        "strategy_id": sid_key,
+                        "engine": engine,
+                        "entry_reason": "RECONCILE",
+                        "order_type": "unknown",
+                        "best_k": None,
+                        "tgt_px": None,
+                        "gap_pct_at_entry": None,
+                    },
+                    "meta": {},
+                    "flags": {
+                        "bear_s1_done": False,
+                        "bear_s2_done": False,
+                        "sold_p1": False,
+                        "sold_p2": False,
+                    },
+                    "code": code_key,
+                    "sid": sid_key,
+                    "engine": engine,
+                    "entry_ts": now_ts,
+                    "high_watermark": float(avg_price),
+                    "last_update_ts": now_ts,
+                }
+
+        total_qty = sum(int(entry.get("qty") or 0) for entry in strategies.values())
+        if total_qty != qty:
+            if len(strategies) == 1:
+                only_entry = next(iter(strategies.values()))
+                only_entry["qty"] = int(qty)
+                only_entry["avg_price"] = float(avg_price)
+            else:
+                base_total = total_qty or len(strategies)
+                adjusted_total = 0
+                entries = list(strategies.values())
+                for entry in entries:
+                    portion = (int(entry.get("qty") or 0) / base_total) if base_total else 0
+                    new_qty = int(round(qty * portion))
+                    entry["qty"] = int(new_qty)
+                    entry["avg_price"] = float(avg_price) if avg_price else entry.get("avg_price")
+                    adjusted_total += new_qty
+                diff = int(qty) - adjusted_total
+                if diff and entries:
+                    entries[0]["qty"] = int(entries[0].get("qty") or 0) + diff
+
+        for sid_key, entry in strategies.items():
+            entry.setdefault("code", code_key)
+            entry.setdefault("sid", str(sid_key))
+            entry.setdefault("engine", entry.get("entry", {}).get("engine") or "reconcile")
+            entry.setdefault("entry_ts", entry.get("entry", {}).get("time"))
+            entry.setdefault(
+                "high_watermark",
+                max(float(entry.get("high_watermark") or 0.0), float(avg_price or 0.0)),
+            )
+            entry["last_update_ts"] = datetime.now(KST).isoformat()
+            entry.setdefault(
+                "flags",
+                {"bear_s1_done": False, "bear_s2_done": False, "sold_p1": False, "sold_p2": False},
+            )
+
+    return state
+
+
 def run_reconcile_self_checks() -> None:
     state = _empty_state()
     lot_state = {
         "lots": [{"pdno": "000001", "strategy_id": 1, "remaining_qty": 5}]
     }
     state["positions"]["000001"] = {
         "strategies": {
             "1": {
                 "qty": 7,
                 "avg_price": 100.0,
                 "entry": {},
                 "meta": {},
                 "flags": {},
             }
         }
     }
     state = reconcile_with_broker(state, [], lot_state=lot_state)
     assert state["positions"]["000001"]["strategies"]["1"]["qty"] == 5
 
 
 if __name__ == "__main__":
     run_reconcile_self_checks()
diff --git a/trader/signals.py b/trader/signals.py
index 54e37114989e8666d1685cb3872fdc68c90b14bf..f9f288b6166aa72a186c22b18e45b2cba06c9801 100644
--- a/trader/signals.py
+++ b/trader/signals.py
@@ -1,110 +1,115 @@
 """ÏãúÍ∑∏ÎÑê Í≥ÑÏÇ∞ Î∞è ÏãúÏÑ∏/Î∞∏Îü∞Ïä§ Ï°∞Ìöå Î≥¥Ï°∞ Ìï®Ïàò."""
 from __future__ import annotations
 
 import logging
+import re
 from datetime import datetime
 import time
 from typing import Any, Dict, List, Optional, Tuple
 
 from .core_constants import (
     ALLOW_WHEN_CLOSED,
     BAD_ENTRY_MAX_BELOW_VWAP_RATIO,
     BAD_ENTRY_MAX_MA20_DIST,
     BAD_ENTRY_MAX_PULLBACK,
     CHAMPION_A_RULES,
     CHAMPION_MAX_MDD,
     CHAMPION_MIN_SHARPE,
     CHAMPION_MIN_TRADES,
     CHAMPION_MIN_WINRATE,
     GOOD_ENTRY_MA20_RANGE,
     GOOD_ENTRY_MAX_FROM_PEAK,
     GOOD_ENTRY_MIN_INTRADAY_SIG,
     GOOD_ENTRY_MIN_RR,
     GOOD_ENTRY_PULLBACK_RANGE,
     KST,
     MOMENTUM_OVERRIDES_FORCE_SELL,
     MOM_FAST,
     MOM_SLOW,
     MOM_TH_PCT,
     PULLBACK_DAYS,
     PULLBACK_LOOKBACK,
     PULLBACK_REVERSAL_BUFFER_PCT,
     SLIPPAGE_ENTER_GUARD_PCT,
     USE_PULLBACK_ENTRY,
     VWAP_TOL,
     logger,
     DAILY_CAPITAL,
     W_MIN_ONE,
     W_MAX_ONE,
 )
 from .core_utils import _get_daily_candles_cached, _to_float, _to_int, _with_retry
 from .kis_wrapper import KisAPI, NetTemporaryError, DataEmptyError, DataShortError
 from .metrics import vwap_guard
+from .code_utils import normalize_code
 
 __all__ = [
     "_safe_get_price",
     "_fetch_balances",
     "_get_effective_ord_cash",
     "_get_daily_candles_cached",
     "_detect_pullback_reversal",
     "_classify_champion_grade",
     "_compute_daily_entry_context",
     "_compute_intraday_entry_context",
     "is_bad_entry",
     "is_good_entry",
     "evaluate_setup_gate",
     "evaluate_trigger_gate",
     "_get_intraday_1min",
     "_compute_vwap_from_1min",
     "_compute_intraday_momentum",
     "is_strong_momentum_vwap",
     "get_20d_return_pct",
     "is_strong_momentum",
     "_percentile_rank",
     "_has_bullish_trend_structure",
     "_weight_to_qty",
     "_notional_to_qty",
     "_get_atr",
 ]
 
 # === [ANCHOR: PRICE_CACHE] ÌòÑÏû¨Í∞Ä Ï∫êÏãú & ÏÑúÌÇ∑Î∏åÎ†àÏù¥Ïª§ ===
 _LAST_PRICE_CACHE: Dict[str, Dict[str, Any]] = {}  # code -> {"px": float, "ts": epoch}
 _PRICE_CB: Dict[str, Dict[str, float]] = {}          # code -> {"fail": int, "until": epoch}
 
 # === [ANCHOR: BALANCE_CACHE] ÏûîÍ≥† Ï∫êÏã± (Î£®ÌîÑ 15Ï¥à Îã®Ïùº Ìò∏Ï∂ú) ===
 _BALANCE_CACHE: Dict[str, Any] = {"ts": 0.0, "balances": []}
 
 def _safe_get_price(
     kis: KisAPI,
     code: str,
     ttl_sec: int = 5,
     stale_ok_sec: int = 30,
     *,
     with_source: bool = False,
 ) -> Optional[float | Tuple[float, str]]:
     import time as _t
+    code = normalize_code(code)
+    if not code:
+        return None
     now = _t.time()
 
     def _store_and_return(val: float, source: str, log_level: Optional[int] = None):
         _LAST_PRICE_CACHE[code] = {"px": float(val), "ts": now, "source": source}
         if log_level:
             logger.log(log_level, f"[PRICE_SRC] {code} ‚Üê {source} ({float(val):.2f})")
         return (float(val), source) if with_source else float(val)
 
     # 0) ÏÑúÌÇ∑Î∏åÎ†àÏù¥Ïª§: ÏµúÍ∑º Ïã§Ìå® ÎàÑÏ†ÅÏù¥Î©¥ Ïû†Ïãú Í±¥ÎÑàÎõ¥Îã§
     cb = _PRICE_CB.get(code, {"fail": 0, "until": 0})
     primary_allowed = now >= cb.get("until", 0)
 
     # Ïû•ÎßàÍ∞êÏù¥Î©¥ Ï∫êÏãú/Ï¢ÖÍ∞ÄÎ°ú ÎåÄÏ≤¥
     try:
         if not kis.is_market_open() and not ALLOW_WHEN_CLOSED:
             ent = _LAST_PRICE_CACHE.get(code)
             if ent:
                 src = ent.get("source") or "cache_close"
                 return (float(ent["px"]), src) if with_source else float(ent["px"])
             if hasattr(kis, "get_close_price"):
                 try:
                     close_px = kis.get_close_price(code)
                     if close_px and float(close_px) > 0:
                         val = float(close_px)
                         return _store_and_return(val, "close_after")
@@ -217,66 +222,66 @@ def _fetch_balances(kis: KisAPI, ttl_sec: int = 15) -> List[Dict[str, Any]]:
     try:
         if _BALANCE_CACHE["balances"] and (now - float(_BALANCE_CACHE["ts"])) <= ttl_sec:
             return list(_BALANCE_CACHE["balances"])
     except Exception:
         pass
 
     if hasattr(kis, "get_balance_all"):
         res = _with_retry(kis.get_balance_all)
     else:
         res = _with_retry(kis.get_balance)
 
     if isinstance(res, dict):
         positions = res.get("positions") or res.get("output1") or []
         if not isinstance(positions, list):
             logger.error(f"[BAL_STD_FAIL] positions ÌÉÄÏûÖ Ïù¥ÏÉÅ: {type(positions)}")
             positions = []
     elif isinstance(res, list):
         positions = res
     else:
         logger.error(f"[BAL_STD_FAIL] ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Î∞òÌôò ÌÉÄÏûÖ: {type(res)}")
         positions = []
 
     normalized: List[Dict[str, Any]] = []
     for row in positions:
         try:
-            code = str(row.get("code") or row.get("pdno") or "").strip()
+            code = normalize_code(row.get("code") or row.get("pdno") or "")
             if not code:
                 continue
             qty = _to_int(row.get("qty") if "qty" in row else row.get("hldg_qty"))
             sell_psbl_qty = _to_int(
                 row.get("sell_psbl_qty") if "sell_psbl_qty" in row else row.get("ord_psbl_qty")
             )
             if qty <= 0 and sell_psbl_qty > 0:
                 qty = sell_psbl_qty
             avg_price = _to_float(
                 row.get("avg_price") if "avg_price" in row else row.get("pchs_avg_pric")
             )
 
             normalized.append(
                 {
-                    "code": code.zfill(6),
+                    "code": code,
                     "name": row.get("name") or row.get("prdt_name"),
                     "qty": qty,
                     "sell_psbl_qty": sell_psbl_qty,
                     "avg_price": avg_price,
                     "current_price": _to_float(row.get("prpr") or row.get("price")),
                     "eval_amount": _to_int(row.get("evlu_amt")),
                     "raw": row,
                 }
             )
         except Exception as e:
             logger.warning(f"[BAL_STD_FAIL] ÏûîÍ≥† Ìñâ ÌååÏã± Ïã§Ìå®: {e}")
             continue
 
     _BALANCE_CACHE["ts"] = now
     _BALANCE_CACHE["balances"] = list(normalized)
     return normalized
 
 
 def _get_effective_ord_cash(kis: KisAPI, soft_cap: int | float | None = None) -> int:
     """
     Ïò§Îäò Ï£ºÎ¨∏ Í∞ÄÎä• ÏòàÏàòÍ∏àÏùÑ Í∞ÄÏ†∏Ïò§Îêò,
     - 0 Ïù¥ÌïòÏù¥Í±∞ÎÇò
     - Ï°∞Ìöå Ïã§Ìå® / None
     Ïù¥Î©¥ DAILY_CAPITALÏùÑ fallbackÏúºÎ°ú ÏÇ¨Ïö©ÌïúÎã§.
     (Î™®ÏùòÌà¨ÏûêÏóêÏÑú get_cash_available_todayÍ∞Ä Ìï≠ÏÉÅ 0ÏùÑ Ï£ºÎäî Í≤ΩÏö∞ Î≥¥Ìò∏)
@@ -455,68 +460,99 @@ def _classify_champion_grade(info: Dict[str, Any]) -> str:
     turnover_ok = turnover <= 0 or turnover >= CHAMPION_A_RULES["min_turnover"]
     if (
         trades >= CHAMPION_A_RULES["min_trades"]
         and cumret >= CHAMPION_A_RULES["min_cumret_pct"]
         and mdd <= CHAMPION_A_RULES["max_mdd_pct"]
         and win >= CHAMPION_A_RULES["min_win_pct"]
         and sharpe >= CHAMPION_A_RULES["min_sharpe"]
         and turnover_ok
     ):
         return "A"
 
     if (
         trades >= CHAMPION_MIN_TRADES
         and win >= CHAMPION_MIN_WINRATE
         and mdd <= CHAMPION_MAX_MDD
         and sharpe >= CHAMPION_MIN_SHARPE
     ):
         return "B"
 
     return "C"
 
 
 def _compute_daily_entry_context(
     kis: KisAPI, code: str, current_price: Optional[float], price_source: Optional[str] = None
 ) -> Dict[str, Any]:
-    ctx: Dict[str, Any] = {"current_price": current_price, "price_source": price_source}
+    code = normalize_code(code)
+    ctx: Dict[str, Any] = {
+        "current_price": current_price,
+        "price_source": price_source,
+        "daily_count": 0,
+        "data_insufficient": False,
+    }
     try:
         candles = _get_daily_candles_cached(kis, code, count=max(PULLBACK_LOOKBACK, 60))
+    except DataShortError as e:
+        ctx["data_insufficient"] = True
+        match = re.search(r"(\d+)\s+candles", str(e))
+        if match:
+            ctx["daily_count"] = int(match.group(1))
+        return ctx
+    except DataEmptyError:
+        ctx["data_insufficient"] = True
+        ctx["daily_count"] = 0
+        return ctx
     except Exception:
         return ctx
 
     today = datetime.now(KST).strftime("%Y%m%d")
     completed = list(candles)
     if completed and str(completed[-1].get("date")) == today:
         completed = completed[:-1]
 
     if not completed:
+        ctx["data_insufficient"] = True
+        ctx["daily_count"] = 0
+        ctx["setup_ok"] = False
         return ctx
 
+    ctx["daily_count"] = len(completed)
+
     closes = [float(c.get("close") or 0.0) for c in completed if c.get("close")]
     highs = [float(c.get("high") or 0.0) for c in completed if c.get("high")]
     lows = [float(c.get("low") or 0.0) for c in completed if c.get("low")]
 
+    if len(closes) >= 2:
+        ctx["prev_close"] = float(closes[-2])
+    else:
+        ctx["prev_close"] = None
+
+    if len(closes) < 21:
+        ctx["data_insufficient"] = True
+        ctx["setup_ok"] = False
+        return ctx
+
     if len(closes) >= 20:
         ma20 = sum(closes[-20:]) / 20.0
         ctx["ma20"] = ma20
         if current_price:
             ctx["ma20_ratio"] = current_price / ma20
             ctx["ma20_risk"] = max(0.0, current_price - ma20)
 
         # Îã®Í∏∞/Ï§ëÍ∏∞ Ï∂îÏÑ∏ Ï†ïÎ∞∞Ïó¥ Î∞è ÏÉÅÏäπ Ïó¨Î∂Ä
         if len(closes) >= 21:
             ma5 = sum(closes[-5:]) / 5.0
             ma10 = sum(closes[-10:]) / 10.0
             prev_ma20 = sum(closes[-21:-1]) / 20.0
 
             ctx["ma5"] = ma5
             ctx["ma10"] = ma10
             ctx["ma20_prev"] = prev_ma20
 
             bullish_stack = (
                 ma5 > ma10 > ma20
                 and ma20 > prev_ma20
                 and float(closes[-1]) > ma20
             )
             ctx["strong_trend"] = bullish_stack
 
     strong_trend = bool(ctx.get("strong_trend"))
@@ -572,70 +608,74 @@ def _compute_daily_entry_context(
             and ctx.get("pullback_depth_pct") <= float(ctx.get("max_pullback_pct") or 60.0)
             and (ctx.get("ma20_ratio") or 0) >= GOOD_ENTRY_MA20_RANGE[0]
         )
 
         ctx["setup_ok"] = bool(base_setup or relaxed_pullback_ok)
         if relaxed_pullback_ok and not base_setup:
             ctx["setup_reason"] = "strong_trend_relaxed"
 
     return ctx
 
 
 def _compute_intraday_entry_context(
     kis: KisAPI,
     code: str,
     prev_high: Optional[float] = None,
     *,
     fast: Optional[int] = None,
     slow: Optional[int] = None,
 ) -> Dict[str, Any]:
     """
     ÏßÑÏûÖ ÏãúÏ†êÏö© 1Î∂ÑÎ¥â VWAP / Î∞ïÏä§ / Í±∞ÎûòÎüâ Ïä§ÌååÏù¥ÌÅ¨ Ïª®ÌÖçÏä§Ìä∏ Í≥ÑÏÇ∞.
 
     prev_highÎäî Ïù¥Ï†Ñ ÏùºÏûê Í≥†Í∞Ä(Ï†ÑÏùº high) Îì± Ïô∏Î∂ÄÏóêÏÑú ÎÑ£Ïñ¥Ï§Ñ Ïàò ÏûàÍ≥†,
     fast/slowÎäî Î™®Î©òÌÖÄÏö© ÌååÎùºÎØ∏ÌÑ∞ÏßÄÎßå, Ïó¨Í∏∞ÏÑúÎäî Ï£ºÎ°ú Ï°∞Ìöå Í∏∏Ïù¥ ÌäúÎãùÏóê ÏÇ¨Ïö©ÌïúÎã§.
     """
-    ctx: Dict[str, Any] = {}
+    code = normalize_code(code)
+    ctx: Dict[str, Any] = {"intraday_available": False, "vwap_enabled": False}
 
     # intraday 1Î∂ÑÎ¥â Ï°∞Ìöå Í∏∏Ïù¥ Í≤∞Ï†ï
     # - Í∏∞Î≥∏ÏùÄ 120Í∞ú
     # - slowÍ∞Ä Îì§Ïñ¥Ïò§Î©¥ slow * 3 Ï†ïÎèÑÎ°ú ÎäòÎ¶¨Îêò ÏµúÏÜå 60Í∞úÎäî ÌôïÎ≥¥
     lookback = 120
     if slow is not None:
         try:
             slow_n = int(slow)
             lookback = max(slow_n * 3, 60)
         except (TypeError, ValueError):
             # ÏûòÎ™ª Îì§Ïñ¥Ïò® Í∞íÏù¥Î©¥ Í∑∏ÎÉ• Í∏∞Î≥∏Í∞í 120 Ïú†ÏßÄ
             pass
 
     candles = _get_intraday_1min(kis, code, count=lookback)
     if not candles:
         return ctx
+    ctx["intraday_available"] = True
 
     vwap_val = _compute_vwap_from_1min(candles)
     ctx["vwap"] = vwap_val
+    if vwap_val and vwap_val > 0:
+        ctx["vwap_enabled"] = True
 
     last = candles[-1]
     last_close = _to_float(last.get("close"), None)
     last_high = _to_float(last.get("high") or last.get("close"), None)
     last_low = _to_float(last.get("low") or last.get("close"), None)
     ctx["last_close"] = last_close
     ctx["last_high"] = last_high
     ctx["last_low"] = last_low
 
     if vwap_val and last_close:
         ctx["vwap_reclaim"] = last_close >= vwap_val
 
     highs = [
         float(c.get("high") or c.get("close") or 0.0)
         for c in candles
         if c.get("high") or c.get("close")
     ]
     lows = [
         float(c.get("low") or c.get("close") or 0.0)
         for c in candles
         if c.get("low") or c.get("close")
     ]
     vols = [float(c.get("volume") or 0.0) for c in candles]
 
     if highs:
@@ -727,51 +767,95 @@ def is_bad_entry(
             " / ".join(reasons),
             daily_ctx,
             intraday_ctx,
             regime_state,
         )
         return True
 
     logger.info(
         "[ENTRY-OK] %s | daily=%s intra=%s regime=%s",
         code,
         daily_ctx,
         intraday_ctx,
         regime_state,
     )
     return False
 
 
 def evaluate_setup_gate(
     daily_ctx: Dict[str, Any],
     intraday_ctx: Dict[str, Any],
     regime_state: Optional[Dict[str, Any]] = None,
 ) -> Dict[str, Any]:
     missing_conditions: List[str] = []
     reasons = _collect_bad_entry_reasons(daily_ctx, intraday_ctx, regime_state)
 
+    if daily_ctx.get("data_insufficient"):
+        daily_count = daily_ctx.get("daily_count")
+        if daily_count is not None and int(daily_count) < 21:
+            reasons.append("data_insufficient_daily_<21")
+        elif daily_count is not None:
+            reasons.append(f"data_insufficient_daily_{daily_count}")
+        else:
+            reasons.append("data_insufficient_daily_unknown")
+
+    if daily_ctx.get("prev_close") in (None, 0):
+        reasons.append("prev_close_missing")
+
+    if not intraday_ctx or not intraday_ctx.get("intraday_available"):
+        reasons.append("intraday_unavailable")
+    elif not intraday_ctx.get("vwap_enabled"):
+        reasons.append("intraday_unavailable")
+
+    down_streak = daily_ctx.get("down_streak")
+    if down_streak is not None and int(down_streak) < 2:
+        reasons.append("down_streak_insufficient")
+
+    pullback = daily_ctx.get("pullback_depth_pct")
+    if pullback is not None:
+        try:
+            pullback_val = float(pullback)
+            max_pb = float(daily_ctx.get("max_pullback_pct") or BAD_ENTRY_MAX_PULLBACK)
+            if pullback_val > max_pb:
+                reasons.append("pullback_depth_too_high")
+        except Exception:
+            reasons.append("pullback_depth_invalid")
+
+    ma20_ratio = daily_ctx.get("ma20_ratio")
+    if ma20_ratio is not None:
+        try:
+            if float(ma20_ratio) < GOOD_ENTRY_MA20_RANGE[0]:
+                reasons.append("ma20_below")
+        except Exception:
+            reasons.append("ma20_invalid")
+
+    if not daily_ctx.get("strong_trend"):
+        reasons.append("not_strong_trend")
+
     ok = bool(daily_ctx.get("setup_ok")) and not reasons
+    if not ok and not reasons:
+        reasons = ["setup_flag_false"]
     return {
         "ok": ok,
         "missing_conditions": missing_conditions,
         "reasons": reasons,
     }
 
 
 def evaluate_trigger_gate(
     daily_ctx: Dict[str, Any],
     intraday_ctx: Dict[str, Any],
     *,
     prev_high: Optional[float] = None,
     prev_price: Optional[float] = None,
     target_price: Optional[float] = None,
     trigger_name: str = "breakout_cross",
 ) -> Dict[str, Any]:
     missing_conditions: List[str] = []
     signals: List[str] = []
 
     cur_px = _to_float(daily_ctx.get("current_price"), None)
     atr = _to_float(daily_ctx.get("atr"), 0.0)
     ma_risk = _to_float(daily_ctx.get("ma20_risk"), 0.0)
     risk = max(atr, ma_risk, (cur_px or 0) * 0.03)
     reward = max(0.0, (daily_ctx.get("peak_price") or 0) - (cur_px or 0)) + atr
     risk_reward = reward / risk if risk else None
@@ -885,50 +969,53 @@ def evaluate_trigger_gate(
     }
 
 
 def is_good_entry(
     code: str,
     daily_ctx: Dict[str, Any],
     intraday_ctx: Dict[str, Any],
     prev_high: Optional[float] = None,
 ) -> bool:
     result = evaluate_trigger_gate(
         daily_ctx,
         intraday_ctx,
         prev_high=prev_high,
         prev_price=None,
         target_price=None,
         trigger_name="breakout_cross",
     )
     return bool(result.get("ok"))
 
 # === [ANCHOR: INTRADAY_MOMENTUM] 1Î∂ÑÎ¥â VWAP + Îã®Í∏∞ Î™®Î©òÌÖÄ ===
 def _get_intraday_1min(kis: KisAPI, code: str, count: int = 60) -> List[Dict[str, Any]]:
     """
     KisAPIÏóê 1Î∂ÑÎ¥â Î©îÏÑúÎìúÍ∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©ÌïòÍ≥†, ÏóÜÏúºÎ©¥ Ìò∏Ìôò Î©îÏÑúÎìúÎ°ú fallback.
     Î∞òÌôòÏùÄ ÏµúÏÜåÌïú 'close'ÏôÄ 'volume' Ï†ïÎ≥¥Î•º Í∞ÄÏßÑ dict Î¶¨Ïä§Ìä∏ÎùºÍ≥† Í∞ÄÏ†ïÌïúÎã§.
     """
+    code = normalize_code(code)
+    if not code:
+        return []
     try:
         if hasattr(kis, "get_intraday_1min"):
             return kis.get_intraday_1min(code, count=count)
         if hasattr(kis, "get_minute_candles"):
             return kis.get_minute_candles(code, unit=1, count=count)
         if hasattr(kis, "get_intraday_candles"):
             return kis.get_intraday_candles(code, unit="1", count=count)
     except Exception as e:
         logger.warning(f"[INTRADAY_1M_FAIL] {code}: {e}")
     return []
 
 def _compute_vwap_from_1min(candles: List[Dict[str, Any]]) -> Optional[float]:
     if not candles:
         return None
     pv = 0.0
     vol_sum = 0.0
     for c in candles:
         try:
             price = float(c.get("close") or c.get("trade_price") or c.get("price") or 0.0)
             vol = float(c.get("volume") or c.get("trade_volume") or 0.0)
         except Exception:
             continue
         if price <= 0 or vol <= 0:
             continue
         pv += price * vol
diff --git a/trader/state_store.py b/trader/state_store.py
index 1c219798a04f6d6a2eafa9c0fdf1821fb9ab4180..0034136ef116f93ccc222c9b7afdaa0b33b4d8ce 100644
--- a/trader/state_store.py
+++ b/trader/state_store.py
@@ -1,35 +1,36 @@
 from __future__ import annotations
 
 import json
 import logging
 import os
 from datetime import datetime
 from pathlib import Path
 from typing import Any, Dict
 
 from .config import KST
+from .code_utils import normalize_code
 
 logger = logging.getLogger(__name__)
 
 SCHEMA_VERSION = 1
 RUNTIME_STATE_DIR = Path(".runtime")
 RUNTIME_STATE_PATH = RUNTIME_STATE_DIR / "state.json"
 
 
 def _default_runtime_state() -> Dict[str, Any]:
     return {
         "schema_version": SCHEMA_VERSION,
         "updated_at": None,
         "positions": {},
         "orders": {},
     }
 
 
 def load_state() -> Dict[str, Any]:
     if not RUNTIME_STATE_PATH.exists():
         return _default_runtime_state()
     try:
         with open(RUNTIME_STATE_PATH, "r", encoding="utf-8") as f:
             state = json.load(f)
         if not isinstance(state, dict):
             logger.warning("[RUNTIME_STATE] invalid state format: %s", type(state))
@@ -42,64 +43,64 @@ def load_state() -> Dict[str, Any]:
     except Exception:
         logger.exception("[RUNTIME_STATE] failed to load %s", RUNTIME_STATE_PATH)
         return _default_runtime_state()
 
 
 def save_state(state: Dict[str, Any]) -> None:
     try:
         RUNTIME_STATE_DIR.mkdir(parents=True, exist_ok=True)
         payload = dict(state)
         payload.setdefault("schema_version", SCHEMA_VERSION)
         payload.setdefault("positions", {})
         payload.setdefault("orders", {})
         payload["updated_at"] = datetime.now(KST).isoformat()
         tmp_path = RUNTIME_STATE_PATH.with_name(f"{RUNTIME_STATE_PATH.name}.tmp")
         with open(tmp_path, "w", encoding="utf-8") as f:
             json.dump(payload, f, ensure_ascii=False, indent=2)
         os.replace(tmp_path, RUNTIME_STATE_PATH)
     except Exception:
         logger.exception("[RUNTIME_STATE] failed to save %s", RUNTIME_STATE_PATH)
 
 
 def get_position(state: Dict[str, Any], symbol: str) -> Dict[str, Any] | None:
     positions = state.get("positions", {})
     if not isinstance(positions, dict):
         return None
-    return positions.get(str(symbol).zfill(6))
+    return positions.get(normalize_code(symbol))
 
 
 def upsert_position(state: Dict[str, Any], symbol: str, fields: Dict[str, Any]) -> None:
     positions = state.setdefault("positions", {})
-    key = str(symbol).zfill(6)
+    key = normalize_code(symbol)
     pos = positions.setdefault(key, {})
     for field, value in fields.items():
         pos[field] = value
 
 
 def _order_bucket(state: Dict[str, Any], symbol: str, side: str) -> Dict[str, Any]:
     orders = state.setdefault("orders", {})
-    symbol_key = str(symbol).zfill(6)
+    symbol_key = normalize_code(symbol)
     symbol_bucket = orders.setdefault(symbol_key, {})
     return symbol_bucket.setdefault(side.upper(), {})
 
 
 def should_block_order(
     state: Dict[str, Any],
     symbol: str,
     side: str,
     now_ts: str,
     *,
     window_sec: int = 300,
     max_attempts: int = 2,
 ) -> bool:
     bucket = _order_bucket(state, symbol, side)
     last_ts = bucket.get("last_ts")
     attempts = int(bucket.get("attempts") or 0)
     if attempts >= max_attempts:
         return True
     if isinstance(last_ts, str):
         try:
             last_dt = datetime.fromisoformat(last_ts)
             now_dt = datetime.fromisoformat(now_ts)
             if (now_dt - last_dt).total_seconds() <= window_sec:
                 return True
         except Exception:
@@ -159,59 +160,59 @@ def mark_fill(
         )
         pos.update({"qty": total_qty, "avg_price": avg_price, "last_buy_ts": ts})
     else:
         pos.update({"qty": max(0, cur_qty - int(qty)), "last_sell_ts": ts})
     pos["strategy_id"] = strategy_id
     pos["last_order_id"] = order_id
     pos["last_action"] = side.upper()
     pos["last_action_ts"] = ts
     pos["last_order_status"] = status
     upsert_position(state, symbol, pos)
 
 
 def reconcile_with_kis_balance(
     state: Dict[str, Any],
     balance: Dict[str, Any],
     *,
     preferred_strategy: Dict[str, Any] | None = None,
 ) -> Dict[str, Any]:
     preferred_strategy = preferred_strategy or {}
     positions = state.setdefault("positions", {})
     balance_positions = balance.get("positions") if isinstance(balance, dict) else None
     if not isinstance(balance_positions, list):
         return state
     seen = set()
     for row in balance_positions:
-        symbol = str(row.get("code") or row.get("pdno") or "").zfill(6)
+        symbol = normalize_code(row.get("code") or row.get("pdno") or "")
         if not symbol:
             continue
         qty = int(row.get("qty") or 0)
         if qty <= 0:
             continue
         seen.add(symbol)
         pos = positions.setdefault(symbol, {})
-        strategy_id = pos.get("strategy_id") or preferred_strategy.get(symbol) or "UNKNOWN"
+        strategy_id = pos.get("strategy_id") or preferred_strategy.get(symbol) or "MANUAL"
         pos.update(
             {
                 "strategy_id": strategy_id,
                 "qty": qty,
                 "avg_price": float(row.get("avg_price") or 0.0),
                 "last_action": "RECONCILE",
             }
         )
         positions[symbol] = pos
     for symbol, pos in list(positions.items()):
         if symbol not in seen:
             pos["qty"] = 0
             pos["last_action"] = "RECONCILE"
             positions[symbol] = pos
     return state
 
 
 def _default_lot_state() -> Dict[str, Any]:
     return {"version": SCHEMA_VERSION, "lots": [], "updated_at": None}
 
 
 def load_lot_state(path_json: str) -> Dict[str, Any]:
     path = Path(path_json)
     if not path.exists():
         return _default_lot_state()
