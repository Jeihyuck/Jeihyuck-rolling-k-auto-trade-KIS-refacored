diff --git a/.github/workflows/trade-runner.yml b/.github/workflows/trade-runner.yml
index 49ce41622236cf0c9fd6a644e2289c2bfc9cc4a9..a35276d8902702c49984fe4b334b0b10f8633adf 100644
--- a/.github/workflows/trade-runner.yml
+++ b/.github/workflows/trade-runner.yml
@@ -82,25 +82,103 @@ jobs:
           token: ${{ secrets.GITHUB_TOKEN }}
 
       - name: Set git identity
         run: |
           git config user.name "trade-bot"
           git config user.email "trade-bot@users.noreply.github.com"
 
       - uses: actions/setup-python@v5
         with:
           python-version: "3.11"
 
       - name: Install dependencies
         run: |
           python -m pip install --upgrade pip
           pip install -r requirements.txt
 
       - name: Compile modules
         run: |
           python -m compileall trader
 
       - name: Run PB1 only
         env:
           PYTHONPATH: ${{ github.workspace }}
         run: |
           python -m trader.pb1_runner --window auto --phase auto --target-branch ${BOTSTATE_BRANCH}
+
+  diag-level1:
+    if: github.event_name == 'push'
+    runs-on: ubuntu-latest
+    timeout-minutes: 60
+    env:
+      PB1_DIAG_LEVEL: "1"
+      PB1_SHADOW_LIVE: "0"
+      BOTSTATE_BRANCH: bot-state
+      BOTSTATE_WORKTREE_DIR: "_botstate"
+      STRATEGY_MODE: "INTENT_ONLY"
+      LIVE_TRADING_ENABLED: "0"
+      DISABLE_LIVE_TRADING: "1"
+      DRY_RUN: "1"
+      PB1_ENTRY_ENABLED: "0"
+      PB1_SKIP_UNIVERSE_IN_DIAG: "1"
+      KIS_ENV: "practice"
+      API_BASE_URL: "https://openapivts.koreainvestment.com:29443"
+      APP_KEY: "dummy"
+      APP_SECRET: "dummy"
+      CANO: "00000000"
+      ACNT_PRDT_CD: "00"
+      PYTHONUNBUFFERED: "1"
+    steps:
+      - uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+      - uses: actions/setup-python@v5
+        with:
+          python-version: "3.11"
+      - name: Install dependencies
+        run: |
+          python -m pip install --upgrade pip
+          pip install -r requirements.txt
+      - name: Run PB1 diag level1
+        env:
+          PYTHONPATH: ${{ github.workspace }}
+        run: |
+          PB1_DIAG_LEVEL=1 PB1_SHADOW_LIVE=0 python -m trader.pb1_runner --window diagnostic --phase verify --target-branch ${BOTSTATE_BRANCH}
+
+  diag-level2-shadow:
+    if: github.event_name == 'workflow_dispatch' || github.event_name == 'schedule'
+    runs-on: ubuntu-latest
+    timeout-minutes: 120
+    env:
+      PB1_DIAG_LEVEL: "2"
+      PB1_SHADOW_LIVE: "1"
+      BOTSTATE_BRANCH: bot-state
+      BOTSTATE_WORKTREE_DIR: "_botstate"
+      STRATEGY_MODE: "INTENT_ONLY"
+      LIVE_TRADING_ENABLED: "0"
+      DISABLE_LIVE_TRADING: "0"
+      DRY_RUN: "0"
+      PB1_ENTRY_ENABLED: "1"
+      PB1_SKIP_UNIVERSE_IN_DIAG: "0"
+      KIS_ENV: "practice"
+      API_BASE_URL: "https://openapivts.koreainvestment.com:29443"
+      APP_KEY: ${{ secrets.KIS_APP_KEY != '' && secrets.KIS_APP_KEY || secrets.APP_KEY }}
+      APP_SECRET: ${{ secrets.KIS_APP_SECRET != '' && secrets.KIS_APP_SECRET || secrets.APP_SECRET }}
+      CANO: ${{ secrets.CANO }}
+      ACNT_PRDT_CD: ${{ secrets.ACNT_PRDT_CD }}
+      PYTHONUNBUFFERED: "1"
+    steps:
+      - uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+      - uses: actions/setup-python@v5
+        with:
+          python-version: "3.11"
+      - name: Install dependencies
+        run: |
+          python -m pip install --upgrade pip
+          pip install -r requirements.txt
+      - name: Run PB1 diag level2 shadow
+        env:
+          PYTHONPATH: ${{ github.workspace }}
+        run: |
+          PB1_DIAG_LEVEL=2 PB1_SHADOW_LIVE=1 python -m trader.pb1_runner --window diagnostic --phase verify --target-branch ${BOTSTATE_BRANCH}
diff --git a/rolling_k_auto_trade_api/conftest.py b/rolling_k_auto_trade_api/conftest.py
new file mode 100644
index 0000000000000000000000000000000000000000..045765585a44841b5fff89583f089721fde8f206
--- /dev/null
+++ b/rolling_k_auto_trade_api/conftest.py
@@ -0,0 +1,11 @@
+import pytest
+
+
+@pytest.fixture
+def access_token():
+    pytest.skip("External KIS API not available in test environment")
+
+
+@pytest.fixture
+def token():
+    pytest.skip("External KIS API not available in test environment")
diff --git a/tests/test_diag_skips_universe.py b/tests/test_diag_skips_universe.py
index e0d6d79781c0c9b81867caea1f7a867f7c5181cc..7785ea725567cd549ffe2ae4218397fe7697aa41 100644
--- a/tests/test_diag_skips_universe.py
+++ b/tests/test_diag_skips_universe.py
@@ -4,39 +4,41 @@ from pathlib import Path
 import pytest
 
 from trader.pb1_engine import PB1Engine
 from trader.window_router import WindowDecision
 
 
 @pytest.fixture(autouse=True)
 def _ensure_env(monkeypatch, tmp_path):
     monkeypatch.setenv("PB1_SKIP_UNIVERSE_IN_DIAG", "1")
     # Avoid git operations during tests
     monkeypatch.setattr("trader.pb1_engine.persist_run_files", lambda *args, **kwargs: None)
     # Keep ledger under a temp directory
     monkeypatch.setattr("trader.pb1_engine.LEDGER_BASE_DIR", Path(tmp_path / "ledger"))
 
 
 def test_diagnostic_window_skips_universe(monkeypatch, tmp_path):
     window = WindowDecision(name="diagnostic", phase="verify")
     engine = PB1Engine(
         kis=None,
         worktree_dir=tmp_path,
         window=window,
         phase_override="auto",
         dry_run=True,
         env="paper",
         run_id="test-run",
+        order_mode="dry_run",
+        diag_level=1,
     )
 
     called = {"build": False}
 
     def _fail_build():
         called["build"] = True
         raise AssertionError("_build_universe should not run in diagnostic")
 
     monkeypatch.setattr(engine, "_build_universe", _fail_build)
 
     touched = engine.run()
 
     assert called["build"] is False
     assert any(p.name == "pnl_snapshot.json" and p.exists() for p in touched)
diff --git a/tests/test_shadow_executor_never_places_orders.py b/tests/test_shadow_executor_never_places_orders.py
new file mode 100644
index 0000000000000000000000000000000000000000..6f2a98f3b2bc8ff1fcd7c2d0ea4486f5b4f503aa
--- /dev/null
+++ b/tests/test_shadow_executor_never_places_orders.py
@@ -0,0 +1,62 @@
+import json
+from pathlib import Path
+
+from trader.pb1_engine import PB1Engine, CandidateFeature
+from trader.window_router import WindowDecision
+
+
+class DummyKis:
+    def __init__(self):
+        self.buy_called = False
+
+    def validate_buy(self, code, qty, price):
+        return True, "ok"
+
+    def validate_sell(self, code, qty, price):
+        return True, "ok"
+
+    def buy_stock_market(self, *_args, **_kwargs):
+        self.buy_called = True
+        raise AssertionError("buy_stock_market should not be called in shadow mode")
+
+
+def test_shadow_executor_never_places_orders(monkeypatch, tmp_path):
+    ledger_dir = tmp_path / "ledger"
+    monkeypatch.setattr("trader.pb1_engine.LEDGER_BASE_DIR", ledger_dir)
+    monkeypatch.setattr("trader.pb1_engine.persist_run_files", lambda *args, **kwargs: None)
+
+    window = WindowDecision(name="afternoon", phase="entry")
+    dummy_kis = DummyKis()
+
+    engine = PB1Engine(
+        kis=dummy_kis,
+        worktree_dir=tmp_path,
+        window=window,
+        phase_override="auto",
+        dry_run=False,
+        env="shadow",
+        run_id="test-run",
+        order_mode="shadow",
+        diag_level=2,
+    )
+
+    cf = CandidateFeature(
+        code="123456",
+        market="KOSPI",
+        features={"close": 1000},
+        setup_ok=True,
+        reasons=[],
+        mode=1,
+        mode_reasons=[],
+        client_order_key="test-key",
+        planned_qty=10,
+    )
+
+    paths = engine._place_entry(cf)
+    ack_file = ledger_dir / "orders_ack" / engine._today / f"run_{engine.run_id}.jsonl"
+    assert ack_file.exists()
+    content = ack_file.read_text(encoding="utf-8").strip().splitlines()
+    last_row = json.loads(content[-1])
+    assert last_row["payload"]["mode"] == "shadow"
+    assert last_row["ok"] is True
+    assert dummy_kis.buy_called is False
diff --git a/tests/test_universe_fallback_cache.py b/tests/test_universe_fallback_cache.py
new file mode 100644
index 0000000000000000000000000000000000000000..90c16331450a1a89559bc19f71a09588e9c25348
--- /dev/null
+++ b/tests/test_universe_fallback_cache.py
@@ -0,0 +1,38 @@
+import json
+from pathlib import Path
+
+import pytest
+
+from trader.pb1_engine import PB1Engine
+from trader.window_router import WindowDecision
+
+
+def test_universe_fallback_cache(monkeypatch, tmp_path):
+    ledger_dir = tmp_path / "ledger"
+    monkeypatch.setattr("trader.pb1_engine.LEDGER_BASE_DIR", ledger_dir)
+    monkeypatch.setattr("trader.pb1_engine.persist_run_files", lambda *args, **kwargs: None)
+
+    cache_path = tmp_path / "bot_state" / "trader_state" / "universe_cache.json"
+    cache_path.parent.mkdir(parents=True, exist_ok=True)
+    cached_universe = {"selected_by_market": {"KOSPI": [{"code": "654321"}]}, "date": "2024-01-01", "source": "cache"}
+    cache_path.write_text(json.dumps(cached_universe), encoding="utf-8")
+
+    window = WindowDecision(name="diagnostic", phase="verify")
+
+    engine = PB1Engine(
+        kis=None,
+        worktree_dir=tmp_path,
+        window=window,
+        phase_override="auto",
+        dry_run=False,
+        env="shadow",
+        run_id="test-run",
+        order_mode="shadow",
+        diag_level=2,
+    )
+
+    monkeypatch.setattr("trader.pb1_engine.run_rebalance", lambda *args, **kwargs: {"selected_by_market": {}})
+
+    selected = engine._build_universe()
+    assert selected == cached_universe["selected_by_market"]
+    assert "pykrx_universe_empty" in engine.diag_counters["fail_reasons"]
diff --git a/trader/config.py b/trader/config.py
index 5ff2f98a6196a3b7c536c4ae25d22c39f53fafc1..eb1fc12708a0e76e90daf9ab37bb40329a325c16 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -79,50 +79,52 @@ CONFIG = {
     "FORCE_WEEKLY_REBALANCE": "0",
     # NEW: 1분봉 VWAP 모멘텀 파라미터
     "MOM_FAST": "5",        # 1분봉 fast MA 길이
     "MOM_SLOW": "20",       # 1분봉 slow MA 길이
     "MOM_TH_PCT": "0.5",    # fast/slow 괴리 임계값(%) – 0.5% 이상이면 강세로 본다
     # Subject flow gate 기본값
     "MIN_SMART_MONEY_RATIO_KOSPI": "0.02",
     "MIN_SMART_MONEY_RATIO_KOSDAQ": "0.03",
     "SUBJECT_FLOW_TIMEOUT_SEC": "1.2",
     "SUBJECT_FLOW_RETRY": "1",
     "SUBJECT_FLOW_CACHE_TTL_SEC": "60",
     "SUBJECT_FLOW_FAIL_POLICY": "CACHE",
     "SUBJECT_FLOW_EMPTY_POLICY": "TREAT_AS_FAIL",
     "SUBJECT_FLOW_DEGRADED_TURNOVER_MULT": "1.5",
     "SUBJECT_FLOW_DEGRADED_OB_ADD": "10",
     "SUBJECT_FLOW_MAX_CALLS_PER_RUN": "200",
     "EMERGENCY_GLOBAL_SELL": "false",
     "STRATEGY_REDUCTION_PRIORITY": "5,4,3,2,1",
     # Diagnostics
     "DIAGNOSTIC_MODE": "false",
     "DIAGNOSTIC_ONLY": "false",
     "DIAGNOSTIC_FORCE_RUN": "false",
     "DIAGNOSTIC_DUMP_PATH": "trader/state/diagnostics",
     "DIAGNOSTIC_TARGET_MARKETS": "",
     "DIAGNOSTIC_MAX_SYMBOLS": "200",
+    "PB1_DIAG_LEVEL": "1",  # 1=fast verify, 2=deep shadow
+    "PB1_SHADOW_LIVE": "0",
     # === Strategy intent/exec defaults ===
     "ENABLED_STRATEGIES": "",
     "STRATEGY_MODE": "INTENT_ONLY",  # INTENT_ONLY | LIVE
     "STRATEGY_DRY_RUN": "true",
     "STRATEGY_INTENTS_PATH": "trader/state/strategy_intents.jsonl",
     "STRATEGY_INTENTS_STATE_PATH": "trader/state/strategy_intents_state.json",
     "STRATEGY_MAX_OPEN_INTENTS": "20",
     "STRATEGY_MAX_POSITION_PCT": "0.10",
     "STRATEGY_ALLOW_SELL_ONLY": "false",
     "STRATEGY_WEIGHTS": "",
     "DISABLE_KOSDAQ_LOOP": "false",
     "DISABLE_KOSPI_ENGINE": "false",
     "ACTIVE_STRATEGIES": "1",  # CSV of strategy IDs eligible for managed exits/entries
     "ALLOW_ADOPT_UNMANAGED": "false",
     "STATE_PATH": "trader/state/state.json",
     # PB1 close-pullback defaults
     "ENABLE_BREAKOUT": "false",
     "LEDGER_LOOKBACK_DAYS": "120",
     "BOTSTATE_LOCK_TTL_SEC": "1800",
     "LEDGER_BASE_DIR": "bot_state/trader_ledger",
     "PB1_ENTRY_ENABLED": "true",
     "MORNING_WINDOW_START": "08:50",
     "MORNING_WINDOW_END": "11:00",
     "MORNING_EXIT_START": "09:00",
     "MORNING_EXIT_END": "09:20",
@@ -417,46 +419,48 @@ def _parse_hhmm(hhmm: str) -> dtime:
 
 SELL_FORCE_TIME = _parse_hhmm(SELL_FORCE_TIME_STR)
 TIME_STOP_TIME = _parse_hhmm(TIME_STOP_HHMM)
 ALLOW_WHEN_CLOSED = _cfg_bool("MARKET_DATA_WHEN_CLOSED")
 DISABLE_KOSDAQ_LOOP = _cfg_bool("DISABLE_KOSDAQ_LOOP")
 DISABLE_KOSPI_ENGINE = _cfg_bool("DISABLE_KOSPI_ENGINE")
 ENABLE_BREAKOUT = _cfg_bool("ENABLE_BREAKOUT")
 PB1_ENTRY_ENABLED = _cfg_bool("PB1_ENTRY_ENABLED", fallback=True)
 LEDGER_LOOKBACK_DAYS = int(_cfg("LEDGER_LOOKBACK_DAYS") or "120")
 BOTSTATE_LOCK_TTL_SEC = int(_cfg("BOTSTATE_LOCK_TTL_SEC") or "900")
 LEDGER_BASE_DIR = Path(_cfg("LEDGER_BASE_DIR") or "bot_state/trader_ledger")
 MORNING_WINDOW_START = _cfg("MORNING_WINDOW_START") or "08:50"
 MORNING_WINDOW_END = _cfg("MORNING_WINDOW_END") or "11:00"
 MORNING_EXIT_START = _cfg("MORNING_EXIT_START") or "09:00"
 MORNING_EXIT_END = _cfg("MORNING_EXIT_END") or "09:20"
 AFTERNOON_WINDOW_START = _cfg("AFTERNOON_WINDOW_START") or "14:00"
 AFTERNOON_WINDOW_END = _cfg("AFTERNOON_WINDOW_END") or "15:30"
 CLOSE_AUCTION_START = _cfg("CLOSE_AUCTION_START") or "15:20"
 CLOSE_AUCTION_END = _cfg("CLOSE_AUCTION_END") or "15:30"
 PB1_REQUIRE_VOLUME = _cfg_bool("PB1_REQUIRE_VOLUME", fallback=False)
 PB1_FORCE_ENTRY_ON_PUSH = _cfg_bool("PB1_FORCE_ENTRY_ON_PUSH", fallback=True)
 PB1_WAIT_FOR_WINDOW = _cfg_bool("PB1_WAIT_FOR_WINDOW", fallback=True)
 PB1_MAX_WAIT_FOR_WINDOW_MIN = int(_cfg("PB1_MAX_WAIT_FOR_WINDOW_MIN") or "240")
 MARKET_OPEN_HHMM = _cfg("MARKET_OPEN_HHMM") or "08:50"
 MARKET_CLOSE_HHMM = _cfg("MARKET_CLOSE_HHMM") or "15:30"
+PB1_DIAG_LEVEL = int(_cfg("PB1_DIAG_LEVEL") or "1")
+PB1_SHADOW_LIVE = _cfg_bool("PB1_SHADOW_LIVE", fallback=False)
 PB1_PULLBACK_BAND_KOSPI = tuple(float(x.strip()) for x in (_cfg("PB1_PULLBACK_BAND_KOSPI") or "3,8").split(","))
 PB1_PULLBACK_BAND_KOSDAQ = tuple(float(x.strip()) for x in (_cfg("PB1_PULLBACK_BAND_KOSDAQ") or "4,10").split(","))
 PB1_VOL_CONTRACTION_MAX = float(_cfg("PB1_VOL_CONTRACTION_MAX") or "0.80")
 PB1_VOLU_CONTRACTION_MAX = float(_cfg("PB1_VOLU_CONTRACTION_MAX") or "0.75")
 PB1_SWING_TREND_MIN = float(_cfg("PB1_SWING_TREND_MIN") or "1.05")
 PB1_SWING_VOL_CONTRACTION_MAX = float(_cfg("PB1_SWING_VOL_CONTRACTION_MAX") or "0.80")
 PB1_SWING_VOLU_CONTRACTION_MAX = float(_cfg("PB1_SWING_VOLU_CONTRACTION_MAX") or "0.75")
 PB1_R_FLOOR_PCT = float(_cfg("PB1_R_FLOOR_PCT") or "2.0")
 PB1_DAY_TP_R = float(_cfg("PB1_DAY_TP_R") or "0.8")
 PB1_DAY_SL_R = float(_cfg("PB1_DAY_SL_R") or "0.6")
 KOSPI_HARD_STOP_PCT = float(_cfg("KOSPI_HARD_STOP_PCT") or "7.0")
 KOSDAQ_HARD_STOP_PCT = float(_cfg("KOSDAQ_HARD_STOP_PCT") or "8.0")
 PB1_SWING_TRAIL_MA = int(_cfg("PB1_SWING_TRAIL_MA") or "20")
 PB1_TIME_STOP_DAYS = int(_cfg("PB1_TIME_STOP_DAYS") or "10")
 
 # === [NEW] 주간 리밸런싱 강제 트리거 상태 파일 ===
 STATE_WEEKLY_PATH = Path(__file__).parent / "state_weekly.json"
 
 def _this_iso_week_key(now=None):
     now = now or datetime.now(KST)
     return f"{now.year}-W{now.isocalendar().week:02d}"
diff --git a/trader/kis_wrapper.py b/trader/kis_wrapper.py
index a173307d02a12987125cb48968bd05ed6eba5757..87d747cd3801f26a66cd11691a0931ecf9ca3805 100644
--- a/trader/kis_wrapper.py
+++ b/trader/kis_wrapper.py
@@ -476,50 +476,106 @@ class KisAPI:
             price = 0.0
         if price <= 0:
             return 0
         cash = self.get_cash_available_today()
         if cash <= 0:
             return 0
 
         try:
             max_qty = int(cash // price)
         except Exception:
             max_qty = 0
         max_qty = min(max_qty, int(req_qty) if req_qty else 0)
         if max_qty <= 0:
             return 0
 
         lo, hi = 0, max_qty
         while lo < hi:
             mid = (lo + hi + 1) // 2
             cost = self._estimate_buy_cost(price, mid, fee_pct, tax_pct)
             if cost <= cash:
                 lo = mid
             else:
                 hi = mid - 1
         return lo
 
+    def get_orderable_qty(self, code: str) -> int:
+        """보유/주문가능 수량 조회 (음수 방지)."""
+        try:
+            balance_map = self.get_balance_map()
+            qty = int(balance_map.get(safe_strip(code), 0))
+            return max(0, qty)
+        except Exception:
+            logger.exception("[ORDERABLE_QTY][FAIL] code=%s", code)
+            return 0
+
+    def validate_buy(self, code: str, qty: int, price: float | None) -> Tuple[bool, str]:
+        """섀도우 모드용 매수 사전검증."""
+        try:
+            qty_int = int(qty)
+        except Exception:
+            qty_int = 0
+        if qty_int <= 0:
+            return False, "qty_invalid"
+        try:
+            if price is None or float(price) <= 0:
+                return False, "price_invalid"
+        except Exception:
+            return False, "price_invalid"
+        try:
+            cash, _meta = self.get_orderable_cash(code, price)
+        except Exception:
+            cash = 0
+        est_cost = self._estimate_buy_cost(price or 0.0, qty_int)
+        if est_cost <= 0:
+            return False, "cost_invalid"
+        if cash <= 0:
+            return False, "cash_empty"
+        if est_cost > cash:
+            return False, "insufficient_cash"
+        return True, "ok"
+
+    def validate_sell(self, code: str, qty: int, price: float | None) -> Tuple[bool, str]:
+        """섀도우 모드용 매도 사전검증."""
+        try:
+            qty_int = int(qty)
+        except Exception:
+            qty_int = 0
+        if qty_int <= 0:
+            return False, "qty_invalid"
+        try:
+            if price is None or float(price) <= 0:
+                return False, "price_invalid"
+        except Exception:
+            return False, "price_invalid"
+        orderable_qty = self.get_orderable_qty(code)
+        if orderable_qty <= 0:
+            return False, "orderable_qty_zero"
+        if qty_int > orderable_qty:
+            return False, "qty_exceeds_available"
+        return True, "ok"
+
     # === 시세 ===
     def _inquire_price_once(self, tr_id: str, market_div: str, code_fmt: str) -> Optional[float]:
         """단일 TR/마켓/코드 조합으로 현재가 1회 조회(성공시 float 반환, 실패/0원시 None)."""
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-price"
         headers = self._headers(tr_id)
         params = {"fid_cond_mrkt_div_code": market_div, "fid_input_iscd": code_fmt}
         try:
             # [CHG] 안전요청 사용
             resp = self._safe_request("GET", url, headers=headers, params=params, timeout=(3.0, 5.0))
             data = resp.json()
         except Exception as e:
             logger.debug("[PRICE_ONCE_EX] %s/%s %s → %s", market_div, code_fmt, tr_id, e)
             return None
 
         if "초당 거래건수" in (data.get("msg1") or ""):
             return None
         if resp.status_code == 200 and data.get("rt_cd") == "0" and data.get("output"):
             try:
                 px = float(data["output"].get("stck_prpr") or 0)
                 return px if px > 0 else None
             except Exception:
                 return None
         return None
 
     def get_last_price(self, code: str, *, attempts: int = 2) -> float:
diff --git a/trader/pb1_engine.py b/trader/pb1_engine.py
index 746212d19d57d45079f9121d3625bfa7e4c7e2e8..8a5a56fc37a862dc6deb54841792eb0651cd1422 100644
--- a/trader/pb1_engine.py
+++ b/trader/pb1_engine.py
@@ -1,28 +1,29 @@
 from __future__ import annotations
 
 import logging
+import json
 from dataclasses import dataclass
 import os
 from datetime import datetime, timedelta
 from pathlib import Path
 from typing import Dict, Iterable, List, Tuple
 
 import pandas as pd
 
 from rolling_k_auto_trade_api.best_k_meta_strategy import run_rebalance
 from trader.config import (
     CAP_CAP,
     DAILY_CAPITAL,
     KOSDAQ_HARD_STOP_PCT,
     KOSPI_HARD_STOP_PCT,
     LEDGER_BASE_DIR,
     LEDGER_LOOKBACK_DAYS,
     PB1_ENTRY_ENABLED,
     PB1_DAY_SL_R,
     PB1_DAY_TP_R,
     PB1_R_FLOOR_PCT,
     PB1_TIME_STOP_DAYS,
     PB1_REQUIRE_VOLUME,
 )
 from trader.utils.env import env_bool
 from trader.kis_wrapper import KisAPI
@@ -39,109 +40,177 @@ logger = logging.getLogger(__name__)
 
 @dataclass
 class CandidateFeature:
     code: str
     market: str
     features: Dict[str, float]
     setup_ok: bool
     reasons: List[str]
     mode: int
     mode_reasons: List[str]
     client_order_key: str | None = None
     planned_qty: int = 0
 
 
 class PB1Engine:
     def __init__(
         self,
         *,
         kis: KisAPI | None,
         worktree_dir: Path,
         window: WindowDecision,
         phase_override: str,
         dry_run: bool,
         env: str,
         run_id: str,
+        order_mode: str = "live",
+        diag_level: int = 1,
     ) -> None:
         self.kis = kis
         self.worktree_dir = worktree_dir
         self.window = window
         self.phase = resolve_phase(window, phase_override)
         self.dry_run = dry_run
         self.env = env
         self.run_id = run_id
+        self.order_mode = order_mode
+        self.diag_level = diag_level
         base_dir = LEDGER_BASE_DIR
         if not Path(base_dir).is_absolute():
             base_dir = worktree_dir / base_dir
         self.ledger = LedgerStore(Path(base_dir), env=env, run_id=run_id)
         self.worktree_dir = worktree_dir
         self._today = now_kst().date().isoformat()
         self.require_volume = env_bool("PB1_REQUIRE_VOLUME", PB1_REQUIRE_VOLUME)
+        self.diag_counters: Dict[str, object] = {
+            "universe_size": 0,
+            "candidates": 0,
+            "entry_orders": 0,
+            "exit_orders": 0,
+            "preflight_ok": 0,
+            "preflight_fail": 0,
+            "fail_reasons": [],
+        }
+        self.executor = self._build_executor()
+
+    def _build_executor(self):
+        if self.order_mode == "shadow":
+            return ShadowExecutor(
+                kis=self.kis,
+                ledger=self.ledger,
+                env=self.env,
+                run_id=self.run_id,
+                worktree_dir=self.worktree_dir,
+                diag_counters=self.diag_counters,
+            )
+        if self.order_mode == "dry_run":
+            return DryRunExecutor(
+                ledger=self.ledger,
+                env=self.env,
+                run_id=self.run_id,
+                diag_counters=self.diag_counters,
+            )
+        return LiveExecutor(
+            kis=self.kis,
+            ledger=self.ledger,
+            env=self.env,
+            run_id=self.run_id,
+            worktree_dir=self.worktree_dir,
+            diag_counters=self.diag_counters,
+        )
 
     def _client_order_key(self, code: str, mode: int, side: str, stage: str, window_tag: str) -> str:
         return f"{self._today}|{code}|sid=1|mode={mode}|{side}|{window_tag}|{stage}"
 
     def _log_setup(self, cf: CandidateFeature) -> None:
         prefix = "[PB1][SETUP-OK]" if cf.setup_ok else "[PB1][SETUP-BAD]"
         logger.info(
             "%s code=%s market=%s mode=%s reasons=%s features=%s",
             prefix,
             cf.code,
             cf.market,
             cf.mode,
             cf.reasons or ["n/a"],
             {k: cf.features.get(k) for k in ["close", "ma20", "ma50", "pullback_pct", "vol_contraction", "volu_contraction"]},
         )
 
     def _fetch_daily(self, code: str, count: int = 120) -> tuple[pd.DataFrame, Dict]:
         if not self.kis:
             return pd.DataFrame(), {"volume_missing": True, "source_cols": [], "mapped": {}}
         try:
             candles = self.kis.safe_get_daily_candles(code, count=count)
         except Exception:
             logger.exception("[PB1][DATA][FAIL] code=%s", code)
             return pd.DataFrame(), {"volume_missing": True, "source_cols": [], "mapped": {}}
         if not candles:
             return pd.DataFrame(), {"volume_missing": True, "source_cols": [], "mapped": {}}
         df = pd.DataFrame(candles).copy()
         if df.empty:
             return df, {"volume_missing": True, "source_cols": [], "mapped": {}}
 
         df_norm, meta = normalize_ohlcv(df)
         return df_norm, meta
 
     def _build_universe(self) -> Dict[str, List[Dict]]:
         """
         Build selection universe for PB1 without triggering any legacy order flows.
         run_rebalance() in best_k_meta_strategy is selection-only and returns weights.
         """
+        cache_path = self.worktree_dir / "bot_state" / "trader_state" / "universe_cache.json"
+        today_str = now_kst().date().isoformat()
+        cache_path.parent.mkdir(parents=True, exist_ok=True)
+        selected_by_market: Dict[str, List[Dict]] = {}
+        cache_loaded = False
         try:
             rebalance_payload = run_rebalance(str(now_kst().date()), return_by_market=True)
-            return rebalance_payload.get("selected_by_market") or {}
+            selected_by_market = rebalance_payload.get("selected_by_market") or {}
+            if selected_by_market:
+                try:
+                    with open(cache_path, "w", encoding="utf-8") as f:
+                        json.dump({"date": today_str, "selected_by_market": selected_by_market, "source": "pykrx"}, f, ensure_ascii=False, indent=2)
+                    logger.info("[PB1][UNIVERSE][CACHE-SAVE] path=%s", cache_path)
+                except Exception:
+                    logger.exception("[PB1][UNIVERSE][CACHE-SAVE][FAIL]")
+            else:
+                raise ValueError("empty_universe")
         except Exception:
             logger.exception("[PB1][UNIVERSE][FAIL]")
-            return {}
+            if cache_path.exists():
+                try:
+                    with open(cache_path, "r", encoding="utf-8") as f:
+                        cached = json.load(f)
+                        selected_by_market = cached.get("selected_by_market") or {}
+                        cache_loaded = True
+                        logger.warning("[PB1][UNIVERSE][FALLBACK]=cache path=%s source=%s", cache_path, cached.get("source"))
+                except Exception:
+                    logger.exception("[PB1][UNIVERSE][CACHE-LOAD][FAIL]")
+        self.diag_counters["universe_size"] = sum(len(v or []) for v in (selected_by_market or {}).values())
+        if not selected_by_market:
+            raise RuntimeError("universe_build_failed")
+        if cache_loaded:
+            self.diag_counters["fail_reasons"].append("pykrx_universe_empty")
+        return selected_by_market
 
     def _code_market_map(self, selected_by_market: Dict[str, List[Dict]]) -> Dict[str, str]:
         mapping: Dict[str, str] = {}
         for market, rows in (selected_by_market or {}).items():
             for row in rows or []:
                 code = str(row.get("code") or row.get("pdno") or "").zfill(6)
                 mapping[code] = market
         return mapping
 
     def _compute_candidates(self, selected_by_market: Dict[str, List[Dict]]) -> List[CandidateFeature]:
         candidates: List[CandidateFeature] = []
         for market, rows in (selected_by_market or {}).items():
             for row in rows or []:
                 code = str(row.get("code") or row.get("pdno") or "").zfill(6)
                 try:
                     df, meta = self._fetch_daily(code, count=120)
                     if df.empty:
                         cf = CandidateFeature(
                             code=code,
                             market=market,
                             features={"reasons": ["data_empty"]},
                             setup_ok=False,
                             reasons=["data_empty"],
                             mode=1,
                             mode_reasons=["default_day_mode"],
@@ -154,177 +223,113 @@ class PB1Engine:
                     features["volume_missing"] = bool(meta.get("volume_missing"))
                     if features.get("volume_missing"):
                         features["volu_contraction"] = None
                     ok, reasons = evaluate_setup(features, market, require_volume=self.require_volume)
                     if features.get("volume_missing") and "volume_missing" not in reasons:
                         reasons.append("volume_missing")
                     if ok:
                         reasons = []
                     elif not reasons:
                         reasons = ["unspecified_fail"]
                     mode, mode_reasons = choose_mode(features)
                     cf = CandidateFeature(
                         code=code,
                         market=market,
                         features=features,
                         setup_ok=ok,
                         reasons=reasons,
                         mode=mode,
                         mode_reasons=mode_reasons,
                     )
                     self._log_setup(cf)
                     candidates.append(cf)
                 except Exception:
                     logger.exception("[PB1][DAILY] fetch/normalize failed code=%s", code)
                     continue
+        self.diag_counters["candidates"] = len(candidates)
         return candidates
 
     def _size_positions(self, candidates: List[CandidateFeature]) -> List[CandidateFeature]:
         ok_list = [c for c in candidates if c.setup_ok]
         total = len(ok_list)
         if total <= 0:
             return candidates
         capital_per = DAILY_CAPITAL * CAP_CAP / total
         for cf in ok_list:
             close_px = cf.features.get("close") or 0
             qty = int(capital_per // close_px) if close_px > 0 else 0
             cf.planned_qty = max(qty, 0)
             cf.client_order_key = self._client_order_key(
                 cf.code, cf.mode, "BUY", "PB1", "close"
             )
             if cf.planned_qty <= 0:
                 cf.setup_ok = False
                 cf.reasons.append("planned_qty_zero")
                 self._log_setup(cf)
         return candidates
 
     def _should_block_order(self, client_order_key: str) -> bool:
         if not client_order_key:
             return True
         return self.ledger.has_client_order_key(client_order_key)
 
     def _append_intent(self, cf: CandidateFeature) -> None:
         event = new_order_intent(
             code=cf.code,
             market=cf.market,
             sid=1,
             mode=cf.mode,
-            env="paper" if self.dry_run else self.kis.env if self.kis else "paper",
+            env=self.env,
             run_id=self.run_id,
             side="BUY",
             qty=cf.planned_qty,
             price=cf.features.get("close"),
             client_order_key=cf.client_order_key,
-            ok=not self.dry_run,
-            reasons=["dry_run"] if self.dry_run else ["pb1_close_entry"],
+            ok=self.order_mode == "live",
+            reasons=["dry_run"] if self.order_mode == "dry_run" else ["shadow_mode"] if self.order_mode == "shadow" else ["pb1_close_entry"],
             stage="PB1-CLOSE",
+            payload={"order_mode": self.order_mode},
         )
         path = self.ledger.append_event("orders_intent", event)
+        self.diag_counters["entry_orders"] = int(self.diag_counters.get("entry_orders", 0)) + 1
         logger.info("[PB1][ENTRY-INTENT] code=%s mode=%s qty=%s key=%s path=%s", cf.code, cf.mode, cf.planned_qty, cf.client_order_key, path)
 
     def _place_entry(self, cf: CandidateFeature) -> List[Path]:
         paths: List[Path] = []
         self._append_intent(cf)
         paths.append(self.ledger._run_file("orders_intent"))
-        if self.dry_run:
-            return paths
-        if not self.kis:
-            err = new_unfilled(
-                code=cf.code,
-                market=cf.market,
-                sid=1,
-                mode=cf.mode,
-                env=self.env,
-                run_id=self.run_id,
-                side="BUY",
-                qty=cf.planned_qty,
-                price=cf.features.get("close"),
-                client_order_key=cf.client_order_key,
-                reasons=["kis_missing"],
-                stage="PB1-CLOSE",
-            )
-            paths.append(self.ledger.append_event("errors", err))
-            return paths
-        resp = None
-        try:
-            resp = self.kis.buy_stock_market(cf.code, cf.planned_qty)
-        except Exception:
-            logger.exception("[PB1][ENTRY][FAIL] code=%s", cf.code)
-        odno = ""
-        if isinstance(resp, dict):
-            odno = (resp.get("output") or {}).get("ODNO") or ""
-        ack = new_order_ack(
+        exec_paths, _ok, _reason = self.executor.submit_order(
             code=cf.code,
             market=cf.market,
-            sid=1,
             mode=cf.mode,
-            env=self.env,
-            run_id=self.run_id,
-            side="BUY",
             qty=cf.planned_qty,
             price=cf.features.get("close"),
-            odno=odno,
             client_order_key=cf.client_order_key,
-            ok=bool(resp and resp.get("rt_cd") == "0"),
-            reasons=[] if resp and resp.get("rt_cd") == "0" else [resp.get("msg1", "order_failed")] if isinstance(resp, dict) else ["order_failed"],
             stage="PB1-CLOSE",
+            side="BUY",
         )
-        paths.append(self.ledger.append_event("orders_ack", ack))
-        if resp and resp.get("rt_cd") == "0":
-            fill_price = cf.features.get("close")
-            fill = new_fill(
-                code=cf.code,
-                market=cf.market,
-                sid=1,
-                mode=cf.mode,
-                env=self.env,
-                run_id=self.run_id,
-                side="BUY",
-                qty=cf.planned_qty,
-                price=fill_price,
-                odno=odno,
-                client_order_key=cf.client_order_key,
-                stage="PB1-CLOSE",
-            )
-            paths.append(self.ledger.append_event("fills", fill))
-            persist_run_files(self.worktree_dir, [paths[-1]], message=f"pb1 fill {self.run_id}")
-        else:
-            unfilled = new_unfilled(
-                code=cf.code,
-                market=cf.market,
-                sid=1,
-                mode=cf.mode,
-                env=self.env,
-                run_id=self.run_id,
-                side="BUY",
-                qty=cf.planned_qty,
-                price=cf.features.get("close"),
-                client_order_key=cf.client_order_key,
-                reasons=ack.reasons if ack.reasons else ["order_failed"],
-                stage="PB1-CLOSE",
-            )
-            paths.append(self.ledger.append_event("errors", unfilled))
+        paths.extend(exec_paths)
         return paths
 
     def _mark_price(self, code: str) -> float | None:
         if self.kis:
             try:
                 quote = self.kis.get_price_quote(code)
                 if isinstance(quote, dict):
                     pr = quote.get("stck_prpr") or quote.get("prpr")
                     return float(pr) if pr is not None else None
             except Exception:
                 logger.exception("[PB1][PRICE][FAIL] code=%s", code)
         return None
 
     def _fetch_marks(self, codes: Iterable[str], fallback: Dict[str, float]) -> Dict[str, float]:
         marks: Dict[str, float] = {}
         for code in codes:
             px = self._mark_price(code)
             if px is None:
                 px = fallback.get(code)
             if px is not None:
                 marks[code] = px
         return marks
 
     def _plan_exit_event(self, pos: Dict, features: Dict[str, float], window_tag: str) -> None:
         avg = pos.get("avg_buy_price")
@@ -370,180 +375,593 @@ class PB1Engine:
                     return
             else:
                 if window_tag != "close":
                     return
                 close_px = features.get("close")
                 ma20 = features.get("ma20")
                 holding_days = pos.get("holding_days") or 0
                 if holding_days >= PB1_TIME_STOP_DAYS:
                     stage = "TIME-STOP"
                 elif close_px is not None and ma20 is not None and close_px < ma20:
                     stage = "MA20-TRAIL"
                 else:
                     return
             reasons = ["pb1_exit"]
         event = new_exit_intent(
             code=code,
             market=market,
             sid=1,
             mode=mode,
             env=self.env,
             run_id=self.run_id,
             side="SELL",
             qty=qty,
             price=mark,
             client_order_key=client_key,
-            ok=not self.dry_run,
-            reasons=["dry_run"] if self.dry_run else reasons,
+            ok=self.order_mode == "live",
+            reasons=["dry_run"] if self.order_mode == "dry_run" else ["shadow_mode"] if self.order_mode == "shadow" else reasons,
             stage=stage,
+            payload={"order_mode": self.order_mode},
         )
         path = self.ledger.append_event("exits_intent", event)
         logger.info("[PB1][EXIT-INTENT] code=%s mode=%s stage=%s ret_pct=%.2f key=%s path=%s", code, mode, stage, ret_pct, client_key, path)
-        # execute sell when allowed
-        if self.dry_run:
-            return
-        if not self.kis:
-            logger.warning("[PB1][EXIT][SKIP] kis missing code=%s", code)
-            return
-        resp = None
-        try:
-            resp = self.kis.sell_stock_market(code, qty)
-        except Exception:
-            logger.exception("[PB1][EXIT][FAIL] code=%s", code)
-        odno = ""
-        if isinstance(resp, dict):
-            odno = (resp.get("output") or {}).get("ODNO") or ""
-        ack = new_order_ack(
+        self.diag_counters["exit_orders"] = int(self.diag_counters.get("exit_orders", 0)) + 1
+        self.executor.submit_exit(
             code=code,
             market=market,
-            sid=1,
             mode=mode,
-            env=self.env,
-            run_id=self.run_id,
-            side="SELL",
             qty=qty,
             price=mark,
-            odno=odno,
             client_order_key=client_key,
-            ok=bool(resp and resp.get("rt_cd") == "0"),
-            reasons=[] if resp and resp.get("rt_cd") == "0" else [resp.get("msg1", "order_failed")] if isinstance(resp, dict) else ["order_failed"],
             stage=stage,
+            side="SELL",
         )
-        self.ledger.append_event("orders_ack", ack)
-        if resp and resp.get("rt_cd") == "0":
-            fill = new_fill(
-                code=code,
-                market=market,
-                sid=1,
-                mode=mode,
-                env=self.env,
-                run_id=self.run_id,
-                side="SELL",
-                qty=qty,
-                price=mark,
-                odno=odno,
-                client_order_key=client_key,
-                stage=stage,
-            )
-            fill_path = self.ledger.append_event("fills", fill)
-            persist_run_files(self.worktree_dir, [fill_path], message=f"pb1 fill {self.run_id}")
-        else:
-            err = new_unfilled(
-                code=code,
-                market=market,
-                sid=1,
-                mode=mode,
-                env=self.env,
-                run_id=self.run_id,
-                side="SELL",
-                qty=qty,
-                price=mark,
-                client_order_key=client_key,
-                reasons=ack.reasons if ack.reasons else ["order_failed"],
-                stage=stage,
-            )
-            self.ledger.append_event("errors", err)
 
     def _positions_with_meta(self, positions: Dict[Tuple[str, int, int], Dict]) -> List[Dict]:
         enriched: List[Dict] = []
         for (code, sid, mode), state in positions.items():
             if sid != 1:
                 continue
             enriched.append(
                 {
                     "code": code,
                     "sid": sid,
                     "mode": mode,
                     "total_qty": state.get("total_qty") or 0,
                     "avg_buy_price": state.get("avg_buy_price"),
                     "market": state.get("market"),
                     "holding_days": state.get("holding_days") or 0,
                     "first_buy_ts": state.get("first_buy_ts"),
                 }
             )
         return enriched
 
     def _is_diagnostic_guard_enabled(self) -> bool:
         skip_env = os.getenv("PB1_SKIP_UNIVERSE_IN_DIAG") == "1"
         return bool(
-            (self.window and self.window.name == "diagnostic")
-            or (self.dry_run and skip_env)
-            or (self.phase == "verify")
+            self.order_mode == "dry_run"
+            and (
+                (self.window and self.window.name == "diagnostic")
+                or (skip_env)
+                or (self.phase == "verify")
+            )
         )
 
     def _run_verify_only(self, positions: Dict[Tuple[str, int, int], Dict], touched: List[Path]) -> List[Path]:
         logger.info(
             "[PB1][DIAG-MODE] universe/rebalance skipped window=%s phase=%s dry_run=%s",
             self.window.name,
             self.phase,
             self.dry_run,
         )
         marks = self._fetch_marks([p["code"] for p in self._positions_with_meta(positions)], {})
         snapshot = self.ledger.generate_pnl_snapshot(positions, marks=marks)
         logger.info(
             "[PNL][SNAPSHOT] portfolio_return_pct=%.2f%% unrealized=%.2f realized=%.2f",
             snapshot["totals"]["portfolio_return_pct"],
             snapshot["totals"]["unrealized"],
             snapshot["totals"]["realized"],
         )
         snap_path = self.ledger.write_snapshot(snapshot, self.run_id)
         touched.append(snap_path)
+        touched = self._emit_diag_summary(touched)
         return touched
 
     def run(self) -> List[Path]:
         entry_allowed = PB1_ENTRY_ENABLED and env_bool("PB1_ENTRY_ENABLED", PB1_ENTRY_ENABLED)
         if not entry_allowed:
             logger.warning("[PB1][ENTRY_DISABLED] PB1_ENTRY_ENABLED=%s -> skip new entries", entry_allowed)
         logger.info("[PB1][RUN] window=%s phase=%s dry_run=%s", self.window.name, self.phase, self.dry_run)
         run_files = self.ledger.open_run_files()
         touched: List[Path] = list(run_files.values())
         logger.info("[LEDGER][APPEND] kind=touch path=%s", run_files)
         persist_run_files(self.worktree_dir, touched, message=f"pb1 touch run_id={self.run_id}")
         positions = self.ledger.rebuild_positions_average_cost(lookback_days=LEDGER_LOOKBACK_DAYS)
         if self._is_diagnostic_guard_enabled():
             return self._run_verify_only(positions, touched)
-        selected = self._build_universe()
+        try:
+            selected = self._build_universe()
+        except Exception as exc:
+            logger.exception("[PB1][UNIVERSE][ERROR]")
+            err = new_error(
+                code="000000",
+                market="",
+                sid=1,
+                mode=0,
+                env=self.env,
+                run_id=self.run_id,
+                reasons=["universe_build_failed", str(exc)],
+            )
+            touched.append(self.ledger.append_event("errors", err))
+            self.diag_counters["fail_reasons"].append("universe_build_failed")
+            return touched
+        code_market = self._code_market_map(selected)
+        marks_fallback: Dict[str, float] = {}
+        if self.phase in {"prep", "entry"}:
+            candidates = self._compute_candidates(selected)
+            candidates = self._size_positions(candidates)
+            if self.phase == "entry" and self.window.name == "afternoon":
+                code_hint = candidates[0].code if candidates else next(iter(code_market), "005930")
+                price_hint = candidates[0].features.get("close") if candidates else None
+                orderable_cash = 0
+                cash_meta: Dict[str, object] = {"source": "none", "raw_fields": {}, "clamp_applied": False}
+                if self.kis:
+                    orderable_cash, cash_meta = self.kis.get_orderable_cash(code_hint, price_hint)
+                if orderable_cash < 0:
+                    orderable_cash = 0
+                logger.info(
+                    "[PB1][CASH][ORDERABLE] value=%s source=%s clamp=%s raw_fields=%s",
+                    orderable_cash,
+                    cash_meta.get("source"),
+                    cash_meta.get("clamp_applied"),
+                    {
+                        k: (cash_meta.get("raw_fields") or {}).get(k)
+                        for k in ("ord_psbl_cash", "ord_psbl_amt", "nrcvb_buy_amt", "dnca_tot_amt")
+                    },
+                )
+                cash_block_logged = False
+                for cf in candidates:
+                    if not cf.setup_ok:
+                        continue
+                    if self._should_block_order(cf.client_order_key):
+                        continue
+                    if orderable_cash <= 0:
+                        if not cash_block_logged:
+                            logger.info(
+                                "[PB1][CASH-BLOCK] orderable=%s meta=%s reason=insufficient_cash",
+                                orderable_cash,
+                                {
+                                    "source": cash_meta.get("source"),
+                                    "raw_fields": {
+                                        k: (cash_meta.get("raw_fields") or {}).get(k)
+                                        for k in ("ord_psbl_cash", "ord_psbl_amt", "nrcvb_buy_amt", "dnca_tot_amt")
+                                    },
+                                    "clamp_applied": cash_meta.get("clamp_applied"),
+                                },
+                            )
+                            cash_block_logged = True
+                        continue
+                    if not entry_allowed:
+                        continue
+                    paths = self._place_entry(cf)
+                    touched.extend(paths)
+        elif self.phase in {"exit", "verify"}:
+            pos_list = self._positions_with_meta(positions)
+            for pos in pos_list:
+                df, _ = self._fetch_daily(pos["code"], count=120)
+                if df.empty:
+                    err = new_error(
+                        code=pos["code"],
+                        market=pos.get("market") or "",
+                        sid=1,
+                        mode=pos["mode"],
+                        env=self.env,
+                        run_id=self.run_id,
+                        reasons=["daily_data_missing"],
+                    )
+                    self.ledger.append_event("errors", err)
+                    continue
+                features = compute_features(df)
+                features["market"] = pos.get("market") or code_market.get(pos["code"], "")
+                marks_fallback[pos["code"]] = features.get("close")
+                if self.phase == "exit":
+                    self._plan_exit_event(pos, features, "morning" if self.window.name == "morning" else "close")
+        if self.phase == "entry" and self.window.name == "afternoon":
+            pos_list = self._positions_with_meta(positions)
+            for pos in pos_list:
+                df, _ = self._fetch_daily(pos["code"], count=120)
+                if df.empty:
+                    continue
+                features = compute_features(df)
+                features["market"] = pos.get("market") or code_market.get(pos["code"], "")
+                marks_fallback[pos["code"]] = features.get("close")
+                self._plan_exit_event(pos, features, "close")
+        marks = self._fetch_marks([p["code"] for p in self._positions_with_meta(positions)], marks_fallback)
+        snapshot = self.ledger.generate_pnl_snapshot(positions, marks=marks)
+        logger.info(
+            "[PNL][SNAPSHOT] portfolio_return_pct=%.2f%% unrealized=%.2f realized=%.2f",
+            snapshot["totals"]["portfolio_return_pct"],
+            snapshot["totals"]["unrealized"],
+            snapshot["totals"]["realized"],
+        )
+        snap_path = self.ledger.write_snapshot(snapshot, self.run_id)
+        touched.append(snap_path)
+        touched = self._emit_diag_summary(touched)
+        return touched
+
+    def _emit_diag_summary(self, touched: List[Path]) -> List[Path]:
+        if self.order_mode != "shadow":
+            return touched
+        fail_reasons = list(self.diag_counters.get("fail_reasons") or [])
+        if not fail_reasons:
+            fail_reasons = ["none"]
+        summary = {
+            "level": self.diag_level,
+            "order_mode": self.order_mode,
+            "universe": int(self.diag_counters.get("universe_size", 0)),
+            "candidates": int(self.diag_counters.get("candidates", 0)),
+            "entry_intents": int(self.diag_counters.get("entry_orders", 0)),
+            "exit_intents": int(self.diag_counters.get("exit_orders", 0)),
+            "preflight_ok": int(self.diag_counters.get("preflight_ok", 0)),
+            "preflight_fail": int(self.diag_counters.get("preflight_fail", 0)),
+            "fail_reasons": fail_reasons,
+            "ts": now_kst().isoformat(),
+        }
+        logger.info(
+            "[PB1][DIAG-SUMMARY] level=%s mode=%s universe=%s candidates=%s entry_intents=%s exit_intents=%s preflight_ok=%s preflight_fail=%s reasons=%s",
+            summary["level"],
+            summary["order_mode"],
+            summary["universe"],
+            summary["candidates"],
+            summary["entry_intents"],
+            summary["exit_intents"],
+            summary["preflight_ok"],
+            summary["preflight_fail"],
+            fail_reasons,
+        )
+        path = self.ledger.base_dir / "reports" / self._today / "diag_summary.json"
+        path.parent.mkdir(parents=True, exist_ok=True)
+        with open(path, "w", encoding="utf-8") as f:
+            json.dump(summary, f, ensure_ascii=False, indent=2)
+        touched.append(path)
+        return touched
+
+
+class OrderExecutor:
+    def __init__(self, *, ledger: LedgerStore, env: str, run_id: str, diag_counters: Dict[str, object]) -> None:
+        self.ledger = ledger
+        self.env = env
+        self.run_id = run_id
+        self.diag_counters = diag_counters
+
+    def _bump_preflight(self, ok: bool, reason: str | None) -> None:
+        key = "preflight_ok" if ok else "preflight_fail"
+        self.diag_counters[key] = int(self.diag_counters.get(key, 0)) + 1
+        if not ok and reason:
+            reasons = self.diag_counters.setdefault("fail_reasons", [])
+            if reason not in reasons:
+                reasons.append(reason)
+
+    def submit_order(
+        self,
+        *,
+        code: str,
+        market: str,
+        mode: int,
+        qty: int,
+        price: float | None,
+        client_order_key: str,
+        stage: str,
+        side: str,
+    ) -> tuple[List[Path], bool, str | None]:
+        raise NotImplementedError
+
+    def submit_exit(
+        self,
+        *,
+        code: str,
+        market: str,
+        mode: int,
+        qty: int,
+        price: float | None,
+        client_order_key: str,
+        stage: str,
+        side: str,
+    ) -> tuple[List[Path], bool, str | None]:
+        raise NotImplementedError
+
+
+class DryRunExecutor(OrderExecutor):
+    def __init__(self, *, ledger: LedgerStore, env: str, run_id: str, diag_counters: Dict[str, object]) -> None:
+        super().__init__(ledger=ledger, env=env, run_id=run_id, diag_counters=diag_counters)
+
+    def submit_order(self, **kwargs) -> tuple[List[Path], bool, str | None]:
+        self._bump_preflight(True, None)
+        return [], True, None
+
+    def submit_exit(self, **kwargs) -> tuple[List[Path], bool, str | None]:
+        self._bump_preflight(True, None)
+        return [], True, None
+
+
+class ShadowExecutor(OrderExecutor):
+    def __init__(
+        self,
+        *,
+        kis: KisAPI | None,
+        ledger: LedgerStore,
+        env: str,
+        run_id: str,
+        worktree_dir: Path,
+        diag_counters: Dict[str, object],
+    ) -> None:
+        super().__init__(ledger=ledger, env=env, run_id=run_id, diag_counters=diag_counters)
+        self.kis = kis
+        self.worktree_dir = worktree_dir
+
+    def _shadow_ack(
+        self,
+        *,
+        code: str,
+        market: str,
+        mode: int,
+        qty: int,
+        price: float | None,
+        client_order_key: str,
+        stage: str,
+        side: str,
+        ok: bool,
+        reason: str | None,
+    ) -> Path:
+        ack = new_order_ack(
+            code=code,
+            market=market,
+            sid=1,
+            mode=mode,
+            env=self.env,
+            run_id=self.run_id,
+            side=side,
+            qty=qty,
+            price=price,
+            odno="",
+            client_order_key=client_order_key,
+            ok=ok,
+            reasons=[] if ok else [reason or "shadow_fail"],
+            stage=stage,
+            payload={
+                "mode": "shadow",
+                "preflight_ok": ok,
+                "reason": reason,
+            },
+        )
+        return self.ledger.append_event("orders_ack", ack)
+
+    def submit_order(self, **kwargs) -> tuple[List[Path], bool, str | None]:
+        code = kwargs.get("code")
+        qty = kwargs.get("qty")
+        price = kwargs.get("price")
+        market = kwargs.get("market")
+        mode = kwargs.get("mode")
+        client_order_key = kwargs.get("client_order_key")
+        stage = kwargs.get("stage")
+        side = kwargs.get("side", "BUY")
+        paths: List[Path] = []
+        if not self.kis:
+            reason = "kis_missing"
+            self._bump_preflight(False, reason)
+            paths.append(
+                self._shadow_ack(
+                    code=code,
+                    market=market,
+                    mode=mode,
+                    qty=qty,
+                    price=price,
+                    client_order_key=client_order_key,
+                    stage=stage,
+                    side=side,
+                    ok=False,
+                    reason=reason,
+                )
+            )
+            return paths, False, reason
+        if side == "BUY":
+            ok, reason = self.kis.validate_buy(code, qty, price)
+        else:
+            ok, reason = self.kis.validate_sell(code, qty, price)
+        self._bump_preflight(ok, reason)
+        paths.append(
+            self._shadow_ack(
+                code=code,
+                market=market,
+                mode=mode,
+                qty=qty,
+                price=price,
+                client_order_key=client_order_key,
+                stage=stage,
+                side=side,
+                ok=ok,
+                reason=reason,
+            )
+        )
+        return paths, ok, reason
+
+    def submit_exit(self, **kwargs) -> tuple[List[Path], bool, str | None]:
+        return self.submit_order(**kwargs)
+
+
+class LiveExecutor(OrderExecutor):
+    def __init__(
+        self,
+        *,
+        kis: KisAPI | None,
+        ledger: LedgerStore,
+        env: str,
+        run_id: str,
+        worktree_dir: Path,
+        diag_counters: Dict[str, object],
+    ) -> None:
+        super().__init__(ledger=ledger, env=env, run_id=run_id, diag_counters=diag_counters)
+        self.kis = kis
+        self.worktree_dir = worktree_dir
+
+    def _handle_order(
+        self,
+        *,
+        code: str,
+        market: str,
+        mode: int,
+        qty: int,
+        price: float | None,
+        client_order_key: str,
+        stage: str,
+        side: str,
+    ) -> tuple[List[Path], bool, str | None]:
+        paths: List[Path] = []
+        if not self.kis:
+            err = new_unfilled(
+                code=code,
+                market=market,
+                sid=1,
+                mode=mode,
+                env=self.env,
+                run_id=self.run_id,
+                side=side,
+                qty=qty,
+                price=price,
+                client_order_key=client_order_key,
+                reasons=["kis_missing"],
+                stage=stage,
+            )
+            paths.append(self.ledger.append_event("errors", err))
+            self._bump_preflight(False, "kis_missing")
+            return paths, False, "kis_missing"
+        resp = None
+        try:
+            if side == "BUY":
+                resp = self.kis.buy_stock_market(code, qty)
+            else:
+                resp = self.kis.sell_stock_market(code, qty)
+        except Exception:
+            logger.exception("[PB1][ORDER][FAIL] code=%s side=%s", code, side)
+        odno = ""
+        if isinstance(resp, dict):
+            odno = (resp.get("output") or {}).get("ODNO") or ""
+        ok = bool(resp and resp.get("rt_cd") == "0")
+        reason = None
+        if not ok:
+            if isinstance(resp, dict):
+                reason = resp.get("msg1") or resp.get("msg_cd") or "order_failed"
+            else:
+                reason = "order_failed"
+        ack = new_order_ack(
+            code=code,
+            market=market,
+            sid=1,
+            mode=mode,
+            env=self.env,
+            run_id=self.run_id,
+            side=side,
+            qty=qty,
+            price=price,
+            odno=odno,
+            client_order_key=client_order_key,
+            ok=ok,
+            reasons=[] if ok else [reason],
+            stage=stage,
+        )
+        paths.append(self.ledger.append_event("orders_ack", ack))
+        if ok:
+            fill = new_fill(
+                code=code,
+                market=market,
+                sid=1,
+                mode=mode,
+                env=self.env,
+                run_id=self.run_id,
+                side=side,
+                qty=qty,
+                price=price,
+                odno=odno,
+                client_order_key=client_order_key,
+                stage=stage,
+            )
+            fill_path = self.ledger.append_event("fills", fill)
+            paths.append(fill_path)
+            persist_run_files(self.worktree_dir, [fill_path], message=f"pb1 fill {self.run_id}")
+        else:
+            unfilled = new_unfilled(
+                code=code,
+                market=market,
+                sid=1,
+                mode=mode,
+                env=self.env,
+                run_id=self.run_id,
+                side=side,
+                qty=qty,
+                price=price,
+                client_order_key=client_order_key,
+                reasons=[reason] if reason else ["order_failed"],
+                stage=stage,
+            )
+            paths.append(self.ledger.append_event("errors", unfilled))
+        self._bump_preflight(ok, reason or None)
+        return paths, ok, reason
+
+    def submit_order(self, **kwargs) -> tuple[List[Path], bool, str | None]:
+        return self._handle_order(**kwargs)
+
+    def submit_exit(self, **kwargs) -> tuple[List[Path], bool, str | None]:
+        return self._handle_order(**kwargs)
+
+    def run(self) -> List[Path]:
+        entry_allowed = PB1_ENTRY_ENABLED and env_bool("PB1_ENTRY_ENABLED", PB1_ENTRY_ENABLED)
+        if not entry_allowed:
+            logger.warning("[PB1][ENTRY_DISABLED] PB1_ENTRY_ENABLED=%s -> skip new entries", entry_allowed)
+        logger.info("[PB1][RUN] window=%s phase=%s dry_run=%s", self.window.name, self.phase, self.dry_run)
+        run_files = self.ledger.open_run_files()
+        touched: List[Path] = list(run_files.values())
+        logger.info("[LEDGER][APPEND] kind=touch path=%s", run_files)
+        persist_run_files(self.worktree_dir, touched, message=f"pb1 touch run_id={self.run_id}")
+        positions = self.ledger.rebuild_positions_average_cost(lookback_days=LEDGER_LOOKBACK_DAYS)
+        if self._is_diagnostic_guard_enabled():
+            return self._run_verify_only(positions, touched)
+        try:
+            selected = self._build_universe()
+        except Exception as exc:
+            logger.exception("[PB1][UNIVERSE][ERROR]")
+            err = new_error(
+                code="000000",
+                market="",
+                sid=1,
+                mode=0,
+                env=self.env,
+                run_id=self.run_id,
+                reasons=["universe_build_failed", str(exc)],
+            )
+            touched.append(self.ledger.append_event("errors", err))
+            self.diag_counters["fail_reasons"].append("universe_build_failed")
+            return touched
         code_market = self._code_market_map(selected)
         marks_fallback: Dict[str, float] = {}
         if self.phase in {"prep", "entry"}:
             candidates = self._compute_candidates(selected)
             candidates = self._size_positions(candidates)
             if self.phase == "entry" and self.window.name == "afternoon":
                 code_hint = candidates[0].code if candidates else next(iter(code_market), "005930")
                 price_hint = candidates[0].features.get("close") if candidates else None
                 orderable_cash = 0
                 cash_meta: Dict[str, object] = {"source": "none", "raw_fields": {}, "clamp_applied": False}
                 if self.kis:
                     orderable_cash, cash_meta = self.kis.get_orderable_cash(code_hint, price_hint)
                 if orderable_cash < 0:
                     orderable_cash = 0
                 logger.info(
                     "[PB1][CASH][ORDERABLE] value=%s source=%s clamp=%s raw_fields=%s",
                     orderable_cash,
                     cash_meta.get("source"),
                     cash_meta.get("clamp_applied"),
                     {
                         k: (cash_meta.get("raw_fields") or {}).get(k)
                         for k in ("ord_psbl_cash", "ord_psbl_amt", "nrcvb_buy_amt", "dnca_tot_amt")
                     },
                 )
                 cash_block_logged = False
diff --git a/trader/pb1_runner.py b/trader/pb1_runner.py
index e9351d8bcf8b41678b17bc00040a2ec3ac4d9371..d53f236959386be40b3ad0f84e30226ffd441912 100644
--- a/trader/pb1_runner.py
+++ b/trader/pb1_runner.py
@@ -1,40 +1,42 @@
 from __future__ import annotations
 
 import argparse
 import logging
 import os
 import time as time_mod
 from datetime import datetime, time as dtime
 from pathlib import Path
 
 from trader.kis_wrapper import KisAPI
 from trader.time_utils import is_trading_day, now_kst
 from trader.config import (
     BOTSTATE_LOCK_TTL_SEC,
     DIAGNOSTIC_MODE,
     DIAGNOSTIC_ONLY,
+    PB1_DIAG_LEVEL,
+    PB1_SHADOW_LIVE,
     MORNING_WINDOW_START,
     MORNING_WINDOW_END,
     MORNING_EXIT_START,
     MORNING_EXIT_END,
     AFTERNOON_WINDOW_START,
     AFTERNOON_WINDOW_END,
     CLOSE_AUCTION_START,
     CLOSE_AUCTION_END,
     PB1_FORCE_ENTRY_ON_PUSH,
     PB1_WAIT_FOR_WINDOW,
     PB1_MAX_WAIT_FOR_WINDOW_MIN,
     MARKET_OPEN_HHMM,
     MARKET_CLOSE_HHMM,
 )
 from trader.utils.env import env_bool, parse_env_flag, resolve_mode
 from trader.botstate_sync import (
     acquire_lock,
     release_lock,
     setup_worktree,
     persist_run_files,
     resolve_botstate_worktree_dir,
 )
 from trader.pb1_engine import PB1Engine
 from trader.window_router import WindowDecision, decide_window
 
@@ -47,92 +49,104 @@ def truthy(value: object) -> bool:
 
 def _parse_hhmm_to_time(hhmm: str) -> time:
     hh, mm = hhmm.split(":")
     return dtime(hour=int(hh), minute=int(mm))
 
 
 def _next_window_start(now: datetime, window_starts: list[dtime]) -> datetime | None:
     sorted_starts = sorted(window_starts)
     for start in sorted_starts:
         if now.time() < start:
             return now.replace(hour=start.hour, minute=start.minute, second=0, microsecond=0)
     return None
 
 
 def _market_session(now: datetime) -> tuple[datetime, datetime]:
     open_t = _parse_hhmm_to_time(MARKET_OPEN_HHMM)
     close_t = _parse_hhmm_to_time(MARKET_CLOSE_HHMM)
     return (
         now.replace(hour=open_t.hour, minute=open_t.minute, second=0, microsecond=0),
         now.replace(hour=close_t.hour, minute=close_t.minute, second=0, microsecond=0),
     )
 
 
 def parse_args() -> argparse.Namespace:
     parser = argparse.ArgumentParser(description="PB1 close pullback runner")
-    parser.add_argument("--window", default="auto", choices=["auto", "morning", "afternoon"], help="Execution window override")
+    parser.add_argument("--window", default="auto", choices=["auto", "morning", "afternoon", "diagnostic"], help="Execution window override")
     parser.add_argument("--phase", default="auto", choices=["auto", "entry", "exit", "verify"], help="Phase override")
     parser.add_argument("--target-branch", default=os.getenv("BOTSTATE_BRANCH", "bot-state"), help="Bot-state target branch")
     return parser.parse_args()
 
 
 def main() -> None:
     args = parse_args()
     now = now_kst()
     event_name = os.getenv("GITHUB_EVENT_NAME", "") or ""
     event_name_lower = event_name.lower()
     trading_day = is_trading_day(now)
     non_trading_day = not trading_day
     diag_env_flag = (
         env_bool("DIAGNOSTIC_FORCE_RUN", False)
         or env_bool("DIAGNOSTIC_ONLY", DIAGNOSTIC_ONLY)
         or env_bool("DIAGNOSTIC_MODE", DIAGNOSTIC_MODE)
     )
+    diag_level_raw = os.getenv("PB1_DIAG_LEVEL", str(PB1_DIAG_LEVEL))
+    try:
+        diag_level = int(diag_level_raw)
+    except Exception:
+        diag_level = 1
+    if diag_level not in (1, 2):
+        diag_level = 1
+    shadow_live_flag = env_bool("PB1_SHADOW_LIVE", PB1_SHADOW_LIVE)
     _, market_close_dt = _market_session(now)
     market_close_time = market_close_dt.time()
     wait_enabled = env_bool("PB1_WAIT_FOR_WINDOW", PB1_WAIT_FOR_WINDOW)
     if event_name_lower == "schedule":
         wait_enabled = False
     max_wait_s = int(PB1_MAX_WAIT_FOR_WINDOW_MIN) * 60
-    window = decide_window(now=now, override=args.window)
+    window = decide_window(now=now, override=args.window if args.window != "diagnostic" else "auto")
+    if args.window == "diagnostic":
+        window = WindowDecision(name="diagnostic", phase=args.phase if args.phase != "auto" else "verify")
     window_name_for_log = window.name if window else "none"
     phase_for_log = window.phase if window and hasattr(window, "phase") else "none"
     target_start = None
 
     os.environ.setdefault("MORNING_WINDOW_START", MORNING_WINDOW_START)
     os.environ.setdefault("MORNING_WINDOW_END", MORNING_WINDOW_END)
     os.environ.setdefault("MORNING_EXIT_START", MORNING_EXIT_START)
     os.environ.setdefault("MORNING_EXIT_END", MORNING_EXIT_END)
     os.environ.setdefault("AFTERNOON_WINDOW_START", AFTERNOON_WINDOW_START)
     os.environ.setdefault("AFTERNOON_WINDOW_END", AFTERNOON_WINDOW_END)
     os.environ.setdefault("CLOSE_AUCTION_START", CLOSE_AUCTION_START)
     os.environ.setdefault("CLOSE_AUCTION_END", CLOSE_AUCTION_END)
 
     worktree_dir = resolve_botstate_worktree_dir()
     setup_worktree(Path.cwd(), worktree_dir, target_branch=args.target_branch)
 
     force_diag = diag_env_flag or not trading_day or now.time() >= market_close_time
+    if window and window.name == "diagnostic":
+        force_diag = True
     if not force_diag and window is None and trading_day and now.time() < market_close_time:
         window_starts = [
             _parse_hhmm_to_time(MORNING_WINDOW_START),
             _parse_hhmm_to_time(AFTERNOON_WINDOW_START),
             _parse_hhmm_to_time(CLOSE_AUCTION_START),
         ]
         target_start = _next_window_start(now, window_starts)
         if target_start is None:
             force_diag = True
         elif not wait_enabled:
             logger.info(
                 "[PB1][RUN-PLAN] event=%s now_kst=%s trading_day=%s action=skip target_start=%s max_wait_s=%s window=%s phase=%s",
                 event_name_lower or "unknown",
                 now.isoformat(),
                 trading_day,
                 target_start.isoformat(),
                 max_wait_s,
                 window_name_for_log,
                 phase_for_log,
             )
             return
         else:
             wait_seconds = int((target_start - now).total_seconds())
             if wait_seconds > max_wait_s:
                 logger.info(
@@ -173,211 +187,238 @@ def main() -> None:
             if remaining <= 0:
                 break
             if remaining > max_wait_s:
                 logger.info(
                     "[PB1][RUN-PLAN] action=skip reason=wait_exceeds_max target_start=%s remaining_s=%.0f max_wait_s=%s",
                     target_start.isoformat(),
                     remaining,
                     max_wait_s,
                 )
                 return
             sleep_for = min(30, remaining)
             logger.info("[PB1][WAIT] until=%s remaining_s=%.0f sleep=%.0f", target_start.isoformat(), remaining, sleep_for)
             time_mod.sleep(sleep_for)
         now = now_kst()
         trading_day = is_trading_day(now)
         non_trading_day = not trading_day
         force_diag = diag_env_flag or not trading_day or now.time() >= market_close_time
         window = decide_window(now=now, override=args.window)
         window_name_for_log = window.name if window else "none"
         phase_for_log = window.phase if window and hasattr(window, "phase") else "none"
         if window is None and not force_diag:
             logger.info("[PB1][WINDOW] outside active windows override=%s now=%s", args.window, now)
             return
         action = "diag" if force_diag else "run"
 
+    if shadow_live_flag and action in {"run", "wait"}:
+        action = "shadow_live"
+    if action == "diag":
+        action = "diag_deep" if diag_level == 2 else "diag_verify"
+
     dry_run_flag = parse_env_flag("DRY_RUN", default=False)
     disable_live_flag = parse_env_flag("DISABLE_LIVE_TRADING", default=False)
     live_trading_flag = parse_env_flag("LIVE_TRADING_ENABLED", default=False)
     expect_live_flag = env_bool("EXPECT_LIVE_TRADING", False)
     mode = resolve_mode(os.getenv("STRATEGY_MODE", ""))
     dry_run_reasons: list[str] = []
+    order_mode = "live"
+    if action == "diag_verify":
+        order_mode = "dry_run"
+    elif action in {"diag_deep", "shadow_live"}:
+        order_mode = "shadow"
     if non_trading_day:
         dry_run_reasons.append("non_trading_day")
         os.environ["PB1_ENTRY_ENABLED"] = "0"
         os.environ["DIAGNOSTIC_FORCE_RUN"] = "1"
-        os.environ["DISABLE_LIVE_TRADING"] = "1"
-        os.environ["DRY_RUN"] = "1"
-        os.environ["LIVE_TRADING_ENABLED"] = "0"
-    diag_enabled = force_diag or diag_env_flag
+        if order_mode != "shadow":
+            os.environ["DISABLE_LIVE_TRADING"] = "1"
+            os.environ["DRY_RUN"] = "1"
+            os.environ["LIVE_TRADING_ENABLED"] = "0"
+            order_mode = "dry_run"
+    diag_enabled = force_diag or diag_env_flag or action.startswith("diag")
     if force_diag and not non_trading_day and now.time() >= market_close_time:
         dry_run_reasons.append("market_closed")
-    if diag_enabled:
+    if diag_enabled and order_mode == "dry_run":
         dry_run_reasons.append("diagnostic_mode")
     if mode == "INTENT_ONLY":
         dry_run_reasons.append("STRATEGY_MODE=INTENT_ONLY")
     if parse_env_flag("DISABLE_LIVE_TRADING", default=disable_live_flag.value).value:
         dry_run_reasons.append("DISABLE_LIVE_TRADING=1")
     live_trading_flag = parse_env_flag("LIVE_TRADING_ENABLED", default=live_trading_flag.value)
     disable_live_flag = parse_env_flag("DISABLE_LIVE_TRADING", default=disable_live_flag.value)
     dry_run_flag = parse_env_flag("DRY_RUN", default=dry_run_flag.value)
     if not live_trading_flag.value and mode == "LIVE":
         dry_run_reasons.append("LIVE_TRADING_ENABLED=0")
     if dry_run_flag.value:
         dry_run_reasons.append("DRY_RUN=1")
     for flag in (dry_run_flag, disable_live_flag, live_trading_flag):
         if not flag.valid:
             dry_run_reasons.append(f"{flag.name}=invalid({flag.raw})")
 
-    dry_run = bool(dry_run_reasons)
+    dry_run = bool(dry_run_reasons) or order_mode == "dry_run"
+    if order_mode == "shadow":
+        dry_run = False
     dry_run_reason = ",".join(dry_run_reasons) if dry_run_reasons else "live"
 
     logger.info(
         "[PB1][DRY_RUN_RESOLVE] event=%s dry_run=%s reasons=%s",
         event_name_lower or "unknown",
         dry_run,
         dry_run_reasons or ["live"],
     )
 
     expect_kis_env = os.getenv("EXPECT_KIS_ENV")
     kis_env_raw = (os.getenv("KIS_ENV") or "").strip()
     kis_env = kis_env_raw.lower()
     api_base_url = (os.getenv("API_BASE_URL") or "").lower()
     guard_live = expect_live_flag and not diag_enabled and trading_day and not dry_run
     if guard_live:
         guard_failures: list[str] = []
         if dry_run:
             guard_failures.append("dry_run")
         if not live_trading_flag.value or not live_trading_flag.valid:
             guard_failures.append("LIVE_TRADING_ENABLED!=1")
         if disable_live_flag.value or not disable_live_flag.valid:
             guard_failures.append("DISABLE_LIVE_TRADING!=0")
         if mode != "LIVE":
             guard_failures.append("STRATEGY_MODE!=LIVE")
         if kis_env != "practice":
             guard_failures.append("KIS_ENV!=practice")
         if "openapivts" not in api_base_url:
             guard_failures.append("API_BASE_URL missing openapivts")
         if expect_kis_env and kis_env_raw != expect_kis_env:
             guard_failures.append("EXPECT_KIS_ENV mismatch")
         if guard_failures:
             raise SystemExit(f"EXPECT_LIVE_TRADING=1 guards failed: {guard_failures}")
 
-    def _apply_env_flags(dry: bool) -> None:
-        os.environ["DRY_RUN"] = "1" if dry else "0"
-        os.environ["DISABLE_LIVE_TRADING"] = "1" if (dry or disable_live_flag.value or non_trading_day) else "0"
-        os.environ["LIVE_TRADING_ENABLED"] = "1" if (live_trading_flag.value and not non_trading_day) else "0"
+    def _apply_env_flags(order_mode_value: str) -> None:
+        os.environ["DRY_RUN"] = "1" if order_mode_value == "dry_run" else "0"
+        if order_mode_value == "shadow":
+            os.environ["DISABLE_LIVE_TRADING"] = "1" if disable_live_flag.value else "0"
+            os.environ["LIVE_TRADING_ENABLED"] = "1" if (live_trading_flag.value and not disable_live_flag.value) else "0"
+        else:
+            os.environ["DISABLE_LIVE_TRADING"] = "1" if (order_mode_value == "dry_run" or disable_live_flag.value or non_trading_day) else "0"
+            os.environ["LIVE_TRADING_ENABLED"] = "1" if (live_trading_flag.value and not non_trading_day and order_mode_value == "live") else "0"
         os.environ["STRATEGY_MODE"] = mode
+        os.environ["ORDER_MODE"] = order_mode_value
 
-    _apply_env_flags(dry_run)
+    _apply_env_flags(order_mode)
 
     phase_override_arg = args.phase
     if (
         window
         and event_name_lower == "push"
         and phase_override_arg == "auto"
         and window.name == "afternoon"
         and env_bool("PB1_FORCE_ENTRY_ON_PUSH", PB1_FORCE_ENTRY_ON_PUSH)
     ):
         try:
             start = datetime.fromisoformat(f"{now.date()}T{AFTERNOON_WINDOW_START}")
             end = datetime.fromisoformat(f"{now.date()}T{AFTERNOON_WINDOW_END}")
             in_afternoon = start.time() <= now.time() < end.time()
         except Exception:
             in_afternoon = False
         if trading_day and in_afternoon and window.phase == "prep":
             logger.info("[PB1][PHASE_OVERRIDE] event=push from=prep to=entry reason=PB1_FORCE_ENTRY_ON_PUSH")
             phase_override_arg = "entry"
 
-    if action == "diag":
-        dry_run = True
+    if action in {"diag_verify", "diag_deep"}:
+        if action == "diag_verify":
+            dry_run = True
+            order_mode = "dry_run"
+        else:
+            dry_run = False
+            order_mode = "shadow"
         dry_run_reason = dry_run_reason if dry_run_reason else "diagnostic"
         dry_run_reasons = dry_run_reasons or ["diagnostic"]
         diag_enabled = True
         if args.phase == "auto":
             phase_override_arg = "verify"
         window = window or WindowDecision(name="diagnostic", phase=phase_override_arg or "verify")
-        _apply_env_flags(dry_run)
+        _apply_env_flags(order_mode)
 
     window_name_for_log = window.name if window else "none"
     phase_for_log = window.phase if window and hasattr(window, "phase") else "none"
 
     logger.info(
-        "[PB1][RUN-START] event=%s now_kst=%s trading_day=%s window=%s phase=%s DRY_RUN=%s DISABLE_LIVE_TRADING=%s LIVE_TRADING_ENABLED=%s STRATEGY_MODE=%s PB1_ENTRY_ENABLED=%s reasons=%s",
+        "[PB1][RUN-START] event=%s now_kst=%s trading_day=%s window=%s phase=%s DRY_RUN=%s DISABLE_LIVE_TRADING=%s LIVE_TRADING_ENABLED=%s STRATEGY_MODE=%s PB1_ENTRY_ENABLED=%s ORDER_MODE=%s reasons=%s",
         event_name_lower or "unknown",
         now.isoformat(),
         trading_day,
         window_name_for_log,
         phase_for_log,
         dry_run,
         os.getenv("DISABLE_LIVE_TRADING"),
         os.getenv("LIVE_TRADING_ENABLED"),
         os.getenv("STRATEGY_MODE"),
         os.getenv("PB1_ENTRY_ENABLED"),
+        order_mode,
         dry_run_reasons or ["live"],
     )
 
     if non_trading_day:
         logger.info("[PB1][SKIP] non-trading-day(%s) → diagnostics/dry-run reason=%s", now.date(), dry_run_reason)
         if diag_enabled:
             logger.warning("[PB1][DIAG] non-trading-day(%s) but running diagnostics", now.date())
 
     owner = os.getenv("GITHUB_ACTOR", "local")
     run_id = os.getenv("GITHUB_RUN_ID", "local")
     lock_acquired = acquire_lock(worktree_dir, owner=owner, run_id=run_id, ttl_sec=BOTSTATE_LOCK_TTL_SEC)
     if not lock_acquired:
         logger.warning("[BOTSTATE][LOCKED] owner=%s run_id=%s", owner, run_id)
         return
 
     os.environ["STATE_PATH"] = str(worktree_dir / "trader" / "state" / "state.json")
     from trader import state_store as runtime_state_store
     state_dir = Path(os.environ["STATE_PATH"]).parent
     state_dir.mkdir(parents=True, exist_ok=True)
     state_target_path = Path(os.environ["STATE_PATH"])
 
     runtime_state = {}
     kis: KisAPI | None = None
     try:
         runtime_state = runtime_state_store.load_state()
         kis = KisAPI()
         balance = kis.get_balance()
         runtime_state = runtime_state_store.reconcile_with_kis_balance(runtime_state, balance, active_strategies={1})
         runtime_state_store.save_state(runtime_state)
     except Exception:
         logger.exception("[PB1] runtime state reconcile failed")
         runtime_state = runtime_state or runtime_state_store.load_state()
         dry_run_reasons.append("kis_init_failed")
         dry_run_reason = ",".join(dry_run_reasons)
         dry_run = True
         _apply_env_flags(dry_run)
 
     if DIAGNOSTIC_ONLY:
         logger.info("[PB1][DIAG] diagnostic_only mode -> exit")
         release_lock(worktree_dir, run_id=run_id)
         return
 
     touched: list[Path] = []
     try:
         engine = PB1Engine(
             kis=kis,
             worktree_dir=worktree_dir,
             window=window,
             phase_override=phase_override_arg,
             dry_run=dry_run,
-            env="paper" if dry_run else kis.env if kis else "paper",
+            env="shadow" if order_mode == "shadow" else "paper" if dry_run else kis.env if kis else "paper",
             run_id=run_id,
+            order_mode=order_mode,
+            diag_level=diag_level,
         )
         touched = engine.run()
         if state_target_path.exists():
             touched.append(state_target_path)
         logger.info("[PB1] run complete touched=%s", touched)
         persist_run_files(
             worktree_dir,
             touched,
             message=f"pb1 ledger run_id={run_id} window={window.name} phase={engine.phase}",
         )
     finally:
         release_lock(worktree_dir, run_id=run_id)
 
 
 if __name__ == "__main__":
     main()
