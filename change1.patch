diff --git a/README.md b/README.md
index 8d133c309b2c59198d9eed4e2a624803e18e4bec..75ed3cfa39c4eb7ee50b67c4e9e36c45370091c0 100644
--- a/README.md
+++ b/README.md
@@ -11,28 +11,35 @@ portfolio/
   portfolio_manager.py
 strategy/
   kospi/{universe.py, rebalance.py, signals.py}
   kosdaq/{universe.py, rolling_entry.py, pullback.py}
 trader/
   trader.py (entrypoint)
   state_manager.py
   legacy_kosdaq_runner.py (previous KOSDAQ loop kept intact)
 ```
 
 ## Engine responsibilities
 - **KOSPI core engine**: KOSPI market-cap Top-N universe, equal-weight targets, periodic rebalance with market orders and KIS quotes.
 - **KOSDAQ alpha engine**: delegates to the legacy rolling-K/VWAP/pullback loop unchanged, using its original state file for backward compatibility.
 - **Capital split**: `PortfolioManager` divides `DAILY_CAPITAL` (or supplied total) into KOSPI and KOSDAQ ratios (default 60/40) and runs each engine independently.
 - **Performance**: portfolio-level PnL snapshots combine KIS cash/positions with engine allocation ratios for unified reporting without coupling the two engines.
   - Engine-level PnL is an attribution estimate based on capital split ratios because positions are pooled at the account level.
 
 ## How to run
 ```
 python -m trader.trader
 ```
 This initializes the portfolio manager, runs KOSPI rebalance if due, then executes the existing KOSDAQ intraday loop without interrupting either engine on errors. The KOSDAQ loop is blocking, so the entrypoint runs a single orchestrated cycle via `run_once()` rather than a repeating scheduler.
 
 Workflow는 bot-state 브랜치에 bot_state/state.json을 커밋하여 런 간 상태를 유지합니다.
 
+## Strategy intent mode (single-account multi-strategy)
+- A new `StrategyManager` runs before engine loops and emits **order intents only** into `trader/state/strategy_intents.jsonl` with a cursor in `trader/state/strategy_intents_state.json`.
+- All five strategies (`breakout`~`volatility`) are present but **disabled by default**: `ENABLED_STRATEGIES=""` means no strategies run, and missing weights are treated as zero even when listed.
+- Enable a subset for testing, e.g. `ENABLED_STRATEGIES="momentum"` with optional weights `STRATEGY_WEIGHTS="momentum=0.10"`. Keep `STRATEGY_MODE=INTENT_ONLY` and `STRATEGY_DRY_RUN=true` (defaults) to avoid any KIS orders.
+- PortfolioManager order: strategies → KOSPI → KOSDAQ. During isolated testing use `DISABLE_KOSPI_ENGINE=true` or `DISABLE_KOSDAQ_LOOP=true` to skip respective engines.
+- State sync scripts in `scripts/state_pull_plain.sh` and `scripts/state_push_plain.sh` now copy the intent log/cursor alongside `trader/state/state.json` into the `bot-state` branch.
+
 ## CI and live-trading safeguards
 - CI (pull_request) runs set `DISABLE_LIVE_TRADING=true` so all KIS API calls are blocked and only static checks execute.
 - The live trading workflow is restricted to the `main` branch and triggers only via schedule or manual dispatch with the branch guard enabled.
diff --git a/portfolio/portfolio_manager.py b/portfolio/portfolio_manager.py
index 6229b1c0ed23b24d378e0111510c444c4da0f110..03c0d9eeaa9a1c2ae913f87fcfc760832ab61d1e 100644
--- a/portfolio/portfolio_manager.py
+++ b/portfolio/portfolio_manager.py
@@ -1,76 +1,120 @@
 from __future__ import annotations
 
 import logging
 from typing import Any, Dict
 
 from rolling_k_auto_trade_api.best_k_meta_strategy import run_rebalance
-from trader.config import DAILY_CAPITAL
+from strategy.manager import StrategyManager
+from strategy.market_data import build_market_data
+import trader.intent_store as intent_store
+from trader.config import (
+    DAILY_CAPITAL,
+    DISABLE_KOSDAQ_LOOP,
+    DISABLE_KOSPI_ENGINE,
+    STRATEGY_INTENTS_PATH,
+)
+from trader.intent_executor import IntentExecutor
+import trader.state_store as state_store
 from trader.core_utils import get_rebalance_anchor_date
 from trader.subject_flow import reset_flow_call_count
 from .kospi_core_engine import KospiCoreEngine
 from .kosdaq_alpha_engine import KosdaqAlphaEngine
 from .performance import PerformanceTracker
 
 logger = logging.getLogger(__name__)
 
 
 class PortfolioManager:
     def __init__(
         self,
         total_capital: float | None = None,
         kospi_ratio: float = 0.6,
         kosdaq_ratio: float = 0.4,
     ) -> None:
         self.total_capital = float(total_capital or DAILY_CAPITAL)
         if kospi_ratio + kosdaq_ratio == 0:
             kospi_ratio, kosdaq_ratio = 0.6, 0.4
         norm = kospi_ratio + kosdaq_ratio
         self.kospi_ratio = kospi_ratio / norm
         self.kosdaq_ratio = kosdaq_ratio / norm
         self.kospi_engine = KospiCoreEngine(capital=self.total_capital * self.kospi_ratio)
         self.kosdaq_engine = KosdaqAlphaEngine(capital=self.total_capital * self.kosdaq_ratio)
         self.performance = PerformanceTracker()
+        self.strategy_manager = StrategyManager(total_capital=self.total_capital)
+        self.intent_executor = IntentExecutor()
         logger.info(
             "[PORTFOLIO] capital=%s kospi=%.0f%% kosdaq=%.0f%%",
             int(self.total_capital),
             self.kospi_ratio * 100,
             self.kosdaq_ratio * 100,
         )
 
     def run_once(self) -> Dict[str, Any]:
         reset_flow_call_count()
         selected_by_market: Dict[str, Any] = {}
         try:
             rebalance_date = str(get_rebalance_anchor_date())
             rebalance_payload = run_rebalance(rebalance_date, return_by_market=True)
             selected_by_market = rebalance_payload.get("selected_by_market") or {}
             logger.info(
                 "[PORTFOLIO][REBALANCE] date=%s kospi=%d kosdaq=%d",
                 rebalance_date,
                 len(selected_by_market.get("KOSPI", [])),
                 len(selected_by_market.get("KOSDAQ", [])),
             )
         except Exception as e:
             logger.exception("[PORTFOLIO] rebalance fetch failed: %s", e)
 
+        runtime_state = state_store.load_state()
         try:
-            kospi = self.kospi_engine.rebalance_if_needed(
-                selected_stocks=selected_by_market.get("KOSPI")
+            market_data = build_market_data(selected_by_market)
+            strategy_result = self.strategy_manager.run_once(
+                market_data=market_data, portfolio_state=runtime_state
             )
+            intents = strategy_result.get("intents") or []
+        except Exception as e:
+            logger.exception("[PORTFOLIO] strategy manager failure: %s", e)
+            strategy_result = {"status": "error", "message": str(e), "enabled": [], "intents": []}
+            intents = []
+
+        try:
+            STRATEGY_INTENTS_PATH.parent.mkdir(parents=True, exist_ok=True)
+            STRATEGY_INTENTS_PATH.touch(exist_ok=True)
+            intent_store.append_intents(intents, STRATEGY_INTENTS_PATH)
+            executor_result = self.intent_executor.run_once()
+        except Exception as e:
+            logger.exception("[PORTFOLIO] intent executor failure: %s", e)
+            executor_result = {"status": "error", "message": str(e)}
+
+        try:
+            if DISABLE_KOSPI_ENGINE:
+                kospi = {"status": "disabled"}
+            else:
+                kospi = self.kospi_engine.rebalance_if_needed(
+                    selected_stocks=selected_by_market.get("KOSPI")
+                )
         except Exception as e:
             logger.exception("[PORTFOLIO] KOSPI engine failure: %s", e)
             kospi = {"status": "error", "message": str(e)}
         try:
-            kosdaq = self.kosdaq_engine.trade_loop(
-                selected_stocks=selected_by_market.get("KOSDAQ")
-            )
+            if DISABLE_KOSDAQ_LOOP:
+                kosdaq = {"status": "disabled"}
+            else:
+                kosdaq = self.kosdaq_engine.trade_loop(
+                    selected_stocks=selected_by_market.get("KOSDAQ")
+                )
         except Exception as e:
             logger.exception("[PORTFOLIO] KOSDAQ engine failure: %s", e)
             kosdaq = {"status": "error", "message": str(e)}
         perf = self.performance.snapshot(
             {
                 "kospi_core": self.kospi_engine.capital,
                 "kosdaq_alpha": self.kosdaq_engine.capital,
             }
         )
-        return {"kospi": kospi, "kosdaq": kosdaq, "performance": perf}
+        return {
+            "strategies": {"manager": strategy_result, "executor": executor_result},
+            "kospi": kospi,
+            "kosdaq": kosdaq,
+            "performance": perf,
+        }
diff --git a/scripts/state_pull_plain.sh b/scripts/state_pull_plain.sh
index cff9153180673aaab6215b42edafb0be0c073cac..ae32087f0a19bc74c401cf0f02c2425936a2eaf8 100755
--- a/scripts/state_pull_plain.sh
+++ b/scripts/state_pull_plain.sh
@@ -1,36 +1,58 @@
 #!/usr/bin/env bash
 set -euo pipefail
 
 STATE_DIR="bot_state"
 JSON_PATH="${STATE_DIR}/state.json"
 REMOTE_PATH="${STATE_DIR}/state.json"
 DEFAULT_STATE='{"version": 1, "lots": [], "updated_at": null}'
 POS_STATE_DIR="trader/state"
 POS_JSON_PATH="${POS_STATE_DIR}/state.json"
 POS_REMOTE_PATH="${POS_STATE_DIR}/state.json"
 DEFAULT_POS_STATE='{"schema_version": 2, "updated_at": null, "positions": {}, "memory": {"last_price": {}, "last_seen": {}}}'
+INTENT_LOG_PATH="${POS_STATE_DIR}/strategy_intents.jsonl"
+INTENT_REMOTE_PATH="${INTENT_LOG_PATH}"
+DEFAULT_INTENT_LOG=""
+INTENT_CURSOR_PATH="${POS_STATE_DIR}/strategy_intents_state.json"
+INTENT_CURSOR_REMOTE_PATH="${INTENT_CURSOR_PATH}"
+DEFAULT_INTENT_CURSOR='{"offset": 0, "last_intent_id": null, "last_ts": null}'
 
 mkdir -p "${STATE_DIR}"
 mkdir -p "${POS_STATE_DIR}"
 
 if git ls-remote --exit-code --heads origin bot-state >/dev/null 2>&1; then
   git fetch --no-tags origin bot-state:refs/remotes/origin/bot-state >/dev/null 2>&1 || true
   if git cat-file -e "origin/bot-state:${REMOTE_PATH}" 2>/dev/null; then
     git show "origin/bot-state:${REMOTE_PATH}" > "${JSON_PATH}"
     echo "[STATE] Pulled ${REMOTE_PATH} from bot-state branch."
   else
     echo "[STATE] WARN: state.json not found in bot-state branch. Initializing."
     echo "${DEFAULT_STATE}" > "${JSON_PATH}"
   fi
   if git cat-file -e "origin/bot-state:${POS_REMOTE_PATH}" 2>/dev/null; then
     git show "origin/bot-state:${POS_REMOTE_PATH}" > "${POS_JSON_PATH}"
     echo "[STATE] Pulled ${POS_REMOTE_PATH} from bot-state branch."
   else
     echo "[STATE] WARN: position state not found in bot-state branch. Initializing."
     echo "${DEFAULT_POS_STATE}" > "${POS_JSON_PATH}"
   fi
+  if git cat-file -e "origin/bot-state:${INTENT_REMOTE_PATH}" 2>/dev/null; then
+    git show "origin/bot-state:${INTENT_REMOTE_PATH}" > "${INTENT_LOG_PATH}"
+    echo "[STATE] Pulled ${INTENT_REMOTE_PATH} from bot-state branch."
+  else
+    echo "[STATE] WARN: intent log not found in bot-state branch. Initializing."
+    echo -n "${DEFAULT_INTENT_LOG}" > "${INTENT_LOG_PATH}"
+  fi
+  if git cat-file -e "origin/bot-state:${INTENT_CURSOR_REMOTE_PATH}" 2>/dev/null; then
+    git show "origin/bot-state:${INTENT_CURSOR_REMOTE_PATH}" > "${INTENT_CURSOR_PATH}"
+    echo "[STATE] Pulled ${INTENT_CURSOR_REMOTE_PATH} from bot-state branch."
+  else
+    echo "[STATE] WARN: intent cursor not found in bot-state branch. Initializing."
+    echo "${DEFAULT_INTENT_CURSOR}" > "${INTENT_CURSOR_PATH}"
+  fi
 else
   echo "[STATE] WARN: bot-state branch not found. Initializing."
   echo "${DEFAULT_STATE}" > "${JSON_PATH}"
   echo "${DEFAULT_POS_STATE}" > "${POS_JSON_PATH}"
+  echo -n "${DEFAULT_INTENT_LOG}" > "${INTENT_LOG_PATH}"
+  echo "${DEFAULT_INTENT_CURSOR}" > "${INTENT_CURSOR_PATH}"
 fi
diff --git a/scripts/state_push_plain.sh b/scripts/state_push_plain.sh
index 6a888bf3c538b06306a5665065d01db35e057019..16671cd677009b945214eb1a09d87218000d2190 100755
--- a/scripts/state_push_plain.sh
+++ b/scripts/state_push_plain.sh
@@ -1,51 +1,63 @@
 #!/usr/bin/env bash
 set -euo pipefail
 
 STATE_DIR="bot_state"
 JSON_PATH="${STATE_DIR}/state.json"
 POS_STATE_DIR="trader/state"
 POS_JSON_PATH="${POS_STATE_DIR}/state.json"
+INTENT_LOG_PATH="${POS_STATE_DIR}/strategy_intents.jsonl"
+INTENT_CURSOR_PATH="${POS_STATE_DIR}/strategy_intents_state.json"
 
 if [[ ! -f "${JSON_PATH}" ]]; then
   echo "[STATE] WARN: ${JSON_PATH} not found. Skipping."
   exit 0
 fi
 if [[ ! -f "${POS_JSON_PATH}" ]]; then
   echo "[STATE] WARN: ${POS_JSON_PATH} not found. Skipping."
   exit 0
 fi
 
 tmp_state="$(mktemp)"
 tmp_pos_state="$(mktemp)"
-trap 'rm -f "${tmp_state}" "${tmp_pos_state}"' EXIT
+tmp_intent_log="$(mktemp)"
+tmp_intent_cursor="$(mktemp)"
+trap 'rm -f "${tmp_state}" "${tmp_pos_state}" "${tmp_intent_log}" "${tmp_intent_cursor}"' EXIT
 cp -f "${JSON_PATH}" "${tmp_state}"
 cp -f "${POS_JSON_PATH}" "${tmp_pos_state}"
+cp -f "${INTENT_LOG_PATH}" "${tmp_intent_log}" 2>/dev/null || touch "${tmp_intent_log}"
+cp -f "${INTENT_CURSOR_PATH}" "${tmp_intent_cursor}" 2>/dev/null || touch "${tmp_intent_cursor}"
 
 # IMPORTANT: avoid "untracked would be overwritten by checkout"
 rm -f "${JSON_PATH}" || true
 rm -f "${POS_JSON_PATH}" || true
+rm -f "${INTENT_LOG_PATH}" || true
+rm -f "${INTENT_CURSOR_PATH}" || true
 
 if git ls-remote --exit-code --heads origin bot-state >/dev/null 2>&1; then
   git fetch --no-tags origin bot-state:refs/remotes/origin/bot-state >/dev/null 2>&1 || true
   git checkout -B bot-state origin/bot-state
 else
   git checkout --orphan bot-state
   git rm -r --cached . >/dev/null 2>&1 || true
 fi
 
 mkdir -p "${STATE_DIR}"
 cp -f "${tmp_state}" "${JSON_PATH}"
 mkdir -p "${POS_STATE_DIR}"
 cp -f "${tmp_pos_state}" "${POS_JSON_PATH}"
+cp -f "${tmp_intent_log}" "${INTENT_LOG_PATH}"
+cp -f "${tmp_intent_cursor}" "${INTENT_CURSOR_PATH}"
 
 git add -f "${JSON_PATH}"
 git add -f "${POS_JSON_PATH}"
+git add -f "${INTENT_LOG_PATH}"
+git add -f "${INTENT_CURSOR_PATH}"
 git status --porcelain
 if git diff --cached --quiet; then
   echo "[STATE] No changes to commit."
   exit 0
 fi
 
 git commit -m "Update bot state (plain) [skip ci]"
 git push --force-with-lease origin HEAD:bot-state
 echo "[STATE] Pushed ${JSON_PATH} to bot-state branch."
diff --git a/strategy/base.py b/strategy/base.py
new file mode 100644
index 0000000000000000000000000000000000000000..6e9ab758d0a065970dabb927ad0c72c9f5976bf1
--- /dev/null
+++ b/strategy/base.py
@@ -0,0 +1,31 @@
+from __future__ import annotations
+
+from typing import Any, Dict
+
+
+class BaseStrategy:
+    """Lightweight base strategy interface for intent generation."""
+
+    name: str = ""
+    sid: int = 0
+
+    def update_state(self, market_data: Dict[str, Any]) -> None:  # pragma: no cover - stub
+        return
+
+    def should_enter(self, market_data: Dict[str, Any], portfolio_state: Dict[str, Any]) -> bool:
+        return False
+
+    def compute_entry(
+        self, market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> Dict[str, Any] | None:
+        return None
+
+    def should_exit(
+        self, position: Dict[str, Any], market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> bool:
+        return False
+
+    def compute_exit(
+        self, position: Dict[str, Any], market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> Dict[str, Any] | None:
+        return None
diff --git a/strategy/manager.py b/strategy/manager.py
new file mode 100644
index 0000000000000000000000000000000000000000..f34f8f0f686ad643d3ef85cb3ab7d76d960bb16e
--- /dev/null
+++ b/strategy/manager.py
@@ -0,0 +1,242 @@
+from __future__ import annotations
+
+import logging
+import math
+from dataclasses import asdict, dataclass
+from datetime import datetime
+from typing import Any, Dict, List, Tuple
+
+import trader.state_store as state_store
+from strategy.base import BaseStrategy
+from strategy.strategies import (
+    BreakoutStrategy,
+    MeanReversionStrategy,
+    MomentumStrategy,
+    PullbackStrategy,
+    VolatilityStrategy,
+)
+from strategy.types import OrderIntent
+from trader.config import (
+    DAILY_CAPITAL,
+    ENABLED_STRATEGIES_SET,
+    KST,
+    STRATEGY_MAX_POSITION_PCT,
+    STRATEGY_WEIGHTS,
+)
+
+logger = logging.getLogger(__name__)
+
+
+@dataclass
+class StrategySlot:
+    name: str
+    sid: int
+    weight: float
+    strategy: BaseStrategy
+
+
+class StrategyManager:
+    def __init__(self, total_capital: float | None = None) -> None:
+        self.total_capital = float(total_capital or DAILY_CAPITAL)
+        self._seq = 0
+        self._zero_weight_warned: set[str] = set()
+        self.slots: list[StrategySlot] = self._register_strategies()
+
+    def _register_strategies(self) -> list[StrategySlot]:
+        return [
+            StrategySlot("breakout", 1, float(STRATEGY_WEIGHTS.get("breakout", 0.0)), BreakoutStrategy()),
+            StrategySlot("pullback", 2, float(STRATEGY_WEIGHTS.get("pullback", 0.0)), PullbackStrategy()),
+            StrategySlot("momentum", 3, float(STRATEGY_WEIGHTS.get("momentum", 0.0)), MomentumStrategy()),
+            StrategySlot(
+                "mean_reversion",
+                4,
+                float(STRATEGY_WEIGHTS.get("mean_reversion", 0.0)),
+                MeanReversionStrategy(),
+            ),
+            StrategySlot(
+                "volatility",
+                5,
+                float(STRATEGY_WEIGHTS.get("volatility", 0.0)),
+                VolatilityStrategy(),
+            ),
+        ]
+
+    def enabled_slots(self) -> list[StrategySlot]:
+        enabled: list[StrategySlot] = []
+        for slot in self.slots:
+            if slot.name not in ENABLED_STRATEGIES_SET:
+                continue
+            if float(slot.weight) <= 0:
+                if slot.name not in self._zero_weight_warned:
+                    logger.info(
+                        "[STRATEGY_MANAGER] strategy %s enabled but weight=0 -> skipped", slot.name
+                    )
+                    self._zero_weight_warned.add(slot.name)
+                continue
+            enabled.append(slot)
+        return enabled
+
+    def _next_intent_id(self, strategy: str, side: str, symbol: str, ts: str) -> str:
+        self._seq += 1
+        return f"{ts}-{strategy}-{side}-{symbol}-{self._seq}"
+
+    def _last_price(self, symbol: str, market_data: Dict[str, Any]) -> float | None:
+        prices = market_data.get("prices") if isinstance(market_data, dict) else None
+        if isinstance(prices, dict):
+            data = prices.get(symbol) or prices.get(str(symbol).zfill(6)) or {}
+            try:
+                return float(data.get("last_price") or data.get("price") or 0.0)
+            except Exception:
+                return None
+        return None
+
+    def _size_position(self, weight: float, price: float) -> int:
+        if price <= 0 or weight <= 0:
+            return 0
+        allocated_capital = self.total_capital * float(weight)
+        max_cap = allocated_capital * STRATEGY_MAX_POSITION_PCT
+        qty = math.floor(max_cap / price) if price else 0
+        return max(qty, 0)
+
+    def _position_matches_strategy(self, position: Dict[str, Any], slot: StrategySlot) -> bool:
+        strategy_id = position.get("strategy_id")
+        if strategy_id is None:
+            return False
+        strategy_key = str(strategy_id).lower()
+        return strategy_key in {slot.name, str(slot.sid)}
+
+    def _build_intent(
+        self,
+        slot: StrategySlot,
+        side: str,
+        symbol: str,
+        qty: int,
+        order_type: str = "MARKET",
+        limit_price: float | None = None,
+        reason: str = "",
+        meta: Dict[str, Any] | None = None,
+    ) -> OrderIntent:
+        ts = datetime.now(KST).isoformat()
+        intent_id = self._next_intent_id(slot.name, side, symbol, ts)
+        return OrderIntent(
+            intent_id=intent_id,
+            ts=ts,
+            strategy=slot.name,
+            sid=slot.sid,
+            side=side.upper(),
+            symbol=str(symbol).zfill(6),
+            qty=int(qty),
+            order_type=order_type.upper(),
+            limit_price=limit_price,
+            reason=reason or f"{slot.name}_{side.lower()}",
+            meta=meta or {},
+        )
+
+    def _entry_intents_for_slot(
+        self,
+        slot: StrategySlot,
+        market_data: Dict[str, Any],
+        portfolio_state: Dict[str, Any],
+    ) -> list[OrderIntent]:
+        strategy = slot.strategy
+        if not strategy.should_enter(market_data, portfolio_state):
+            return []
+        entry = strategy.compute_entry(market_data, portfolio_state) or {}
+        if not isinstance(entry, dict):
+            return []
+        symbol = entry.get("symbol")
+        if not symbol:
+            return []
+        price = entry.get("price") or self._last_price(symbol, market_data)
+        qty = self._size_position(slot.weight, float(price or 0))
+        if qty <= 0:
+            return []
+        order_type = entry.get("order_type") or "MARKET"
+        limit_price = entry.get("limit_price")
+        reason = entry.get("reason") or f"{slot.name}_entry"
+        meta = entry.get("meta")
+        return [
+            self._build_intent(
+                slot,
+                "BUY",
+                symbol,
+                qty,
+                order_type=order_type,
+                limit_price=limit_price,
+                reason=reason,
+                meta=meta,
+            )
+        ]
+
+    def _exit_intents_for_slot(
+        self,
+        slot: StrategySlot,
+        market_data: Dict[str, Any],
+        portfolio_state: Dict[str, Any],
+    ) -> list[OrderIntent]:
+        intents: list[OrderIntent] = []
+        positions = portfolio_state.get("positions", {}) if isinstance(portfolio_state, dict) else {}
+        for symbol, position in positions.items():
+            if not isinstance(position, dict):
+                continue
+            if not self._position_matches_strategy(position, slot):
+                continue
+            qty = int(position.get("qty") or 0)
+            if qty <= 0:
+                continue
+            if not slot.strategy.should_exit(position, market_data, portfolio_state):
+                continue
+            exit_payload = slot.strategy.compute_exit(position, market_data, portfolio_state) or {}
+            if not isinstance(exit_payload, dict):
+                continue
+            price = exit_payload.get("price") or self._last_price(symbol, market_data)
+            if price and price > 0:
+                qty = min(qty, int(exit_payload.get("qty") or qty))
+            order_type = exit_payload.get("order_type") or "MARKET"
+            limit_price = exit_payload.get("limit_price")
+            reason = exit_payload.get("reason") or f"{slot.name}_exit"
+            intents.append(
+                self._build_intent(
+                    slot,
+                    "SELL",
+                    symbol,
+                    qty,
+                    order_type=order_type,
+                    limit_price=limit_price,
+                    reason=reason,
+                    meta=exit_payload.get("meta"),
+                )
+            )
+        return intents
+
+    def run_once(
+        self,
+        market_data: Dict[str, Any] | None = None,
+        portfolio_state: Dict[str, Any] | None = None,
+    ) -> Dict[str, Any]:
+        state = portfolio_state or state_store.load_state()
+        market_data = market_data or {}
+        intents: list[OrderIntent] = []
+        enabled: list[str] = []
+        dedupe_keys: set[Tuple[str, str, str]] = set()
+
+        for slot in self.enabled_slots():
+            enabled.append(slot.name)
+            try:
+                slot.strategy.update_state(market_data)
+            except Exception:
+                logger.exception("[STRATEGY_MANAGER] failed to update state for %s", slot.name)
+            for intent in self._entry_intents_for_slot(slot, market_data, state):
+                key = (slot.name, intent.symbol, intent.side)
+                if key in dedupe_keys:
+                    continue
+                dedupe_keys.add(key)
+                intents.append(intent)
+            for intent in self._exit_intents_for_slot(slot, market_data, state):
+                key = (slot.name, intent.symbol, intent.side)
+                if key in dedupe_keys:
+                    continue
+                dedupe_keys.add(key)
+                intents.append(intent)
+
+        return {"enabled": enabled, "intents": [asdict(intent) for intent in intents]}
diff --git a/strategy/market_data.py b/strategy/market_data.py
new file mode 100644
index 0000000000000000000000000000000000000000..ad322cf95155479d7ceb558624816575879f4940
--- /dev/null
+++ b/strategy/market_data.py
@@ -0,0 +1,54 @@
+from __future__ import annotations
+
+from datetime import datetime
+from typing import Any, Dict
+
+from trader.config import KST
+
+
+def _collect_symbols(selected_by_market: Dict[str, Any] | None) -> set[str]:
+    symbols: set[str] = set()
+    if not isinstance(selected_by_market, dict):
+        return symbols
+    for rows in selected_by_market.values():
+        if not rows:
+            continue
+        for row in rows:
+            code = str(row.get("code") or row.get("pdno") or row.get("stock_code") or "").zfill(6)
+            if code and code != "000000":
+                symbols.add(code)
+    return symbols
+
+
+def build_market_data(
+    selected_by_market: Dict[str, Any] | None = None,
+    kis_client: Any | None = None,
+    now_ts: str | None = None,
+) -> Dict[str, Any]:
+    """Build minimal market data snapshot for strategies."""
+
+    now_ts = now_ts or datetime.now(KST).isoformat()
+    prices: dict[str, Dict[str, Any]] = {}
+    symbols = _collect_symbols(selected_by_market)
+    for symbol in symbols:
+        prices[symbol] = {}
+
+    snapshot: Dict[str, Any] = {
+        "as_of": now_ts,
+        "prices": prices,
+    }
+
+    # Optionally hydrate last prices if client provided; safe no-op for now.
+    if kis_client and hasattr(kis_client, "get_price_quote"):
+        for symbol in symbols:
+            try:
+                quote = kis_client.get_price_quote(symbol)
+                if isinstance(quote, dict):
+                    last_price = quote.get("stck_prpr") or quote.get("prpr")
+                    if last_price:
+                        prices[symbol]["last_price"] = float(last_price)
+            except Exception:
+                # keep minimal snapshot even if fetch fails
+                continue
+
+    return snapshot
diff --git a/strategy/strategies/__init__.py b/strategy/strategies/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..5145b7284406552f6b055456467a8f9852bd1a1c
--- /dev/null
+++ b/strategy/strategies/__init__.py
@@ -0,0 +1,13 @@
+from .s1_breakout import BreakoutStrategy
+from .s2_pullback import PullbackStrategy
+from .s3_momentum import MomentumStrategy
+from .s4_mean_reversion import MeanReversionStrategy
+from .s5_volatility import VolatilityStrategy
+
+__all__ = [
+    "BreakoutStrategy",
+    "PullbackStrategy",
+    "MomentumStrategy",
+    "MeanReversionStrategy",
+    "VolatilityStrategy",
+]
diff --git a/strategy/strategies/s1_breakout.py b/strategy/strategies/s1_breakout.py
new file mode 100644
index 0000000000000000000000000000000000000000..98129f17ec399cf70390680d94e3007a0ff93529
--- /dev/null
+++ b/strategy/strategies/s1_breakout.py
@@ -0,0 +1,31 @@
+from __future__ import annotations
+
+from typing import Any, Dict
+
+from strategy.base import BaseStrategy
+
+
+class BreakoutStrategy(BaseStrategy):
+    name = "breakout"
+    sid = 1
+
+    def update_state(self, market_data: Dict[str, Any]) -> None:
+        return
+
+    def should_enter(self, market_data: Dict[str, Any], portfolio_state: Dict[str, Any]) -> bool:
+        return False
+
+    def compute_entry(
+        self, market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> Dict[str, Any] | None:
+        return None
+
+    def should_exit(
+        self, position: Dict[str, Any], market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> bool:
+        return False
+
+    def compute_exit(
+        self, position: Dict[str, Any], market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> Dict[str, Any] | None:
+        return None
diff --git a/strategy/strategies/s2_pullback.py b/strategy/strategies/s2_pullback.py
new file mode 100644
index 0000000000000000000000000000000000000000..6e628f526178b8d8b08d96c2a9cd30315856ff55
--- /dev/null
+++ b/strategy/strategies/s2_pullback.py
@@ -0,0 +1,31 @@
+from __future__ import annotations
+
+from typing import Any, Dict
+
+from strategy.base import BaseStrategy
+
+
+class PullbackStrategy(BaseStrategy):
+    name = "pullback"
+    sid = 2
+
+    def update_state(self, market_data: Dict[str, Any]) -> None:
+        return
+
+    def should_enter(self, market_data: Dict[str, Any], portfolio_state: Dict[str, Any]) -> bool:
+        return False
+
+    def compute_entry(
+        self, market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> Dict[str, Any] | None:
+        return None
+
+    def should_exit(
+        self, position: Dict[str, Any], market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> bool:
+        return False
+
+    def compute_exit(
+        self, position: Dict[str, Any], market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> Dict[str, Any] | None:
+        return None
diff --git a/strategy/strategies/s3_momentum.py b/strategy/strategies/s3_momentum.py
new file mode 100644
index 0000000000000000000000000000000000000000..0ed8d60499eab22714cf09522878553dd3060a35
--- /dev/null
+++ b/strategy/strategies/s3_momentum.py
@@ -0,0 +1,31 @@
+from __future__ import annotations
+
+from typing import Any, Dict
+
+from strategy.base import BaseStrategy
+
+
+class MomentumStrategy(BaseStrategy):
+    name = "momentum"
+    sid = 3
+
+    def update_state(self, market_data: Dict[str, Any]) -> None:
+        return
+
+    def should_enter(self, market_data: Dict[str, Any], portfolio_state: Dict[str, Any]) -> bool:
+        return False
+
+    def compute_entry(
+        self, market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> Dict[str, Any] | None:
+        return None
+
+    def should_exit(
+        self, position: Dict[str, Any], market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> bool:
+        return False
+
+    def compute_exit(
+        self, position: Dict[str, Any], market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> Dict[str, Any] | None:
+        return None
diff --git a/strategy/strategies/s4_mean_reversion.py b/strategy/strategies/s4_mean_reversion.py
new file mode 100644
index 0000000000000000000000000000000000000000..81db7344f9dd7e1471fa73ad6e251303115f256a
--- /dev/null
+++ b/strategy/strategies/s4_mean_reversion.py
@@ -0,0 +1,31 @@
+from __future__ import annotations
+
+from typing import Any, Dict
+
+from strategy.base import BaseStrategy
+
+
+class MeanReversionStrategy(BaseStrategy):
+    name = "mean_reversion"
+    sid = 4
+
+    def update_state(self, market_data: Dict[str, Any]) -> None:
+        return
+
+    def should_enter(self, market_data: Dict[str, Any], portfolio_state: Dict[str, Any]) -> bool:
+        return False
+
+    def compute_entry(
+        self, market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> Dict[str, Any] | None:
+        return None
+
+    def should_exit(
+        self, position: Dict[str, Any], market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> bool:
+        return False
+
+    def compute_exit(
+        self, position: Dict[str, Any], market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> Dict[str, Any] | None:
+        return None
diff --git a/strategy/strategies/s5_volatility.py b/strategy/strategies/s5_volatility.py
new file mode 100644
index 0000000000000000000000000000000000000000..02a51fc321f22a228702dd9cfaf7d679fda121d0
--- /dev/null
+++ b/strategy/strategies/s5_volatility.py
@@ -0,0 +1,31 @@
+from __future__ import annotations
+
+from typing import Any, Dict
+
+from strategy.base import BaseStrategy
+
+
+class VolatilityStrategy(BaseStrategy):
+    name = "volatility"
+    sid = 5
+
+    def update_state(self, market_data: Dict[str, Any]) -> None:
+        return
+
+    def should_enter(self, market_data: Dict[str, Any], portfolio_state: Dict[str, Any]) -> bool:
+        return False
+
+    def compute_entry(
+        self, market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> Dict[str, Any] | None:
+        return None
+
+    def should_exit(
+        self, position: Dict[str, Any], market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> bool:
+        return False
+
+    def compute_exit(
+        self, position: Dict[str, Any], market_data: Dict[str, Any], portfolio_state: Dict[str, Any]
+    ) -> Dict[str, Any] | None:
+        return None
diff --git a/strategy/types.py b/strategy/types.py
new file mode 100644
index 0000000000000000000000000000000000000000..b5821b1eb5ee69ca56f1d02ef5e52f0e8007f416
--- /dev/null
+++ b/strategy/types.py
@@ -0,0 +1,37 @@
+from __future__ import annotations
+
+from dataclasses import dataclass, field
+from typing import Any, Dict, Optional
+
+
+@dataclass
+class OrderIntent:
+    intent_id: str
+    ts: str
+    strategy: str
+    sid: int
+    side: str  # BUY | SELL
+    symbol: str
+    qty: int
+    order_type: str  # MARKET | LIMIT
+    limit_price: Optional[float]
+    reason: str
+    meta: Dict[str, Any] = field(default_factory=dict)
+
+
+@dataclass
+class ExecutionAck:
+    intent_id: str
+    ok: bool
+    message: str
+    order_id: Optional[str] = None
+
+
+@dataclass
+class FillEvent:
+    order_id: str
+    symbol: str
+    qty: int
+    price: float
+    ts: str
+    side: str  # BUY | SELL
diff --git a/trader/config.py b/trader/config.py
index 0b854427d77f1c1ede90f3cf7928bf3711ec523b..9d5e05d219f38a5c631180980cdfc41e07e1dd5a 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -70,50 +70,62 @@ CONFIG = {
     "CHAMPION_MIN_TRADES": "5",            # 최소 거래수
     "CHAMPION_MIN_WINRATE": "45.0",        # 최소 승률(%)
     "CHAMPION_MAX_MDD": "30.0",            # 최대 허용 MDD(%)
     "CHAMPION_MIN_SHARPE": "0.0",          # 최소 샤프 비율
     "NEUTRAL_ENTRY_SCALE": "0.6",          # 중립 레짐 신규/재진입 스케일링 비율
     # 기타
     "MARKET_DATA_WHEN_CLOSED": "false",
     "FORCE_WEEKLY_REBALANCE": "0",
     # NEW: 1분봉 VWAP 모멘텀 파라미터
     "MOM_FAST": "5",        # 1분봉 fast MA 길이
     "MOM_SLOW": "20",       # 1분봉 slow MA 길이
     "MOM_TH_PCT": "0.5",    # fast/slow 괴리 임계값(%) – 0.5% 이상이면 강세로 본다
     # Subject flow gate 기본값
     "MIN_SMART_MONEY_RATIO_KOSPI": "0.02",
     "MIN_SMART_MONEY_RATIO_KOSDAQ": "0.03",
     "SUBJECT_FLOW_TIMEOUT_SEC": "1.2",
     "SUBJECT_FLOW_RETRY": "1",
     "SUBJECT_FLOW_CACHE_TTL_SEC": "60",
     "SUBJECT_FLOW_FAIL_POLICY": "CACHE",
     "SUBJECT_FLOW_EMPTY_POLICY": "TREAT_AS_FAIL",
     "SUBJECT_FLOW_DEGRADED_TURNOVER_MULT": "1.5",
     "SUBJECT_FLOW_DEGRADED_OB_ADD": "10",
     "SUBJECT_FLOW_MAX_CALLS_PER_RUN": "200",
     "EMERGENCY_GLOBAL_SELL": "false",
     "STRATEGY_REDUCTION_PRIORITY": "5,4,3,2,1",
+    # === Strategy intent/exec defaults ===
+    "ENABLED_STRATEGIES": "",
+    "STRATEGY_MODE": "INTENT_ONLY",  # INTENT_ONLY | LIVE
+    "STRATEGY_DRY_RUN": "true",
+    "STRATEGY_INTENTS_PATH": "trader/state/strategy_intents.jsonl",
+    "STRATEGY_INTENTS_STATE_PATH": "trader/state/strategy_intents_state.json",
+    "STRATEGY_MAX_OPEN_INTENTS": "20",
+    "STRATEGY_MAX_POSITION_PCT": "0.10",
+    "STRATEGY_ALLOW_SELL_ONLY": "false",
+    "STRATEGY_WEIGHTS": "",
+    "DISABLE_KOSDAQ_LOOP": "false",
+    "DISABLE_KOSPI_ENGINE": "false",
 }
 
 
 def _cfg(key: str) -> str:
     """환경변수 > CONFIG 기본값"""
     return os.getenv(key, CONFIG.get(key, ""))
 
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 LOG_DIR = Path(__file__).parent / "logs"
 LOG_DIR.mkdir(exist_ok=True)
 STATE_FILE = Path(__file__).parent / "trade_state.json"  # legacy; position state uses STATE_PATH
 STATE_DIR = Path(__file__).parent / "state"
 STATE_PATH = STATE_DIR / "state.json"
 STATE_DIR.mkdir(parents=True, exist_ok=True)
 
 # 종목별 시장코드 고정 맵 (실전에서는 마스터테이블 로드로 대체 권장)
 MARKET_MAP: Dict[str, str] = {
     # 예시: '145020': 'J', '347850': 'J', '257720': 'U', '178320': 'J', '348370': 'U'
 }
 
 # 데이터 없음 1차 감지 상태 저장(연속 DATA_EMPTY 확인용)
 EXCLUDE_STATE: Dict[str, Dict[str, bool]] = {}
@@ -146,50 +158,106 @@ ALLOW_PYRAMID = (_cfg("ALLOW_PYRAMID") or "false").lower() == "true"
 REBALANCE_ANCHOR = _cfg("REBALANCE_ANCHOR")
 WEEKLY_ANCHOR_REF = _cfg("WEEKLY_ANCHOR_REF").lower()
 MOMENTUM_OVERRIDES_FORCE_SELL = _cfg("MOMENTUM_OVERRIDES_FORCE_SELL").lower() == "true"
 BASE_QTY_MODE = (_cfg("BASE_QTY_MODE") or "initial").lower()
 if BASE_QTY_MODE not in {"initial", "current"}:
     logging.getLogger(__name__).warning(
         f"[CONFIG] BASE_QTY_MODE={BASE_QTY_MODE} 지원 안 함 → initial로 대체"
     )
     BASE_QTY_MODE = "initial"
 
 # NEW: 1분봉 모멘텀 파라미터
 MOM_FAST = int(_cfg("MOM_FAST") or "5")
 MOM_SLOW = int(_cfg("MOM_SLOW") or "20")
 MOM_TH_PCT = float(_cfg("MOM_TH_PCT") or "0.5")
 # subject flow
 MIN_SMART_MONEY_RATIO_KOSPI = float(_cfg("MIN_SMART_MONEY_RATIO_KOSPI") or "0.02")
 MIN_SMART_MONEY_RATIO_KOSDAQ = float(_cfg("MIN_SMART_MONEY_RATIO_KOSDAQ") or "0.03")
 SUBJECT_FLOW_TIMEOUT_SEC = float(_cfg("SUBJECT_FLOW_TIMEOUT_SEC") or "1.2")
 SUBJECT_FLOW_RETRY = int(_cfg("SUBJECT_FLOW_RETRY") or "1")
 SUBJECT_FLOW_CACHE_TTL_SEC = float(_cfg("SUBJECT_FLOW_CACHE_TTL_SEC") or "60")
 SUBJECT_FLOW_FAIL_POLICY = (_cfg("SUBJECT_FLOW_FAIL_POLICY") or "CACHE").upper()
 SUBJECT_FLOW_EMPTY_POLICY = (_cfg("SUBJECT_FLOW_EMPTY_POLICY") or "TREAT_AS_FAIL").upper()
 SUBJECT_FLOW_DEGRADED_TURNOVER_MULT = float(_cfg("SUBJECT_FLOW_DEGRADED_TURNOVER_MULT") or "1.5")
 SUBJECT_FLOW_DEGRADED_OB_ADD = float(_cfg("SUBJECT_FLOW_DEGRADED_OB_ADD") or "10")
 SUBJECT_FLOW_MAX_CALLS_PER_RUN = int(_cfg("SUBJECT_FLOW_MAX_CALLS_PER_RUN") or "200")
+# 전략별 활성/가중치 파싱
+def parse_enabled_strategies(raw: str) -> set[str]:
+    strategies: set[str] = set()
+    for name in (raw or "").split(","):
+        cleaned = name.strip().lower()
+        if cleaned:
+            strategies.add(cleaned)
+    return strategies
+
+
+def _parse_strategy_weights(raw: str) -> Dict[str, float]:
+    weights: Dict[str, float] = {}
+    for item in (raw or "").split(","):
+        if not item.strip():
+            continue
+        if "=" in item:
+            key, value = item.split("=", 1)
+        elif ":" in item:
+            key, value = item.split(":", 1)
+        else:
+            key, value = item, "0"
+        key = key.strip().lower()
+        try:
+            weight = float(value)
+        except ValueError:
+            weight = 0.0
+        if key:
+            weights[key] = weight
+    return weights
+
+
+ENABLED_STRATEGIES_SET = parse_enabled_strategies(_cfg("ENABLED_STRATEGIES"))
+RAW_STRATEGY_WEIGHTS = _parse_strategy_weights(_cfg("STRATEGY_WEIGHTS"))
+
+if ENABLED_STRATEGIES_SET:
+    STRATEGY_WEIGHTS = {
+        name: (RAW_STRATEGY_WEIGHTS.get(name, 0.0) if name in ENABLED_STRATEGIES_SET else 0.0)
+        for name in ENABLED_STRATEGIES_SET.union(RAW_STRATEGY_WEIGHTS.keys())
+    }
+else:
+    STRATEGY_WEIGHTS = {name: 0.0 for name in RAW_STRATEGY_WEIGHTS.keys()}
+
+STRATEGY_MODE = (_cfg("STRATEGY_MODE") or "INTENT_ONLY").upper()
+STRATEGY_DRY_RUN = (_cfg("STRATEGY_DRY_RUN") or "true").lower() in ("1", "true", "yes")
+STRATEGY_INTENTS_PATH = Path(_cfg("STRATEGY_INTENTS_PATH") or CONFIG["STRATEGY_INTENTS_PATH"])
+STRATEGY_INTENTS_STATE_PATH = Path(
+    _cfg("STRATEGY_INTENTS_STATE_PATH") or CONFIG["STRATEGY_INTENTS_STATE_PATH"]
+)
+STRATEGY_MAX_OPEN_INTENTS = int(_cfg("STRATEGY_MAX_OPEN_INTENTS") or "20")
+STRATEGY_MAX_POSITION_PCT = float(_cfg("STRATEGY_MAX_POSITION_PCT") or "0.10")
+STRATEGY_ALLOW_SELL_ONLY = (_cfg("STRATEGY_ALLOW_SELL_ONLY") or "false").lower() in (
+    "1",
+    "true",
+    "yes",
+)
+
 # 전략별 레짐 축소 우선순위
 def _parse_strategy_priority(raw: str) -> list[int]:
     priorities: list[int] = []
     for item in raw.split(","):
         item = item.strip()
         if not item:
             continue
         try:
             value = int(item)
         except ValueError:
             continue
         if 1 <= value <= 5 and value not in priorities:
             priorities.append(value)
     return priorities or [5, 4, 3, 2, 1]
 
 
 STRATEGY_REDUCTION_PRIORITY = _parse_strategy_priority(
     _cfg("STRATEGY_REDUCTION_PRIORITY")
 )
 # 신고가 → 3일 눌림 → 반등 확인 후 매수 파라미터
 USE_PULLBACK_ENTRY = _cfg("USE_PULLBACK_ENTRY").lower() != "false"
 PULLBACK_LOOKBACK = int(_cfg("PULLBACK_LOOKBACK") or "60")
 PULLBACK_DAYS = int(_cfg("PULLBACK_DAYS") or "3")
 PULLBACK_REVERSAL_BUFFER_PCT = float(_cfg("PULLBACK_REVERSAL_BUFFER_PCT") or "0.2")
 PULLBACK_TOPN = int(_cfg("PULLBACK_TOPN") or "50")
@@ -212,32 +280,34 @@ CHAMPION_A_RULES = {
 
 GOOD_ENTRY_PULLBACK_RANGE = (5.0, 15.0)  # 신고가 대비 눌림폭(%): 최소~최대
 GOOD_ENTRY_MA20_RANGE = (1.0, 1.15)  # 현재가/20MA 허용 구간
 GOOD_ENTRY_MAX_FROM_PEAK = 0.97  # 현재가/최근고점 최대치(≤0.97)
 GOOD_ENTRY_MIN_RR = 2.0  # 기대수익/리스크 최소 비율
 GOOD_ENTRY_MIN_INTRADAY_SIG = 2  # GOOD 타점으로 인정하기 위한 최소 intraday 시그널 개수
 
 BAD_ENTRY_MAX_MA20_DIST = 1.25  # 현재가/20MA 상한(추격매수 방지)
 BAD_ENTRY_MAX_PULLBACK = 20.0  # 신고가 대비 눌림폭 상한(과도한 붕괴 방지)
 BAD_ENTRY_MAX_BELOW_VWAP_RATIO = 0.7  # 분봉에서 VWAP 아래 체류 비중이 이 이상이면 BAD
 NEUTRAL_ENTRY_SCALE = float(_cfg("NEUTRAL_ENTRY_SCALE") or "0.6")
 
 
 def _parse_hhmm(hhmm: str) -> dtime:
     try:
         hh, mm = hhmm.split(":")
         return dtime(hour=int(hh), minute=int(mm))
     except Exception:
         logger.warning(f"[설정경고] SELL_FORCE_TIME 형식 오류 → 기본값 14:40 적용: {hhmm}")
         return dtime(hour=14, minute=40)
 
 
 SELL_FORCE_TIME = _parse_hhmm(SELL_FORCE_TIME_STR)
 TIME_STOP_TIME = _parse_hhmm(TIME_STOP_HHMM)
 ALLOW_WHEN_CLOSED = _cfg("MARKET_DATA_WHEN_CLOSED").lower() == "true"
+DISABLE_KOSDAQ_LOOP = (_cfg("DISABLE_KOSDAQ_LOOP") or "false").lower() in ("1", "true", "yes")
+DISABLE_KOSPI_ENGINE = (_cfg("DISABLE_KOSPI_ENGINE") or "false").lower() in ("1", "true", "yes")
 
 # === [NEW] 주간 리밸런싱 강제 트리거 상태 파일 ===
 STATE_WEEKLY_PATH = Path(__file__).parent / "state_weekly.json"
 
 def _this_iso_week_key(now=None):
     now = now or datetime.now(KST)
     return f"{now.year}-W{now.isocalendar().week:02d}"
diff --git a/trader/intent_executor.py b/trader/intent_executor.py
new file mode 100644
index 0000000000000000000000000000000000000000..e47749536e012a925ea551abfb9a04a79a7b6ae0
--- /dev/null
+++ b/trader/intent_executor.py
@@ -0,0 +1,131 @@
+from __future__ import annotations
+
+import logging
+import os
+from typing import Any, Dict
+
+import trader.intent_store as intent_store
+from strategy.types import ExecutionAck
+from trader.config import (
+    STRATEGY_ALLOW_SELL_ONLY,
+    STRATEGY_DRY_RUN,
+    STRATEGY_INTENTS_PATH,
+    STRATEGY_INTENTS_STATE_PATH,
+    STRATEGY_MAX_OPEN_INTENTS,
+    STRATEGY_MODE,
+)
+
+logger = logging.getLogger(__name__)
+
+
+class IntentExecutor:
+    """Strategy intent executor (Phase 1: dry-run)."""
+
+    def __init__(self) -> None:
+        self.intents_path = STRATEGY_INTENTS_PATH
+        self.cursor_state_path = STRATEGY_INTENTS_STATE_PATH
+        self.allow_sell_only = STRATEGY_ALLOW_SELL_ONLY
+        self.max_open_intents = int(STRATEGY_MAX_OPEN_INTENTS)
+
+    def _should_dry_run(self) -> bool:
+        disable_live = os.getenv("DISABLE_LIVE_TRADING", "").lower() in {"1", "true", "yes", "on"}
+        return disable_live or STRATEGY_DRY_RUN or STRATEGY_MODE == "INTENT_ONLY"
+
+    def run_once(self) -> Dict[str, Any]:
+        intents: list[Dict[str, Any]] = []
+        cursor: Dict[str, Any] = {"offset": 0, "last_intent_id": None, "last_ts": None, "start_offset": 0}
+        try:
+            intents, cursor = intent_store.load_intents_since_cursor(
+                self.intents_path, self.cursor_state_path
+            )
+            intents = intent_store.dedupe_intents(intents)
+        except Exception:
+            logger.exception("[INTENT_EXECUTOR] failed to load intents")
+            return {"acks": [], "status": "error"}
+
+        dry_run = self._should_dry_run()
+        acks: list[ExecutionAck] = []
+        processed = 0
+        last_processed_offset = int(cursor.get("start_offset") or cursor.get("offset") or 0)
+        last_intent_id = cursor.get("last_intent_id")
+        last_ts = cursor.get("last_ts")
+        for idx, intent in enumerate(intents):
+            intent_id = intent.get("intent_id") or f"unknown-{idx}"
+            side = str(intent.get("side") or "").upper()
+            intent_offset = intent.get("_end_offset")
+
+            if processed >= self.max_open_intents:
+                acks.append(
+                    ExecutionAck(
+                        intent_id=intent_id,
+                        ok=False,
+                        message="max_open_intents_cap",
+                        order_id=None,
+                    )
+                )
+                break
+
+            if self.allow_sell_only and side == "BUY":
+                acks.append(
+                    ExecutionAck(
+                        intent_id=intent_id,
+                        ok=False,
+                        message="sell_only_mode",
+                        order_id=None,
+                    )
+                )
+                if intent_offset is not None:
+                    try:
+                        last_processed_offset = max(last_processed_offset, int(intent_offset))
+                    except Exception:
+                        pass
+                processed += 1
+                last_intent_id = intent_id
+                last_ts = intent.get("ts") or last_ts
+                continue
+
+            if dry_run:
+                logger.info(
+                    "[INTENT_EXECUTOR][DRY_RUN] intent_id=%s side=%s symbol=%s qty=%s",
+                    intent_id,
+                    side,
+                    intent.get("symbol"),
+                    intent.get("qty"),
+                )
+                acks.append(
+                    ExecutionAck(
+                        intent_id=intent_id,
+                        ok=True,
+                        message="dry_run",
+                        order_id=None,
+                    )
+                )
+                processed += 1
+                if intent_offset is not None:
+                    try:
+                        last_processed_offset = max(last_processed_offset, int(intent_offset))
+                    except Exception:
+                        pass
+                last_intent_id = intent_id
+                last_ts = intent.get("ts") or last_ts
+                continue
+
+            acks.append(
+                ExecutionAck(intent_id=intent_id, ok=False, message="live_mode_not_implemented")
+            )
+            processed += 1
+            if intent_offset is not None:
+                try:
+                    last_processed_offset = max(last_processed_offset, int(intent_offset))
+                except Exception:
+                    pass
+            last_intent_id = intent_id
+            last_ts = intent.get("ts") or last_ts
+
+        intent_store.save_cursor(
+            self.cursor_state_path,
+            offset=last_processed_offset,
+            last_intent_id=last_intent_id,
+            last_ts=last_ts,
+        )
+        return {"acks": [ack.__dict__ for ack in acks], "processed": processed, "dry_run": dry_run}
diff --git a/trader/intent_store.py b/trader/intent_store.py
new file mode 100644
index 0000000000000000000000000000000000000000..32eead08f6dc0a12530d920a5c4188978fa06e27
--- /dev/null
+++ b/trader/intent_store.py
@@ -0,0 +1,140 @@
+from __future__ import annotations
+
+import json
+import logging
+import os
+from pathlib import Path
+from typing import Any, Dict, Iterable, List, Tuple
+
+logger = logging.getLogger(__name__)
+
+
+def append_intents(intents: Iterable[Dict[str, Any]], path: Path) -> None:
+    """Append intents as JSON lines."""
+
+    intents_list = list(intents)
+    if not intents_list:
+        return
+
+    path = Path(path)
+    path.parent.mkdir(parents=True, exist_ok=True)
+    lines = [json.dumps(intent, ensure_ascii=False) for intent in intents_list]
+    try:
+        with open(path, "a", encoding="utf-8") as f:
+            for line in lines:
+                f.write(line + "\n")
+    except Exception:
+        logger.exception("[INTENT_STORE] failed to append %d intents to %s", len(lines), path)
+
+
+def _load_cursor(cursor_state_path: Path) -> Dict[str, Any]:
+    cursor_state_path = Path(cursor_state_path)
+    if not cursor_state_path.exists():
+        return {"offset": 0}
+    try:
+        with open(cursor_state_path, "r", encoding="utf-8") as f:
+            state = json.load(f)
+        if not isinstance(state, dict):
+            return {"offset": 0}
+        state.setdefault("offset", 0)
+        return state
+    except Exception:
+        logger.exception("[INTENT_STORE] failed to load cursor from %s", cursor_state_path)
+        return {"offset": 0}
+
+
+def load_intents_since_cursor(
+    path: Path, cursor_state_path: Path
+) -> Tuple[List[Dict[str, Any]], Dict[str, Any]]:
+    """Read new intents from JSONL starting at cursor offset."""
+
+    intents: list[Dict[str, Any]] = []
+    path = Path(path)
+    cursor = _load_cursor(cursor_state_path)
+    offset = int(cursor.get("offset") or 0)
+    start_offset = offset
+    last_intent_id = cursor.get("last_intent_id")
+    last_ts = cursor.get("last_ts")
+
+    if not path.exists():
+        return intents, {
+            "offset": offset,
+            "last_intent_id": last_intent_id,
+            "last_ts": last_ts,
+            "start_offset": start_offset,
+        }
+
+    try:
+        with open(path, "r", encoding="utf-8") as f:
+            try:
+                f.seek(offset)
+            except OSError:
+                f.seek(0)
+            while True:
+                line = f.readline()
+                if not line:
+                    break
+                try:
+                    end_offset = f.tell()
+                except OSError:
+                    end_offset = offset
+                offset = end_offset
+                if not line.strip():
+                    continue
+                try:
+                    intent = json.loads(line)
+                except json.JSONDecodeError:
+                    logger.warning("[INTENT_STORE] skip invalid intent line: %s", line.strip())
+                    continue
+                if isinstance(intent, dict):
+                    intent["_end_offset"] = end_offset
+                    intents.append(intent)
+                    last_intent_id = intent.get("intent_id") or last_intent_id
+                    last_ts = intent.get("ts") or last_ts
+    except Exception:
+        logger.exception("[INTENT_STORE] failed to load intents from %s", path)
+
+    return intents, {
+        "offset": offset,
+        "last_intent_id": last_intent_id,
+        "last_ts": last_ts,
+        "start_offset": start_offset,
+    }
+
+
+def save_cursor(
+    cursor_state_path: Path,
+    *,
+    offset: int,
+    last_intent_id: str | None = None,
+    last_ts: str | None = None,
+) -> None:
+    payload = {
+        "offset": int(offset),
+        "last_intent_id": last_intent_id,
+        "last_ts": last_ts,
+    }
+    cursor_state_path = Path(cursor_state_path)
+    cursor_state_path.parent.mkdir(parents=True, exist_ok=True)
+    tmp_path = cursor_state_path.with_name(f"{cursor_state_path.name}.tmp")
+    try:
+        with open(tmp_path, "w", encoding="utf-8") as f:
+            json.dump(payload, f, ensure_ascii=False, indent=2)
+        os.replace(tmp_path, cursor_state_path)
+    except Exception:
+        logger.exception("[INTENT_STORE] failed to save cursor to %s", cursor_state_path)
+
+
+def dedupe_intents(intents: Iterable[Dict[str, Any]]) -> list[Dict[str, Any]]:
+    deduped: list[Dict[str, Any]] = []
+    seen: set[str] = set()
+    for intent in intents:
+        if not isinstance(intent, dict):
+            continue
+        intent_id = intent.get("intent_id")
+        if intent_id:
+            if intent_id in seen:
+                continue
+            seen.add(intent_id)
+        deduped.append(intent)
+    return deduped
