diff --git a/.github/workflows/pb1-runner.yml b/.github/workflows/pb1-runner.yml
new file mode 100644
index 0000000000000000000000000000000000000000..c0c2735295d41555ea881c2fe3c77ca521823bc2
--- /dev/null
+++ b/.github/workflows/pb1-runner.yml
@@ -0,0 +1,66 @@
+name: PB1 Close Pullback Runner
+
+permissions:
+  contents: write
+
+concurrency:
+  group: pb1-close-runner
+  cancel-in-progress: true
+
+on:
+  workflow_dispatch:
+  schedule:
+    - cron: "*/5 23 * * *"
+    - cron: "*/5 0-2 * * *"
+    - cron: "*/5 5-6 * * *"
+
+jobs:
+  pb1-run:
+    if: github.ref != 'refs/heads/bot-state'
+    runs-on: ubuntu-latest
+    timeout-minutes: 25
+    env:
+      BOTSTATE_BRANCH: bot-state
+      MORNING_WINDOW_START: "08:50"
+      MORNING_WINDOW_END: "11:00"
+      MORNING_EXIT_START: "09:00"
+      MORNING_EXIT_END: "09:20"
+      AFTERNOON_WINDOW_START: "14:00"
+      AFTERNOON_WINDOW_END: "15:30"
+      CLOSE_AUCTION_START: "15:20"
+      CLOSE_AUCTION_END: "15:30"
+      ENABLE_BREAKOUT: "false"
+      LEDGER_BASE_DIR: "bot_state/trader_ledger"
+      LEDGER_LOOKBACK_DAYS: "120"
+      BOTSTATE_LOCK_TTL_SEC: "900"
+      STRATEGY_MODE: "INTENT_ONLY"
+      DRY_RUN: "1"
+      EXPECT_LIVE_TRADING: "0"
+    steps:
+      - uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+
+      - name: Set git identity
+        run: |
+          git config user.name "trade-bot"
+          git config user.email "trade-bot@users.noreply.github.com"
+
+      - uses: actions/setup-python@v5
+        with:
+          python-version: "3.11"
+
+      - name: Install dependencies
+        run: |
+          python -m pip install --upgrade pip
+          pip install -r requirements.txt
+
+      - name: Compile modules
+        run: |
+          python -m compileall trader
+
+      - name: Run PB1 window router
+        env:
+          PYTHONPATH: ${{ github.workspace }}
+        run: |
+          python -m trader.pb1_runner --window auto --phase auto --target-branch ${BOTSTATE_BRANCH}
diff --git a/README.md b/README.md
index 4a112f0488c859b732bc00a0101d4519d328ab29..474ee0182df4a876bb953cde0a17ddbe369a22f5 100644
--- a/README.md
+++ b/README.md
@@ -35,25 +35,32 @@ Workflow는 bot-state 브랜치에 bot_state/state.json을 커밋하여 런 간
 
 ## Diagnostic mode (no-order safety)
 Run a diagnostics-only pass (no KIS orders) even on non-trading days:
 ```
 DIAGNOSTIC_MODE=true DIAGNOSTIC_ONLY=true python -m trader.trader
 ```
 Key log markers for grep:
 - `[DIAG][TRADER] forcing DISABLE_LIVE_TRADING=true ...`
 - `[DIAG][STATE] reconciled positions=...`
 - `[DIAG][REBALANCE] kospi=... kosdaq=...`
 - `[DATA-HEALTH] code=... reasons=[...]`
 - `[SETUP-BAD] ... reasons=['...']` (never empty on failures)
 - `[ORPHAN]` / `[UNKNOWN]` aggregates
 - `[DIAG][DUMP] path=...`
 
 ## Strategy intent mode (single-account multi-strategy)
 - A new `StrategyManager` runs before engine loops and emits **order intents only** into `trader/state/strategy_intents.jsonl` with a cursor in `trader/state/strategy_intents_state.json`.
 - All five strategies (`breakout`~`volatility`) are present but **disabled by default**: `ENABLED_STRATEGIES=""` means no strategies run, and missing weights are treated as zero even when listed.
 - Enable a subset for testing, e.g. `ENABLED_STRATEGIES="momentum"` with optional weights `STRATEGY_WEIGHTS="momentum=0.10"`. Keep `STRATEGY_MODE=INTENT_ONLY` and `STRATEGY_DRY_RUN=true` (defaults) to avoid any KIS orders.
 - PortfolioManager order: strategies → KOSPI → KOSDAQ. During isolated testing use `DISABLE_KOSPI_ENGINE=true` or `DISABLE_KOSDAQ_LOOP=true` to skip respective engines.
 - State sync scripts in `scripts/state_pull_plain.sh` and `scripts/state_push_plain.sh` now copy the intent log/cursor alongside `trader/state/state.json` into the `bot-state` branch.
 
 ## CI and live-trading safeguards
 - CI (pull_request) runs set `DISABLE_LIVE_TRADING=true` so all KIS API calls are blocked and only static checks execute.
 - The live trading workflow is restricted to the `main` branch and triggers only via schedule or manual dispatch with the branch guard enabled.
+
+## PB1 운영 가이드 (종가 눌림목 클로즈 매수)
+- **윈도우**: 오전 08:50~11:00 KST(09:00~09:20 청산 전용), 오후 14:00~15:30 KST(15:20~15:30 신규 진입 전용). 윈도우 밖에서는 즉시 종료한다.
+- **모드**: 매수 시 `mode=1`(DAY) 또는 `mode=2`(SWING)으로 고정해 원장에 남긴다. DAY는 다음날 09:00~09:20에 시간청산(+R 기반 익절/손절), SWING은 -7%/-8% 하드스톱, MA20 트레일, 10거래일 타임스톱을 따른다.
+- **원장 경로**: 모든 이벤트는 `bot_state/trader_ledger/<kind>/<YYYY-MM-DD>/run_<run_id>.jsonl`(orders_intent/orders_ack/fills/exits_intent/errors)과 `bot_state/trader_ledger/reports/<YYYY-MM-DD>/pnl_snapshot.json`에 append-only로 남는다. 평균원가(가중평균)로 평단/수익률%를 재구성한다.
+- **DRY_RUN/LIVE**: `STRATEGY_MODE=INTENT_ONLY`+`DRY_RUN=1`이면 주문 호출 없이 ledger에 intent만 적재하며, LIVE(모의/실전)는 동일 로직으로 주문 수행 후 fill을 기록한다. `ENABLE_BREAKOUT=false`가 기본이며 돌파 신규 진입 경로는 차단된다.
+- **실행 방법**: `python -m trader.trader --window auto --phase auto --target-branch bot-state` (GitHub Actions `pb1-runner.yml`는 5분 간격으로 오전/오후 윈도우를 모두 커버).
diff --git a/trader/botstate_sync.py b/trader/botstate_sync.py
new file mode 100644
index 0000000000000000000000000000000000000000..a9f7753a47558a1c0a42c29b0e2921a0c405d16f
--- /dev/null
+++ b/trader/botstate_sync.py
@@ -0,0 +1,108 @@
+from __future__ import annotations
+
+import json
+import os
+import subprocess
+import time
+import logging
+from datetime import datetime, timedelta
+from pathlib import Path
+from typing import Dict, Iterable
+from zoneinfo import ZoneInfo
+
+logger = logging.getLogger(__name__)
+
+KST = ZoneInfo("Asia/Seoul")
+
+
+def _run(cmd: list[str], cwd: Path | None = None) -> subprocess.CompletedProcess:
+    return subprocess.run(cmd, cwd=cwd, check=True, text=True, capture_output=True)
+
+
+def setup_worktree(base_dir: Path, worktree_dir: Path, target_branch: str = "bot-state") -> None:
+    worktree_dir.mkdir(parents=True, exist_ok=True)
+    try:
+        _run(["git", "worktree", "add", "-B", target_branch, str(worktree_dir), target_branch], cwd=base_dir)
+    except subprocess.CalledProcessError:
+        _run(["git", "fetch", "origin", f"{target_branch}:{target_branch}"], cwd=base_dir)
+        _run(["git", "worktree", "add", "-B", target_branch, str(worktree_dir), target_branch], cwd=base_dir)
+    _run(["git", "pull", "--rebase"], cwd=worktree_dir)
+
+
+def _lock_path(worktree_dir: Path) -> Path:
+    return worktree_dir / "bot_state" / "locks" / "trader.lock.json"
+
+
+def acquire_lock(worktree_dir: Path, owner: str, run_id: str, ttl_sec: int = 900) -> bool:
+    lock_path = _lock_path(worktree_dir)
+    lock_path.parent.mkdir(parents=True, exist_ok=True)
+    now = datetime.now(tz=KST)
+    if lock_path.exists():
+        try:
+            payload = json.loads(lock_path.read_text())
+            ts = datetime.fromisoformat(payload.get("ts"))
+            ttl = int(payload.get("ttl_sec") or ttl_sec)
+            if ts + timedelta(seconds=ttl) > now:
+                logger.warning("[BOTSTATE][LOCKED] owner=%s run_id=%s until=%s", payload.get("owner"), payload.get("run_id"), ts + timedelta(seconds=ttl))
+                return False
+        except Exception:
+            pass
+    lock_payload = {
+        "owner": owner,
+        "run_id": run_id,
+        "ts": now.isoformat(),
+        "ttl_sec": ttl_sec,
+    }
+    lock_path.write_text(json.dumps(lock_payload))
+    _run(["git", "add", str(lock_path)], cwd=worktree_dir)
+    push_retry(worktree_dir, message=f"lock run_id={run_id}")
+    logger.info("[BOTSTATE][LOCK-ACQUIRED] owner=%s run_id=%s", owner, run_id)
+    return True
+
+
+def release_lock(worktree_dir: Path, run_id: str) -> None:
+    lock_path = _lock_path(worktree_dir)
+    if lock_path.exists():
+        lock_path.unlink()
+        _run(["git", "add", "-u"], cwd=worktree_dir)
+        push_retry(worktree_dir, message=f"unlock run_id={run_id}")
+        logger.info("[BOTSTATE][LOCK-RELEASED] run_id=%s", run_id)
+
+
+def persist_run_files(worktree_dir: Path, new_files: Iterable[Path], message: str) -> None:
+    files = list(new_files)
+    for path in files:
+        try:
+            if path.resolve().is_relative_to(worktree_dir.resolve()):
+                target = path
+            else:
+                if "bot_state" in path.parts:
+                    idx = path.parts.index("bot_state")
+                    rel = Path(*path.parts[idx:])
+                else:
+                    rel = Path("bot_state") / Path(*path.parts[-4:])
+                target = worktree_dir / rel
+                target.parent.mkdir(parents=True, exist_ok=True)
+                target.write_bytes(path.read_bytes())
+            _run(["git", "add", str(target)], cwd=worktree_dir)
+        except Exception:
+            continue
+    push_retry(worktree_dir, message=message)
+    logger.info("[BOTSTATE][PERSIST] files=%s message=%s", len(files), message)
+
+
+def push_retry(worktree_dir: Path, message: str, retries: int = 3) -> None:
+    for attempt in range(1, retries + 1):
+        try:
+            _run(["git", "commit", "-m", message], cwd=worktree_dir)
+        except subprocess.CalledProcessError:
+            pass
+        try:
+            _run(["git", "pull", "--rebase"], cwd=worktree_dir)
+            _run(["git", "push"], cwd=worktree_dir)
+            logger.info("[BOTSTATE][PUSH] message=%s attempt=%s", message, attempt)
+            return
+        except subprocess.CalledProcessError as e:
+            if attempt == retries:
+                raise
+            time.sleep(2 * attempt)
diff --git a/trader/config.py b/trader/config.py
index 1afa881ac2698f971c33d15e8a459f4aead01ed5..0601565bd306d8ca210a62ada56011650850a549 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -94,50 +94,77 @@ CONFIG = {
     "SUBJECT_FLOW_MAX_CALLS_PER_RUN": "200",
     "EMERGENCY_GLOBAL_SELL": "false",
     "STRATEGY_REDUCTION_PRIORITY": "5,4,3,2,1",
     # Diagnostics
     "DIAGNOSTIC_MODE": "false",
     "DIAGNOSTIC_ONLY": "false",
     "DIAGNOSTIC_FORCE_RUN": "false",
     "DIAGNOSTIC_DUMP_PATH": "trader/state/diagnostics",
     "DIAGNOSTIC_TARGET_MARKETS": "",
     "DIAGNOSTIC_MAX_SYMBOLS": "200",
     # === Strategy intent/exec defaults ===
     "ENABLED_STRATEGIES": "",
     "STRATEGY_MODE": "INTENT_ONLY",  # INTENT_ONLY | LIVE
     "STRATEGY_DRY_RUN": "true",
     "STRATEGY_INTENTS_PATH": "trader/state/strategy_intents.jsonl",
     "STRATEGY_INTENTS_STATE_PATH": "trader/state/strategy_intents_state.json",
     "STRATEGY_MAX_OPEN_INTENTS": "20",
     "STRATEGY_MAX_POSITION_PCT": "0.10",
     "STRATEGY_ALLOW_SELL_ONLY": "false",
     "STRATEGY_WEIGHTS": "",
     "DISABLE_KOSDAQ_LOOP": "false",
     "DISABLE_KOSPI_ENGINE": "false",
     "ACTIVE_STRATEGIES": "1",  # CSV of strategy IDs eligible for managed exits/entries
     "ALLOW_ADOPT_UNMANAGED": "false",
     "STATE_PATH": "trader/state/state.json",
+    # PB1 close-pullback defaults
+    "ENABLE_BREAKOUT": "false",
+    "LEDGER_LOOKBACK_DAYS": "120",
+    "BOTSTATE_LOCK_TTL_SEC": "900",
+    "LEDGER_BASE_DIR": "bot_state/trader_ledger",
+    "MORNING_WINDOW_START": "08:50",
+    "MORNING_WINDOW_END": "11:00",
+    "MORNING_EXIT_START": "09:00",
+    "MORNING_EXIT_END": "09:20",
+    "AFTERNOON_WINDOW_START": "14:00",
+    "AFTERNOON_WINDOW_END": "15:30",
+    "CLOSE_AUCTION_START": "15:20",
+    "CLOSE_AUCTION_END": "15:30",
+    "PB1_PULLBACK_BAND_KOSPI": "3,8",
+    "PB1_PULLBACK_BAND_KOSDAQ": "4,10",
+    "PB1_VOL_CONTRACTION_MAX": "0.80",
+    "PB1_VOLU_CONTRACTION_MAX": "0.75",
+    "PB1_SWING_TREND_MIN": "1.05",
+    "PB1_SWING_VOL_CONTRACTION_MAX": "0.80",
+    "PB1_SWING_VOLU_CONTRACTION_MAX": "0.75",
+    "PB1_R_FLOOR_PCT": "2.0",
+    "PB1_DAY_TP_R": "0.8",
+    "PB1_DAY_SL_R": "0.6",
+    "KOSPI_HARD_STOP_PCT": "7.0",
+    "KOSDAQ_HARD_STOP_PCT": "8.0",
+    "PB1_SWING_TRAIL_MA": "20",
+    "PB1_TIME_STOP_DAYS": "10",
 }
 
 
 def _cfg(key: str) -> str:
     """환경변수 > CONFIG 기본값"""
     return os.getenv(key, CONFIG.get(key, ""))
 
 
 def _default_bool(key: str, fallback: bool = False) -> bool:
     raw_default = str(CONFIG.get(key, "")).strip().lower()
     if raw_default in TRUE_VALUES:
         return True
     if raw_default in FALSE_VALUES:
         return False
     return fallback
 
 
 def _cfg_bool(key: str, fallback: bool | None = None) -> bool:
     default_value = _default_bool(key, fallback if fallback is not None else False)
     return env_bool(key, default=default_value)
 
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
@@ -364,32 +391,58 @@ def resolve_active_strategies(raw: str | None = None) -> set[int]:
     parsed = _parse_active_strategies(raw_env or "")
     if parsed:
         return parsed
     return ACTIVE_STRATEGIES
 
 BAD_ENTRY_MAX_MA20_DIST = 1.25  # 현재가/20MA 상한(추격매수 방지)
 BAD_ENTRY_MAX_PULLBACK = 20.0  # 신고가 대비 눌림폭 상한(과도한 붕괴 방지)
 BAD_ENTRY_MAX_BELOW_VWAP_RATIO = 0.7  # 분봉에서 VWAP 아래 체류 비중이 이 이상이면 BAD
 NEUTRAL_ENTRY_SCALE = float(_cfg("NEUTRAL_ENTRY_SCALE") or "0.6")
 
 
 def _parse_hhmm(hhmm: str) -> dtime:
     try:
         hh, mm = hhmm.split(":")
         return dtime(hour=int(hh), minute=int(mm))
     except Exception:
         logger.warning(f"[설정경고] SELL_FORCE_TIME 형식 오류 → 기본값 14:40 적용: {hhmm}")
         return dtime(hour=14, minute=40)
 
 
 SELL_FORCE_TIME = _parse_hhmm(SELL_FORCE_TIME_STR)
 TIME_STOP_TIME = _parse_hhmm(TIME_STOP_HHMM)
 ALLOW_WHEN_CLOSED = _cfg_bool("MARKET_DATA_WHEN_CLOSED")
 DISABLE_KOSDAQ_LOOP = _cfg_bool("DISABLE_KOSDAQ_LOOP")
 DISABLE_KOSPI_ENGINE = _cfg_bool("DISABLE_KOSPI_ENGINE")
+ENABLE_BREAKOUT = _cfg_bool("ENABLE_BREAKOUT")
+LEDGER_LOOKBACK_DAYS = int(_cfg("LEDGER_LOOKBACK_DAYS") or "120")
+BOTSTATE_LOCK_TTL_SEC = int(_cfg("BOTSTATE_LOCK_TTL_SEC") or "900")
+LEDGER_BASE_DIR = Path(_cfg("LEDGER_BASE_DIR") or "bot_state/trader_ledger")
+MORNING_WINDOW_START = _cfg("MORNING_WINDOW_START") or "08:50"
+MORNING_WINDOW_END = _cfg("MORNING_WINDOW_END") or "11:00"
+MORNING_EXIT_START = _cfg("MORNING_EXIT_START") or "09:00"
+MORNING_EXIT_END = _cfg("MORNING_EXIT_END") or "09:20"
+AFTERNOON_WINDOW_START = _cfg("AFTERNOON_WINDOW_START") or "14:00"
+AFTERNOON_WINDOW_END = _cfg("AFTERNOON_WINDOW_END") or "15:30"
+CLOSE_AUCTION_START = _cfg("CLOSE_AUCTION_START") or "15:20"
+CLOSE_AUCTION_END = _cfg("CLOSE_AUCTION_END") or "15:30"
+PB1_PULLBACK_BAND_KOSPI = tuple(float(x.strip()) for x in (_cfg("PB1_PULLBACK_BAND_KOSPI") or "3,8").split(","))
+PB1_PULLBACK_BAND_KOSDAQ = tuple(float(x.strip()) for x in (_cfg("PB1_PULLBACK_BAND_KOSDAQ") or "4,10").split(","))
+PB1_VOL_CONTRACTION_MAX = float(_cfg("PB1_VOL_CONTRACTION_MAX") or "0.80")
+PB1_VOLU_CONTRACTION_MAX = float(_cfg("PB1_VOLU_CONTRACTION_MAX") or "0.75")
+PB1_SWING_TREND_MIN = float(_cfg("PB1_SWING_TREND_MIN") or "1.05")
+PB1_SWING_VOL_CONTRACTION_MAX = float(_cfg("PB1_SWING_VOL_CONTRACTION_MAX") or "0.80")
+PB1_SWING_VOLU_CONTRACTION_MAX = float(_cfg("PB1_SWING_VOLU_CONTRACTION_MAX") or "0.75")
+PB1_R_FLOOR_PCT = float(_cfg("PB1_R_FLOOR_PCT") or "2.0")
+PB1_DAY_TP_R = float(_cfg("PB1_DAY_TP_R") or "0.8")
+PB1_DAY_SL_R = float(_cfg("PB1_DAY_SL_R") or "0.6")
+KOSPI_HARD_STOP_PCT = float(_cfg("KOSPI_HARD_STOP_PCT") or "7.0")
+KOSDAQ_HARD_STOP_PCT = float(_cfg("KOSDAQ_HARD_STOP_PCT") or "8.0")
+PB1_SWING_TRAIL_MA = int(_cfg("PB1_SWING_TRAIL_MA") or "20")
+PB1_TIME_STOP_DAYS = int(_cfg("PB1_TIME_STOP_DAYS") or "10")
 
 # === [NEW] 주간 리밸런싱 강제 트리거 상태 파일 ===
 STATE_WEEKLY_PATH = Path(__file__).parent / "state_weekly.json"
 
 def _this_iso_week_key(now=None):
     now = now or datetime.now(KST)
     return f"{now.year}-W{now.isocalendar().week:02d}"
diff --git a/trader/ledger/event_types.py b/trader/ledger/event_types.py
new file mode 100644
index 0000000000000000000000000000000000000000..6a11e116732eeb2cb37e9fcfc85948dd93c7c3e1
--- /dev/null
+++ b/trader/ledger/event_types.py
@@ -0,0 +1,94 @@
+from __future__ import annotations
+
+"""Ledger event models used for append-only JSONL persistence.
+
+This module intentionally keeps the schema explicit and small so it can be
+shared between the trading runtime and the bot-state worktree copier. Each
+event is a dataclass with JSONL-friendly serialization helpers.
+"""
+
+from dataclasses import dataclass, field
+from datetime import datetime
+from typing import Any, Dict, List, Optional
+from uuid import uuid4
+from zoneinfo import ZoneInfo
+
+KST = ZoneInfo("Asia/Seoul")
+
+
+def _ts(dt: datetime | None = None) -> datetime:
+    return (dt or datetime.now(tz=KST)).astimezone(tz=KST)
+
+
+@dataclass
+class LedgerEvent:
+    event_type: str
+    code: str
+    market: str
+    sid: int
+    mode: int
+    env: str
+    run_id: str
+    side: Optional[str] = None
+    qty: Optional[int] = None
+    price: Optional[float] = None
+    odno: Optional[str] = None
+    client_order_key: Optional[str] = None
+    ok: bool = True
+    reasons: List[str] = field(default_factory=list)
+    payload: Optional[Dict[str, Any]] = None
+    stage: Optional[str] = None
+    event_id: str = field(default_factory=lambda: str(uuid4()))
+    ts: datetime = field(default_factory=_ts)
+
+    def to_dict(self) -> Dict[str, Any]:
+        return {
+            "event_id": self.event_id,
+            "event_type": self.event_type,
+            "ts": self.ts.isoformat(),
+            "run_id": self.run_id,
+            "env": self.env,
+            "code": str(self.code).zfill(6),
+            "market": self.market,
+            "sid": self.sid,
+            "mode": self.mode,
+            "side": self.side,
+            "qty": self.qty,
+            "price": self.price,
+            "odno": self.odno,
+            "client_order_key": self.client_order_key,
+            "ok": bool(self.ok),
+            "reasons": list(self.reasons or []),
+            "payload": self.payload or {},
+            "stage": self.stage,
+        }
+
+    def to_jsonl(self) -> str:
+        import json
+
+        return json.dumps(self.to_dict(), ensure_ascii=False)
+
+
+def new_order_intent(**kwargs: Any) -> LedgerEvent:
+    return LedgerEvent(event_type="ORDER_INTENT", **kwargs)
+
+
+def new_order_ack(**kwargs: Any) -> LedgerEvent:
+    return LedgerEvent(event_type="ORDER_ACK", **kwargs)
+
+
+def new_fill(**kwargs: Any) -> LedgerEvent:
+    return LedgerEvent(event_type="FILL", **kwargs)
+
+
+def new_exit_intent(**kwargs: Any) -> LedgerEvent:
+    return LedgerEvent(event_type="EXIT_INTENT", **kwargs)
+
+
+def new_error(**kwargs: Any) -> LedgerEvent:
+    return LedgerEvent(event_type="ERROR", ok=False, **kwargs)
+
+
+def new_unfilled(**kwargs: Any) -> LedgerEvent:
+    return LedgerEvent(event_type="UNFILLED", ok=False, **kwargs)
+
diff --git a/trader/ledger/store.py b/trader/ledger/store.py
new file mode 100644
index 0000000000000000000000000000000000000000..898f5935521ec75d2417954e8d2ae3b9016aa3a6
--- /dev/null
+++ b/trader/ledger/store.py
@@ -0,0 +1,219 @@
+from __future__ import annotations
+
+import json
+import os
+import uuid
+import logging
+from datetime import datetime, timedelta
+from pathlib import Path
+from typing import Dict, Iterable, List, Tuple
+
+from trader.ledger.event_types import LedgerEvent
+from trader.time_utils import now_kst
+
+logger = logging.getLogger(__name__)
+
+KST = now_kst().tzinfo  # reuse timezone
+
+
+def _today_str() -> str:
+    return now_kst().date().isoformat()
+
+
+def _ensure_dir(path: Path) -> None:
+    path.parent.mkdir(parents=True, exist_ok=True)
+
+
+class LedgerStore:
+    def __init__(self, base_dir: Path, env: str = "paper", run_id: str | None = None) -> None:
+        self.base_dir = Path(base_dir)
+        self.env = env
+        self.run_id = run_id or os.getenv("GITHUB_RUN_ID", str(uuid.uuid4()))
+        self.today = _today_str()
+
+    def _run_file(self, kind: str) -> Path:
+        return self.base_dir / kind / self.today / f"run_{self.run_id}.jsonl"
+
+    def open_run_files(self) -> Dict[str, Path]:
+        files = {}
+        for kind in [
+            "orders_intent",
+            "orders_ack",
+            "fills",
+            "exits_intent",
+            "errors",
+        ]:
+            path = self._run_file(kind)
+            _ensure_dir(path)
+            if not path.exists():
+                path.touch()
+            files[kind] = path
+        return files
+
+    def append_event(self, kind: str, event: LedgerEvent) -> Path:
+        path = self._run_file(kind)
+        _ensure_dir(path)
+        line = event.to_jsonl()
+        with open(path, "a", encoding="utf-8") as f:
+            f.write(line + "\n")
+            f.flush()
+            os.fsync(f.fileno())
+        logger.info("[LEDGER][APPEND] kind=%s path=%s", kind, path)
+        return path
+
+    def _iter_jsonl(self, paths: Iterable[Path]) -> Iterable[Dict]:
+        for path in paths:
+            if not path.exists():
+                continue
+            with open(path, "r", encoding="utf-8") as f:
+                for line in f:
+                    line = line.strip()
+                    if not line:
+                        continue
+                    try:
+                        yield json.loads(line)
+                    except json.JSONDecodeError:
+                        continue
+
+    def _recent_files(self, lookback_days: int) -> List[Path]:
+        cutoff = now_kst().date() - timedelta(days=lookback_days)
+        paths: List[Path] = []
+        for kind in ["fills", "orders_intent", "orders_ack", "exits_intent", "errors"]:
+            base = self.base_dir / kind
+            if not base.exists():
+                continue
+            for day_dir in base.iterdir():
+                try:
+                    day = datetime.strptime(day_dir.name, "%Y-%m-%d").date()
+                except ValueError:
+                    continue
+                if day >= cutoff:
+                    paths.extend(day_dir.glob("run_*.jsonl"))
+        return sorted(paths)
+
+    def has_client_order_key(self, client_order_key: str) -> bool:
+        if not client_order_key:
+            return False
+        for row in self._iter_jsonl(self._recent_files(lookback_days=7)):
+            if row.get("client_order_key") == client_order_key:
+                return True
+        return False
+
+    def rebuild_positions_average_cost(self, lookback_days: int = 120) -> Dict[Tuple[str, int, int], Dict]:
+        positions: Dict[Tuple[str, int, int], Dict[str, float | int | None]] = {}
+        fill_paths = [p for p in self._recent_files(lookback_days) if "fills" in str(p)]
+        for row in self._iter_jsonl(fill_paths):
+            code = str(row.get("code") or "").zfill(6)
+            sid = int(row.get("sid") or 0)
+            mode = int(row.get("mode") or 0)
+            side = (row.get("side") or "").upper()
+            qty = int(row.get("qty") or 0)
+            price = float(row.get("price") or 0.0)
+            key = (code, sid, mode)
+            state = positions.setdefault(
+                key,
+                {
+                    "total_qty": 0,
+                    "total_cost": 0.0,
+                    "avg_buy_price": None,
+                    "realized_pnl": 0.0,
+                    "realized_cost_basis": 0.0,
+                    "first_buy_ts": None,
+                    "market": row.get("market"),
+                },
+            )
+            if side == "BUY":
+                state["total_cost"] += qty * price
+                state["total_qty"] += qty
+                state["avg_buy_price"] = state["total_cost"] / state["total_qty"]
+                if state["first_buy_ts"] is None:
+                    state["first_buy_ts"] = row.get("ts")
+            elif side == "SELL":
+                cost_basis = qty * (state.get("avg_buy_price") or 0.0)
+                state["realized_pnl"] += qty * price - cost_basis
+                state["realized_cost_basis"] += cost_basis
+                state["total_qty"] -= qty
+                state["total_cost"] -= cost_basis
+                if state["total_qty"] <= 0:
+                    state["avg_buy_price"] = None
+                    state["total_qty"] = max(0, state["total_qty"])
+        # holding days
+        now_date = now_kst().date()
+        for state in positions.values():
+            if state.get("first_buy_ts"):
+                try:
+                    first_dt = datetime.fromisoformat(state["first_buy_ts"])
+                    state["holding_days"] = (now_date - first_dt.date()).days
+                except Exception:
+                    state["holding_days"] = None
+            else:
+                state["holding_days"] = None
+        return positions
+
+    def compute_returns_pct(self, positions: Dict[Tuple[str, int, int], Dict], marks: Dict[str, float]) -> Dict[Tuple[str, int, int], Dict[str, float | int | None]]:
+        result: Dict[Tuple[str, int, int], Dict[str, float | int | None]] = {}
+        for key, state in positions.items():
+            code, sid, mode = key
+            mark_price = marks.get(code)
+            avg = state.get("avg_buy_price")
+            qty = state.get("total_qty") or 0
+            if avg:
+                unrealized = ((mark_price - avg) / avg) * 100 if mark_price else None
+            else:
+                unrealized = None
+            realized_basis = state.get("realized_cost_basis") or 0.0
+            realized_return = (
+                (state.get("realized_pnl") or 0.0) / realized_basis * 100
+                if realized_basis > 0
+                else None
+            )
+            result[key] = {
+                "qty": qty,
+                "avg_buy_price": avg,
+                "mark_price_used": mark_price,
+                "unrealized_return_pct": unrealized,
+                "realized_pnl": state.get("realized_pnl"),
+                "realized_return_pct_to_date": realized_return,
+                "holding_days": state.get("holding_days"),
+                "market": state.get("market"),
+            }
+        return result
+
+    def generate_pnl_snapshot(self, positions: Dict[Tuple[str, int, int], Dict], marks: Dict[str, float]) -> Dict:
+        returns = self.compute_returns_pct(positions, marks)
+        total_unrealized = 0.0
+        total_cost = 0.0
+        total_realized = 0.0
+        snapshot_positions = {}
+        for key, state in positions.items():
+            data = returns.get(key) or {}
+            code, sid, mode = key
+            avg = data.get("avg_buy_price") or 0.0
+            qty = data.get("qty") or 0
+            mark = data.get("mark_price_used") or avg
+            total_cost += avg * qty
+            total_unrealized += (mark - avg) * qty
+            total_realized += state.get("realized_pnl") or 0.0
+            snapshot_positions[f"{code}|sid={sid}|mode={mode}"] = data
+            snapshot_positions[f"{code}|sid={sid}|mode={mode}"]["last_actions"] = state.get("last_actions")
+        total_return_pct = (total_unrealized / total_cost * 100) if total_cost else 0.0
+        snapshot = {
+            "ts": now_kst().isoformat(),
+            "positions": snapshot_positions,
+            "totals": {
+                "total_cost": total_cost,
+                "unrealized": total_unrealized,
+                "realized": total_realized,
+                "portfolio_return_pct": total_return_pct,
+            },
+        }
+        return snapshot
+
+    def write_snapshot(self, snapshot: Dict, run_id: str) -> Path:
+        date_str = self.today
+        path = self.base_dir / "reports" / date_str / "pnl_snapshot.json"
+        _ensure_dir(path)
+        with open(path, "w", encoding="utf-8") as f:
+            json.dump(snapshot, f, ensure_ascii=False, indent=2)
+        logger.info("[LEDGER][APPEND] kind=pnl_snapshot path=%s", path)
+        return path
diff --git a/trader/pb1_engine.py b/trader/pb1_engine.py
new file mode 100644
index 0000000000000000000000000000000000000000..23da1281cbf80b4c337ecdc2b5d589894b91f307
--- /dev/null
+++ b/trader/pb1_engine.py
@@ -0,0 +1,540 @@
+from __future__ import annotations
+
+import logging
+from dataclasses import dataclass
+from datetime import datetime, timedelta
+from pathlib import Path
+from typing import Dict, Iterable, List, Tuple
+
+import pandas as pd
+
+from rolling_k_auto_trade_api.best_k_meta_strategy import run_rebalance
+from trader.config import (
+    CAP_CAP,
+    DAILY_CAPITAL,
+    ENABLE_BREAKOUT,
+    KOSDAQ_HARD_STOP_PCT,
+    KOSPI_HARD_STOP_PCT,
+    LEDGER_BASE_DIR,
+    LEDGER_LOOKBACK_DAYS,
+    PB1_DAY_SL_R,
+    PB1_DAY_TP_R,
+    PB1_R_FLOOR_PCT,
+    PB1_TIME_STOP_DAYS,
+)
+from trader.kis_wrapper import KisAPI
+from trader.ledger.event_types import new_error, new_exit_intent, new_order_intent, new_fill, new_order_ack, new_unfilled
+from trader.ledger.store import LedgerStore
+from trader.strategies.pb1_pullback_close import choose_mode, compute_features, evaluate_setup
+from trader.time_utils import now_kst
+from trader.window_router import WindowDecision, resolve_phase
+from trader.botstate_sync import persist_run_files
+
+logger = logging.getLogger(__name__)
+
+
+@dataclass
+class CandidateFeature:
+    code: str
+    market: str
+    features: Dict[str, float]
+    setup_ok: bool
+    reasons: List[str]
+    mode: int
+    mode_reasons: List[str]
+    client_order_key: str | None = None
+    planned_qty: int = 0
+
+
+class PB1Engine:
+    def __init__(
+        self,
+        *,
+        kis: KisAPI | None,
+        worktree_dir: Path,
+        window: WindowDecision,
+        phase_override: str,
+        dry_run: bool,
+        env: str,
+        run_id: str,
+    ) -> None:
+        self.kis = kis
+        self.worktree_dir = worktree_dir
+        self.window = window
+        self.phase = resolve_phase(window, phase_override)
+        self.dry_run = dry_run
+        self.env = env
+        self.run_id = run_id
+        self.ledger = LedgerStore(worktree_dir / LEDGER_BASE_DIR, env=env, run_id=run_id)
+        self.worktree_dir = worktree_dir
+        self._today = now_kst().date().isoformat()
+
+    def _client_order_key(self, code: str, mode: int, side: str, stage: str, window_tag: str) -> str:
+        return f"{self._today}|{code}|sid=1|mode={mode}|{side}|{window_tag}|{stage}"
+
+    def _log_setup(self, cf: CandidateFeature) -> None:
+        prefix = "[PB1][SETUP-OK]" if cf.setup_ok else "[PB1][SETUP-BAD]"
+        logger.info(
+            "%s code=%s market=%s mode=%s reasons=%s features=%s",
+            prefix,
+            cf.code,
+            cf.market,
+            cf.mode,
+            cf.reasons or ["n/a"],
+            {k: cf.features.get(k) for k in ["close", "ma20", "ma50", "pullback_pct", "vol_contraction", "volu_contraction"]},
+        )
+
+    def _fetch_daily(self, code: str, count: int = 120) -> pd.DataFrame:
+        if not self.kis:
+            return pd.DataFrame()
+        try:
+            candles = self.kis.safe_get_daily_candles(code, count=count)
+        except Exception:
+            logger.exception("[PB1][DATA][FAIL] code=%s", code)
+            return pd.DataFrame()
+        if not candles:
+            return pd.DataFrame()
+        df = pd.DataFrame(candles)
+        rename_map = {
+            "stck_clpr": "close",
+            "stck_hgpr": "high",
+            "stck_lwpr": "low",
+            "stck_trqu": "volume",
+            "stck_bsop_date": "date",
+        }
+        for src, dst in rename_map.items():
+            if src in df.columns:
+                df.rename(columns={src: dst}, inplace=True)
+        df["close"] = df["close"].astype(float)
+        df["high"] = df["high"].astype(float)
+        df["low"] = df["low"].astype(float)
+        df["volume"] = df["volume"].astype(float)
+        return df
+
+    def _build_universe(self) -> Dict[str, List[Dict]]:
+        try:
+            rebalance_payload = run_rebalance(str(now_kst().date()), return_by_market=True)
+            return rebalance_payload.get("selected_by_market") or {}
+        except Exception:
+            logger.exception("[PB1][UNIVERSE][FAIL]")
+            return {}
+
+    def _code_market_map(self, selected_by_market: Dict[str, List[Dict]]) -> Dict[str, str]:
+        mapping: Dict[str, str] = {}
+        for market, rows in (selected_by_market or {}).items():
+            for row in rows or []:
+                code = str(row.get("code") or row.get("pdno") or "").zfill(6)
+                mapping[code] = market
+        return mapping
+
+    def _compute_candidates(self, selected_by_market: Dict[str, List[Dict]]) -> List[CandidateFeature]:
+        candidates: List[CandidateFeature] = []
+        for market, rows in (selected_by_market or {}).items():
+            for row in rows or []:
+                code = str(row.get("code") or row.get("pdno") or "").zfill(6)
+                df = self._fetch_daily(code, count=120)
+                if df.empty:
+                    cf = CandidateFeature(
+                        code=code,
+                        market=market,
+                        features={"reasons": ["data_empty"]},
+                        setup_ok=False,
+                        reasons=["data_empty"],
+                        mode=1,
+                        mode_reasons=["default_day_mode"],
+                    )
+                    self._log_setup(cf)
+                    candidates.append(cf)
+                    continue
+                features = compute_features(df)
+                features["market"] = market
+                ok, reasons = evaluate_setup(features, market)
+                if not reasons:
+                    reasons = ["missing_reason"]
+                mode, mode_reasons = choose_mode(features)
+                cf = CandidateFeature(
+                    code=code,
+                    market=market,
+                    features=features,
+                    setup_ok=ok,
+                    reasons=reasons,
+                    mode=mode,
+                    mode_reasons=mode_reasons,
+                )
+                self._log_setup(cf)
+                candidates.append(cf)
+        return candidates
+
+    def _size_positions(self, candidates: List[CandidateFeature]) -> List[CandidateFeature]:
+        ok_list = [c for c in candidates if c.setup_ok]
+        total = len(ok_list)
+        if total <= 0:
+            return candidates
+        capital_per = DAILY_CAPITAL * CAP_CAP / total
+        for cf in ok_list:
+            close_px = cf.features.get("close") or 0
+            qty = int(capital_per // close_px) if close_px > 0 else 0
+            cf.planned_qty = max(qty, 0)
+            cf.client_order_key = self._client_order_key(
+                cf.code, cf.mode, "BUY", "PB1", "close"
+            )
+            if cf.planned_qty <= 0:
+                cf.setup_ok = False
+                cf.reasons.append("planned_qty_zero")
+                self._log_setup(cf)
+        return candidates
+
+    def _should_block_order(self, client_order_key: str) -> bool:
+        if not client_order_key:
+            return True
+        return self.ledger.has_client_order_key(client_order_key)
+
+    def _append_intent(self, cf: CandidateFeature) -> None:
+        event = new_order_intent(
+            code=cf.code,
+            market=cf.market,
+            sid=1,
+            mode=cf.mode,
+            env="paper" if self.dry_run else self.kis.env if self.kis else "paper",
+            run_id=self.run_id,
+            side="BUY",
+            qty=cf.planned_qty,
+            price=cf.features.get("close"),
+            client_order_key=cf.client_order_key,
+            ok=not self.dry_run,
+            reasons=["dry_run"] if self.dry_run else ["pb1_close_entry"],
+            stage="PB1-CLOSE",
+        )
+        path = self.ledger.append_event("orders_intent", event)
+        logger.info("[PB1][ENTRY-INTENT] code=%s mode=%s qty=%s key=%s path=%s", cf.code, cf.mode, cf.planned_qty, cf.client_order_key, path)
+
+    def _place_entry(self, cf: CandidateFeature) -> List[Path]:
+        paths: List[Path] = []
+        self._append_intent(cf)
+        paths.append(self.ledger._run_file("orders_intent"))
+        if self.dry_run:
+            return paths
+        if not self.kis:
+            err = new_unfilled(
+                code=cf.code,
+                market=cf.market,
+                sid=1,
+                mode=cf.mode,
+                env=self.env,
+                run_id=self.run_id,
+                side="BUY",
+                qty=cf.planned_qty,
+                price=cf.features.get("close"),
+                client_order_key=cf.client_order_key,
+                reasons=["kis_missing"],
+                stage="PB1-CLOSE",
+            )
+            paths.append(self.ledger.append_event("errors", err))
+            return paths
+        resp = None
+        try:
+            resp = self.kis.buy_stock_market(cf.code, cf.planned_qty)
+        except Exception:
+            logger.exception("[PB1][ENTRY][FAIL] code=%s", cf.code)
+        odno = ""
+        if isinstance(resp, dict):
+            odno = (resp.get("output") or {}).get("ODNO") or ""
+        ack = new_order_ack(
+            code=cf.code,
+            market=cf.market,
+            sid=1,
+            mode=cf.mode,
+            env=self.env,
+            run_id=self.run_id,
+            side="BUY",
+            qty=cf.planned_qty,
+            price=cf.features.get("close"),
+            odno=odno,
+            client_order_key=cf.client_order_key,
+            ok=bool(resp and resp.get("rt_cd") == "0"),
+            reasons=[] if resp and resp.get("rt_cd") == "0" else [resp.get("msg1", "order_failed")] if isinstance(resp, dict) else ["order_failed"],
+            stage="PB1-CLOSE",
+        )
+        paths.append(self.ledger.append_event("orders_ack", ack))
+        if resp and resp.get("rt_cd") == "0":
+            fill_price = cf.features.get("close")
+            fill = new_fill(
+                code=cf.code,
+                market=cf.market,
+                sid=1,
+                mode=cf.mode,
+                env=self.env,
+                run_id=self.run_id,
+                side="BUY",
+                qty=cf.planned_qty,
+                price=fill_price,
+                odno=odno,
+                client_order_key=cf.client_order_key,
+                stage="PB1-CLOSE",
+            )
+            paths.append(self.ledger.append_event("fills", fill))
+            persist_run_files(self.worktree_dir, [paths[-1]], message=f"pb1 fill {self.run_id}")
+        else:
+            unfilled = new_unfilled(
+                code=cf.code,
+                market=cf.market,
+                sid=1,
+                mode=cf.mode,
+                env=self.env,
+                run_id=self.run_id,
+                side="BUY",
+                qty=cf.planned_qty,
+                price=cf.features.get("close"),
+                client_order_key=cf.client_order_key,
+                reasons=ack.reasons if ack.reasons else ["order_failed"],
+                stage="PB1-CLOSE",
+            )
+            paths.append(self.ledger.append_event("errors", unfilled))
+        return paths
+
+    def _mark_price(self, code: str) -> float | None:
+        if self.kis:
+            try:
+                quote = self.kis.get_price_quote(code)
+                if isinstance(quote, dict):
+                    pr = quote.get("stck_prpr") or quote.get("prpr")
+                    return float(pr) if pr is not None else None
+            except Exception:
+                logger.exception("[PB1][PRICE][FAIL] code=%s", code)
+        return None
+
+    def _fetch_marks(self, codes: Iterable[str], fallback: Dict[str, float]) -> Dict[str, float]:
+        marks: Dict[str, float] = {}
+        for code in codes:
+            px = self._mark_price(code)
+            if px is None:
+                px = fallback.get(code)
+            if px is not None:
+                marks[code] = px
+        return marks
+
+    def _plan_exit_event(self, pos: Dict, features: Dict[str, float], window_tag: str) -> None:
+        avg = pos.get("avg_buy_price")
+        if not avg:
+            return
+        code = pos.get("code")
+        market = pos.get("market")
+        mode = pos.get("mode")
+        if pos.get("sid") != 1:
+            return
+        qty = pos.get("total_qty") or 0
+        if qty <= 0:
+            return
+        mark = self._mark_price(code) or features.get("close")
+        if not mark:
+            return
+        ret_pct = ((mark - avg) / avg) * 100
+        client_key = self._client_order_key(code, mode, "SELL", window_tag, "exit")
+        if self._should_block_order(client_key):
+            logger.info("[PB1][EXIT-SKIP] code=%s mode=%s reason=dup key=%s", code, mode, client_key)
+            return
+
+        if mode == 1:
+            atr_pct = ((features.get("atr14") or 0.0) / avg) * 100
+            r_pct = max(PB1_R_FLOOR_PCT, atr_pct)
+            take_profit = PB1_DAY_TP_R * r_pct
+            stop_loss = PB1_DAY_SL_R * r_pct
+            trigger_tp = ret_pct >= take_profit
+            trigger_sl = ret_pct <= -stop_loss
+            if window_tag != "morning":
+                return
+            stage = "DAY-EXIT"
+            reasons = ["take_profit"] if trigger_tp else []
+            if trigger_sl:
+                reasons.append("stop_loss")
+            if not reasons:
+                reasons.append("time_exit")
+        else:
+            hard_stop = KOSDAQ_HARD_STOP_PCT if market == "KOSDAQ" else KOSPI_HARD_STOP_PCT
+            if ret_pct <= -hard_stop:
+                stage = "HARD-STOP"
+                if window_tag not in {"morning", "close"}:
+                    return
+            else:
+                if window_tag != "close":
+                    return
+                close_px = features.get("close")
+                ma20 = features.get("ma20")
+                holding_days = pos.get("holding_days") or 0
+                if holding_days >= PB1_TIME_STOP_DAYS:
+                    stage = "TIME-STOP"
+                elif close_px is not None and ma20 is not None and close_px < ma20:
+                    stage = "MA20-TRAIL"
+                else:
+                    return
+            reasons = ["pb1_exit"]
+        event = new_exit_intent(
+            code=code,
+            market=market,
+            sid=1,
+            mode=mode,
+            env=self.env,
+            run_id=self.run_id,
+            side="SELL",
+            qty=qty,
+            price=mark,
+            client_order_key=client_key,
+            ok=not self.dry_run,
+            reasons=["dry_run"] if self.dry_run else reasons,
+            stage=stage,
+        )
+        path = self.ledger.append_event("exits_intent", event)
+        logger.info("[PB1][EXIT-INTENT] code=%s mode=%s stage=%s ret_pct=%.2f key=%s path=%s", code, mode, stage, ret_pct, client_key, path)
+        # execute sell when allowed
+        if self.dry_run:
+            return
+        if not self.kis:
+            logger.warning("[PB1][EXIT][SKIP] kis missing code=%s", code)
+            return
+        resp = None
+        try:
+            resp = self.kis.sell_stock_market(code, qty)
+        except Exception:
+            logger.exception("[PB1][EXIT][FAIL] code=%s", code)
+        odno = ""
+        if isinstance(resp, dict):
+            odno = (resp.get("output") or {}).get("ODNO") or ""
+        ack = new_order_ack(
+            code=code,
+            market=market,
+            sid=1,
+            mode=mode,
+            env=self.env,
+            run_id=self.run_id,
+            side="SELL",
+            qty=qty,
+            price=mark,
+            odno=odno,
+            client_order_key=client_key,
+            ok=bool(resp and resp.get("rt_cd") == "0"),
+            reasons=[] if resp and resp.get("rt_cd") == "0" else [resp.get("msg1", "order_failed")] if isinstance(resp, dict) else ["order_failed"],
+            stage=stage,
+        )
+        self.ledger.append_event("orders_ack", ack)
+        if resp and resp.get("rt_cd") == "0":
+            fill = new_fill(
+                code=code,
+                market=market,
+                sid=1,
+                mode=mode,
+                env=self.env,
+                run_id=self.run_id,
+                side="SELL",
+                qty=qty,
+                price=mark,
+                odno=odno,
+                client_order_key=client_key,
+                stage=stage,
+            )
+            fill_path = self.ledger.append_event("fills", fill)
+            persist_run_files(self.worktree_dir, [fill_path], message=f"pb1 fill {self.run_id}")
+        else:
+            err = new_unfilled(
+                code=code,
+                market=market,
+                sid=1,
+                mode=mode,
+                env=self.env,
+                run_id=self.run_id,
+                side="SELL",
+                qty=qty,
+                price=mark,
+                client_order_key=client_key,
+                reasons=[ack.reasons] if ack.reasons else ["order_failed"],
+                stage=stage,
+            )
+            self.ledger.append_event("errors", err)
+
+    def _positions_with_meta(self, positions: Dict[Tuple[str, int, int], Dict]) -> List[Dict]:
+        enriched: List[Dict] = []
+        for (code, sid, mode), state in positions.items():
+            if sid != 1:
+                continue
+            enriched.append(
+                {
+                    "code": code,
+                    "sid": sid,
+                    "mode": mode,
+                    "total_qty": state.get("total_qty") or 0,
+                    "avg_buy_price": state.get("avg_buy_price"),
+                    "market": state.get("market"),
+                    "holding_days": state.get("holding_days") or 0,
+                    "first_buy_ts": state.get("first_buy_ts"),
+                }
+            )
+        return enriched
+
+    def run(self) -> List[Path]:
+        entry_allowed = True
+        if ENABLE_BREAKOUT:
+            logger.warning("[PB1][BREAKOUT_DISABLED] ENABLE_BREAKOUT=%s -> skip new entries", ENABLE_BREAKOUT)
+            entry_allowed = False
+        logger.info("[PB1][RUN] window=%s phase=%s dry_run=%s", self.window.name, self.phase, self.dry_run)
+        run_files = self.ledger.open_run_files()
+        touched: List[Path] = list(run_files.values())
+        logger.info("[LEDGER][APPEND] kind=touch path=%s", run_files)
+        persist_run_files(self.worktree_dir, touched, message=f"pb1 touch run_id={self.run_id}")
+        positions = self.ledger.rebuild_positions_average_cost(lookback_days=LEDGER_LOOKBACK_DAYS)
+        selected = self._build_universe()
+        code_market = self._code_market_map(selected)
+        marks_fallback: Dict[str, float] = {}
+        if self.phase in {"prep", "entry"}:
+            candidates = self._compute_candidates(selected)
+            candidates = self._size_positions(candidates)
+            if self.phase == "entry" and self.window.name == "afternoon":
+                for cf in candidates:
+                    if not cf.setup_ok:
+                        continue
+                    if self._should_block_order(cf.client_order_key):
+                        continue
+                    if not entry_allowed:
+                        continue
+                    paths = self._place_entry(cf)
+                    touched.extend(paths)
+        elif self.phase in {"exit", "verify"}:
+            pos_list = self._positions_with_meta(positions)
+            for pos in pos_list:
+                df = self._fetch_daily(pos["code"], count=120)
+                if df.empty:
+                    err = new_error(
+                        code=pos["code"],
+                        market=pos.get("market") or "",
+                        sid=1,
+                        mode=pos["mode"],
+                        env=self.env,
+                        run_id=self.run_id,
+                        reasons=["daily_data_missing"],
+                    )
+                    self.ledger.append_event("errors", err)
+                    continue
+                features = compute_features(df)
+                features["market"] = pos.get("market") or code_market.get(pos["code"], "")
+                marks_fallback[pos["code"]] = features.get("close")
+                if self.phase == "exit":
+                    self._plan_exit_event(pos, features, "morning" if self.window.name == "morning" else "close")
+        if self.phase == "entry" and self.window.name == "afternoon":
+            pos_list = self._positions_with_meta(positions)
+            for pos in pos_list:
+                df = self._fetch_daily(pos["code"], count=120)
+                if df.empty:
+                    continue
+                features = compute_features(df)
+                features["market"] = pos.get("market") or code_market.get(pos["code"], "")
+                marks_fallback[pos["code"]] = features.get("close")
+                self._plan_exit_event(pos, features, "close")
+        marks = self._fetch_marks([p["code"] for p in self._positions_with_meta(positions)], marks_fallback)
+        snapshot = self.ledger.generate_pnl_snapshot(positions, marks=marks)
+        logger.info(
+            "[PNL][SNAPSHOT] portfolio_return_pct=%.2f%% unrealized=%.2f realized=%.2f",
+            snapshot["totals"]["portfolio_return_pct"],
+            snapshot["totals"]["unrealized"],
+            snapshot["totals"]["realized"],
+        )
+        snap_path = self.ledger.write_snapshot(snapshot, self.run_id)
+        touched.append(snap_path)
+        return touched
diff --git a/trader/pb1_runner.py b/trader/pb1_runner.py
new file mode 100644
index 0000000000000000000000000000000000000000..cb2b24585cf01e089b3eb298e078920078529be7
--- /dev/null
+++ b/trader/pb1_runner.py
@@ -0,0 +1,185 @@
+from __future__ import annotations
+
+import argparse
+import logging
+import os
+from pathlib import Path
+
+from trader.kis_wrapper import KisAPI
+from trader import state_store as runtime_state_store
+from trader.time_utils import is_trading_day, now_kst
+from trader.config import (
+    BOTSTATE_LOCK_TTL_SEC,
+    DIAG_ENABLED,
+    DIAGNOSTIC_FORCE_RUN,
+    DIAGNOSTIC_MODE,
+    DIAGNOSTIC_ONLY,
+    MORNING_WINDOW_START,
+    MORNING_WINDOW_END,
+    MORNING_EXIT_START,
+    MORNING_EXIT_END,
+    AFTERNOON_WINDOW_START,
+    AFTERNOON_WINDOW_END,
+    CLOSE_AUCTION_START,
+    CLOSE_AUCTION_END,
+)
+from trader.utils.env import env_bool, parse_env_flag, resolve_mode
+from trader.botstate_sync import acquire_lock, release_lock, setup_worktree, persist_run_files
+from trader.pb1_engine import PB1Engine
+from trader.window_router import decide_window
+
+logger = logging.getLogger(__name__)
+
+
+def truthy(value: object) -> bool:
+    return str(value).strip().lower() in {"1", "true", "yes", "y", "on"}
+
+
+def parse_args() -> argparse.Namespace:
+    parser = argparse.ArgumentParser(description="PB1 close pullback runner")
+    parser.add_argument("--window", default="auto", choices=["auto", "morning", "afternoon"], help="Execution window override")
+    parser.add_argument("--phase", default="auto", choices=["auto", "entry", "exit", "verify"], help="Phase override")
+    parser.add_argument("--target-branch", default=os.getenv("BOTSTATE_BRANCH", "bot-state"), help="Bot-state target branch")
+    return parser.parse_args()
+
+
+def main() -> None:
+    args = parse_args()
+    now = now_kst()
+    event_name = os.getenv("GITHUB_EVENT_NAME", "") or ""
+    event_name_lower = event_name.lower()
+    trading_day = is_trading_day(now)
+    dry_run_flag = parse_env_flag("DRY_RUN", default=False)
+    disable_live_flag = parse_env_flag("DISABLE_LIVE_TRADING", default=False)
+    live_trading_flag = parse_env_flag("LIVE_TRADING_ENABLED", default=False)
+    expect_live_flag = env_bool("EXPECT_LIVE_TRADING", False)
+    allow_live_on_push = truthy(os.getenv("ALLOW_LIVE_ON_PUSH", "0"))
+    mode = resolve_mode(os.getenv("STRATEGY_MODE", ""))
+    diag_enabled = bool(DIAG_ENABLED or DIAGNOSTIC_FORCE_RUN)
+
+    dry_run_reasons: list[str] = []
+    if mode == "INTENT_ONLY":
+        dry_run_reasons.append("STRATEGY_MODE=INTENT_ONLY")
+    if disable_live_flag.value:
+        dry_run_reasons.append("DISABLE_LIVE_TRADING=1")
+    if diag_enabled:
+        dry_run_reasons.append("diagnostic_mode")
+    if not live_trading_flag.value and mode == "LIVE":
+        dry_run_reasons.append("LIVE_TRADING_ENABLED=0")
+    if dry_run_flag.value:
+        dry_run_reasons.append("DRY_RUN=1")
+    if mode == "LIVE":
+        if event_name_lower == "pull_request":
+            dry_run_reasons.append("event=pull_request")
+        elif event_name_lower == "push" and not allow_live_on_push:
+            dry_run_reasons.append("event=push")
+    for flag in (dry_run_flag, disable_live_flag, live_trading_flag):
+        if not flag.valid:
+            dry_run_reasons.append(f"{flag.name}=invalid({flag.raw})")
+
+    dry_run = bool(dry_run_reasons)
+    dry_run_reason = ",".join(dry_run_reasons) if dry_run_reasons else "live"
+
+    logger.info(
+        "[PB1][DRY_RUN_RESOLVE] event=%s dry_run=%s reasons=%s",
+        event_name_lower or "unknown",
+        dry_run,
+        dry_run_reasons or ["live"],
+    )
+
+    expect_kis_env = os.getenv("EXPECT_KIS_ENV")
+    kis_env_raw = (os.getenv("KIS_ENV") or "").strip()
+    kis_env = kis_env_raw.lower()
+    api_base_url = (os.getenv("API_BASE_URL") or "").lower()
+    if expect_live_flag:
+        guard_failures: list[str] = []
+        if dry_run:
+            guard_failures.append("dry_run")
+        if not live_trading_flag.value or not live_trading_flag.valid:
+            guard_failures.append("LIVE_TRADING_ENABLED!=1")
+        if disable_live_flag.value or not disable_live_flag.valid:
+            guard_failures.append("DISABLE_LIVE_TRADING!=0")
+        if mode != "LIVE":
+            guard_failures.append("STRATEGY_MODE!=LIVE")
+        if kis_env != "practice":
+            guard_failures.append("KIS_ENV!=practice")
+        if "openapivts" not in api_base_url:
+            guard_failures.append("API_BASE_URL missing openapivts")
+        if expect_kis_env and kis_env_raw != expect_kis_env:
+            guard_failures.append("EXPECT_KIS_ENV mismatch")
+        if guard_failures:
+            raise SystemExit(f"EXPECT_LIVE_TRADING=1 guards failed: {guard_failures}")
+
+    os.environ["DRY_RUN"] = "1" if dry_run else "0"
+    os.environ["DISABLE_LIVE_TRADING"] = "1" if (dry_run or disable_live_flag.value) else "0"
+    os.environ["LIVE_TRADING_ENABLED"] = "1" if live_trading_flag.value else "0"
+    os.environ["STRATEGY_MODE"] = mode
+
+    if (not trading_day) and (not (DIAG_ENABLED and DIAGNOSTIC_FORCE_RUN)):
+        logger.warning("[PB1] 비거래일(%s) → 즉시 종료 dry_run=%s reason=%s", now.date(), dry_run, dry_run_reason)
+        return
+    if (not trading_day) and diag_enabled:
+        logger.warning("[PB1][DIAG] non-trading-day(%s) but running diagnostics", now.date())
+
+    os.environ.setdefault("MORNING_WINDOW_START", MORNING_WINDOW_START)
+    os.environ.setdefault("MORNING_WINDOW_END", MORNING_WINDOW_END)
+    os.environ.setdefault("MORNING_EXIT_START", MORNING_EXIT_START)
+    os.environ.setdefault("MORNING_EXIT_END", MORNING_EXIT_END)
+    os.environ.setdefault("AFTERNOON_WINDOW_START", AFTERNOON_WINDOW_START)
+    os.environ.setdefault("AFTERNOON_WINDOW_END", AFTERNOON_WINDOW_END)
+    os.environ.setdefault("CLOSE_AUCTION_START", CLOSE_AUCTION_START)
+    os.environ.setdefault("CLOSE_AUCTION_END", CLOSE_AUCTION_END)
+
+    runtime_state = {}
+    kis: KisAPI | None = None
+    try:
+        runtime_state = runtime_state_store.load_state()
+        kis = KisAPI()
+        balance = kis.get_balance()
+        runtime_state = runtime_state_store.reconcile_with_kis_balance(runtime_state, balance, active_strategies={1})
+        runtime_state_store.save_state(runtime_state)
+    except Exception:
+        logger.exception("[PB1] runtime state reconcile failed")
+        runtime_state = runtime_state or runtime_state_store.load_state()
+
+    if DIAGNOSTIC_ONLY:
+        logger.info("[PB1][DIAG] diagnostic_only mode -> exit")
+        return
+
+    window = decide_window(now=now, override=args.window)
+    if window is None:
+        logger.info("[PB1][WINDOW] outside active windows override=%s now=%s", args.window, now)
+        return
+
+    worktree_dir = Path("_botstate")
+    setup_worktree(Path.cwd(), worktree_dir, target_branch=args.target_branch)
+    owner = os.getenv("GITHUB_ACTOR", "local")
+    run_id = os.getenv("GITHUB_RUN_ID", "local")
+    if not acquire_lock(worktree_dir, owner=owner, run_id=run_id, ttl_sec=BOTSTATE_LOCK_TTL_SEC):
+        logger.warning("[BOTSTATE][LOCKED] owner=%s run_id=%s", owner, run_id)
+        return
+
+    touched: list[Path] = []
+    try:
+        engine = PB1Engine(
+            kis=kis,
+            worktree_dir=worktree_dir,
+            window=window,
+            phase_override=args.phase,
+            dry_run=dry_run,
+            env="paper" if dry_run else kis.env if kis else "paper",
+            run_id=run_id,
+        )
+        touched = engine.run()
+        logger.info("[PB1] run complete touched=%s", touched)
+        persist_run_files(
+            worktree_dir,
+            touched,
+            message=f"pb1 ledger run_id={run_id} window={window.name} phase={engine.phase}",
+        )
+    finally:
+        release_lock(worktree_dir, run_id=run_id)
+
+
+if __name__ == "__main__":
+    main()
diff --git a/trader/strategies/pb1_pullback_close.py b/trader/strategies/pb1_pullback_close.py
new file mode 100644
index 0000000000000000000000000000000000000000..03730c02b27d7d41427bfe8e93be523b34ccf48d
--- /dev/null
+++ b/trader/strategies/pb1_pullback_close.py
@@ -0,0 +1,248 @@
+from __future__ import annotations
+
+import math
+from dataclasses import dataclass
+from datetime import datetime, time
+from typing import Dict, List, Tuple
+
+import numpy as np
+import pandas as pd
+
+from trader.config import (
+    PB1_DAY_SL_R,
+    PB1_DAY_TP_R,
+    PB1_PULLBACK_BAND_KOSDAQ,
+    PB1_PULLBACK_BAND_KOSPI,
+    PB1_R_FLOOR_PCT,
+    PB1_SWING_TREND_MIN,
+    PB1_SWING_VOL_CONTRACTION_MAX,
+    PB1_SWING_VOLU_CONTRACTION_MAX,
+    PB1_VOL_CONTRACTION_MAX,
+    PB1_VOLU_CONTRACTION_MAX,
+    PB1_TIME_STOP_DAYS,
+    KOSDAQ_HARD_STOP_PCT,
+    KOSPI_HARD_STOP_PCT,
+)
+
+
+def _pct(a: float, b: float) -> float:
+    if b == 0:
+        return 0.0
+    return (a / b) * 100.0
+
+
+def compute_features(daily_df: pd.DataFrame) -> Dict[str, float]:
+    df = daily_df.copy()
+    df = df.sort_values("date")
+    if len(df) < 60:
+        return {"setup_ok": False, "reasons": ["insufficient_candles"], "count": len(df)}
+    df["ma20"] = df["close"].rolling(20).mean()
+    df["ma50"] = df["close"].rolling(50).mean()
+    df["ma10"] = df["close"].rolling(10).mean()
+    df["tr"] = np.maximum(df["high"], df["close"].shift(1)) - np.minimum(df["low"], df["close"].shift(1))
+    df["atr14"] = df["tr"].rolling(14).mean()
+    df["tr_range_pct"] = (df["high"] - df["low"]) / df["close"] * 100
+    df["vol_contraction"] = df["tr_range_pct"].rolling(5).mean() / df["tr_range_pct"].rolling(20).mean()
+    df["volu_contraction"] = df["volume"].rolling(5).mean() / df["volume"].rolling(20).mean()
+
+    ma20_tail = df["ma20"].tail(5)
+    slope = None
+    if len(ma20_tail.dropna()) >= 5:
+        x = np.arange(len(ma20_tail))
+        try:
+            slope = float(np.polyfit(x, ma20_tail.values, 1)[0])
+        except Exception:
+            slope = None
+
+    last = df.iloc[-1]
+    high20 = df["high"].tail(20).max()
+    features = {
+        "close": float(last["close"]),
+        "ma20": float(last["ma20"]),
+        "ma50": float(last["ma50"]),
+        "ma10": float(last["ma10"]),
+        "atr14": float(last["atr14"]),
+        "vol_contraction": float(last["vol_contraction"]),
+        "volu_contraction": float(last["volu_contraction"]),
+        "ma20_slope": slope,
+        "high20": float(high20),
+        "pullback_pct": _pct(high20 - last["close"], high20),
+        "tr_range_pct": float(last["tr_range_pct"]),
+        "trend_strength": float(last["close"] / last["ma50"] if last["ma50"] else math.inf),
+    }
+    return features
+
+
+def evaluate_setup(features: Dict[str, float], market: str) -> Tuple[bool, List[str]]:
+    reasons: List[str] = []
+    close = features.get("close")
+    ma20 = features.get("ma20")
+    ma50 = features.get("ma50")
+    pullback = features.get("pullback_pct")
+    vol_c = features.get("vol_contraction")
+    volu_c = features.get("volu_contraction")
+    slope = features.get("ma20_slope")
+
+    if close is None or ma20 is None or ma50 is None:
+        reasons.append("missing_ma")
+    else:
+        if not (close > ma20 and close > ma50):
+            reasons.append("close_below_ma")
+    if slope is None or slope <= 0:
+        reasons.append("ma20_slope_nonpos")
+
+    if pullback is None:
+        reasons.append("pullback_missing")
+    else:
+        low, high = (PB1_PULLBACK_BAND_KOSPI if market == "KOSPI" else PB1_PULLBACK_BAND_KOSDAQ)
+        if not (low <= pullback <= high):
+            reasons.append("pullback_out_of_band")
+
+    if vol_c is None or vol_c > PB1_VOL_CONTRACTION_MAX:
+        reasons.append("vol_contraction_fail")
+    if volu_c is None or volu_c > PB1_VOLU_CONTRACTION_MAX:
+        reasons.append("volu_contraction_fail")
+
+    return (len(reasons) == 0, reasons)
+
+
+def choose_mode(features: Dict[str, float]) -> Tuple[int, List[str]]:
+    reasons: List[str] = []
+    trend = features.get("trend_strength") or 0
+    vol_c = features.get("vol_contraction") or 0
+    volu_c = features.get("volu_contraction") or 0
+    if trend >= PB1_SWING_TREND_MIN and vol_c <= PB1_SWING_VOL_CONTRACTION_MAX and volu_c <= PB1_SWING_VOLU_CONTRACTION_MAX:
+        reasons.append("swing_conditions_met")
+        return 2, reasons
+    reasons.append("default_day_mode")
+    return 1, reasons
+
+
+@dataclass
+class OrderIntent:
+    code: str
+    market: str
+    sid: int
+    mode: int
+    qty: int
+    price: float
+    window: str
+    client_order_key: str
+    stage: str
+
+
+def plan_entry(code: str, features: Dict[str, float], mode: int, now: datetime, close_window: Tuple[time, time]) -> OrderIntent | None:
+    start, end = close_window
+    if not (start <= now.time() < end):
+        return None
+    price = features.get("close")
+    if price is None:
+        return None
+    client_key = f"{now.date()}|{code}|sid=1|mode={mode}|BUY|close"
+    return OrderIntent(
+        code=code,
+        market=features.get("market", ""),
+        sid=1,
+        mode=mode,
+        qty=features.get("planned_qty", 0) or 0,
+        price=float(price),
+        window="close",
+        client_order_key=client_key,
+        stage="PB1-CLOSE",
+    )
+
+
+@dataclass
+class ExitIntent:
+    code: str
+    market: str
+    sid: int
+    mode: int
+    reason: str
+    qty: int
+    price: float | None
+    stage: str
+
+
+def plan_exit(position: Dict, features: Dict[str, float], now: datetime, windows: Dict[str, Tuple[time, time]]) -> ExitIntent | None:
+    mode = position.get("mode")
+    qty = position.get("total_qty") or 0
+    if qty <= 0:
+        return None
+    avg = position.get("avg_buy_price")
+    if avg is None:
+        return None
+    code = position.get("code")
+    market = position.get("market")
+    if mode == 1:
+        window = windows.get("morning_exit")
+        if not window:
+            return None
+        start, end = window
+        if not (start <= now.time() <= end):
+            return None
+        atr_pct = _pct(features.get("atr14", 0.0), avg)
+        r_pct = max(atr_pct, PB1_R_FLOOR_PCT)
+        take_profit_pct = PB1_DAY_TP_R * r_pct
+        stop_loss_pct = PB1_DAY_SL_R * r_pct
+        mark = features.get("mark_price", features.get("close"))
+        if mark is None:
+            return None
+        ret_pct = _pct(mark - avg, avg)
+        if ret_pct >= take_profit_pct or ret_pct <= -stop_loss_pct or now.time() >= end:
+            return ExitIntent(
+                code=code,
+                market=market,
+                sid=1,
+                mode=mode,
+                reason="mode1_exit",
+                qty=qty,
+                price=mark,
+                stage="DAY-EXIT",
+            )
+    elif mode == 2:
+        start, end = windows.get("close", (None, None))
+        mark = features.get("mark_price", features.get("close"))
+        if mark is None:
+            return None
+        ret_pct = _pct(mark - avg, avg)
+        hard_stop = KOSDAQ_HARD_STOP_PCT if market == "KOSDAQ" else KOSPI_HARD_STOP_PCT
+        if ret_pct <= -hard_stop:
+            return ExitIntent(
+                code=code,
+                market=market,
+                sid=1,
+                mode=mode,
+                reason="hard_stop",
+                qty=qty,
+                price=mark,
+                stage="HARD-STOP",
+            )
+        close_px = features.get("close")
+        ma20 = features.get("ma20")
+        holding_days = position.get("holding_days") or 0
+        if holding_days >= PB1_TIME_STOP_DAYS:
+            if start and end and (start <= now.time() < end or now.time() >= end):
+                return ExitIntent(
+                    code=code,
+                    market=market,
+                    sid=1,
+                    mode=mode,
+                    reason="time_stop",
+                    qty=qty,
+                    price=mark,
+                    stage="TIME-STOP",
+                )
+        if close_px is not None and ma20 is not None and close_px < ma20:
+            if start and end and (start <= now.time() < end or now.time() >= end):
+                return ExitIntent(
+                    code=code,
+                    market=market,
+                    sid=1,
+                    mode=mode,
+                    reason="ma20_trail",
+                    qty=qty,
+                    price=close_px,
+                    stage="MA20-TRAIL",
+                )
+    return None
diff --git a/trader/window_router.py b/trader/window_router.py
new file mode 100644
index 0000000000000000000000000000000000000000..712dd8e98cbeebc03af8c7ca7662aae808cf94b1
--- /dev/null
+++ b/trader/window_router.py
@@ -0,0 +1,59 @@
+from __future__ import annotations
+
+import os
+from dataclasses import dataclass
+from datetime import datetime, time, timedelta, timezone
+from typing import Optional
+
+KST = timezone(timedelta(hours=9))
+
+MORNING_WINDOW_START = time.fromisoformat(os.getenv("MORNING_WINDOW_START", "08:50"))
+MORNING_WINDOW_END = time.fromisoformat(os.getenv("MORNING_WINDOW_END", "11:00"))
+AFTERNOON_WINDOW_START = time.fromisoformat(os.getenv("AFTERNOON_WINDOW_START", "14:00"))
+AFTERNOON_WINDOW_END = time.fromisoformat(os.getenv("AFTERNOON_WINDOW_END", "15:30"))
+MORNING_EXIT_START = time.fromisoformat(os.getenv("MORNING_EXIT_START", "09:00"))
+MORNING_EXIT_END = time.fromisoformat(os.getenv("MORNING_EXIT_END", "09:20"))
+CLOSE_AUCTION_START = time.fromisoformat(os.getenv("CLOSE_AUCTION_START", "15:20"))
+CLOSE_AUCTION_END = time.fromisoformat(os.getenv("CLOSE_AUCTION_END", "15:30"))
+
+
+@dataclass
+class WindowDecision:
+    name: str
+    phase: str
+
+
+def get_kst_now() -> datetime:
+    return datetime.now(tz=KST)
+
+
+def in_window(now: datetime, start: time, end: time) -> bool:
+    return start <= now.time() < end
+
+
+def decide_window(now: datetime | None = None, override: str = "auto") -> Optional[WindowDecision]:
+    now = now or get_kst_now()
+    if override == "morning":
+        if in_window(now, MORNING_WINDOW_START, MORNING_WINDOW_END):
+            phase = "exit" if in_window(now, MORNING_EXIT_START, MORNING_EXIT_END) else "verify"
+            return WindowDecision(name="morning", phase=phase)
+        return None
+    if override == "afternoon":
+        if in_window(now, AFTERNOON_WINDOW_START, AFTERNOON_WINDOW_END):
+            phase = "entry" if in_window(now, CLOSE_AUCTION_START, CLOSE_AUCTION_END) else "prep"
+            return WindowDecision(name="afternoon", phase=phase)
+        return None
+
+    if in_window(now, MORNING_WINDOW_START, MORNING_WINDOW_END):
+        phase = "exit" if in_window(now, MORNING_EXIT_START, MORNING_EXIT_END) else "verify"
+        return WindowDecision(name="morning", phase=phase)
+    if in_window(now, AFTERNOON_WINDOW_START, AFTERNOON_WINDOW_END):
+        phase = "entry" if in_window(now, CLOSE_AUCTION_START, CLOSE_AUCTION_END) else "prep"
+        return WindowDecision(name="afternoon", phase=phase)
+    return None
+
+
+def resolve_phase(window: WindowDecision, phase_override: str) -> str:
+    if phase_override != "auto":
+        return phase_override
+    return window.phase
