diff --git a/rolling_k_auto_trade_api/kis_api.py b/rolling_k_auto_trade_api/kis_api.py
index c03d36908d57a81a0d158f779e0f86ed477d42e2..41144ce94bb582210adaa0775b18c902d45dc255 100644
--- a/rolling_k_auto_trade_api/kis_api.py
+++ b/rolling_k_auto_trade_api/kis_api.py
@@ -262,60 +262,75 @@ def _order_cash(body: Dict[str, Any], *, is_sell: bool) -> Dict[str, Any]:
 
             # 정상 처리
             if r.status_code == 200 and isinstance(j, dict) and j.get("rt_cd") == "0":
                 logger.info(f"[ORDER_OK] ord_dvsn={ord_dvsn} output={j.get('output')}")
                 return j
 
             # 게이트웨이/과다/5xx 재시도
             msg_cd = (j or {}).get("msg_cd", "") if isinstance(j, dict) else ""
             msg1 = (j or {}).get("msg1", "") if isinstance(j, dict) else ""
             if r.status_code >= 500 or msg_cd == "IGW00008" or (isinstance(msg1, str) and ("MCA" in msg1 or "초당" in msg1)):
                 back = min(0.6 * (1.7 ** (attempt - 1)), 5.0) + random.uniform(0, 0.3)
                 logger.warning(f"[ORDER_GATEWAY_RETRY] ord_dvsn={ord_dvsn} attempt={attempt} resp={j} → sleep {back:.2f}s")
                 time.sleep(back)
                 last_err = j
                 continue
 
             # 비즈니스 실패는 그대로 반환(상위에서 판단)
             logger.error(f"[ORDER_FAIL_BIZ] ord_dvsn={ord_dvsn} resp={j} raw_head={raw[:300]}")
             return j if isinstance(j, dict) else {"_status": r.status_code, "raw": raw[:500]}
 
         logger.warning(f"[ORDER_FALLBACK] ord_dvsn={ord_dvsn} 실패 → 다음 방식")
 
     raise RuntimeError(f"ORDER_FAIL: {last_err}")
 
 
-def send_order(code: str, qty: int, price: Optional[int] = None, side: str = "buy") -> Dict[str, Any]:
+def send_order(
+    code: str,
+    qty: int,
+    price: Optional[int] = None,
+    side: str = "buy",
+    order_type: Optional[str] = None,
+    **kwargs: Any,
+) -> Dict[str, Any]:
     """공용 주문 API
     side: 'buy' or 'sell'
     price: None이면 시장가 체인, 지정가면 지정가 고정(00)
+    order_type: 과거 호출부 호환용(예: "market"); 인식 가능한 값은 price를 무시하고 시장가로 처리
     반환: KIS 응답(dict). 비정상 응답 시에도 원문/상태 일부 포함
     """
     _guard_live_trading("order")
     code = str(code).strip()
     is_sell = (side.lower() == "sell")
 
+    # 호환성 처리: order_type="market" 등으로 호출돼도 TypeError 없이 시장가로 처리
+    ord_type_norm = str(order_type).lower() if order_type is not None else ""
+    if ord_type_norm in {"market", "mkt"}:
+        price = None
+    if kwargs:
+        logger.debug(f"[ORDER_KWARGS_IGNORED] extra_keys={list(kwargs.keys())}")
+
     if price is None:
         # 시장가 체인
         body = {
             "CANO": CANO,
             "ACNT_PRDT_CD": ACNT_PRDT_CD,
             "PDNO": code,
             "ORD_QTY": str(int(qty)),
         }
         return _order_cash(body, is_sell=is_sell)
     else:
         # 지정가(고정, 00)
         body = {
             "CANO": CANO,
             "ACNT_PRDT_CD": ACNT_PRDT_CD,
             "PDNO": code,
             "ORD_QTY": str(int(qty)),
             "ORD_DVSN": "00",
             "ORD_UNPR": str(int(price)),
             "EXCG_ID_DVSN_CD": "KRX",
         }
         if is_sell:
             body["SLL_TYPE"] = "01"
         hk = _create_hashkey(body)
         tr_id = ("VTTC0011U" if KIS_ENV == "practice" else "TTTC0011U") if is_sell else ("VTTC0012U" if KIS_ENV == "practice" else "TTTC0012U")
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/order-cash"
