diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
new file mode 100644
index 0000000000000000000000000000000000000000..2e8063c97ab1e4c3f215b09445e6d91834cf17ab
--- /dev/null
+++ b/.github/workflows/ci.yml
@@ -0,0 +1,27 @@
+name: CI (no live trading)
+
+on:
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ubuntu-latest
+    env:
+      DISABLE_LIVE_TRADING: "true"
+    steps:
+      - uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+
+      - uses: actions/setup-python@v5
+        with:
+          python-version: "3.11"
+
+      - name: Install dependencies
+        run: |
+          python -m pip install --upgrade pip
+          pip install -r requirements.txt
+
+      - name: Static compile check
+        run: |
+          python -m compileall portfolio strategy trader rolling_k_auto_trade_api
diff --git a/.github/workflows/trade-monitor.yml b/.github/workflows/trade-monitor.yml
index a6a1c9116e762d8ce137a8693320984f91054293..f10ea0fc094e38538168bbec335cf6762714d839 100644
--- a/.github/workflows/trade-monitor.yml
+++ b/.github/workflows/trade-monitor.yml
@@ -1,41 +1,37 @@
-name: Trade Monitor (trader_refactor branch)
+name: Trade Monitor (main branch only)
 
 on:
-  push:
-    branches: [ main, trader_refactor ]
-  pull_request:
-    branches: [ main, trader_refactor ]
   schedule:
     - cron: "57 23 * * 0-6"
   workflow_dispatch:
 
 
 jobs:
   monitor-trade:
     # ğŸ”’ ì•ˆì „ì¥ì¹˜: main ë¸Œëœì¹˜ì—ì„œë§Œ ëª¨ë‹ˆí„°ë§/ìë™ë§¤ë§¤ ì‹¤í–‰
-    # if: github.ref == 'refs/heads/main'
+    if: github.ref == 'refs/heads/main'
     runs-on: ubuntu-latest
 
     env:
       # === KIS ì¸ì¦í‚¤(ë‘ ì´ë¦„ ëª¨ë‘ ëŒ€ì‘: ë¨¼ì € KIS_*ê°€ ìˆìœ¼ë©´ ê·¸ê±¸, ì—†ìœ¼ë©´ APP_* ì‚¬ìš©) ===
       KIS_APP_KEY:    ${{ secrets.KIS_APP_KEY != '' && secrets.KIS_APP_KEY || secrets.APP_KEY }}
       KIS_APP_SECRET: ${{ secrets.KIS_APP_SECRET != '' && secrets.KIS_APP_SECRET || secrets.APP_SECRET }}
       # (ì¼ë¶€ ëª¨ë“ˆì´ APP_*ë¥¼ ì½ì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ ë™ì¼ ê°’ ë™ì‹œ ì£¼ì…)
       APP_KEY:        ${{ secrets.KIS_APP_KEY != '' && secrets.KIS_APP_KEY || secrets.APP_KEY }}
       APP_SECRET:     ${{ secrets.KIS_APP_SECRET != '' && secrets.KIS_APP_SECRET || secrets.APP_SECRET }}
 
       CANO:           ${{ secrets.CANO }}
       ACNT_PRDT_CD:   ${{ secrets.ACNT_PRDT_CD }}
       KIS_ENV:        ${{ secrets.KIS_ENV }}          # practice / real
 
       # settings.pyê°€ KIS_ENVë¡œ ìë™íŒë‹¨í•˜ë¯€ë¡œ API_BASE_URLì€ ë³´í†µ ë¶ˆí•„ìš”
       API_BASE_URL:   ${{ secrets.API_BASE_URL }}
 
       # === trader.py ìš´ì˜ íŒŒë¼ë¯¸í„° ===
       PARTIAL1: "0.5"
       PARTIAL2: "0.3"
       TRAIL_PCT: "0.02"
       FAST_STOP: "0.01"
       ATR_STOP: "1.5"
 
       TIME_STOP_HHMM: "13:00"
diff --git a/README.md b/README.md
index a9f1d5859ef18aadd5011d558aa69b0df7720d7a..9b19f0d21950cfa874ecc0a37bdcd8144fb3b409 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,36 @@
 # Jeihyuck-rolling-k-auto-trade-KIS-refacored
 
+## Portfolio split architecture
+This refactor promotes KOSPI and KOSDAQ trading into parallel engines under a shared portfolio manager while preserving the existing KOSDAQ intraday behavior.
 
+```
+portfolio/
+  base_engine.py
+  kospi_core_engine.py
+  kosdaq_alpha_engine.py
+  portfolio_manager.py
+strategy/
+  kospi/{universe.py, rebalance.py, signals.py}
+  kosdaq/{universe.py, rolling_entry.py, pullback.py}
+trader/
+  trader.py (entrypoint)
+  state_manager.py
+  legacy_kosdaq_runner.py (previous KOSDAQ loop kept intact)
+```
 
+## Engine responsibilities
+- **KOSPI core engine**: KOSPI market-cap Top-N universe, equal-weight targets, periodic rebalance with market orders and KIS quotes.
+- **KOSDAQ alpha engine**: delegates to the legacy rolling-K/VWAP/pullback loop unchanged, using its original state file for backward compatibility.
+- **Capital split**: `PortfolioManager` divides `DAILY_CAPITAL` (or supplied total) into KOSPI and KOSDAQ ratios (default 60/40) and runs each engine independently.
+- **Performance**: portfolio-level PnL snapshots combine KIS cash/positions with engine allocation ratios for unified reporting without coupling the two engines.
+  - Engine-level PnL is an attribution estimate based on capital split ratios because positions are pooled at the account level.
+
+## How to run
+```
+python -m trader.trader
+```
+This initializes the portfolio manager, runs KOSPI rebalance if due, then executes the existing KOSDAQ intraday loop without interrupting either engine on errors. The KOSDAQ loop is blocking, so the entrypoint runs a single orchestrated cycle via `run_once()` rather than a repeating scheduler.
+
+## CI and live-trading safeguards
+- CI (pull_request) runs set `DISABLE_LIVE_TRADING=true` so all KIS API calls are blocked and only static checks execute.
+- The live trading workflow is restricted to the `main` branch and triggers only via schedule or manual dispatch with the branch guard enabled.
diff --git a/portfolio/__init__.py b/portfolio/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/portfolio/base_engine.py b/portfolio/base_engine.py
new file mode 100644
index 0000000000000000000000000000000000000000..56a5d5216f0f7fc489784539a87311d628ca1a3e
--- /dev/null
+++ b/portfolio/base_engine.py
@@ -0,0 +1,29 @@
+from __future__ import annotations
+
+import logging
+from abc import ABC, abstractmethod
+from typing import Any
+
+
+class BaseEngine(ABC):
+    """Shared interface for independent trading engines."""
+
+    def __init__(self, name: str, capital: float) -> None:
+        self.name = name
+        self.capital = float(capital)
+        self.logger = logging.getLogger(self.__class__.__name__)
+
+    @property
+    def tag(self) -> str:
+        return f"[{self.name.upper()}]"
+
+    @abstractmethod
+    def rebalance_if_needed(self) -> Any:
+        ...
+
+    @abstractmethod
+    def trade_loop(self) -> Any:
+        ...
+
+    def _log(self, message: str) -> None:
+        self.logger.info(f"{self.tag} {message}")
diff --git a/portfolio/kosdaq_alpha_engine.py b/portfolio/kosdaq_alpha_engine.py
new file mode 100644
index 0000000000000000000000000000000000000000..8c05c1c107371a9a58e2c5a0d5f5ff40dfcda991
--- /dev/null
+++ b/portfolio/kosdaq_alpha_engine.py
@@ -0,0 +1,20 @@
+from __future__ import annotations
+
+from typing import Any, Dict
+
+from .base_engine import BaseEngine
+from strategy.kosdaq.rolling_entry import run_trade_loop
+
+
+class KosdaqAlphaEngine(BaseEngine):
+    def __init__(self, capital: float) -> None:
+        super().__init__("kosdaq_alpha", capital)
+
+    def rebalance_if_needed(self) -> Dict[str, Any]:
+        # kosdaq engine keeps its own intraday logic; rebalance handled inside legacy loop
+        return {"status": "delegated"}
+
+    def trade_loop(self) -> Any:
+        self._log("starting legacy KOSDAQ loop")
+        result = run_trade_loop(capital_override=self.capital)
+        return result
diff --git a/portfolio/kospi_core_engine.py b/portfolio/kospi_core_engine.py
new file mode 100644
index 0000000000000000000000000000000000000000..c09e1cd7d3ed2bd93144ef34d42422b62bc82cec
--- /dev/null
+++ b/portfolio/kospi_core_engine.py
@@ -0,0 +1,104 @@
+from __future__ import annotations
+
+import logging
+from datetime import datetime, time, timedelta, timezone
+from typing import Any, Dict
+
+from trader import state_manager
+from .base_engine import BaseEngine
+from strategy.kospi.rebalance import INDEX_CODE, build_target_allocations, evaluate_regime
+from strategy.kospi.signals import execute_rebalance
+
+logger = logging.getLogger(__name__)
+KST = timezone(timedelta(hours=9))
+INTRADAY_DROP_LIMIT = -2.0
+
+
+class KospiCoreEngine(BaseEngine):
+    def __init__(self, capital: float, top_n: int = 100, rebalance_days: int = 30) -> None:
+        super().__init__("kospi_core", capital)
+        self.top_n = top_n
+        self.rebalance_days = rebalance_days
+        self._last_rebalance: datetime | None = self._load_last_rebalance()
+
+    def _load_last_rebalance(self) -> datetime | None:
+        _, _, meta = state_manager.load_state(self.name, include_meta=True)
+        ts = meta.get("last_rebalance") if isinstance(meta, dict) else None
+        if not ts:
+            return None
+        try:
+            return datetime.fromisoformat(ts)
+        except Exception:
+            logger.warning("[KOSPI_CORE] invalid last_rebalance in state: %s", ts)
+            return None
+
+    def _should_rebalance(self) -> bool:
+        if self._last_rebalance is None:
+            return True
+        return datetime.now() - self._last_rebalance >= timedelta(days=self.rebalance_days)
+
+    def _current_index_change_pct(self) -> float | None:
+        try:
+            from rolling_k_auto_trade_api.kis_api import get_price_quote
+
+            quote = get_price_quote(INDEX_CODE)
+            current = float(quote.get("stck_prpr") or quote.get("prpr") or 0)
+            prev_close = float(quote.get("prdy_clpr") or 0)
+            if current and prev_close:
+                return (current / prev_close - 1) * 100
+        except Exception:
+            logger.exception("[KOSPI_CORE] failed to fetch live index quote")
+        return None
+
+    def _buys_permitted(self, regime: Dict[str, Any]) -> bool:
+        if not regime.get("regime_on"):
+            self._log("[KOSPI_CORE][BUYS] blocked (regime OFF)")
+            return False
+
+        now = datetime.now(tz=KST).time()
+        if now < time(9, 30):
+            self._log("[KOSPI_CORE][BUYS] blocked (pre-open window)")
+            return False
+
+        daily_change = float(regime.get("daily_change_pct") or 0)
+        if daily_change <= INTRADAY_DROP_LIMIT:
+            self._log(
+                f"[KOSPI_CORE][BUYS] blocked (prev change {daily_change:.2f}% <= {INTRADAY_DROP_LIMIT}%)"
+            )
+            return False
+
+        live_change = self._current_index_change_pct()
+        if live_change is not None and live_change <= INTRADAY_DROP_LIMIT:
+            self._log(
+                f"[KOSPI_CORE][BUYS] blocked (live change {live_change:.2f}% <= {INTRADAY_DROP_LIMIT}%)"
+            )
+            return False
+
+        return True
+
+    def rebalance_if_needed(self) -> Dict[str, Any]:
+        if not self._should_rebalance():
+            return {"status": "skip"}
+        regime = evaluate_regime()
+        allow_buys = self._buys_permitted(regime)
+        if not regime.get("regime_on"):
+            targets: list[dict[str, float]] = []
+            self._log("[KOSPI_CORE][REGIME] OFF â†’ liquidate positions")
+        else:
+            targets, meta = build_target_allocations(self.capital, self.top_n)
+            self._log(f"[KOSPI_CORE][SELECTION] selected={meta.get('selected')}")
+
+        fills = execute_rebalance(targets, self.capital, self.tag, allow_buys=allow_buys)
+        self._last_rebalance = datetime.now()
+        holding, traded, _ = state_manager.load_state(self.name, include_meta=True)
+        state_manager.save_state(
+            self.name,
+            holding,
+            traded,
+            meta={"last_rebalance": self._last_rebalance.isoformat()},
+        )
+        self._log(f"[KOSPI_CORE][PORTFOLIO] targets={len(targets)} fills={len(fills)}")
+        return {"targets": targets, "fills": fills, "regime": regime}
+
+    def trade_loop(self) -> Dict[str, Any]:
+        return self.rebalance_if_needed()
diff --git a/portfolio/performance.py b/portfolio/performance.py
new file mode 100644
index 0000000000000000000000000000000000000000..196bc616f14bc601b26d21c830d82f1c9da73937
--- /dev/null
+++ b/portfolio/performance.py
@@ -0,0 +1,138 @@
+from __future__ import annotations
+
+import logging
+from dataclasses import dataclass
+from typing import Any, Dict, List
+
+from rolling_k_auto_trade_api.kis_api import get_price_quote, inquire_balance, inquire_cash_balance
+
+logger = logging.getLogger(__name__)
+
+
+@dataclass
+class PositionSnapshot:
+    code: str
+    qty: int
+    avg_price: float
+    last_price: float
+    market_value: float
+    unrealized_pnl: float
+
+
+class PerformanceTracker:
+    """Aggregate realized/unrealized marks for portfolio-level observability.
+
+    Engine-level PnL is an attribution estimate using allocation ratios because
+    KIS positions are pooled at the account level.
+    """
+
+    def __init__(self) -> None:
+        self._peak_value: float | None = None
+        self._max_drawdown_pct: float = 0.0
+
+    def _mark_positions(self) -> List[PositionSnapshot]:
+        positions: List[PositionSnapshot] = []
+        for row in inquire_balance():
+            code = str(row.get("pdno") or row.get("code") or "").zfill(6)
+            qty = int(float(row.get("hldg_qty") or row.get("qty") or 0))
+            if qty <= 0:
+                continue
+            avg_price = float(row.get("pchs_avg_pric") or row.get("avg_price") or 0)
+            last_price = float(row.get("prpr") or row.get("stck_prpr") or 0)
+            if not last_price:
+                try:
+                    quote = get_price_quote(code)
+                    last_price = float(quote.get("stck_prpr") or quote.get("askp1") or 0)
+                except Exception:
+                    logger.exception("[PERF] quote fail for %s", code)
+                    last_price = 0.0
+            market_value = max(last_price, 0.0) * qty
+            unrealized_pnl = (last_price - avg_price) * qty if avg_price else 0.0
+            positions.append(
+                PositionSnapshot(
+                    code=code,
+                    qty=qty,
+                    avg_price=avg_price,
+                    last_price=last_price,
+                    market_value=market_value,
+                    unrealized_pnl=unrealized_pnl,
+                )
+            )
+        return positions
+
+    def snapshot(self, engine_capitals: Dict[str, float]) -> Dict[str, Any]:
+        """Return per-engine and portfolio PnL snapshots.
+
+        engine_capitals: engine name -> allocated capital (absolute, not ratio)
+        """
+
+        cash = float(inquire_cash_balance())
+        positions = self._mark_positions()
+        equity_value = sum(p.market_value for p in positions)
+        unrealized = sum(p.unrealized_pnl for p in positions)
+        total_allocated = sum(engine_capitals.values())
+        total_value = cash + equity_value
+        pnl = total_value - float(total_allocated)
+        pnl_pct = (pnl / float(total_allocated) * 100) if total_allocated else 0.0
+
+        if self._peak_value is None or total_value > self._peak_value:
+            self._peak_value = total_value
+        drawdown_pct = 0.0
+        if self._peak_value:
+            drawdown_pct = max((self._peak_value - total_value) / self._peak_value * 100, 0.0)
+            self._max_drawdown_pct = max(self._max_drawdown_pct, drawdown_pct)
+
+        engines: Dict[str, Dict[str, Any]] = {}
+        for name, cap in engine_capitals.items():
+            ratio = cap / total_allocated if total_allocated else 0.0
+            engine_cash = cash * ratio
+            engine_equity = equity_value * ratio
+            engine_value = engine_cash + engine_equity
+            engine_pnl = engine_value - cap
+            engine_pct = (engine_pnl / cap * 100) if cap else 0.0
+            engines[name] = {
+                "allocated_capital": cap,
+                "cash": engine_cash,
+                "equity_value": engine_equity,
+                "total_value": engine_value,
+                "pnl": engine_pnl,
+                "pnl_pct": engine_pct,
+            }
+            logger.info(
+                "[%s][PERF] alloc=%.0f value=%.0f pnl=%.0f (%.2f%%)",
+                name.upper(),
+                cap,
+                engine_value,
+                engine_pnl,
+                engine_pct,
+            )
+
+        logger.info(
+            "[PORTFOLIO][PERF] total=%.0f cash=%.0f equity=%.0f pnl=%.0f (%.2f%%)",
+            total_value,
+            cash,
+            equity_value,
+            pnl,
+            pnl_pct,
+        )
+
+        logger.info(
+            "[PORTFOLIO][DRAWDOWN] current=%.2f%% max=%.2f%%",
+            drawdown_pct,
+            self._max_drawdown_pct,
+        )
+
+        return {
+            "portfolio": {
+                "cash": cash,
+                "equity_value": equity_value,
+                "total_value": total_value,
+                "unrealized": unrealized,
+                "pnl": pnl,
+                "pnl_pct": pnl_pct,
+                "drawdown_pct": drawdown_pct,
+                "max_drawdown_pct": self._max_drawdown_pct,
+            },
+            "engines": engines,
+            "positions": [p.__dict__ for p in positions],
+        }
diff --git a/portfolio/portfolio_manager.py b/portfolio/portfolio_manager.py
new file mode 100644
index 0000000000000000000000000000000000000000..8eaa4062a7cf08c3db3b62ec3c9a3dfce445da07
--- /dev/null
+++ b/portfolio/portfolio_manager.py
@@ -0,0 +1,54 @@
+from __future__ import annotations
+
+import logging
+from typing import Any, Dict
+
+from trader.config import DAILY_CAPITAL
+from .kospi_core_engine import KospiCoreEngine
+from .kosdaq_alpha_engine import KosdaqAlphaEngine
+from .performance import PerformanceTracker
+
+logger = logging.getLogger(__name__)
+
+
+class PortfolioManager:
+    def __init__(
+        self,
+        total_capital: float | None = None,
+        kospi_ratio: float = 0.6,
+        kosdaq_ratio: float = 0.4,
+    ) -> None:
+        self.total_capital = float(total_capital or DAILY_CAPITAL)
+        if kospi_ratio + kosdaq_ratio == 0:
+            kospi_ratio, kosdaq_ratio = 0.6, 0.4
+        norm = kospi_ratio + kosdaq_ratio
+        self.kospi_ratio = kospi_ratio / norm
+        self.kosdaq_ratio = kosdaq_ratio / norm
+        self.kospi_engine = KospiCoreEngine(capital=self.total_capital * self.kospi_ratio)
+        self.kosdaq_engine = KosdaqAlphaEngine(capital=self.total_capital * self.kosdaq_ratio)
+        self.performance = PerformanceTracker()
+        logger.info(
+            "[PORTFOLIO] capital=%s kospi=%.0f%% kosdaq=%.0f%%",
+            int(self.total_capital),
+            self.kospi_ratio * 100,
+            self.kosdaq_ratio * 100,
+        )
+
+    def run_once(self) -> Dict[str, Any]:
+        try:
+            kospi = self.kospi_engine.rebalance_if_needed()
+        except Exception as e:
+            logger.exception("[PORTFOLIO] KOSPI engine failure: %s", e)
+            kospi = {"status": "error", "message": str(e)}
+        try:
+            kosdaq = self.kosdaq_engine.trade_loop()
+        except Exception as e:
+            logger.exception("[PORTFOLIO] KOSDAQ engine failure: %s", e)
+            kosdaq = {"status": "error", "message": str(e)}
+        perf = self.performance.snapshot(
+            {
+                "kospi_core": self.kospi_engine.capital,
+                "kosdaq_alpha": self.kosdaq_engine.capital,
+            }
+        )
+        return {"kospi": kospi, "kosdaq": kosdaq, "performance": perf}
diff --git a/rolling_k_auto_trade_api/auto_trade_signal.py b/rolling_k_auto_trade_api/auto_trade_signal.py
index c85ccbe6933ab08d3cb082d034fe8bfb9a08e27d..7f781cc6c5aa4a12e1f416255d2a806517fb5e05 100644
--- a/rolling_k_auto_trade_api/auto_trade_signal.py
+++ b/rolling_k_auto_trade_api/auto_trade_signal.py
@@ -1,84 +1,126 @@
 # auto_trade_signal.py
-import os
 import time
 import logging
-import requests
-import pandas as pd
 from datetime import datetime, timedelta
 from typing import List, Dict
 
-from rolling_k_auto_trade_api.kis_api import send_order
-from rolling_k_auto_trade_api.best_k_meta_strategy import get_best_k_for_kosdaq_50, get_price_data_segments
+import pytz
+
+from rolling_k_auto_trade_api.kis_api import send_order, get_price_quote
+from rolling_k_auto_trade_api.best_k_meta_strategy import get_best_k_for_kosdaq_topn, get_price_data_segments
+from rolling_k_auto_trade_api.adjust_price_to_tick import adjust_price_to_tick
 
 logger = logging.getLogger(__name__)
+KST = pytz.timezone("Asia/Seoul")
 
 
-def get_latest_price(stock_code: str) -> float:
-    """ì‹¤ì‹œê°„ ê°€ê²© ë°ì´í„°: í•œêµ­íˆ¬ì OpenAPIê°€ ì—†ìœ¼ë©´ FDRë¡œ ì„ì‹œ êµ¬í˜„"""
-    # TODO: ì‹¤ì „ì—ì„œëŠ” websocket/REST ì‹¤ì‹œê°„ ì—°ë™ í•„ìš”
-    import FinanceDataReader as fdr
+def _safe_float(v, default: float = 0.0) -> float:
     try:
-        df = fdr.DataReader(stock_code, datetime.now()-timedelta(days=5), datetime.now())
-        if not df.empty:
-            price = float(df.iloc[-1]["Close"])
-            logger.debug(f"[RT] {stock_code} FDR ìµœì‹ ê°€: {price}")
-            return price
+        return float(v)
+    except Exception:
+        return default
+
+
+def _get_price_context(stock_code: str, rebalance_date: datetime.date) -> Dict[str, float]:
+    """KIS ì‹œì„¸ë¥¼ ìš°ì„  ì‚¬ìš©í•´ ëª©í‘œê°€ ê³„ì‚°ì— í•„ìš”í•œ ê°’ë“¤ì„ ë°˜í™˜."""
+
+    try:
+        quote = get_price_quote(stock_code)
     except Exception as e:
-        logger.warning(f"[RT] FDR ê°€ê²©ì¡°íšŒ ì‹¤íŒ¨: {e}")
-    return 0.0
+        logger.warning(f"[QUOTE_FAIL] {stock_code} ì‹œì„¸ ì¡°íšŒ ì‹¤íŒ¨: {e}")
+        quote = {}
+
+    context: Dict[str, float] = {
+        "current_price": _safe_float(quote.get("stck_prpr"), 0.0),
+        "today_open": _safe_float(quote.get("stck_oprc"), 0.0),
+        "prev_high": _safe_float(quote.get("prdy_hgpr"), 0.0),
+        "prev_low": _safe_float(quote.get("prdy_lwpr"), 0.0),
+        "ask_price": _safe_float(quote.get("askp1") or quote.get("askp"), 0.0),
+        "bid_price": _safe_float(quote.get("bidp1") or quote.get("bidp"), 0.0),
+    }
+
+    if context["prev_high"] and context["prev_low"] and context["today_open"]:
+        return context
+
+    # ë³´ì™„: ì˜¤ëŠ˜ë³´ë‹¤ ì´ì „ ë‚ ì§œì˜ í™•ì • ì¼ë´‰ì—ì„œ ì „ì¼ ê³ ê°€/ì €ê°€ë¥¼ ì±„ì›€
+    segments = get_price_data_segments(stock_code, rebalance_date)
+    month_records = sorted(segments.get("month", []), key=lambda x: x.get("date"))
+    today = datetime.now(tz=KST).date()
+    prev_rec = max(
+        (rec for rec in month_records if rec.get("date") and rec.get("date") < today),
+        key=lambda r: r.get("date"),
+        default=None,
+    )
+
+    if prev_rec:
+        if not context["prev_high"]:
+            context["prev_high"] = _safe_float(prev_rec.get("high"), 0.0)
+        if not context["prev_low"]:
+            context["prev_low"] = _safe_float(prev_rec.get("low"), 0.0)
+
+    return context
 
 
 def rolling_k_auto_trade_loop(
     rebalance_date: str,
     invest_amount: int = 10_000_000,
     order_test: bool = False,
     dryrun: bool = True
 ):
     """
     ì‹¤ì‹œê°„ ìë™ë§¤ë§¤ ì‹œê·¸ë„ loop (ì‹¤ì „/ëª¨ì˜)
-    - íˆ¬ì ëŒ€ìƒ ì¢…ëª©êµ°/Best-K: get_best_k_for_kosdaq_50(rebalance_date) ê²°ê³¼ í™œìš©
+    - íˆ¬ì ëŒ€ìƒ ì¢…ëª©êµ°/Best-K: get_best_k_for_kosdaq_topn(rebalance_date) ê²°ê³¼ í™œìš©
     - ì‹¤ì‹œê°„ ëª©í‘œê°€ ê³„ì‚°/ë§¤ìˆ˜/ë§¤ë„
     - dryrun=True: ì£¼ë¬¸ ì‹¤í–‰X ë¡œê·¸ë§Œ
     - order_test=True: ê°•ì œ ë§¤ìˆ˜
     """
     logger.info(f"[ì‹¤ì‹œê°„ AUTO LOOP] {rebalance_date} ì‹œì‘ (test={order_test}, dryrun={dryrun})")
-    target_stocks: List[Dict] = get_best_k_for_kosdaq_50(rebalance_date)
+    target_stocks: List[Dict] = get_best_k_for_kosdaq_topn(rebalance_date)
     logger.info(f"[AUTO] íˆ¬ì ëŒ€ìƒ = {len(target_stocks)}ì¢…ëª©")
-    each_invest = invest_amount // max(len(target_stocks), 1)
 
     for s in target_stocks:
         code, name, best_k = s["code"], s["name"], s["best_k"]
+        weight = _safe_float(s.get("weight"), 0.0)
         logger.info(f"[LOOP] {name}({code}) - K={best_k}")
         # ì‹¤ì‹œê°„ ê°€ê²© ë°ì´í„°/ëª©í‘œê°€ ì‚°ì¶œ
-        price_segments = get_price_data_segments(code, datetime.strptime(rebalance_date, "%Y-%m-%d").date())
-        # ëŒíŒŒëª©í‘œê°€: ì˜¤ëŠ˜ ì‹œê°€ + (ì „ì¼ê³ ê°€-ì „ì¼ì €ê°€)*best_k
-        today = datetime.today().date()
-        today_prices = [p for p in price_segments["month"] if p["date"] == today]
-        if not today_prices:
-            logger.warning(f"[SKIP] {code} ì˜¤ëŠ˜ ì‹œê°€ ì—†ìŒ")
+        price_ctx = _get_price_context(code, datetime.strptime(rebalance_date, "%Y-%m-%d").date())
+        if not price_ctx["today_open"] or not price_ctx["prev_high"] or not price_ctx["prev_low"]:
+            logger.warning(f"[SKIP] {code} ëª©í‘œê°€ ê³„ì‚°ì— í•„ìš”í•œ ì‹œì„¸ ì—†ìŒ")
+            continue
+
+        target_price = adjust_price_to_tick(
+            round(price_ctx["today_open"] + (price_ctx["prev_high"] - price_ctx["prev_low"]) * best_k, 2)
+        )
+
+        current_price = price_ctx["current_price"]
+        best_ask = price_ctx.get("ask_price", 0.0)
+        if current_price <= 0:
+            logger.warning(f"[SKIP] {code} í˜„ì¬ê°€ ì—†ìŒ")
             continue
-        today_open = today_prices[0]["open"]
-        yesterday_prices = [p for p in price_segments["month"] if p["date"] == today - timedelta(days=1)]
-        if not yesterday_prices:
-            logger.warning(f"[SKIP] {code} ì „ì¼ ë°ì´í„° ì—†ìŒ")
+        if weight <= 0:
+            logger.warning(f"[SKIP] {code} weight<=0 (weight={weight})")
             continue
-        prev_high = yesterday_prices[0]["high"]
-        prev_low  = yesterday_prices[0]["low"]
-        target_price = round(today_open + (prev_high - prev_low) * best_k, 2)
 
-        current_price = get_latest_price(code)
         logger.info(f"[RT] {code} ëª©í‘œê°€={target_price}, í˜„ì¬ê°€={current_price}")
         # ë§¤ìˆ˜ ì‹œê·¸ë„
-        if order_test or (current_price > 0 and current_price >= target_price):
-            qty = max(each_invest // int(current_price), 1)
+        if order_test or (current_price >= target_price):
+            allocated = invest_amount * weight
+            unit_price = best_ask if best_ask > 0 else current_price
+            if unit_price <= 0:
+                logger.warning(f"[SKIP] {code} í˜¸ê°€/í˜„ì¬ê°€ ì—†ìŒ")
+                continue
+            qty = int(allocated // unit_price)
+            if qty <= 0:
+                logger.warning(f"[SKIP] {code} ë°°ë¶„ê¸ˆì•¡ ë¶€ì¡± allocated={allocated} unit_price={unit_price}")
+                continue
             if dryrun:
-                logger.info(f"[DRYRUN] {code} {name}: ë§¤ìˆ˜ì‹ í˜¸ qty={qty} ëª©í‘œê°€={target_price} í˜„ì¬ê°€={current_price}")
+                logger.info(f"[DRYRUN] {code} {name}: ë§¤ìˆ˜ì‹ í˜¸ qty={qty} ëª©í‘œê°€={target_price} ê¸°ì¤€ê°€ê²©={unit_price} í˜„ì¬ê°€={current_price}")
             else:
                 try:
-                    resp = send_order(code, qty=qty, price=target_price, side="buy")
+                    resp = send_order(code, qty=qty, price=None, side="buy")
                     logger.info(f"[ORDER] {code} {name}: {resp}")
                     time.sleep(3)
                 except Exception as e:
                     logger.exception(f"[ORDER_FAIL] {code} ì£¼ë¬¸ì‹¤íŒ¨: {e}")
         else:
             logger.info(f"[WAIT] {code} ëª©í‘œê°€ ë¯¸ì¶©ì¡± or ë°ì´í„° ë¶€ì¡±")
diff --git a/rolling_k_auto_trade_api/best_k_meta_strategy.py b/rolling_k_auto_trade_api/best_k_meta_strategy.py
index 325912d9a6d82cb7db92b5f0f1a47053f6b6548a..4f4154d7473c47d540941752d96afd44e4611e07 100644
--- a/rolling_k_auto_trade_api/best_k_meta_strategy.py
+++ b/rolling_k_auto_trade_api/best_k_meta_strategy.py
@@ -1,44 +1,45 @@
 # -*- coding: utf-8 -*-
 # best_k_meta_strategy.py (ì‹¤ì „ rolling_k, ìµœì í™” ì „ì²´ë³¸)
 """
 ì‹¤ì „í˜• rolling_k ë³€ë™ì„±ëŒíŒŒ + ì›”ì´ˆ/rolling/TopN/ë³´ìœ ë¶„/ë™ì K/ê°€ì¤‘ì¹˜ ìµœì í™” ì „ëµ
 - KOSDAQ TopN(pykrx+fdr) ìœ ë‹ˆë²„ìŠ¤/ì‹œì´ ë™ì 
 - ì›”/ë¶„ê¸°/ì—°ê°„ K-grid(ê³ ì •/ATRë™ì )
 - ëª©í‘œê°€: ì „ì¼ ë³€ë™í­*K + í‹±ë³´ì •
 - best_k/Sharpe/ìŠ¹ë¥ /ìˆ˜ìµë¥ /MDD/ê±°ë˜ìˆ˜ í•„í„° + assign_weights
 - ë³´ìœ ì¢…ëª© ê°•ì œí¬í•¨/ë¹„ì¤‘í•˜í•œ/rolling í†µí•©
 - FastAPI(trader.py/main.py)ì—ì„œ /rebalance/run/{date}ê°€ í˜¸ì¶œí•  run_rebalance() ì œê³µ
 """
 
 from __future__ import annotations
 
 import logging
 import math
 import os
 from datetime import datetime, timedelta, date
-from typing import Any, Dict, List, Optional, Iterable
+from functools import lru_cache
+from typing import Any, Dict, Iterable, List, Optional
 
 import numpy as np
 import pandas as pd
 import FinanceDataReader as fdr
 from pykrx.stock import (
     get_market_cap_by_ticker,
     get_nearest_business_day_in_a_week,
 )
 
 from trader.rkmax_utils import get_best_k_meta, assign_weights, _enforce_min_weight_for_forced
 from .simulate_with_k_and_get_metrics import simulate_with_k_and_get_metrics
 from rolling_k_auto_trade_api.adjust_price_to_tick import adjust_price_to_tick
 
 logger = logging.getLogger(__name__)
 
 # -----------------------------
 # í™˜ê²½ íŒŒë¼ë¯¸í„° (íŠœë‹ ê°€ëŠ¥)
 # -----------------------------
 K_MIN = float(os.getenv("K_MIN", "0.1"))
 K_MAX = float(os.getenv("K_MAX", "1.0"))
 K_STEP = float(os.getenv("K_STEP", "0.1"))
 K_GRID_MODE = os.getenv("K_GRID_MODE", "fixed").lower()  # fixed|fine|atr
 K_STEP_FINE = float(os.getenv("K_STEP_FINE", "0.05"))
 K_DYNAMIC_STEP_MIN = float(os.getenv("K_DYNAMIC_STEP_MIN", "0.03"))
 K_DYNAMIC_STEP_MAX = float(os.getenv("K_DYNAMIC_STEP_MAX", "0.10"))
@@ -57,103 +58,129 @@ KEEP_HELD_BYPASS_FILTERS = os.getenv("KEEP_HELD_BYPASS_FILTERS", "true").lower()
 HELD_MIN_WEIGHT = float(os.getenv("HELD_MIN_WEIGHT", "0.01"))
 
 # -----------------------------
 # ìœ í‹¸
 # -----------------------------
 def _clip(v: float, lo: float, hi: float) -> float:
     return max(lo, min(hi, v))
 
 def _round2(x: float) -> float:
     return float(np.round(x, 2))
 
 def _safe_float(x: Any, default: float = 0.0) -> float:
     try:
         return float(x)
     except Exception:
         return default
 
 def _find_column(df: pd.DataFrame, keyword: str) -> Optional[str]:
     kw = keyword.replace(" ", "")
     for c in df.columns:
         if kw in str(c).replace(" ", ""):
             return c
     return None
 
 # -----------------------------
-# 1) ì‹œê°€ì´ì•¡ ê¸°ì¤€ KOSDAQ Top-N
+# 1) ì‹œê°€ì´ì•¡ ê¸°ì¤€ Top-N (KOSDAQ only for rolling-k universe)
 # -----------------------------
-def get_kosdaq_top_n(date_str: Optional[str] = None, n: int = TOP_N) -> pd.DataFrame:
-    """ì‹œê°€ì´ì•¡ ìƒìœ„ nê°œ KOSDAQ ì¢…ëª© ë°˜í™˜ (Code, Name, Marcap)."""
+@lru_cache(maxsize=None)
+def _get_listing_df_cached(markets: tuple[str, ...]) -> pd.DataFrame:
+    frames: List[pd.DataFrame] = []
+    for m in markets:
+        try:
+            df = fdr.StockListing(m).rename(columns={"Symbol": "Code", "Name": "Name"})
+            df["Code"] = df["Code"].astype(str).str.zfill(6)
+            frames.append(df[["Code", "Name"]])
+        except Exception:
+            logger.exception("âŒ  StockListing(%s) ì‹¤íŒ¨", m)
+    if not frames:
+        return pd.DataFrame(columns=["Code", "Name"])
+    merged = pd.concat(frames, ignore_index=True)
+    merged = merged.drop_duplicates(subset=["Code"], keep="first")
+    return merged
+
+
+def _get_listing_df(markets: Iterable[str]) -> pd.DataFrame:
+    """ì£¼ì–´ì§„ ì‹œì¥ ë¦¬ìŠ¤íŠ¸ì— ëŒ€í•œ ì¢…ëª©ëª… DF í•©ì¹œ í›„ Code í¬ë§·ì„ ì •ê·œí™”í•œë‹¤."""
+    normalized_markets = tuple(dict.fromkeys(markets))
+    return _get_listing_df_cached(normalized_markets).copy()
+
+def _get_top_n_for_market(date_str: Optional[str], n: int, market: str) -> pd.DataFrame:
+    """ì£¼ì–´ì§„ ì‹œì¥ì˜ ì‹œê°€ì´ì•¡ ìƒìœ„ nê°œ ì¢…ëª© ë°˜í™˜."""
     try:
         target_dt = datetime.today() if date_str is None else datetime.strptime(date_str, "%Y-%m-%d")
         from_date = get_nearest_business_day_in_a_week(target_dt.strftime("%Y%m%d"))
-        logger.info(f"ğŸ“… pykrx ì‹œì´ ì¡°íšŒì¼ â†’ {from_date}")
+        logger.info(f"ğŸ“… pykrx ì‹œì´ ì¡°íšŒì¼({market}) â†’ {from_date}")
 
-        mktcap_df = get_market_cap_by_ticker(from_date, market="KOSDAQ")
+        mktcap_df = get_market_cap_by_ticker(from_date, market=market)
         if mktcap_df is None or len(mktcap_df) == 0:
-            logger.warning("âš ï¸  pykrx ì‹œì´ DFê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤ â†’ ë¹ˆ DF ë°˜í™˜")
+            logger.warning("âš ï¸  pykrx ì‹œì´ DF(%s)ê°€ ë¹„ì—ˆìŠµë‹ˆë‹¤ â†’ ë¹ˆ DF ë°˜í™˜", market)
             return pd.DataFrame(columns=["Code", "Name", "Marcap"])
 
         mktcap_df = mktcap_df.reset_index()
         capcol = _find_column(mktcap_df, "ì‹œê°€ì´ì•¡")
         ticcol = _find_column(mktcap_df, "í‹°ì»¤") or _find_column(mktcap_df, "ì½”ë“œ")
         if capcol is None or ticcol is None:
-            logger.error("âŒ  ì‹œì´/í‹°ì»¤ ì»¬ëŸ¼ íƒìƒ‰ ì‹¤íŒ¨ â†’ ë¹ˆ DF ë°˜í™˜")
+            logger.error("âŒ  %s ì‹œì´/í‹°ì»¤ ì»¬ëŸ¼ íƒìƒ‰ ì‹¤íŒ¨ â†’ ë¹ˆ DF ë°˜í™˜", market)
             return pd.DataFrame(columns=["Code", "Name", "Marcap"])
 
         mktcap_df = mktcap_df.rename(columns={capcol: "Marcap", ticcol: "Code"})
         mktcap_df["Code"] = mktcap_df["Code"].astype(str).str.zfill(6)
 
-        fdr_df = fdr.StockListing("KOSDAQ").rename(columns={"Symbol": "Code", "Name": "Name"})
-        fdr_df["Code"] = fdr_df["Code"].astype(str).str.zfill(6)
-
+        fdr_df = _get_listing_df([market])
         merged = pd.merge(
             fdr_df[["Code", "Name"]],
             mktcap_df[["Code", "Marcap"]],
             on="Code",
             how="inner",
         )
         if "Marcap" not in merged.columns:
             for cand in ("Marcap_x", "Marcap_y", "MarketCap", "MarketCap_x", "MarketCap_y"):
                 if cand in merged.columns:
                     merged = merged.rename(columns={cand: "Marcap"})
                     break
         if "Marcap" not in merged.columns:
-            logger.error("âŒ  ë³‘í•© í›„ì—ë„ 'Marcap' ì—†ìŒ â†’ ë¹ˆ DF ë°˜í™˜")
+            logger.error("âŒ  ë³‘í•© í›„ì—ë„ 'Marcap' ì—†ìŒ(%s) â†’ ë¹ˆ DF ë°˜í™˜", market)
             return pd.DataFrame(columns=["Code", "Name", "Marcap"])
 
         topn = merged.dropna(subset=["Marcap"])
         # 6ìë¦¬ ìˆ«ì ì½”ë“œë§Œ ì‚¬ìš© (ìš°ì„ ì£¼/ETN ë“± íŠ¹ìˆ˜ì½”ë“œ, 0009K0 ê°™ì€ ê²ƒ ì œê±°)
         topn = topn[topn["Code"].astype(str).str.match(r"^\d{6}$")]
         topn = topn.sort_values("Marcap", ascending=False).head(n)
-        logger.info(f"âœ…  ì‹œì´ Top{n} ì¶”ì¶œ ì™„ë£Œ â†’ {len(topn)} ì¢…ëª©")
+        logger.info(f"âœ…  {market} ì‹œì´ Top{n} ì¶”ì¶œ ì™„ë£Œ â†’ {len(topn)} ì¢…ëª©")
         return topn[["Code", "Name", "Marcap"]]
 
     except Exception:
-        logger.exception("âŒ  get_kosdaq_top_n ì˜ˆì™¸:")
+        logger.exception("âŒ  get_top_n_for_market(%s) ì˜ˆì™¸:", market)
         return pd.DataFrame(columns=["Code", "Name", "Marcap"])
 
+def get_kosdaq_top_n(date_str: Optional[str] = None, n: int = TOP_N) -> pd.DataFrame:
+    return _get_top_n_for_market(date_str, n, market="KOSDAQ")
+
+def get_kospi_top_n(date_str: Optional[str] = None, n: int = TOP_N) -> pd.DataFrame:
+    return _get_top_n_for_market(date_str, n, market="KOSPI")
+
 # -----------------------------
 # ATR ê³„ì‚°(ì›” ë°ì´í„° ë ˆì½”ë“œì—ì„œ)
 # -----------------------------
 def _compute_atr_from_records(records: List[Dict[str, Any]], window: int = 14) -> Optional[float]:
     """ì›” êµ¬ê°„ ë ˆì½”ë“œ([{open,high,low,close}...])ì—ì„œ ATR ê³„ì‚°."""
     if not records or len(records) < window + 1:
         return None
     df = pd.DataFrame(records).copy()
     need = {"open", "high", "low", "close"}
     if not need.issubset(set(df.columns)):
         return None
     df = df[["open", "high", "low", "close"]].astype(float)
     prev_close = df["close"].shift(1)
     tr = pd.concat(
         [
             (df["high"] - df["low"]).abs(),
             (df["high"] - prev_close).abs(),
             (df["low"] - prev_close).abs(),
         ],
         axis=1,
     ).max(axis=1)
     atr = tr.rolling(window=window, min_periods=window).mean().iloc[-1]
     try:
         return float(atr) if atr and not math.isnan(atr) else None
     except Exception:
@@ -244,80 +271,84 @@ def get_price_data_segments(code: str, base_date: date) -> Dict[str, List[Dict[s
         df = df[["date", "open", "high", "low", "close", "volume"]].sort_values("date")
         return {
             "year": df[df["date"] >= base_date - timedelta(days=365)].to_dict("records"),
             "quarter": df[df["date"] >= base_date - timedelta(days=90)].to_dict("records"),
             "month": df[df["date"] >= base_date - timedelta(days=30)].to_dict("records"),
         }
     except Exception as e:
         logger.exception(f"[ERROR] âŒ Failed to fetch data for {code}: {e}")
         return {"year": [], "quarter": [], "month": []}
 
 # -----------------------------
 # 4) K ìµœì í™” & í•„í„°ë§ (+ ë³´ìœ ë¶„ ê°•ì œ í¬í•¨)
 # -----------------------------
 def _parse_force_include_codes(env_codes: Iterable[str]) -> List[str]:
     out = []
     for c in env_codes:
         c = str(c).strip()
         if not c:
             continue
         out.append(c.zfill(6))
     return sorted(set(out))
 
 def _inject_forced_codes(universe_df: pd.DataFrame, forced_codes: List[str]) -> pd.DataFrame:
     if not forced_codes:
         return universe_df
-    fdr_df = fdr.StockListing("KOSDAQ").rename(columns={"Symbol": "Code", "Name": "Name"})
-    fdr_df["Code"] = fdr_df["Code"].astype(str).str.zfill(6)
+    fdr_df = _get_listing_df(["KOSDAQ"])
     force_df = fdr_df[fdr_df["Code"].isin(forced_codes)][["Code", "Name"]].copy()
     missing = [c for c in forced_codes if c not in set(force_df["Code"])]
     if missing:
         force_df = pd.concat(
             [force_df, pd.DataFrame({"Code": missing, "Name": [None] * len(missing)})],
             ignore_index=True,
         )
     uni = universe_df.copy()
     uni = pd.concat([uni[["Code", "Name", "Marcap"]], force_df.assign(Marcap=np.nan)], ignore_index=True)
     uni = uni.drop_duplicates(subset=["Code"], keep="first")
     return uni
 
-def get_best_k_for_kosdaq_50(rebalance_date_str: str) -> List[Dict[str, Any]]:
+def get_best_k_for_kosdaq_topn(rebalance_date_str: str) -> List[Dict[str, Any]]:
     """
     ë¦¬ë°¸ëŸ°ì‹± ëŒ€ìƒ ë¦¬ìŠ¤íŠ¸ ì‘ì„±:
     - code/name/best_k/weight(+qty=None) + prev_* + ëª©í‘œê°€(close í¬í•¨)ê¹Œì§€ ì±„ì›€
+    - KOSDAQ TopNë§Œ í¬í•¨ (KOSPIëŠ” ë³„ë„ ì½”ì–´ ì—”ì§„ì—ì„œ ì²˜ë¦¬)
     """
     rebalance_date = datetime.strptime(rebalance_date_str, "%Y-%m-%d").date()
 
-    top_df = get_kosdaq_top_n(rebalance_date_str, n=TOP_N)
+    kosdaq_df = get_kosdaq_top_n(rebalance_date_str, n=TOP_N)
+    logger.info("ğŸ“ˆ ìœ ë‹ˆë²„ìŠ¤ ìˆ˜ì§‘: KOSDAQ=%d (Top%d)", len(kosdaq_df), TOP_N)
+    top_df = kosdaq_df.copy()
     forced_codes = _parse_force_include_codes(ALWAYS_INCLUDE_CODES)
     if forced_codes:
         top_df = _inject_forced_codes(top_df, forced_codes)
 
     if top_df.empty:
-        logger.warning("[WARN] get_kosdaq_top_n ê²°ê³¼ ì—†ìŒ â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜")
+        logger.warning("[WARN] KOSDAQ TopN ê²°ê³¼ ì—†ìŒ â†’ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜")
         return []
 
+    logger.info("ğŸ“Š KOSDAQ ì‹œì´ TopN ìœ ë‹ˆë²„ìŠ¤ ìˆ˜ëŸ‰: %dê°œ (ê³ ìœ )", len(top_df))
+
     results: Dict[str, Dict[str, Any]] = {}
 
     for _, stock in top_df.iterrows():
         code, name = str(stock["Code"]).zfill(6), stock.get("Name")
         try:
             segments = get_price_data_segments(code, rebalance_date)
             month_data = segments["month"]
 
             if not month_data:
                 logger.debug(f"[SKIP] {name}({code}) ì „ì›” ë°ì´í„° ì—†ìŒ")
                 if code in forced_codes and KEEP_HELD_BYPASS_FILTERS:
                     results[code] = {
                         "code": code, "name": name, "best_k": 0.5,
                         "avg_return_pct": 0.0, "win_rate_pct": 0.0,
                         "mdd_pct": 0.0, "trades": 0, "cumulative_return_pct": 0.0,
                         "avg_holding_days": 0.0, "sharpe_m": 0.0,
                         "ëª©í‘œê°€": None, "close": None,
                         "prev_open": None, "prev_high": None, "prev_low": None, "prev_close": None, "prev_volume": None,
                         "forced_include": True, "filtered_reason": "NO_DATA",
                         "qty": None, "weight": None, "k_grid_mode": K_GRID_MODE,
                     }
                 continue
 
             # K grid â†’ best_k ì„ íƒ
             k_range = _build_k_range(code, month_data)
@@ -408,54 +439,65 @@ def get_best_k_for_kosdaq_50(rebalance_date_str: str) -> List[Dict[str, Any]]:
                 # ë©”íƒ€
                 "forced_include": code in forced_codes,
                 "k_grid_mode": K_GRID_MODE,
                 # ìˆ˜ëŸ‰ì€ trader.pyê°€ weightâ†’qtyë¡œ ë³€í™˜í•˜ë¯€ë¡œ ê¸°ë³¸ None
                 "qty": None,
                 "weight": None,  # assign_weights í›„ ì±„ì›Œì§
             }
 
             logger.info(
                 f"[SIM] {name}({code}) R={avg_return:.1f}% W={win_rate:.1f}% MDD={mdd:.1f}% "
                 f"K={best_k} trades={trades} forced={code in forced_codes}"
             )
 
         except Exception as e:
             logger.exception(f"[ERR] {name}({code}) ì‹œë®¬ ì‹¤íŒ¨: {e}")
             continue
 
     logger.info(f"ğŸ“Š í•„í„°/ê°•ì œí¬í•¨ ë°˜ì˜ ì¢…ëª© = {len(results)}ê°œ")
 
     # ê°€ì¤‘ì¹˜ ë¶€ì—¬
     selected = list(results.values())
     selected = assign_weights(selected)  # ë‚´ë¶€ì—ì„œ 'weight' ì±„ì›Œì§
 
     # ë³´ìœ ë¶„ ìµœì†Œ ë¹„ì¤‘ í•˜í•œ ë³´ì • (í•©ê³„ 1 ìœ ì§€)
     if selected and HELD_MIN_WEIGHT > 0:
-        selected = _enforce_min_weight_for_forced(selected, [], min_weight=HELD_MIN_WEIGHT)
+        selected = _enforce_min_weight_for_forced(selected, forced_codes, min_weight=HELD_MIN_WEIGHT)
+
+    # ì‚¬í›„ ì •ê·œí™”ë¡œ weight í•©ê³„ë¥¼ 1.0ìœ¼ë¡œ ìœ ì§€
+    if selected:
+        total_weight = sum(float(it.get("weight") or 0) for it in selected)
+        if total_weight > 0:
+            for it in selected:
+                it["weight"] = float(it.get("weight") or 0) / total_weight
 
     return selected
 
+
+# Backward compatibility alias for earlier naming that implied KRX scope
+get_best_k_for_krx_topn = get_best_k_for_kosdaq_topn
+
 # -----------------------------
 # 5) API ì§„ì…ì : /rebalance/run/{date} ì—ì„œ í˜¸ì¶œ
 # -----------------------------
 def run_rebalance(date: str, force_order: bool = False) -> Dict[str, Any]:
     """
     /rebalance/run/{date} ì—”ë“œí¬ì¸íŠ¸ì—ì„œ ì§ì ‘ í˜¸ì¶œë˜ëŠ” ì§„ì…ì .
     ë°˜í™˜ ìŠ¤í‚¤ë§ˆëŠ” trader.py/main.pyê°€ ê¸°ëŒ€í•˜ëŠ” í˜•íƒœë¡œ ë³´ì¥í•œë‹¤.
 
     Returns:
         {
           "selected": [ ... ],
           "selected_stocks": [ ... ]  # ë™ì¼ ë°°ì—´(í˜¸í™˜ì„±)
         }
     """
     try:
-        selected = get_best_k_for_kosdaq_50(date)
+        selected = get_best_k_for_kosdaq_topn(date)
         # force_orderê°€ Trueë¼ê³  í•´ì„œ ì—¬ê¸°ì„œ ì‹¤ì£¼ë¬¸ì„ ë‚´ì§€ ì•ŠìŒ.
         # (ì£¼ë¬¸ì€ trader.pyê°€ ê´€ë¦¬) â€” í•„ìš” ì‹œ 'strategy'ì— í”Œë˜ê·¸ë§Œ ë‚¨ê¹€.
         for it in selected:
             it.setdefault("strategy", "ì „ì›” rolling K ìµœì í™”")
     except Exception as e:
         logger.exception("[run_rebalance] failed: %s", e)
         selected = []
 
     return {"selected": selected, "selected_stocks": selected}
diff --git a/rolling_k_auto_trade_api/kis_api.py b/rolling_k_auto_trade_api/kis_api.py
index 9219fdb9d002c88765af2da7afbfc10b89a6ccc0..c03d36908d57a81a0d158f779e0f86ed477d42e2 100644
--- a/rolling_k_auto_trade_api/kis_api.py
+++ b/rolling_k_auto_trade_api/kis_api.py
@@ -4,119 +4,170 @@ rolling_k_auto_trade_api.kis_api â€” ìµœì‹  ì‘ë‹µë¡œê¹… + íŒŒë¼ë¯¸í„° ìµœì‹ 
 
 í•µì‹¬ ê°œì„ 
 - send_order: KIS ì‘ë‹µ ì›ë¬¸(raw text) ë° JSON ëª¨ë‘ ìƒì„¸ ë¡œê¹…(ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹) + ì‹¤íŒ¨ ì‚¬ìœ /ì½”ë“œ í•¨ê»˜ ê¸°ë¡
 - HashKey ë° ì£¼ë¬¸ íŒŒë¼ë¯¸í„° ìµœì‹ í™”: /uapi/hashkey, /uapi/domestic-stock/v1/trading/order-cash
 - TR_ID ìë™ ì „í™˜: (ëª¨ì˜) VTTC0012U/VTTC0011U, (ì‹¤ì „) TTTC0012U/TTTC0011U
 - ì£¼ë¬¸ ë°©ì‹ ì²´ì¸: ì‹œì¥ê°€â†’IOCì‹œì¥ê°€â†’ìµœìœ ë¦¬(ë§¤ìˆ˜/ë§¤ë„ ê³µí†µ)ë¡œ í´ë°±
 - ê²¬ê³ í•œ ì¬ì‹œë„: ê²Œì´íŠ¸ì›¨ì´/5xx/ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ì— ë°±ì˜¤í”„ ì¬ì‹œë„
 - inquire_balance(ë‹¨ì¼/ì „ì²´), inquire_cash_balance, inquire_filled_order(ì‘ë‹µ ë¡œê¹… í¬í•¨)
 
 ì£¼ì˜: settings ëª¨ë“ˆì´ ìˆìœ¼ë©´ ìš°ì„  ì‚¬ìš©í•˜ê³ , ì—†ìœ¼ë©´ í™˜ê²½ë³€ìˆ˜ì—ì„œ ì½ìŠµë‹ˆë‹¤.
 """
 
 import os
 import json
 import time
 import random
 import logging
 from typing import Any, Dict, Optional, List
 
 import requests
 from requests.adapters import HTTPAdapter
 from urllib3.util.retry import Retry
 
 logger = logging.getLogger(__name__)
 
+# =============================
+# ì‹¤í–‰ ë³´í˜¸ í”Œë˜ê·¸ (CI ë“±ì—ì„œ ì‹¤ê±°ë˜ ë°©ì§€)
+# =============================
+
+
+class LiveTradingDisabledError(RuntimeError):
+    """Raised when live KIS API calls are disabled via environment flag."""
+
+
+LIVE_TRADING_DISABLED = os.getenv("DISABLE_LIVE_TRADING", "").lower() in {"1", "true", "yes", "on"}
+
+
+def _guard_live_trading(action: str) -> None:
+    if LIVE_TRADING_DISABLED:
+        logger.warning(
+            f"[KIS_DISABLED] {action} skipped because DISABLE_LIVE_TRADING is set"
+        )
+        raise LiveTradingDisabledError("DISABLE_LIVE_TRADING is enabled; KIS API calls are blocked.")
+
 # =============================
 # ì„¤ì • ë¡œë”© (settings ìš°ì„ , ì—†ìœ¼ë©´ ENV)
 # =============================
 try:  # settings.pyê°€ ìˆìœ¼ë©´ í•´ë‹¹ ê°’ì„ ìš°ì„  ì‚¬ìš©
     from settings import APP_KEY as _APP_KEY
     from settings import APP_SECRET as _APP_SECRET
     from settings import API_BASE_URL as _API_BASE_URL
     from settings import CANO as _CANO
     from settings import ACNT_PRDT_CD as _ACNT_PRDT_CD
     from settings import KIS_ENV as _KIS_ENV
     APP_KEY = _APP_KEY
     APP_SECRET = _APP_SECRET
     API_BASE_URL = _API_BASE_URL
     CANO = _CANO
     ACNT_PRDT_CD = _ACNT_PRDT_CD
     KIS_ENV = _KIS_ENV
 except Exception:
     APP_KEY = os.getenv("APP_KEY") or os.getenv("KIS_APP_KEY", "")
     APP_SECRET = os.getenv("APP_SECRET") or os.getenv("KIS_APP_SECRET", "")
     API_BASE_URL = os.getenv("API_BASE_URL", "https://openapi.koreainvestment.com:9443")
     CANO = os.getenv("CANO", "")
     ACNT_PRDT_CD = os.getenv("ACNT_PRDT_CD", "01")
     KIS_ENV = (os.getenv("KIS_ENV", "practice") or "practice").lower()
 
 # í•„ìˆ˜ê°’ ì²´í¬ ë¡œê·¸
 logger.info(f"[KIS] ENV={KIS_ENV} API_BASE_URL={API_BASE_URL} CANO={'***' if CANO else ''} ACNT={'***' if ACNT_PRDT_CD else ''}")
 
 # =============================
 # ì„¸ì…˜/ì¬ì‹œë„
 # =============================
 session = requests.Session()
 retry = Retry(
     total=3,
     connect=3,
     read=3,
     status=3,
     backoff_factor=0.5,
     status_forcelist=(500, 502, 503, 504),
     allowed_methods=frozenset(["GET", "POST"]),
     raise_on_status=False,
 )
 adapter = HTTPAdapter(max_retries=retry, pool_connections=50, pool_maxsize=50)
 session.mount("https://", adapter)
 session.mount("http://", adapter)
 
+# =============================
+# ì‹œì„¸ ì¡°íšŒ (ì‹¤ì‹œê°„/ë‹¹ì¼)
+# =============================
+
+
+def get_price_quote(stock_code: str) -> Dict[str, Any]:
+    """ì‹¤ì‹œê°„/ë‹¹ì¼ ì‹œì„¸ ì¡°íšŒ."""
+
+    _guard_live_trading("quote")
+    code = str(stock_code).zfill(6)
+    url = f"{API_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-price"
+    params = {"FID_COND_MRKT_DIV_CODE": "J", "FID_INPUT_ISCD": code}
+    tr_id = "FHKST01010100"
+
+    r = session.get(url, headers=_headers(tr_id), params=params, timeout=(3.0, 7.0))
+    try:
+        j = r.json()
+    except Exception:
+        logger.error(f"[QUOTE_RAW] status={r.status_code} text={r.text[:400]}")
+        raise
+
+    if r.status_code != 200:
+        logger.error(f"[QUOTE_FAIL] code={code} status={r.status_code} resp={j}")
+        raise RuntimeError(f"quote fail: {j}")
+
+    output = j.get("output") or {}
+    if not output:
+        logger.error(f"[QUOTE_EMPTY] code={code} resp={j}")
+    return output
+
 # =============================
 # í† í° ìºì‹œ
 # =============================
 _TOKEN_CACHE = {"token": None, "expires_at": 0.0, "last_issued": 0.0}
 _TOKEN_FILE = os.getenv("KIS_TOKEN_CACHE", "kis_token_cache.json")
 
 
 def _issue_token() -> Dict[str, Any]:
+    _guard_live_trading("token")
     path = "/oauth2/tokenP" if KIS_ENV == "practice" else "/oauth2/token"
     url = f"{API_BASE_URL}{path}"
     hdr = {"content-type": "application/json"}
     data = {"grant_type": "client_credentials", "appkey": APP_KEY, "appsecret": APP_SECRET}
     r = session.post(url, json=data, headers=hdr, timeout=(3.0, 7.0))
     try:
         j = r.json()
     except Exception:
         logger.error(f"[ğŸ”‘ TOKEN_RESP_RAW] status={r.status_code} text={r.text[:400]}")
         raise
     if "access_token" in j:
         return j
     raise RuntimeError(f"TOKEN_FAIL: {j}")
 
 
 def _get_token() -> str:
+    _guard_live_trading("token")
     now = time.time()
     if _TOKEN_CACHE["token"] and now < _TOKEN_CACHE["expires_at"] - 300:
         return _TOKEN_CACHE["token"]
     # íŒŒì¼ ìºì‹œ
     if os.path.exists(_TOKEN_FILE):
         try:
             with open(_TOKEN_FILE, "r", encoding="utf-8") as f:
                 c = json.load(f)
             if c.get("access_token") and now < float(c.get("expires_at", 0)) - 300:
                 _TOKEN_CACHE.update({"token": c["access_token"], "expires_at": float(c["expires_at"]), "last_issued": float(c.get("last_issued", 0))})
                 logger.info("[TOKEN] file cache reuse")
                 return c["access_token"]
         except Exception as e:
             logger.warning(f"[TOKEN_CACHE_READ_FAIL] {e}")
     # ë°œê¸‰ ë¹ˆë„ ì œí•œ(1ë¶„)
     if now - _TOKEN_CACHE["last_issued"] < 61 and _TOKEN_CACHE["token"]:
         logger.warning("[TOKEN] throttle: reuse current token")
         return _TOKEN_CACHE["token"]
     j = _issue_token()
     token = j["access_token"]
     exp_in = int(j.get("expires_in", 86400))
     _TOKEN_CACHE.update({"token": token, "expires_at": now + exp_in, "last_issued": now})
     try:
         with open(_TOKEN_FILE, "w", encoding="utf-8") as f:
             json.dump({"access_token": token, "expires_at": now + exp_in, "last_issued": now}, f, ensure_ascii=False)
@@ -126,71 +177,73 @@ def _get_token() -> str:
 
 
 # =============================
 # ê³µí†µ í—¤ë”/HashKey
 # =============================
 
 def _headers(tr_id: str, *, hashkey: Optional[str] = None) -> Dict[str, str]:
     h = {
         "authorization": f"Bearer {_get_token()}",
         "appkey": APP_KEY,
         "appsecret": APP_SECRET,
         "tr_id": tr_id,
         "custtype": "P",
         "content-type": "application/json; charset=utf-8",
     }
     if hashkey:
         h["hashkey"] = hashkey
     return h
 
 
 def _json_dumps(body: Dict[str, Any]) -> str:
     return json.dumps(body, ensure_ascii=False, separators=(",", ":"), sort_keys=False)
 
 
 def _create_hashkey(body: Dict[str, Any]) -> str:
+    _guard_live_trading("hashkey")
     url = f"{API_BASE_URL}/uapi/hashkey"
     hdr = {"content-type": "application/json; charset=utf-8", "appkey": APP_KEY, "appsecret": APP_SECRET}
     body_str = _json_dumps(body)
     r = session.post(url, headers=hdr, data=body_str.encode("utf-8"), timeout=(3.0, 5.0))
     try:
         j = r.json()
     except Exception:
         logger.error(f"[HASHKEY_RAW] status={r.status_code} text={r.text[:400]}")
         raise
     hk = j.get("HASH") or j.get("hash") or j.get("hashkey")
     if not hk:
         logger.error(f"[HASHKEY_FAIL] resp={j}")
         raise RuntimeError(f"hashkey fail: {j}")
     return hk
 
 
 # =============================
 # ì£¼ë¬¸ (í˜„ê¸ˆ)
 # =============================
 
 def _order_cash(body: Dict[str, Any], *, is_sell: bool) -> Dict[str, Any]:
+    _guard_live_trading("order")
     url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/order-cash"
     tr_id = ("VTTC0011U" if KIS_ENV == "practice" else "TTTC0011U") if is_sell else ("VTTC0012U" if KIS_ENV == "practice" else "TTTC0012U")
 
     # ì‹œì¥ê°€â†’IOCì‹œì¥ê°€â†’ìµœìœ ë¦¬(03)
     ord_chain = ["01", "13", "03"]
     last_err: Any = None
 
     for ord_dvsn in ord_chain:
         body["ORD_DVSN"] = ord_dvsn
         body["ORD_UNPR"] = body.get("ORD_UNPR", "0") if ord_dvsn == "00" else "0"
         if is_sell and not body.get("SLL_TYPE"):
             body["SLL_TYPE"] = "01"  # ì¼ë°˜ë§¤ë„
         body.setdefault("EXCG_ID_DVSN_CD", "KRX")
 
         hk = _create_hashkey(body)
         hdr = _headers(tr_id, hashkey=hk)
 
         # ë§ˆìŠ¤í‚¹ ë¡œê·¸
         log_body = {k: ("***" if k in ("CANO", "ACNT_PRDT_CD") else v) for k, v in body.items()}
         logger.info(f"[ORDER_REQ] tr_id={tr_id} ord_dvsn={ord_dvsn} body={log_body}")
 
         for attempt in range(1, 4):
             try:
                 r = session.post(url, headers=hdr, data=_json_dumps(body).encode("utf-8"), timeout=(3.0, 7.0))
                 raw = r.text
@@ -215,146 +268,150 @@ def _order_cash(body: Dict[str, Any], *, is_sell: bool) -> Dict[str, Any]:
             # ê²Œì´íŠ¸ì›¨ì´/ê³¼ë‹¤/5xx ì¬ì‹œë„
             msg_cd = (j or {}).get("msg_cd", "") if isinstance(j, dict) else ""
             msg1 = (j or {}).get("msg1", "") if isinstance(j, dict) else ""
             if r.status_code >= 500 or msg_cd == "IGW00008" or (isinstance(msg1, str) and ("MCA" in msg1 or "ì´ˆë‹¹" in msg1)):
                 back = min(0.6 * (1.7 ** (attempt - 1)), 5.0) + random.uniform(0, 0.3)
                 logger.warning(f"[ORDER_GATEWAY_RETRY] ord_dvsn={ord_dvsn} attempt={attempt} resp={j} â†’ sleep {back:.2f}s")
                 time.sleep(back)
                 last_err = j
                 continue
 
             # ë¹„ì¦ˆë‹ˆìŠ¤ ì‹¤íŒ¨ëŠ” ê·¸ëŒ€ë¡œ ë°˜í™˜(ìƒìœ„ì—ì„œ íŒë‹¨)
             logger.error(f"[ORDER_FAIL_BIZ] ord_dvsn={ord_dvsn} resp={j} raw_head={raw[:300]}")
             return j if isinstance(j, dict) else {"_status": r.status_code, "raw": raw[:500]}
 
         logger.warning(f"[ORDER_FALLBACK] ord_dvsn={ord_dvsn} ì‹¤íŒ¨ â†’ ë‹¤ìŒ ë°©ì‹")
 
     raise RuntimeError(f"ORDER_FAIL: {last_err}")
 
 
 def send_order(code: str, qty: int, price: Optional[int] = None, side: str = "buy") -> Dict[str, Any]:
     """ê³µìš© ì£¼ë¬¸ API
     side: 'buy' or 'sell'
     price: Noneì´ë©´ ì‹œì¥ê°€ ì²´ì¸, ì§€ì •ê°€ë©´ ì§€ì •ê°€ ê³ ì •(00)
     ë°˜í™˜: KIS ì‘ë‹µ(dict). ë¹„ì •ìƒ ì‘ë‹µ ì‹œì—ë„ ì›ë¬¸/ìƒíƒœ ì¼ë¶€ í¬í•¨
     """
+    _guard_live_trading("order")
     code = str(code).strip()
     is_sell = (side.lower() == "sell")
 
     if price is None:
         # ì‹œì¥ê°€ ì²´ì¸
         body = {
             "CANO": CANO,
             "ACNT_PRDT_CD": ACNT_PRDT_CD,
             "PDNO": code,
             "ORD_QTY": str(int(qty)),
         }
         return _order_cash(body, is_sell=is_sell)
     else:
         # ì§€ì •ê°€(ê³ ì •, 00)
         body = {
             "CANO": CANO,
             "ACNT_PRDT_CD": ACNT_PRDT_CD,
             "PDNO": code,
             "ORD_QTY": str(int(qty)),
             "ORD_DVSN": "00",
             "ORD_UNPR": str(int(price)),
             "EXCG_ID_DVSN_CD": "KRX",
         }
         if is_sell:
             body["SLL_TYPE"] = "01"
         hk = _create_hashkey(body)
         tr_id = ("VTTC0011U" if KIS_ENV == "practice" else "TTTC0011U") if is_sell else ("VTTC0012U" if KIS_ENV == "practice" else "TTTC0012U")
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/order-cash"
         hdr = _headers(tr_id, hashkey=hk)
 
         log_body = {k: ("***" if k in ("CANO", "ACNT_PRDT_CD") else v) for k, v in body.items()}
         logger.info(f"[ORDER_REQ_LIMIT] tr_id={tr_id} body={log_body}")
         r = session.post(url, headers=hdr, data=_json_dumps(body).encode("utf-8"), timeout=(3.0, 7.0))
         raw = r.text
         try:
             j = r.json()
         except Exception:
             j = {"_non_json": True}
         logger.info(f"[ORDER_RESP_LIMIT] status={r.status_code} json={j} raw_head={raw[:300]}")
         return j if isinstance(j, dict) else {"_status": r.status_code, "raw": raw[:500]}
 
 
 # =============================
 # ì”ê³ /ì˜ˆìˆ˜ê¸ˆ/ì²´ê²° ì¡°íšŒ
 # =============================
 
 def inquire_cash_balance() -> int:
+    _guard_live_trading("cash_balance")
     url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/inquire-balance"
     tr_id = "VTTC8434R" if KIS_ENV == "practice" else "TTTC8434R"
     hdr = _headers(tr_id)
     params = {
         "CANO": CANO,
         "ACNT_PRDT_CD": ACNT_PRDT_CD,
         "AFHR_FLPR_YN": "N",
         "UNPR_YN": "N",
         "UNPR_DVSN": "01",
         "FUND_STTL_ICLD_YN": "N",
         "FNCG_AMT_AUTO_RDPT_YN": "N",
         "PRCS_DVSN": "01",
         "OFL_YN": "N",
         "INQR_DVSN": "02",
         "CTX_AREA_FK100": "",
         "CTX_AREA_NK100": "",
     }
     logger.info(f"[INQ_BAL_REQ] params={{...masked...}}")
     r = session.get(url, headers=hdr, params=params, timeout=(3.0, 7.0))
     raw = r.text
     try:
         j = r.json()
     except Exception:
         logger.error(f"[INQ_BAL_RAW] status={r.status_code} raw={raw[:300]}")
         return 0
     logger.info(f"[INQ_BAL_RESP] {j}")
     try:
         if j.get("rt_cd") == "0" and j.get("output2"):
             return int(j["output2"][0]["dnca_tot_amt"])  # ì˜ˆìˆ˜ê¸ˆ
     except Exception as e:
         logger.error(f"[INQ_BAL_PARSE_FAIL] {e}")
     return 0
 
 
 def inquire_balance(code: Optional[str] = None) -> List[Dict[str, Any]]:
+    _guard_live_trading("positions")
     url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/inquire-balance"
     tr_id = "VTTC8434R" if KIS_ENV == "practice" else "TTTC8434R"
     hdr = _headers(tr_id)
     params = {
         "CANO": CANO,
         "ACNT_PRDT_CD": ACNT_PRDT_CD,
         "AFHR_FLPR_YN": "N",
         "UNPR_YN": "N",
         "UNPR_DVSN": "01",
         "FUND_STTL_ICLD_YN": "N",
         "FNCG_AMT_AUTO_RDPT_YN": "N",
         "PRCS_DVSN": "01",
         "OFL_YN": "N",
         "INQR_DVSN": "02",
         "CTX_AREA_FK100": "",
         "CTX_AREA_NK100": "",
     }
     r = session.get(url, headers=hdr, params=params, timeout=(3.0, 7.0))
     raw = r.text
     try:
         j = r.json()
     except Exception:
         logger.error(f"[INQ_POS_RAW] status={r.status_code} raw={raw[:300]}")
         return []
     out = j.get("output1") or []
     if code:
         out = [o for o in out if str(o.get("pdno")) == str(code)]
     logger.info(f"[INQ_POS_RESP] count={len(out)} code={code}")
     return out
 
 
 def inquire_filled_order(ord_no: str) -> Dict[str, Any]:
     """ì²´ê²°/ì£¼ë¬¸ ì¡°íšŒ (ê°„í¸í˜•)
     ì£¼ì˜: KISì˜ ì²´ê²° ì¡°íšŒ APIëŠ” ê³„ì¢Œ/ì¼ì/ì£¼ë¬¸ë²ˆí˜¸ ë“± ë‹¤ì–‘í•œ TRì´ ìˆìœ¼ë¯€ë¡œ
     ì‹¤ì œ ë°°í¬ í™˜ê²½ì— ë§ì¶”ì–´ ìƒì„¸ TRì„ êµì²´í•´ì•¼ í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œëŠ” ìš”ì²­/ì‘ë‹µ ë¡œê¹…ì— ì¤‘ì .
     """
+    _guard_live_trading("filled_order")
     # ë°ëª¨ìš©: ì£¼ë¬¸ë²ˆí˜¸ë§Œ ë¡œê¹…/ì—ì½”
     logger.info(f"[INQ_FILL] ord_no={ord_no}")
     return {"ord_no": ord_no, "status": "dummy", "note": "Fill inquiry TR ì—°ê²° í•„ìš”"}
diff --git a/rolling_k_auto_trade_api/rebalance_api.py b/rolling_k_auto_trade_api/rebalance_api.py
index 2b1d7516a11124de56320e7c6af1c22bcbcb4085..e28971adf388e1e98d8a8c20b1838984904fea35 100644
--- a/rolling_k_auto_trade_api/rebalance_api.py
+++ b/rolling_k_auto_trade_api/rebalance_api.py
@@ -1,40 +1,40 @@
 import os
 import json
 import uuid
 import logging
 from datetime import datetime, time as dtime
 from typing import Any, Dict, List, Optional
 
 import pytz
 from fastapi import APIRouter, Query, Request, HTTPException
 from fastapi.responses import JSONResponse
 import pandas as pd
 import numpy as np
 from FinanceDataReader import StockListing, DataReader
 
-from rolling_k_auto_trade_api.best_k_meta_strategy import get_best_k_for_kosdaq_50
+from rolling_k_auto_trade_api.best_k_meta_strategy import get_best_k_for_kosdaq_topn
 from rolling_k_auto_trade_api.logging_config import configure_logging
 
 configure_logging()
 logger = logging.getLogger(__name__)
 
 rebalance_router = APIRouter()
 latest_rebalance_result: Dict[str, Any] = {"date": None, "selected_stocks": []}
 
 TOTAL_CAPITAL = int(os.getenv("TOTAL_CAPITAL", "10000000"))
 MIN_WINRATE = float(os.getenv("MIN_WINRATE", "50"))
 MAX_MDD = float(os.getenv("MAX_MDD", "10"))
 MIN_CUMRET = float(os.getenv("MIN_CUMRET", "2"))
 TOP_K_LIMIT = int(os.getenv("TOP_K_LIMIT", "20"))
 REBALANCE_OUT_DIR = os.getenv("REBALANCE_OUT_DIR", "rebalance_results")
 REBALANCE_STORE = os.getenv("REBALANCE_STORE", "./data/selected_stocks.json")
 
 KST = pytz.timezone("Asia/Seoul")
 MARKET_OPEN: dtime = dtime(9, 0)
 MARKET_CLOSE: dtime = dtime(15, 20)
 
 def is_market_open(ts: Optional[datetime] = None) -> bool:
     ts = ts or datetime.now(tz=KST)
     if ts.weekday() >= 5:
         return False
     return MARKET_OPEN <= ts.time() <= MARKET_CLOSE
@@ -48,51 +48,51 @@ def _assign_weights(selected: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
             win = float(it.get("win_rate_pct", it.get("ìŠ¹ë¥ (%)", 0))) / 100.0
             ret = float(it.get("avg_return_pct", it.get("ìˆ˜ìµë¥ (%)", 0))) / 100.0
             mdd = abs(float(it.get("mdd_pct", it.get("MDD(%)", 0)))) / 100.0
         except Exception:
             win, ret, mdd = 0.5, 0.1, 0.1
         vol = float(it.get("prev_volume", 1))
         score = (0.6 * win + 0.6 * ret + 0.1 * np.log1p(vol)) / max(0.05, (0.4 * mdd))
         scores.append(max(0.0, score))
     s = sum(scores) or 1.0
     weights = [sc / s for sc in scores]
     out: List[Dict[str, Any]] = []
     for it, w in zip(selected, weights):
         o = dict(it)
         o["weight"] = round(float(w), 6)
         out.append(o)
     return out
 
 def _ensure_dir(path: str) -> None:
     os.makedirs(path, exist_ok=True)
 
 @rebalance_router.post("/rebalance/run/{date}", tags=["Rebalance"])
 async def run_rebalance(date: str):
     logger.info(f"[RUN] run_rebalance í˜¸ì¶œ: date={date}")
 
     try:
-        raw_results = get_best_k_for_kosdaq_50(date)
+        raw_results = get_best_k_for_kosdaq_topn(date)
     except Exception as e:
         logger.exception(f"[ERROR] Best K ê³„ì‚° ì‹¤íŒ¨: {e}")
         raise HTTPException(status_code=500, detail="Best K ê³„ì‚° ì‹¤íŒ¨")
 
     results_map: Dict[str, Dict[str, Any]] = {}
     if isinstance(raw_results, dict):
         results_map = raw_results
     else:
         for s in raw_results:
             code_key = s.get("stock_code") or s.get("code") or s.get("í‹°ì»¤")
             if not code_key:
                 logger.warning(f"[WARN] ì½”ë“œ ëˆ„ë½: {s}")
                 continue
             s["stock_code"] = code_key
             results_map[code_key] = s
 
     logger.info(f"[FILTER] í›„ë³´ ì¢…ëª© ìˆ˜ = {len(results_map)}ê°œ")
 
     candidates: List[Dict[str, Any]] = []
     selected: List[Dict[str, Any]] = []
     for code, info0 in results_map.items():
         info = dict(info0)
         candidates.append(info)
         try:
             cumret = float(info.get("cumulative_return_pct", info.get("ìˆ˜ìµë¥ (%)", 0)))
diff --git a/rolling_k_auto_trade_api/rolling_k_rebalance_api.py b/rolling_k_auto_trade_api/rolling_k_rebalance_api.py
index e74242d037fd1810cbc0155a8d556a35657e0133..b372a5ad9bdce77d670726de6a925a07fa1c0d33 100644
--- a/rolling_k_auto_trade_api/rolling_k_rebalance_api.py
+++ b/rolling_k_auto_trade_api/rolling_k_rebalance_api.py
@@ -1,71 +1,71 @@
 import os
 import json
 import logging
 from datetime import datetime
 from fastapi import APIRouter, HTTPException, Query
 
-from rolling_k_auto_trade_api.best_k_meta_strategy import get_best_k_for_kosdaq_50
+from rolling_k_auto_trade_api.best_k_meta_strategy import get_best_k_for_kosdaq_topn
 from rolling_k_auto_trade_api.logging_config import configure_logging
 
 configure_logging()
 logger = logging.getLogger(__name__)
 
 rolling_rebalance_router = APIRouter()
 
 ROLLING_RATIO = float(os.getenv("ROLLING_RATIO", "0.3"))
 TOP_K_LIMIT = int(os.getenv("TOP_K_LIMIT", "20"))
 REBALANCE_OUT_DIR = os.getenv("REBALANCE_OUT_DIR", "rebalance_results")
 REBALANCE_STORE = os.getenv("REBALANCE_STORE", "./data/selected_stocks.json")
 
 def _ensure_dir(path: str) -> None:
     os.makedirs(path, exist_ok=True)
 
 @rolling_rebalance_router.post("/rebalance/rolling/{date}", tags=["RollingRebalance"])
 async def run_rolling_rebalance(
     date: str,
     rolling_ratio: float = Query(ROLLING_RATIO, description="í•˜ìœ„ ëª‡ % êµì²´(0.0~1.0)"),
 ):
     """
     ROLLING(ë¶€ë¶„) ë¦¬ë°¸ëŸ°ì‹±: ìœ ë‹ˆë²„ìŠ¤ ì¤‘ í•˜ìœ„ rolling_ratioë§Œ êµì²´, ì‹ ê·œ ê°•ì„¸ì£¼ ìë™ í¸ì…
     """
     logger.info(f"[ROLLING] rolling_rebalance í˜¸ì¶œ: date={date}, rolling_ratio={rolling_ratio}")
 
     # 1) ê¸°ì¡´ í¬íŠ¸í´ë¦¬ì˜¤ ë¶ˆëŸ¬ì˜¤ê¸°
     try:
         with open(REBALANCE_STORE, "r", encoding="utf-8") as f:
             prev_data = json.load(f)
             old_universe = prev_data.get("selected_stocks", [])
     except Exception:
         old_universe = []
 
     old_codes = [s.get("code") or s.get("stock_code") for s in old_universe if (s.get("code") or s.get("stock_code"))]
     logger.info(f"[ROLLING] ê¸°ì¡´ ìœ ë‹ˆë²„ìŠ¤: {old_codes}")
 
     # 2) ì „ì²´ í›„ë³´êµ° + score(ìˆ˜ìµë¥ , ìŠ¹ë¥ , ëª¨ë©˜í…€ ë“±) ì¬ì‚°ì¶œ
     try:
-        new_candidates = get_best_k_for_kosdaq_50(date)
+        new_candidates = get_best_k_for_kosdaq_topn(date)
     except Exception as e:
         logger.exception(f"[ERROR] Rolling BestK ê³„ì‚° ì‹¤íŒ¨: {e}")
         raise HTTPException(status_code=500, detail="Rolling Best K ê³„ì‚° ì‹¤íŒ¨")
     candidates_map = {}
     for s in new_candidates:
         code = s.get("stock_code") or s.get("code") or s.get("í‹°ì»¤")
         if code:
             s["code"] = code
             candidates_map[code] = s
 
     # 3) í˜„ì¬ í¬íŠ¸ ë‚´ í•˜ìœ„ rolling_ratioë§Œ ì œê±°
     current_scored = [candidates_map.get(code, {}) for code in old_codes]
     valid_current = [c for c in current_scored if c]
     num_drop = int(len(valid_current) * rolling_ratio)
     sorted_current = sorted(valid_current, key=lambda x: float(x.get("avg_return_pct", 0)))
     codes_to_drop = set([c["code"] for c in sorted_current[:num_drop]])
     logger.info(f"[ROLLING] drop {num_drop}/{len(valid_current)}: {codes_to_drop}")
 
     # 4) ì‹ ê·œ ìƒìœ„ ê°•ì„¸ì£¼ ìë™ í¸ì… (Top Kì¤‘ OUT ì¢…ëª© ìš°ì„ )
     sorted_candidates = sorted(candidates_map.values(), key=lambda x: float(x.get("avg_return_pct", 0)), reverse=True)
     add_candidates = []
     for c in sorted_candidates:
         code = c["code"]
         if code not in old_codes:
             add_candidates.append(c)
diff --git a/strategy/__init__.py b/strategy/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/strategy/kosdaq/__init__.py b/strategy/kosdaq/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/strategy/kosdaq/pullback.py b/strategy/kosdaq/pullback.py
new file mode 100644
index 0000000000000000000000000000000000000000..0d43d6c3bf3425202b4ce77cf409a05ab46ef989
--- /dev/null
+++ b/strategy/kosdaq/pullback.py
@@ -0,0 +1,5 @@
+from __future__ import annotations
+
+from trader import signals
+
+__all__ = ["signals"]
diff --git a/strategy/kosdaq/rolling_entry.py b/strategy/kosdaq/rolling_entry.py
new file mode 100644
index 0000000000000000000000000000000000000000..c19b5a3fcaee45a40e34ea027eaf4f76bbd62e5b
--- /dev/null
+++ b/strategy/kosdaq/rolling_entry.py
@@ -0,0 +1,11 @@
+from __future__ import annotations
+
+from typing import Any
+
+
+def run_trade_loop(capital_override: float | None = None) -> Any:
+    # Delay import to avoid any potential circular initialization between
+    # strategy and trader modules while still delegating to the legacy runner.
+    from trader import legacy_kosdaq_runner
+
+    return legacy_kosdaq_runner.main(capital_override=capital_override)
diff --git a/strategy/kosdaq/universe.py b/strategy/kosdaq/universe.py
new file mode 100644
index 0000000000000000000000000000000000000000..7ad7b920bd8b9b690bb4b061ef2cbbb98135eaaf
--- /dev/null
+++ b/strategy/kosdaq/universe.py
@@ -0,0 +1,10 @@
+from __future__ import annotations
+
+from typing import List, Dict
+
+from rolling_k_auto_trade_api.best_k_meta_strategy import get_kosdaq_top_n
+
+
+def kosdaq_universe(top_n: int) -> List[Dict[str, str]]:
+    df = get_kosdaq_top_n(n=top_n)
+    return [{"code": str(row.Code).zfill(6), "name": row.Name} for row in df.itertuples(index=False)]
diff --git a/strategy/kospi/__init__.py b/strategy/kospi/__init__.py
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/strategy/kospi/rebalance.py b/strategy/kospi/rebalance.py
new file mode 100644
index 0000000000000000000000000000000000000000..b05fc25a151eb9e8c97b08684c2cd42bd267260c
--- /dev/null
+++ b/strategy/kospi/rebalance.py
@@ -0,0 +1,162 @@
+from __future__ import annotations
+
+import logging
+from datetime import datetime, timedelta, timezone
+from typing import Dict, List, Tuple
+
+import FinanceDataReader as fdr
+import numpy as np
+import pandas as pd
+
+from rolling_k_auto_trade_api.adjust_price_to_tick import adjust_price_to_tick
+from rolling_k_auto_trade_api.kis_api import get_price_quote
+from .universe import kospi_universe
+
+logger = logging.getLogger(__name__)
+
+KST = timezone(timedelta(hours=9))
+INDEX_CODE = "KS11"
+DEFAULT_TOP_N = 100
+MAX_POSITIONS = 10
+
+
+def _latest_index_history(days: int = 400) -> pd.DataFrame:
+    today = datetime.now(tz=KST).date()
+    start = today - timedelta(days=days)
+    df = fdr.DataReader(INDEX_CODE, start=start, end=today)
+    if df is None or df.empty:
+        raise ValueError("no index history")
+    df = df.dropna(subset=["Close"]).reset_index()
+    if "Date" not in df.columns:
+        df = df.rename_axis("Date").reset_index()
+    df["date"] = pd.to_datetime(df["Date"]).dt.date
+    df = df[["date", "Close"]].rename(columns={"Close": "close"}).sort_values("date")
+    return df
+
+
+def evaluate_regime() -> Dict[str, float | bool]:
+    history = _latest_index_history()
+    close = pd.Series(history["close"].astype(float))
+    if len(close) < 200:
+        raise ValueError("insufficient index history for regime")
+    ma_200 = close.rolling(200).mean().iloc[-1]
+    trend_ok = bool(close.iloc[-1] > ma_200)
+    momentum_ok = False
+    if len(close) > 63:
+        momentum_ok = bool((close.iloc[-1] / close.shift(63).iloc[-1] - 1) * 100 > 0)
+    log_ret = np.log(close / close.shift(1)).dropna()
+    vol_ok = False
+    if len(log_ret) >= 60:
+        vol_20 = log_ret.tail(20).std()
+        vol_60 = log_ret.tail(60).std()
+        vol_ok = bool(vol_20 < vol_60 * 1.2)
+    regime_on = sum([trend_ok, momentum_ok, vol_ok]) >= 2
+    daily_change = 0.0
+    if len(close) >= 2:
+        daily_change = float((close.iloc[-1] / close.iloc[-2] - 1) * 100)
+    logger.info(
+        "[KOSPI_CORE][REGIME] %s | trend=%s | momentum=%s | vol=%s",
+        "ON" if regime_on else "OFF",
+        trend_ok,
+        momentum_ok,
+        vol_ok,
+    )
+    return {
+        "regime_on": regime_on,
+        "trend_ok": trend_ok,
+        "momentum_ok": momentum_ok,
+        "vol_ok": vol_ok,
+        "daily_change_pct": daily_change,
+    }
+
+
+def _stock_history(code: str, days: int = 220) -> pd.DataFrame:
+    today = datetime.now(tz=KST).date()
+    start = today - timedelta(days=days)
+    df = fdr.DataReader(code, start=start, end=today)
+    if df is None or df.empty:
+        return pd.DataFrame()
+    df = df.dropna(subset=["Close"]).reset_index()
+    if "Date" not in df.columns:
+        df = df.rename_axis("Date").reset_index()
+    df["date"] = pd.to_datetime(df["Date"]).dt.date
+    df = df[["date", "Close"]].rename(columns={"Close": "close"}).sort_values("date")
+    return df
+
+
+def _compute_metrics(code: str) -> Dict[str, float] | None:
+    df = _stock_history(code)
+    if df.empty or len(df) < 126:
+        return None
+    close = pd.Series(df["close"].astype(float))
+    ret_6m = float((close.iloc[-1] / close.iloc[-126] - 1) * 100)
+    vol_6m = float(close.pct_change().dropna().tail(126).std())
+    return {"code": code, "ret_6m": ret_6m, "vol_6m": vol_6m}
+
+
+def _select_candidates(universe: List[Dict[str, str]]) -> List[str]:
+    metrics: List[Dict[str, float]] = []
+    for item in universe:
+        code = item.get("code")
+        m = _compute_metrics(code)
+        if m:
+            metrics.append(m)
+    if not metrics:
+        logger.warning("[KOSPI_CORE] no metrics available for selection")
+        return []
+    metrics = sorted(metrics, key=lambda x: x["ret_6m"], reverse=True)
+    top_cut = max(1, int(len(metrics) * 0.4))
+    top_momentum = {m["code"] for m in metrics[:top_cut]}
+
+    vol_sorted = sorted(metrics, key=lambda x: x["vol_6m"])
+    vol_cut = max(1, int(len(vol_sorted) * 0.3))
+    low_vol = {m["code"] for m in vol_sorted[:vol_cut]}
+
+    intersection = [m for m in metrics if m["code"] in top_momentum and m["code"] in low_vol]
+    intersection = sorted(intersection, key=lambda x: (-x["ret_6m"], x["vol_6m"]))
+    final_n = min(MAX_POSITIONS, len(intersection))
+    return [m["code"] for m in intersection[:final_n]]
+
+
+def build_target_allocations(
+    total_capital: float, top_n: int = DEFAULT_TOP_N, max_positions: int = MAX_POSITIONS
+) -> Tuple[List[Dict[str, float]], Dict[str, List[str]]]:
+    universe = kospi_universe(top_n)
+    if not universe:
+        logger.warning("[KOSPI_CORE] universe empty")
+        return [], {"selected": []}
+    selected_codes = _select_candidates(universe)[:max_positions]
+    if not selected_codes:
+        return [], {"selected": []}
+
+    weight = min(1.0 / len(selected_codes), 0.15)
+    targets: List[Dict[str, float]] = []
+    for item in universe:
+        code = item.get("code")
+        if code not in selected_codes:
+            continue
+        try:
+            quote = get_price_quote(code)
+            price = float(quote.get("askp1") or quote.get("stck_prpr") or 0)
+        except Exception:
+            logger.exception("[KOSPI_CORE] quote fail for %s", code)
+            price = 0.0
+        price = adjust_price_to_tick(price) if price else 0.0
+        if price <= 0:
+            logger.warning("[KOSPI_CORE] skip %s (no price)", code)
+            continue
+        target_val = total_capital * weight
+        target_qty = int(target_val // price) if price > 0 else 0
+        targets.append(
+            {
+                "code": code,
+                "name": item.get("name") or "",
+                "weight": weight,
+                "target_value": target_val,
+                "last_price": price,
+                "target_qty": target_qty,
+            }
+        )
+
+    logger.info("[KOSPI_CORE][SELECTION] selected=%s", selected_codes)
+    return targets, {"selected": selected_codes}
diff --git a/strategy/kospi/signals.py b/strategy/kospi/signals.py
new file mode 100644
index 0000000000000000000000000000000000000000..4d15968efb548ce7f0c74ac2cc3cd07726d4f776
--- /dev/null
+++ b/strategy/kospi/signals.py
@@ -0,0 +1,150 @@
+from __future__ import annotations
+
+import logging
+from datetime import datetime, time, timedelta, timezone
+from typing import Dict, List
+
+from rolling_k_auto_trade_api.adjust_price_to_tick import adjust_price_to_tick
+from rolling_k_auto_trade_api.kis_api import (
+    inquire_balance,
+    inquire_cash_balance,
+    send_order,
+    get_price_quote,
+)
+
+logger = logging.getLogger(__name__)
+
+KST = timezone(timedelta(hours=9))
+
+
+def _current_positions() -> Dict[str, Dict[str, float]]:
+    pos: Dict[str, Dict[str, float]] = {}
+    for row in inquire_balance():
+        code = str(row.get("pdno") or row.get("code") or "").zfill(6)
+        qty = int(float(row.get("hldg_qty") or row.get("qty") or 0))
+        price = float(row.get("pchs_avg_pric") or row.get("avg_price") or 0)
+        pos[code] = {"qty": qty, "avg_price": price}
+    return pos
+
+
+def _buy_window_open() -> bool:
+    now = datetime.now(tz=KST).time()
+    return now >= time(9, 30)
+
+
+def execute_rebalance(
+    targets: List[Dict[str, float]],
+    cash: float,
+    tag: str,
+    *,
+    allow_buys: bool = True,
+) -> List[Dict[str, str]]:
+    fills: List[Dict[str, str]] = []
+    positions = _current_positions()
+    target_map = {str(t.get("code") or "").zfill(6): t for t in targets}
+    all_codes = set(positions.keys()) | set(target_map.keys())
+    buys = sells = 0
+    available_cash = min(float(cash), float(inquire_cash_balance() or 0))
+
+    before_snapshot = {code: data.get("qty", 0) for code, data in positions.items() if data.get("qty")}
+    target_snapshot = {
+        code: int(float(payload.get("target_qty") or 0))
+        for code, payload in target_map.items()
+        if float(payload.get("target_qty") or 0) > 0
+    }
+    delta_snapshot = {
+        code: target_snapshot.get(code, 0) - before_snapshot.get(code, 0)
+        for code in sorted(all_codes)
+        if before_snapshot.get(code, 0) != target_snapshot.get(code, 0)
+    }
+    logger.info(
+        "%s[KOSPI_CORE][DIFF] before=%s targets=%s delta=%s",
+        tag + " " if tag else "",
+        before_snapshot,
+        target_snapshot,
+        delta_snapshot,
+    )
+
+    orders: List[Dict[str, float]] = []
+    for code in sorted(all_codes):
+        current = positions.get(code, {})
+        current_qty = int(current.get("qty") or 0)
+        target = target_map.get(code)
+        target_qty = int(target.get("target_qty") or 0) if target else 0
+        weight = float(target.get("weight") or 0) if target else 0.0
+        if not target:
+            weight = 0.0
+        try:
+            quote = get_price_quote(code)
+            mkt_price = float(quote.get("askp1") or quote.get("stck_prpr") or target.get("last_price") if target else 0)
+        except Exception:
+            logger.exception("%s quote fail for %s", tag, code)
+            mkt_price = float(target.get("last_price") or 0 if target else 0)
+        mkt_price = adjust_price_to_tick(mkt_price) if mkt_price else 0.0
+
+        if weight <= 0 or target_qty <= 0:
+            delta_qty = -current_qty
+        else:
+            delta_qty = target_qty - current_qty
+
+        if delta_qty == 0:
+            continue
+        side = "buy" if delta_qty > 0 else "sell"
+        qty = abs(delta_qty)
+        orders.append(
+            {
+                "code": code,
+                "side": side,
+                "qty": qty,
+                "mkt_price": mkt_price,
+                "allow_weight": weight,
+            }
+        )
+
+    # Execute sells first to release cash before any new buys.
+    for order in [o for o in orders if o["side"] == "sell"]:
+        code, qty, mkt_price = order["code"], order["qty"], order["mkt_price"]
+        try:
+            res = send_order(code, qty=qty, price=None, side="sell", order_type="market")
+            fills.append({"code": code, "side": "sell", "qty": qty, "resp": str(res)})
+            sells += 1
+            logger.info("%s SELL %s qty=%s price=%s", tag, code, qty, mkt_price)
+            if mkt_price > 0:
+                available_cash += qty * mkt_price
+        except Exception:
+            logger.exception("%s order fail %s qty=%s", tag, code, qty)
+
+    for order in [o for o in orders if o["side"] == "buy"]:
+        code, qty, mkt_price, weight = (
+            order["code"],
+            order["qty"],
+            order["mkt_price"],
+            order["allow_weight"],
+        )
+        if not allow_buys:
+            logger.info("%s skip buy %s (buys disabled)", tag, code)
+            continue
+        if not _buy_window_open():
+            logger.info("%s skip buy %s (pre-open window)", tag, code)
+            continue
+        if mkt_price <= 0:
+            logger.info("%s skip buy %s (no price)", tag, code)
+            continue
+        affordable = int(available_cash // mkt_price)
+        if affordable <= 0:
+            logger.info("%s skip buy %s (insufficient cash)", tag, code)
+            continue
+        qty = min(qty, affordable)
+        try:
+            res = send_order(code, qty=qty, price=None, side="buy", order_type="market")
+            fills.append({"code": code, "side": "buy", "qty": qty, "resp": str(res)})
+            buys += 1
+            logger.info("%s BUY %s qty=%s price=%s", tag, code, qty, mkt_price)
+            available_cash = max(0.0, available_cash - qty * mkt_price)
+        except Exception:
+            logger.exception("%s order fail %s qty=%s", tag, code, qty)
+    invested = sum(float(t.get("target_value") or 0) for t in targets)
+    cash_left = max(float(available_cash), 0.0)
+    logger.info("%s[KOSPI_CORE][REBALANCE] BUY=%s SELL=%s", tag + " " if tag else "", buys, sells)
+    logger.info("%s[KOSPI_CORE][PORTFOLIO] invested=%.0f cash=%.0f", tag + " " if tag else "", invested, cash_left)
+    return fills
diff --git a/strategy/kospi/universe.py b/strategy/kospi/universe.py
new file mode 100644
index 0000000000000000000000000000000000000000..58fcf890a6fd5bb71539dc4f32b58e89445a95fa
--- /dev/null
+++ b/strategy/kospi/universe.py
@@ -0,0 +1,10 @@
+from __future__ import annotations
+
+from typing import List, Dict
+
+from rolling_k_auto_trade_api.best_k_meta_strategy import get_kospi_top_n
+
+
+def kospi_universe(top_n: int) -> List[Dict[str, str]]:
+    df = get_kospi_top_n(n=top_n)
+    return [{"code": str(row.Code).zfill(6), "name": row.Name} for row in df.itertuples(index=False)]
diff --git a/trader/legacy_kosdaq_runner.py b/trader/legacy_kosdaq_runner.py
new file mode 100644
index 0000000000000000000000000000000000000000..bb43aca8a424795b6b996333ba3c4ee240edb2ca
--- /dev/null
+++ b/trader/legacy_kosdaq_runner.py
@@ -0,0 +1,1205 @@
+# -*- coding: utf-8 -*-
+"""ê±°ë˜ ë©”ì¸ ë£¨í”„.
+
+ê¸°ì¡´ trader.pyì˜ ì„¤ì •/ìœ í‹¸ì„ ë¶„ë¦¬í•˜ê³ , ë©”ì¸ ì§„ì…ì ë§Œ ë‚¨ê²¨ ì „ëµ ì¶”ê°€ê°€
+ì‰¬ìš´ êµ¬ì¡°ë¡œ ë³€ê²½í–ˆë‹¤.
+"""
+from __future__ import annotations
+
+import time
+from datetime import datetime, time as dtime, timedelta
+from typing import Any, Dict, List, Tuple, TYPE_CHECKING
+
+
+from .config import (
+    DAILY_CAPITAL,
+    FORCE_SELL_PASSES_CLOSE,
+    FORCE_SELL_PASSES_CUTOFF,
+    KST,
+    RATE_SLEEP_SEC,
+    SELL_ALL_BALANCES_AT_CUTOFF,
+    SELL_FORCE_TIME,
+    SLIPPAGE_ENTER_GUARD_PCT,
+    USE_PULLBACK_ENTRY,
+    PULLBACK_MAX_BUYS_PER_DAY,
+    _cfg,
+    logger,
+)
+from .core import *  # noqa: F401,F403 - ì „ëµ ìœ í‹¸ ì „ì²´ ë…¸ì¶œë¡œ í™•ì¥ì„± í™•ë³´
+
+if TYPE_CHECKING:
+    # core ìª½ì— êµ¬í˜„ë¼ ìˆëŠ” í—¬í¼ë“¤ì„ íƒ€ì…ì²´ì»¤ì—ê²Œë§Œ ëª…ì‹œì ìœ¼ë¡œ ì•Œë ¤ì¤€ë‹¤.
+    from .core import (
+        _this_iso_week_key,
+        _get_effective_ord_cash,
+        _to_float,
+        _to_int,
+        _weight_to_qty,
+        _classify_champion_grade,
+        _update_market_regime,
+        _notional_to_qty,
+        _fetch_balances,
+        _init_position_state_from_balance,
+        _sell_once,
+        _adaptive_exit,
+        _compute_daily_entry_context,
+        _compute_intraday_entry_context,
+        _safe_get_price,
+        _round_to_tick,
+        _init_position_state,
+        _detect_pullback_reversal,
+        _has_bullish_trend_structure,
+    )
+
+
+def main(capital_override: float | None = None):
+    effective_capital = int(capital_override) if capital_override is not None else DAILY_CAPITAL
+    kis = KisAPI()
+
+    rebalance_date = get_rebalance_anchor_date()
+    logger.info(f"[â„¹ï¸ ë¦¬ë°¸ëŸ°ì‹± ê¸°ì¤€ì¼(KST)]: {rebalance_date} (anchor={REBALANCE_ANCHOR}, ref={WEEKLY_ANCHOR_REF})")
+    logger.info(
+        f"[â±ï¸ ì»¤íŠ¸ì˜¤í”„(KST)] SELL_FORCE_TIME={SELL_FORCE_TIME.strftime('%H:%M')} / ì „ì²´ì”ê³ ë§¤ë„={SELL_ALL_BALANCES_AT_CUTOFF} / "
+        f"íŒ¨ìŠ¤(ì»¤íŠ¸ì˜¤í”„/ë§ˆê°)={FORCE_SELL_PASSES_CUTOFF}/{FORCE_SELL_PASSES_CLOSE}"
+    )
+    logger.info(f"[ğŸ’° CAPITAL] {effective_capital:,}ì› (configured DAILY_CAPITAL={DAILY_CAPITAL:,})")
+    logger.info(f"[ğŸ›¡ï¸ SLIPPAGE_ENTER_GUARD_PCT] {SLIPPAGE_ENTER_GUARD_PCT:.2f}%")
+
+    # ìƒíƒœ ë³µêµ¬
+    state_loaded_at = datetime.now(KST)
+    state_loaded_date = state_loaded_at.strftime("%Y-%m-%d")
+    state_loaded_str = state_loaded_at.strftime("%Y-%m-%d %H:%M:%S")
+    state_loaded_midnight = f"{state_loaded_date} 00:00:00"
+
+    holding, traded = load_state()
+
+    if isinstance(traded, (set, list, tuple)):
+        logger.warning(
+            f"[STATE-MIGRATE] traded íƒ€ì… {type(traded)} â†’ dictë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜(ì¤‘ë³µ ì§„ì… ê°€ë“œ ìœ ì§€)"
+        )
+        traded = {
+            code: {"buy_time": state_loaded_midnight, "qty": 0, "price": 0.0}
+            for code in traded
+        }
+    elif not isinstance(traded, dict):
+        logger.warning(
+            f"[STATE-FORMAT] traded íƒ€ì… {type(traded)} ì§€ì› ì•ˆ í•¨ â†’ ë¹ˆ dictë¡œ ì¬ì„¤ì •"
+        )
+        traded = {}
+
+    def _traded_codes(traded_state: Any) -> List[str]:
+        if isinstance(traded_state, dict):
+            return list(traded_state.keys())
+        return []
+
+    def _traded_today(traded_state: Any, today_prefix: str) -> set:
+        if not isinstance(traded_state, dict):
+            return set()
+
+        today_codes = set()
+        for code, payload in traded_state.items():
+            payload = payload or {}
+            buy_time = payload.get("buy_time")
+            status = payload.get("status")
+            # pending/other ìƒíƒœëŠ” ì¬ì‹œë„ í—ˆìš©, filled/ê¸°ì¡´(None)ë§Œ ì¤‘ë³µ ë°©ì§€
+            if status not in (None, "filled"):
+                continue
+            if isinstance(buy_time, str) and buy_time.startswith(today_prefix):
+                today_codes.add(code)
+        return today_codes
+
+    def _record_trade(traded_state: Any, code: str, payload: Dict[str, Any]) -> None:
+        try:
+            traded_state[code] = payload
+        except Exception:
+            logger.warning(f"[TRADED-STATE] tradedì— ì½”ë“œ ì¶”ê°€ ì‹¤íŒ¨: type={type(traded_state)}")
+
+    def _cleanup_expired_pending(traded_state: dict, now_dt: datetime, ttl_sec: int = 300) -> None:
+        if not isinstance(traded_state, dict):
+            return
+
+        for code, payload in list(traded_state.items()):
+            payload = payload or {}
+            if payload.get("status") != "pending":
+                continue
+
+            ts = payload.get("pending_since") or payload.get("buy_time")
+            if not isinstance(ts, str):
+                continue
+
+            try:
+                pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(tzinfo=now_dt.tzinfo)
+                if (now_dt - pending_dt).total_seconds() > ttl_sec:
+                    logger.warning(f"[PENDING-EXPIRE] {code}: {ttl_sec}s ì´ˆê³¼ â†’ pending ì œê±°")
+                    traded_state.pop(code, None)
+            except Exception:
+                continue
+
+    def _pending_block(traded_state: dict, code: str, now_dt: datetime, block_sec: int = 45) -> bool:
+        if not isinstance(traded_state, dict):
+            return False
+        payload = traded_state.get(code) or {}
+        if payload.get("status") != "pending":
+            return False
+
+        ts = payload.get("pending_since") or payload.get("buy_time")
+        if not isinstance(ts, str):
+            return True
+
+        try:
+            pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(tzinfo=now_dt.tzinfo)
+            return (now_dt - pending_dt).total_seconds() <= block_sec
+        except Exception:
+            return True
+
+    def _is_balance_reflected(code: str, prev_qty: int = 0, delay_sec: float = 1.0) -> bool:
+        try:
+            time.sleep(delay_sec)
+            balances = _fetch_balances(kis, ttl_sec=0)
+        except Exception as e:
+            logger.warning(f"[BAL-REFRESH-FAIL] {code}: ì”ê³  í™•ì¸ ì‹¤íŒ¨ {e}")
+            return False
+
+        for row in balances:
+            try:
+                if str(row.get("code")).zfill(6) != str(code).zfill(6):
+                    continue
+                qty_here = _to_int(row.get("qty") or 0)
+                sellable_here = _to_int((row.get("sell_psbl_qty") or row.get("ord_psbl_qty")) or 0)
+                baseline_qty = max(0, int(prev_qty))
+                if qty_here > baseline_qty or sellable_here > baseline_qty:
+                    return True
+            except Exception:
+                continue
+
+        return False
+
+    def _is_order_success(res: Any) -> bool:
+        if not isinstance(res, dict):
+            return False
+        rt_cd = str(res.get("rt_cd") or res.get("rtCode") or "").strip()
+        return rt_cd in ("0", "0000", "OK")
+
+    def _extract_fill_price(res: Any, fallback_price: float) -> float:
+        if isinstance(res, dict):
+            output = res.get("output") or {}
+            for payload in (output, res):
+                for key in (
+                    # ì²´ê²°ê°€/í‰ê· ê°€ í›„ë³´
+                    "ccld_prc",
+                    "ccld_unpr",
+                    "tot_ccld_unpr",
+                    "tot_ccld_prc",
+                    "avg_price",
+                    "avg_prvs",
+                    "fill_price",
+                    # ì£¼ë¬¸ê°€(í›„ìˆœìœ„)
+                    "prdt_price",
+                    "ord_unpr",
+                    "ord_prc",
+                    "order_price",
+                ):
+                    val = None
+                    if isinstance(payload, dict):
+                        val = payload.get(key)
+                    if val not in (None, ""):
+                        try:
+                            return float(val)
+                        except Exception:
+                            continue
+        return float(fallback_price)
+
+    logger.info(f"[ìƒíƒœë³µêµ¬] holding: {list(holding.keys())}, traded: {_traded_codes(traded)}")
+
+    pullback_buys_today = 0
+    pullback_buy_date = datetime.now(KST).date()
+
+    # === [NEW] ì£¼ê°„ ë¦¬ë°¸ëŸ°ì‹± ê°•ì œ/ì¤‘ë³µ ë°©ì§€ ===
+    targets: List[Dict[str, Any]] = []
+    if REBALANCE_ANCHOR == "weekly":
+        if should_weekly_rebalance_now():
+            targets = fetch_rebalancing_targets(rebalance_date)
+            # ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ë¥¼ ìœ„í•´ ì¦‰ì‹œ ìŠ¤íƒ¬í”„(í•„ìš” ì‹œ FORCEë¡œ ì¬ì‹¤í–‰ ê°€ëŠ¥)
+            stamp_weekly_done()
+            logger.info(f"[REBALANCE] ì´ë²ˆ ì£¼ ë¦¬ë°¸ëŸ°ì‹± ì‹¤í–‰ ê¸°ë¡ ì €ì¥({_this_iso_week_key()})")
+        else:
+            logger.info("[REBALANCE] ì´ë²ˆ ì£¼ ì´ë¯¸ ì‹¤í–‰ë¨ â†’ ì‹ ê·œ ë¦¬ë°¸ëŸ°ì‹± ìƒëµ (ë³´ìœ  ê´€ë¦¬ë§Œ)")
+    else:
+        # today/monthly ë“± ë‹¤ë¥¸ ì•µì»¤ ëª¨ë“œëŠ” ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ë°”ë¡œ í˜¸ì¶œ
+        targets = fetch_rebalancing_targets(rebalance_date)
+
+    # === [NEW] ì˜ˆì‚° ê°€ë“œ: ì˜ˆìˆ˜ê¸ˆì´ 0/ë¶€ì¡±ì´ë©´ ì‹ ê·œ ë§¤ìˆ˜ë§Œ ìŠ¤í‚µ ===
+    effective_cash = _get_effective_ord_cash(kis, soft_cap=effective_capital)
+    if effective_cash <= 0:
+        can_buy = False
+        logger.warning("[BUDGET] ìœ íš¨ ì˜ˆì‚° 0 â†’ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ(ë³´ìœ  ê´€ë¦¬ë§Œ ìˆ˜í–‰)")
+    else:
+        can_buy = True
+    logger.info(
+        f"[BUDGET] today effective cash = {effective_cash:,} KRW (capital base={effective_capital:,})"
+    )
+
+    # ë¦¬ë°¸ëŸ°ì‹± ëŒ€ìƒ í›„ì²˜ë¦¬: qty ì—†ê³  weightë§Œ ìˆìœ¼ë©´ ë°°ì • ìë³¸ìœ¼ë¡œ ìˆ˜ëŸ‰ ê³„ì‚°
+    processed_targets: Dict[str, Any] = {}
+    for t in targets:
+        code = t.get("stock_code") or t.get("code")
+        if not code:
+            continue
+        name = t.get("name") or t.get("ì¢…ëª©ëª…")
+        k_best = t.get("best_k") or t.get("K") or t.get("k")
+        target_price = _to_float(t.get("ëª©í‘œê°€") or t.get("target_price"))
+        qty = _to_int(t.get("ë§¤ìˆ˜ìˆ˜ëŸ‰") or t.get("qty"), 0)
+        weight = t.get("weight")
+        strategy = t.get("strategy") or "ì „ì›” rolling K ìµœì í™”"
+        avg_return_pct = _to_float(t.get("avg_return_pct") or t.get("ìˆ˜ìµë¥ (%)"), 0.0)
+        win_rate_pct = _to_float(t.get("win_rate_pct") or t.get("ìŠ¹ë¥ (%)"), 0.0)
+        mdd_pct = _to_float(t.get("mdd_pct") or t.get("MDD(%)"), 0.0)
+        trades = _to_int(t.get("trades"), 0)
+        sharpe_m = _to_float(t.get("sharpe_m"), 0.0)
+        cumret_pct = _to_float(t.get("cumulative_return_pct") or t.get("ìˆ˜ìµë¥ (%)"), 0.0)
+
+        if qty <= 0 and weight is not None:
+            ref_px = _to_float(t.get("close")) or _to_float(t.get("prev_close"))
+            try:
+                qty = _weight_to_qty(kis, code, float(weight), effective_capital, ref_price=ref_px)
+            except Exception as e:
+                logger.warning("[REBALANCE] weightâ†’qty ë³€í™˜ ì‹¤íŒ¨ %s: %s", code, e)
+                qty = 0
+
+        processed_targets[code] = {
+            "code": code,
+            "name": name,
+            "best_k": k_best,
+            "target_price": target_price,
+            "qty": qty,
+            "strategy": strategy,
+            "avg_return_pct": avg_return_pct,
+            "win_rate_pct": win_rate_pct,
+            "mdd_pct": mdd_pct,
+            "trades": trades,
+            "sharpe_m": sharpe_m,
+            "cumulative_return_pct": cumret_pct,
+            "prev_open": t.get("prev_open"),
+            "prev_high": t.get("prev_high"),
+            "prev_low": t.get("prev_low"),
+            "prev_close": t.get("prev_close"),
+            "prev_volume": t.get("prev_volume"),
+        }
+
+    filtered_targets: Dict[str, Any] = {}
+    for code, info in processed_targets.items():
+        trades = _to_int(info.get("trades"), 0)
+        win_rate = _to_float(info.get("win_rate_pct"), 0.0)
+        mdd = abs(_to_float(info.get("mdd_pct"), 0.0) or 0.0)
+        sharpe = _to_float(info.get("sharpe_m"), 0.0)
+
+        if (
+            trades < CHAMPION_MIN_TRADES
+            or win_rate < CHAMPION_MIN_WINRATE
+            or mdd > CHAMPION_MAX_MDD
+            or sharpe < CHAMPION_MIN_SHARPE
+        ):
+            logger.info(
+                f"[CHAMPION_FILTER_SKIP] {code}: trades={trades}, win={win_rate:.1f}%, mdd={mdd:.1f}%, sharpe={sharpe:.2f}"
+            )
+            continue
+
+        filtered_targets[code] = info
+
+    processed_targets = filtered_targets
+
+    # ì±”í”¼ì–¸ ë“±ê¸‰í™” (A/B/C) â†’ ì‹¤ì œ ë§¤ìˆ˜ í›„ë³´ëŠ” Aê¸‰ë§Œ ì‚¬ìš©
+    graded_targets: Dict[str, Any] = {}
+    grade_counts = {"A": 0, "B": 0, "C": 0}
+    for code, info in processed_targets.items():
+        grade = _classify_champion_grade(info)
+        info["champion_grade"] = grade
+        graded_targets[code] = info
+        grade_counts[grade] = grade_counts.get(grade, 0) + 1
+
+    logger.info(
+        "[CHAMPION-GRADE] A:%d / B:%d / C:%d (A/Bê¸‰ ì‹¤ì œ ë§¤ìˆ˜)",
+        grade_counts.get("A", 0),
+        grade_counts.get("B", 0),
+        grade_counts.get("C", 0),
+    )
+
+    # ğŸ”½ ì—¬ê¸° í•„í„°ë¥¼ A â†’ A/B ë¡œ
+    processed_targets = {
+        k: v
+        for k, v in graded_targets.items()
+        if v.get("champion_grade") in ("A", "B")
+    }
+    # === [ì±”í”¼ì–¸ & ë ˆì§ ìƒì„¸ ë¡œê·¸] ===
+    try:
+        if isinstance(processed_targets, dict) and len(processed_targets) > 0:
+            # 1) ì±”í”¼ì–¸ 1ê°œ(1ìˆœìœ„)ë§Œ ë½‘ì•„ì„œ ë¡œê·¸ (processed_targetsê°€ dictì¼ ë•Œ)
+            first_code = next(iter(processed_targets.keys()))
+            champion_one = processed_targets.get(first_code)
+
+            # champion dict ì•ˆì— codeê°€ ì—†ìœ¼ë©´ ë³´ê°•
+            if isinstance(champion_one, dict) and "code" not in champion_one:
+                champion_one = {**champion_one, "code": first_code}
+
+            # 2) regime_stateëŠ” ì´ë¯¸ ë§Œë“  regime(ë˜ëŠ” _update_market_regime(kis) ê²°ê³¼)ë¥¼ ë„£ì–´ì•¼ í•¨
+            #    ì´ ë¸”ë¡ ì§ì „ì— regime = _update_market_regime(kis) ê°€ ìˆì–´ì•¼ í•¨
+            #    ì—†ìœ¼ë©´ ì—¬ê¸°ì„œ í•œ ë²ˆ êµ¬í•´ë„ ë¨:
+            try:
+                regime_state = regime  # regime ë³€ìˆ˜ê°€ ìœ„ì—ì„œ ë§Œë“¤ì–´ì ¸ ìˆìœ¼ë©´ ì´ê±¸ ì‚¬ìš©
+            except NameError:
+                regime_state = _update_market_regime(kis)
+
+            # 3) contextëŠ” ë¬¸ìì—´ë¡œ(í˜¹ì€ execution.pyë¥¼ Anyë¡œ ë°”ê¿¨ë‹¤ë©´ dictë„ ê°€ëŠ¥)
+            context = "rebalance_api"
+
+            log_champion_and_regime(logger, champion_one, regime_state, context)
+    except Exception as e:
+        logger.warning(f"[CHAMPION_LOG] ì±”í”¼ì–¸/ë ˆì§ ë¡œê·¸ ìƒì„± ì‹¤íŒ¨: {e}")
+
+    # í˜„ì¬ ë ˆì§ ê¸°ë°˜ ìë³¸ ìŠ¤ì¼€ì¼ë§ & ì±”í”¼ì–¸ ì„ íƒ
+    selected_targets: Dict[str, Any] = {}
+    regime = _update_market_regime(kis)
+    pct_change = regime.get("pct_change") or 0.0
+    mode = regime.get("mode") or "neutral"
+    stage = regime.get("bear_stage") or 0
+    regime_key = regime.get("key")
+    R20 = regime.get("R20")
+    D1 = regime.get("D1")
+
+    REGIME_CAP_TABLE = {
+        ("bull", 0): 1.0,
+        ("neutral", 0): 0.8,
+        ("bear", 0): 0.7,
+        ("bear", 1): 0.5,
+        ("bear", 2): 0.3,
+    }
+
+    REGIME_WEIGHTS = {
+        ("bull", 0): [0.22, 0.20, 0.18, 0.16, 0.14, 0.10],
+        ("neutral", 0): [0.20, 0.18, 0.16, 0.14, 0.12, 0.10, 0.10],
+        ("bear", 0): [0.18, 0.16, 0.14, 0.12, 0.10],
+        ("bear", 1): [0.16, 0.14, 0.12],
+        ("bear", 2): [0.14, 0.12, 0.10],
+    }
+
+    REGIME_MAX_ACTIVE = {
+        ("bull", 0): 6,
+        ("neutral", 0): 5,
+        ("bear", 0): 4,
+        ("bear", 1): 3,
+        ("bear", 2): 2,
+    }
+
+    REG_PARTIAL_S1 = float(_cfg("REG_PARTIAL_S1") or "0.3")
+    REG_PARTIAL_S2 = float(_cfg("REG_PARTIAL_S2") or "0.3")
+    TRAIL_PCT_BULL = float(_cfg("TRAIL_PCT_BULL") or "0.025")
+    TRAIL_PCT_BEAR = float(_cfg("TRAIL_PCT_BEAR") or "0.012")
+    TP_PROFIT_PCT_BULL = float(_cfg("TP_PROFIT_PCT_BULL") or "3.5")
+
+    cap_scale = REGIME_CAP_TABLE.get(regime.get("key"), 0.8)
+    ord_cash = _get_effective_ord_cash(kis, soft_cap=effective_capital)
+    capital_base = min(ord_cash, int(CAP_CAP * effective_capital))
+    capital_active = int(min(capital_base * cap_scale, effective_capital))
+    logger.info(
+        f"[REGIME-CAP] mode={mode} stage={stage} R20={R20 if R20 is not None else 'N/A'} "
+        f"D1={D1 if D1 is not None else 'N/A'} "
+        f"ord_cash(effective)={ord_cash:,} base={capital_base:,} active={capital_active:,} "
+        f"scale={cap_scale:.2f}"
+    )
+
+    # ë ˆì§ë³„ ìµœëŒ€ ë³´ìœ  ì¢…ëª© ìˆ˜
+    n_active = REGIME_MAX_ACTIVE.get(regime_key, REGIME_MAX_ACTIVE.get(("neutral", 0), 3))
+
+    scored: List[Tuple[str, float, bool]] = []
+
+    for code, info in processed_targets.items():
+        score = _to_float(info.get("composite_score"), 0.0) or 0.0
+
+        # ë‹¨ê¸° ëª¨ë©˜í…€ ê°•ì„¸ ì—¬ë¶€ (is_strong_momentum)ë¡œ ë²„í‚· êµ¬ë¶„
+        try:
+            strong = is_strong_momentum(kis, code)
+        except Exception as e:
+            logger.warning("[REBALANCE] ëª¨ë©˜í…€ íŒë³„ ì‹¤íŒ¨ %s: %s", code, e)
+            strong = False
+
+        scored.append((code, score, strong))
+
+    # ëª¨ë©˜í…€ strong ë²„í‚· ìš°ì„ , ê·¸ ë‹¤ìŒ ë‚˜ë¨¸ì§€ ì¤‘ì—ì„œ ì ìˆ˜ ìˆœìœ¼ë¡œ ì±„ìš°ê¸°
+    strong_bucket = [x for x in scored if x[2]]
+    weak_bucket = [x for x in scored if not x[2]]
+
+    strong_bucket.sort(key=lambda x: x[1], reverse=True)
+    weak_bucket.sort(key=lambda x: x[1], reverse=True)
+
+    picked: List[str] = []
+
+    # ëª¨ë©˜í…€ ê°• ë²„í‚·ì„ ìš°ì„  ì‚¬ìš©í•˜ë˜, ì „ì²´ ë³´ìœ  ì¢…ëª© ìˆ˜ëŠ” ë ˆì§ë³„ n_activeë¡œ ì œí•œ
+    for code, score, _ in strong_bucket:
+        if len(picked) >= n_active:
+            break
+        picked.append(code)
+
+    for code, score, _ in weak_bucket:
+        if len(picked) >= n_active:
+            break
+        picked.append(code)
+
+    # === [NEW] ë ˆì§ë³„ ì±”í”¼ì–¸ ë¹„ì¤‘ & Target Notional ê³„ì‚° ===
+    regime_weights = REGIME_WEIGHTS.get(regime_key, REGIME_WEIGHTS.get(("neutral", 0), [1.0]))
+    # ì„ íƒëœ ì¢…ëª© ìˆ˜ë§Œí¼ ë¹„ì¤‘ ìŠ¬ë¼ì´ìŠ¤
+    weights_for_picked: List[float] = list(regime_weights[: len(picked)])
+
+    for idx, code in enumerate(picked):
+        if code not in processed_targets:
+            continue
+        w = weights_for_picked[idx] if idx < len(weights_for_picked) else 0.0
+        t = processed_targets[code]
+        t["regime_weight"] = float(w)
+        t["capital_active"] = int(capital_active)
+        target_notional = int(round(capital_active * w))
+        t["target_notional"] = target_notional
+
+        ref_px = _to_float(t.get("close")) or _to_float(t.get("prev_close"))
+        planned_qty = _notional_to_qty(kis, code, target_notional, ref_price=ref_px)
+        t["qty"] = int(planned_qty)
+        t["ë§¤ìˆ˜ìˆ˜ëŸ‰"] = int(planned_qty)
+        processed_targets[code] = t
+
+    for code in picked:
+        if code in processed_targets:
+            selected_targets[code] = processed_targets[code]
+
+    logger.info(
+        "[REGIME-CHAMPIONS] mode=%s stage=%s n_active=%s picked=%s capital_active=%s",
+        mode,
+        stage,
+        n_active,
+        picked,
+        f"{capital_active:,}",
+    )
+
+    logger.info(
+        "[REBALANCE] ë ˆì§=%s pct=%.2f%%, í›„ë³´ %dê°œ ì¤‘ ìƒìœ„ %dì¢…ëª©ë§Œ ì„ íƒ: %s",
+        mode,
+        pct_change,
+        len(processed_targets),
+        len(selected_targets),
+        ",".join(selected_targets.keys()),
+    )
+
+    code_to_target: Dict[str, Any] = selected_targets
+
+    # ëˆŒë¦¼ëª© ìŠ¤ìº”ìš© ì½”ìŠ¤ë‹¥ ì‹œì´ ìƒìœ„ ë¦¬ìŠ¤íŠ¸ (ì±”í”¼ì–¸ê³¼ ë³„ë„ë¡œ ê´€ë¦¬)
+    pullback_watch: Dict[str, Dict[str, Any]] = {}
+    if USE_PULLBACK_ENTRY:
+        try:
+            pb_weight = max(0.0, min(PULLBACK_UNIT_WEIGHT, 1.0))
+            base_notional = int(round(capital_active * pb_weight))
+            pb_df = get_kosdaq_top_n(date_str=rebalance_date, n=PULLBACK_TOPN)
+            for _, row in pb_df.iterrows():
+                code = str(row.get("Code") or row.get("code") or "").zfill(6)
+                if not code:
+                    continue
+                pullback_watch[code] = {
+                    "code": code,
+                    "name": row.get("Name") or row.get("name"),
+                    "notional": base_notional,
+                }
+            logger.info(
+                f"[PULLBACK-WATCH] ì½”ìŠ¤ë‹¥ ì‹œì´ Top{PULLBACK_TOPN} {len(pullback_watch)}ì¢…ëª© ìŠ¤ìº” ì¤€ë¹„"
+            )
+        except Exception as e:
+            logger.warning(f"[PULLBACK-WATCH-FAIL] ì‹œì´ ìƒìœ„ ë¡œë“œ ì‹¤íŒ¨: {e}")
+
+    loop_sleep_sec = 2.5  # ë©”ì¸ ë£¨í”„ ëŒ€ê¸° ì‹œê°„(ì´ˆ)
+
+    try:
+        while True:
+            # === ì½”ìŠ¤ë‹¥ ë ˆì§ ì—…ë°ì´íŠ¸ ===
+            regime = _update_market_regime(kis)
+            regime_state = regime
+            pct_txt = f"{regime.get('pct_change'):.2f}%" if regime.get("pct_change") is not None else "N/A"
+            logger.info(f"[REGIME] mode={regime['mode']} stage={regime['bear_stage']} pct={pct_txt}")
+
+            # ì¥ ìƒíƒœ
+            now_dt_kst = datetime.now(KST)
+            is_open = kis.is_market_open()
+            now_str = now_dt_kst.strftime("%Y-%m-%d %H:%M:%S")
+            today_prefix = now_dt_kst.strftime("%Y-%m-%d")
+            _cleanup_expired_pending(traded, now_dt_kst, ttl_sec=300)
+            traded_today = _traded_today(traded, today_prefix)
+
+            if now_dt_kst.date() != pullback_buy_date:
+                pullback_buy_date = now_dt_kst.date()
+                pullback_buys_today = 0
+
+            if not is_open:
+                if not ALLOW_WHEN_CLOSED:
+                    logger.info("[CLOSED] ì¥ ì¢…ë£Œ â†’ 10ì´ˆ ëŒ€ê¸° í›„ ì¬í™•ì¸")
+                    time.sleep(10)
+                    continue
+                else:
+                    logger.warning("[CLOSED-DATA] ì¥ ì¢…ë£Œì§€ë§Œ í™˜ê²½ì„¤ì • í—ˆìš© â†’ ì‹œì„¸ ì¡°íšŒ í›„ ì§„í–‰")
+
+            if kis.should_cooldown(now_dt_kst):
+                logger.warning("[COOLDOWN] 2ì´ˆê°„ ëŒ€ê¸° (API ì œí•œ ë³´í˜¸)")
+                time.sleep(2)
+
+            # ì”ê³  ê°€ì ¸ì˜¤ê¸°
+            prev_holding = holding if isinstance(holding, dict) else {}
+            balances = _fetch_balances(kis)
+            holding = {}
+            for bal in balances:
+                code = bal.get("code")
+                qty = int(bal.get("qty", 0))
+                if qty <= 0:
+                    continue
+                price = float(bal.get("avg_price", 0.0))
+                holding[code] = {
+                    "qty": qty,
+                    "buy_price": price,
+                    "bear_s1_done": False,
+                    "bear_s2_done": False,
+                }
+                _init_position_state_from_balance(kis, holding, code, price, qty)
+
+            # ì”ê³  ê¸°ì¤€ìœ¼ë¡œ ë³´ìœ ì¢…ëª© ë§¤ë„ ê°€ëŠ¥ ìˆ˜ëŸ‰ ë§µ ìƒì„±
+            ord_psbl_map = {bal.get("code"): int(bal.get("sell_psbl_qty", 0)) for bal in balances}
+
+            if isinstance(traded, dict):
+                for code, payload in list(traded.items()):
+                    if (payload or {}).get("status") == "pending" and code in holding:
+                        traded[code]["status"] = "filled"
+
+            for code, info in list(holding.items()):
+                prev_qty = int((prev_holding.get(code) or {}).get("qty", info.get("qty", 0)))
+                balance_qty = int(info.get("qty", 0))
+                # ì”ê³ ê°€ ì¼ì‹œì ìœ¼ë¡œ ì¤„ì–´ë“  ì¼€ì´ìŠ¤ë§Œ ë³´í˜¸í•˜ê³ , ì •ìƒì ì¸ ìˆ˜ëŸ‰ ì¦ê°€ëŠ” ìœ ì§€í•œë‹¤.
+                if prev_qty > 0 and 0 < balance_qty < prev_qty:
+                    holding[code]["qty"] = prev_qty
+                    logger.info(
+                        f"[HOLDING-QTY-CLAMP] {code}: balance_qty={balance_qty} prev_qty={prev_qty} â†’ {prev_qty}"
+                    )
+
+            recent_keep_minutes = 5
+            for code, info in prev_holding.items():
+                if code in holding:
+                    continue
+                buy_time_str = None
+                if isinstance(traded, dict):
+                    buy_time_str = (traded.get(code) or {}).get("buy_time")
+                if buy_time_str:
+                    try:
+                        buy_dt = datetime.strptime(buy_time_str, "%Y-%m-%d %H:%M:%S")
+                        buy_dt = buy_dt.replace(tzinfo=now_dt_kst.tzinfo)
+                        if now_dt_kst - buy_dt <= timedelta(minutes=recent_keep_minutes):
+                            holding[code] = info
+                            ord_psbl_map.setdefault(code, int(info.get("qty", 0)))
+                            logger.info(
+                                f"[HOLDING-MERGE] {code} ìµœê·¼ ë§¤ìˆ˜({buy_time_str}) ë°˜ì˜ â†’ ì”ê³  ë¯¸ë°˜ì˜ ë³´í˜¸"
+                            )
+                    except Exception as e:
+                        logger.warning(f"[HOLDING-MERGE-FAIL] {code}: {e}")
+
+            logger.info(
+                f"[STATUS] holdings={holding} traded_today={sorted(traded_today)} ord_psbl={ord_psbl_map}"
+            )
+
+            # ì»¤íŠ¸ì˜¤í”„ íƒ€ì„ ë„ë‹¬ ì‹œ ê°•ì œë§¤ë„ ë£¨í‹´
+            if now_dt_kst.time() >= SELL_FORCE_TIME and SELL_ALL_BALANCES_AT_CUTOFF:
+                logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ë„ë‹¬: ì „ëŸ‰ë§¤ë„ ë£¨í‹´ ì‹¤í–‰]")
+                pass_count = FORCE_SELL_PASSES_CUTOFF
+                if now_dt_kst.time() >= dtime(hour=15, minute=0):
+                    pass_count = FORCE_SELL_PASSES_CLOSE
+                for code, qty in ord_psbl_map.items():
+                    if qty <= 0:
+                        continue
+                    exec_px, result = _sell_once(kis, code, qty, prefer_market=True)
+                    log_trade(
+                        {
+                            "datetime": now_str,
+                            "code": code,
+                            "name": None,
+                            "qty": int(qty),
+                            "K": None,
+                            "target_price": None,
+                            "strategy": "ê°•ì œë§¤ë„",
+                            "side": "SELL",
+                            "price": exec_px,
+                            "amount": int((exec_px or 0)) * int(qty),
+                            "result": result,
+                            "reason": "ì»¤íŠ¸ì˜¤í”„ ê°•ì œë§¤ë„",
+                        }
+                    )
+                    time.sleep(RATE_SLEEP_SEC)
+                for _ in range(pass_count - 1):
+                    logger.info(
+                        f"[ì»¤íŠ¸ì˜¤í”„ ì¶”ê°€íŒ¨ìŠ¤] {pass_count}íšŒ ì¤‘ ë‚¨ì€ íŒ¨ìŠ¤ ì‹¤í–‰ (ì”ê³ ë³€ë™ ê°ì§€ìš©)"
+                    )
+                    time.sleep(loop_sleep_sec)
+                    continue
+                logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ì¢…ë£Œ] ë£¨í”„ ì¢…ë£Œ")
+                break
+
+            # === (1) ì”ì—¬ ë¬¼ëŸ‰ ëŒ€ìƒ ìŠ¤íƒ‘/ë¦¬ë°¸ëŸ°ìŠ¤ ê´€ë¦¬ ===
+            for code in list(holding.keys()):
+                # ì‹ ê·œ ì§„ì… ê¸ˆì§€ ëª¨ë“œ
+                if code not in code_to_target:
+                    continue
+
+                # --- 1a) ê°•ì œ ë ˆì§ë³„ ì¶•ì†Œ ë¡œì§ ---
+                sellable_qty = ord_psbl_map.get(code, 0)
+                if sellable_qty <= 0:
+                    continue
+
+                regime_key = regime.get("key")
+                mode = regime.get("mode")
+                if regime_key and regime_key[0] == "bear":
+                    if regime["bear_stage"] >= 1 and not holding[code].get("bear_s1_done"):
+                        cut_qty = max(1, int(holding[code]["qty"] * REG_PARTIAL_S1))
+                        logger.info(
+                            f"[REGIME-REDUCE-S1] {code} ì•½ì„¸1ë‹¨ê³„ {REG_PARTIAL_S1 * 100:.0f}% ì¶•ì†Œ â†’ {cut_qty}"
+                        )
+                        exec_px, result = _sell_once(kis, code, cut_qty, prefer_market=True)
+                        holding[code]["qty"] -= int(cut_qty)
+                        holding[code]["bear_s1_done"] = True
+                        log_trade(
+                            {
+                                "datetime": now_str,
+                                "code": code,
+                                "name": None,
+                                "qty": int(cut_qty),
+                                "K": holding[code].get("k_value"),
+                                "target_price": holding[code].get("target_price_src"),
+                                "strategy": "ë ˆì§ì¶•ì†Œ",  # ì‹ ê·œ ì „ëµ êµ¬ë¶„ì„ ìœ„í•´ strategy í•„ë“œ í™œìš©
+                                "side": "SELL",
+                                "price": exec_px,
+                                "amount": int((exec_px or 0)) * int(cut_qty),
+                                "result": result,
+                                "reason": "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ",
+                            }
+                        )
+                        save_state(holding, traded)
+                        time.sleep(RATE_SLEEP_SEC)
+
+                    if regime["bear_stage"] >= 2 and not holding[code].get("bear_s2_done"):
+                        cut_qty = max(1, int(holding[code]["qty"] * REG_PARTIAL_S2))
+                        logger.info(
+                            f"[REGIME-REDUCE-S2] {code} ì•½ì„¸2ë‹¨ê³„ {REG_PARTIAL_S2 * 100:.0f}% ì¶•ì†Œ â†’ {cut_qty}"
+                        )
+                        exec_px, result = _sell_once(kis, code, cut_qty, prefer_market=True)
+                        holding[code]["qty"] -= int(cut_qty)
+                        holding[code]["bear_s2_done"] = True
+                        log_trade(
+                            {
+                                "datetime": now_str,
+                                "code": code,
+                                "name": None,
+                                "qty": int(cut_qty),
+                                "K": holding[code].get("k_value"),
+                                "target_price": holding[code].get("target_price_src"),
+                                "strategy": "ë ˆì§ì¶•ì†Œ",
+                                "side": "SELL",
+                                "price": exec_px,
+                                "amount": int((exec_px or 0)) * int(cut_qty),
+                                "result": result,
+                                "reason": "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ",
+                            }
+                        )
+                        save_state(holding, traded)
+                        time.sleep(RATE_SLEEP_SEC)
+
+                # --- 1b) TP/SL/íŠ¸ë ˆì¼ë§, VWAP ê°€ë“œ ---
+                _adaptive_exit(
+                    kis,
+                    holding,
+                    traded,
+                    code,
+                    ord_psbl_map,
+                    regime,
+                    now_dt_kst,
+                    now_str,
+                    R20,
+                    can_buy,
+                    PARTIAL1,
+                    PARTIAL2,
+                    TRAIL_PCT_BULL,
+                    TRAIL_PCT_BEAR,
+                    TP_PROFIT_PCT_BULL,
+                    DEFAULT_PROFIT_PCT,
+                    DEFAULT_LOSS_PCT,
+                    ATR_STOP,
+                    FAST_STOP,
+                )
+
+            # === (2) ì‹ ê·œ ì§„ì… ë¡œì§ (ì±”í”¼ì–¸) ===
+            for code, info in code_to_target.items():
+                if not can_buy:
+                    continue
+
+                if code in traded_today:
+                    continue
+
+                if code in holding:
+                    continue
+
+                target_qty = int(info.get("qty", 0))
+                if target_qty <= 0:
+                    logger.info(f"[REBALANCE] {code}: target_qty=0 â†’ ìŠ¤í‚µ")
+                    continue
+
+                target_price = info.get("target_price")
+                k_value = info.get("best_k")
+                strategy = info.get("strategy")
+                weight = _to_float(info.get("weight") or 0.0)
+
+                planned_notional = int(_to_float(info.get("target_notional") or 0.0) or 0)
+                logger.info(
+                    f"[TARGET] {code} qty={target_qty} tgt_px={target_price} notional={planned_notional} K={k_value}"
+                )
+
+                # [ì¤‘ë³µ ì§„ì… ë°©ì§€] ì´ë¯¸ ì£¼ë¬¸ëœ ì¢…ëª©ì¸ì§€ í™•ì¸
+                if code in traded_today:
+                    logger.info(f"[SKIP] {code}: ì´ë¯¸ ê¸ˆì¼ ê±°ë˜ë¨")
+                    continue
+
+                if _pending_block(traded, code, now_dt_kst, block_sec=45):
+                    logger.info(f"[SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘ â†’ ì¬ì£¼ë¬¸ ë°©ì§€")
+                    continue
+
+                # === GOOD/BAD íƒ€ì  í‰ê°€ ===
+                daily_ctx = _compute_daily_entry_context(kis, code, PULLBACK_LOOKBACK)
+                intra_ctx = _compute_intraday_entry_context(kis, code, fast=MOM_FAST, slow=MOM_SLOW)
+
+                if is_bad_entry(code, daily_ctx, intra_ctx, regime_state):
+                    logger.info(f"[ENTRY-SKIP] {code}: BAD íƒ€ì  ê°ì§€ â†’ ì´ë²ˆ ë£¨í”„ ë§¤ìˆ˜ ìŠ¤í‚µ")
+                    continue
+
+                if not is_good_entry(daily_ctx, intra_ctx):
+                    logger.info(
+                        f"[ENTRY-SKIP] {code}: GOOD íƒ€ì  ë¯¸ì¶©ì¡± â†’ ë‹¤ìŒ ë£¨í”„ì—ì„œ ì¬í™•ì¸"
+                    )
+                    continue
+
+                logger.info(f"[ENTRY-GOOD] {code}: GOOD íƒ€ì  í™•ì¸ â†’ ë§¤ìˆ˜ ì‹œë„")
+
+                # === VWAP ê°€ë“œ(ìŠ¬ë¦¬í”¼ì§€ ë°©ì–´) ===
+                try:
+                    guard_passed = vwap_guard(kis, code, SLIPPAGE_ENTER_GUARD_PCT)
+                except Exception as e:
+                    logger.warning(f"[VWAP_GUARD_FAIL] {code}: VWAP ê°€ë“œ ì˜¤ë¥˜ â†’ ì§„ì… ë³´ë¥˜ ({e})")
+                    continue
+
+                if not guard_passed:
+                    logger.info(f"[VWAP_GUARD] {code}: ìŠ¬ë¦¬í”¼ì§€ ìœ„í—˜ â†’ ë§¤ìˆ˜ ìŠ¤í‚µ")
+                    continue
+
+                current_price = _safe_get_price(kis, code)
+                if not current_price or current_price <= 0:
+                    logger.warning(f"[PRICE_FAIL] {code}: í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ")
+                    continue
+
+                qty = target_qty
+                trade_ctx = {
+                    "datetime": now_str,
+                    "code": code,
+                    "name": info.get("name"),
+                    "qty": int(qty),
+                    "K": k_value,
+                    "target_price": target_price,
+                    "strategy": strategy,
+                    "side": "BUY",
+                }
+
+                limit_px, mo_px = compute_entry_target(kis, info)
+                if limit_px is None and mo_px is None:
+                    logger.warning(f"[TARGET-PRICE] {code}: limit/mo ê°€ê²© ì‚°ì¶œ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ")
+                    continue
+
+                if limit_px and abs(limit_px - current_price) / current_price * 100 > SLIPPAGE_LIMIT_PCT:
+                    logger.info(
+                        f"[SLIPPAGE_LIMIT] {code}: í˜¸ê°€ä¹–é›¢ {abs(limit_px - current_price) / current_price * 100:.2f}% â†’ ìŠ¤í‚µ"
+                    )
+                    continue
+
+                logger.info(
+                    f"[BUY-TRY] {code}: qty={qty} limit={limit_px} mo={mo_px} target={target_price} k={k_value}"
+                )
+
+                prev_qty = int((holding.get(code) or {}).get("qty", 0))
+                result = place_buy_with_fallback(kis, code, qty, limit_px or _round_to_tick(current_price))
+                if not _is_order_success(result):
+                    logger.warning(f"[BUY-FAIL] {code}: result={result}")
+                    continue
+
+                exec_price = _extract_fill_price(result, current_price)
+                _record_trade(
+                    traded,
+                    code,
+                    {
+                        "buy_time": now_str,
+                        "qty": int(qty),
+                        "price": float(exec_price),
+                        "status": "pending",
+                        "pending_since": now_str,
+                    },
+                )
+                save_state(holding, traded)
+                if not _is_balance_reflected(code, prev_qty=prev_qty):
+                    logger.warning(
+                        f"[BUY-PENDING] {code}: ì”ê³ ì— ë°˜ì˜ë˜ì§€ ì•Šì•„ ìƒíƒœ ê¸°ë¡ ë³´ë¥˜(result={result})"
+                    )
+                    continue
+                traded[code]["status"] = "filled"
+                _record_trade(
+                    traded,
+                    code,
+                    {
+                        "buy_time": now_str,
+                        "qty": int(qty),
+                        "price": float(exec_price),
+                        "status": "filled",
+                        "pending_since": None,
+                    },
+                )
+
+                _init_position_state(
+                    kis,
+                    holding,
+                    code,
+                    float(exec_price),
+                    int(qty),
+                    k_value,
+                    target_price,
+                )
+
+                log_trade(
+                    {
+                        **trade_ctx,
+                        "price": float(exec_price),
+                        "amount": int(float(exec_price) * int(qty)),
+                        "result": result,
+                    }
+                )
+                effective_cash = _get_effective_ord_cash(kis, soft_cap=effective_capital)
+                if effective_cash <= 0:
+                    can_buy = False
+                save_state(holding, traded)
+                time.sleep(RATE_SLEEP_SEC)
+
+            # ====== ëˆŒë¦¼ëª© ì „ìš© ë§¤ìˆ˜ (ì±”í”¼ì–¸ê³¼ ë…ë¦½ì ìœ¼ë¡œ Top-N ì‹œì´ ë¦¬ìŠ¤íŠ¸ ìŠ¤ìº”) ======
+            if USE_PULLBACK_ENTRY and is_open:
+                if not can_buy:
+                    logger.info("[PULLBACK-SKIP] can_buy=False â†’ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ")
+                else:
+                    if pullback_watch:
+                        logger.info(f"[PULLBACK-SCAN] {len(pullback_watch)}ì¢…ëª© ê²€ì‚¬")
+
+                    for code, info in list(pullback_watch.items()):
+                        if pullback_buys_today >= PULLBACK_MAX_BUYS_PER_DAY:
+                            logger.info(
+                                f"[PULLBACK-LIMIT] í•˜ë£¨ ìµœëŒ€ {PULLBACK_MAX_BUYS_PER_DAY}ê±´ ë„ë‹¬ â†’ ìŠ¤ìº” ì¤‘ë‹¨"
+                            )
+                            break
+
+                        if code in traded_today or code in holding:
+                            continue  # ì±”í”¼ì–¸ ë£¨í”„ì™€ ë³„ë„ë¡œë§Œ ì²˜ë¦¬
+
+                        if _pending_block(traded, code, now_dt_kst, block_sec=45):
+                            logger.info(f"[PULLBACK-SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘")
+                            continue
+
+                        base_notional = int(info.get("notional") or 0)
+                        if base_notional <= 0:
+                            logger.info(f"[PULLBACK-SKIP] {code}: ì˜ˆì‚° 0")
+                            continue
+
+                        try:
+                            resp = _detect_pullback_reversal(
+                                kis,
+                                code,
+                                lookback=PULLBACK_LOOKBACK,
+                                pullback_days=PULLBACK_DAYS,
+                                reversal_buffer_pct=PULLBACK_REVERSAL_BUFFER_PCT,
+                            )
+
+                            pullback_ok = False
+                            trigger_price = None
+
+                            if isinstance(resp, dict):
+                                pullback_ok = bool(resp.get("setup")) and bool(
+                                    resp.get("reversing")
+                                )
+                                trigger_price = resp.get("reversal_price")
+                                if not pullback_ok:
+                                    reason = resp.get("reason")
+                                    if reason:
+                                        logger.info(
+                                            f"[PULLBACK-SKIP] {code}: íŒ¨í„´ ë¯¸ì¶©ì¡±(reason={reason})"
+                                        )
+                            elif isinstance(resp, tuple):
+                                if len(resp) >= 1:
+                                    pullback_ok = bool(resp[0])
+                                if len(resp) >= 2:
+                                    trigger_price = resp[1]
+                            else:
+                                pullback_ok = bool(resp)
+
+                        except Exception as e:
+                            logger.warning(f"[PULLBACK-FAIL] {code}: ìŠ¤ìº” ì‹¤íŒ¨ {e}")
+                            continue
+
+                        if not pullback_ok:
+                            continue
+
+                        if trigger_price is None:
+                            logger.info(f"[PULLBACK-SKIP] {code}: trigger_price None")
+                            continue
+
+                        qty = _notional_to_qty(kis, code, base_notional)
+                        if qty <= 0:
+                            logger.info(f"[PULLBACK-SKIP] {code}: ìˆ˜ëŸ‰ ì‚°ì¶œ 0")
+                            continue
+
+                        current_price = _safe_get_price(kis, code)
+                        if not current_price:
+                            logger.warning(f"[PULLBACK-PRICE] {code}: í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨")
+                            continue
+
+                        if trigger_price and current_price < trigger_price * 0.98:
+                            logger.info(
+                                f"[PULLBACK-DELAY] {code}: ê°€ê²©ì´ íŠ¸ë¦¬ê±° ëŒ€ë¹„ 2% ì´ìƒ í•˜ë½ â†’ ëŒ€ê¸° (cur={current_price}, trigger={trigger_price})"
+                            )
+                            continue
+
+                        prev_qty = int((holding.get(code) or {}).get("qty", 0))
+                        result = place_buy_with_fallback(
+                            kis,
+                            code,
+                            int(qty),
+                            _round_to_tick(trigger_price or current_price),
+                        )
+
+                        if not _is_order_success(result):
+                            logger.warning(f"[PULLBACK-BUY-FAIL] {code}: result={result}")
+                            continue
+
+                        exec_price = _extract_fill_price(result, trigger_price or current_price)
+                        _record_trade(
+                            traded,
+                            code,
+                            {
+                                "buy_time": now_str,
+                                "qty": int(qty),
+                                "price": float(exec_price),
+                                "status": "pending",
+                                "pending_since": now_str,
+                            },
+                        )
+                        save_state(holding, traded)
+                        if not _is_balance_reflected(code, prev_qty=prev_qty):
+                            logger.warning(
+                                f"[PULLBACK-PENDING] {code}: ì”ê³ ì— ë°˜ì˜ë˜ì§€ ì•Šì•„ ìƒíƒœ ê¸°ë¡ ë³´ë¥˜(result={result})"
+                            )
+                            continue
+
+                        traded[code]["status"] = "filled"
+                        holding[code] = {
+                            "qty": int(qty),
+                            "buy_price": float(exec_price),
+                            "bear_s1_done": False,
+                            "bear_s2_done": False,
+                        }
+                        _record_trade(
+                            traded,
+                            code,
+                            {
+                                "buy_time": now_str,
+                                "qty": int(qty),
+                                "price": float(exec_price),
+                                "status": "filled",
+                                "pending_since": None,
+                            },
+                        )
+                        pullback_buys_today += 1
+
+                        try:
+                            _init_position_state(
+                                kis,
+                                holding,
+                                code,
+                                float(exec_price),
+                                int(qty),
+                                None,
+                                trigger_price,
+                            )
+                        except Exception as e:
+                            logger.warning(f"[PULLBACK-INIT-FAIL] {code}: {e}")
+
+                        logger.info(
+                            f"[âœ… ëˆŒë¦¼ëª© ë§¤ìˆ˜] {code}, qty={qty}, price={exec_price}, trigger={trigger_price}, result={result}"
+                        )
+
+                        log_trade(
+                            {
+                                "datetime": now_str,
+                                "code": code,
+                                "name": info.get("name"),
+                                "qty": int(qty),
+                                "K": None,
+                                "target_price": trigger_price,
+                                "strategy": f"ì½”ìŠ¤ë‹¥ Top{PULLBACK_TOPN} ëˆŒë¦¼ëª©",
+                                "side": "BUY",
+                                "price": float(exec_price),
+                                "amount": int(float(exec_price) * int(qty)),
+                                "result": result,
+                            }
+                        )
+                        effective_cash = _get_effective_ord_cash(kis, soft_cap=effective_capital)
+                        if effective_cash <= 0:
+                            can_buy = False
+                        save_state(holding, traded)
+                        time.sleep(RATE_SLEEP_SEC)
+
+            # ====== (A) ë¹„íƒ€ê²Ÿ ë³´ìœ ë¶„ë„ ì¥ì¤‘ ëŠ¥ë™ê´€ë¦¬ ======
+            if is_open:
+                for code in list(holding.keys()):
+                    if code in code_to_target:
+                        continue  # ìœ„ ë£¨í”„ì—ì„œ ì´ë¯¸ ì²˜ë¦¬
+
+                    # ì•½ì„¸ ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)
+                    if regime["mode"] == "bear":
+                        sellable_here = ord_psbl_map.get(code, 0)
+                        if sellable_here > 0:
+                            if (
+                                regime["bear_stage"] >= 1
+                                and not holding[code].get("bear_s1_done")
+                            ):
+                                cut_qty = max(
+                                    1, int(holding[code]["qty"] * REG_PARTIAL_S1)
+                                )
+                                logger.info(
+                                    f"[REGIME-REDUCE-S1/ë¹„íƒ€ê²Ÿ] {code} ì•½ì„¸1ë‹¨ê³„ {REG_PARTIAL_S1 * 100:.0f}% ì¶•ì†Œ â†’ {cut_qty}"
+                                )
+                                exec_px, result = _sell_once(
+                                    kis, code, cut_qty, prefer_market=True
+                                )
+                                holding[code]["qty"] -= int(cut_qty)
+                                holding[code]["bear_s1_done"] = True
+                                log_trade(
+                                    {
+                                        "datetime": now_str,
+                                        "code": code,
+                                        "name": None,
+                                        "qty": int(cut_qty),
+                                        "K": holding[code].get("k_value"),
+                                        "target_price": holding[code].get(
+                                            "target_price_src"
+                                        ),
+                                        "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
+                                        "side": "SELL",
+                                        "price": exec_px,
+                                        "amount": int((exec_px or 0))
+                                        * int(cut_qty),
+                                        "result": result,
+                                        "reason": "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)",
+                                    }
+                                )
+                                save_state(holding, traded)
+                                time.sleep(RATE_SLEEP_SEC)
+
+                            if (
+                                regime["bear_stage"] >= 2
+                                and not holding[code].get("bear_s2_done")
+                            ):
+                                cut_qty = max(
+                                    1, int(holding[code]["qty"] * REG_PARTIAL_S2)
+                                )
+                                logger.info(
+                                    f"[REGIME-REDUCE-S2/ë¹„íƒ€ê²Ÿ] {code} ì•½ì„¸2ë‹¨ê³„ {REG_PARTIAL_S2 * 100:.0f}% ì¶•ì†Œ â†’ {cut_qty}"
+                                )
+                                exec_px, result = _sell_once(
+                                    kis, code, cut_qty, prefer_market=True
+                                )
+                                holding[code]["qty"] -= int(cut_qty)
+                                holding[code]["bear_s2_done"] = True
+                                log_trade(
+                                    {
+                                        "datetime": now_str,
+                                        "code": code,
+                                        "name": None,
+                                        "qty": int(cut_qty),
+                                        "K": holding[code].get("k_value"),
+                                        "target_price": holding[code].get(
+                                            "target_price_src"
+                                        ),
+                                        "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
+                                        "side": "SELL",
+                                        "price": exec_px,
+                                        "amount": int((exec_px or 0))
+                                        * int(cut_qty),
+                                        "result": result,
+                                        "reason": "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ(íƒ€ê²Ÿ)",
+                                    }
+                                )
+                                save_state(holding, traded)
+                                time.sleep(RATE_SLEEP_SEC)
+
+                    try:
+                        momentum_intact, trend_ctx = _has_bullish_trend_structure(kis, code)
+                    except NetTemporaryError:
+                        logger.warning(
+                            f"[20D_TREND_TEMP_SKIP] {code}: ë„¤íŠ¸ì›Œí¬ ì¼ì‹œ ì‹¤íŒ¨ â†’ ì´ë²ˆ ë£¨í”„ ìŠ¤í‚µ"
+                        )
+                        continue
+                    except DataEmptyError:
+                        logger.warning(
+                            f"[DATA_EMPTY] {code}: 0ìº”ë“¤ â†’ ë‹¤ìŒ ë£¨í”„ì—ì„œ ì¬í™•ì¸"
+                        )
+                        continue
+                    except DataShortError:
+                        logger.error(
+                            f"[DATA_SHORT] {code}: 21ê°œ ë¯¸ë§Œ â†’ ì´ë²ˆ ë£¨í”„ íŒë‹¨ ìŠ¤í‚µ"
+                        )
+                        continue
+
+                    if momentum_intact:
+                        logger.info(
+                            (
+                                f"[ëª¨ë©˜í…€ ë³´ìœ ] {code}: 5/10/20 ì •ë°°ì—´ & 20ì¼ì„  ìƒìŠ¹ & ì¢…ê°€>20ì¼ì„  ìœ ì§€ "
+                                f"(close={trend_ctx.get('last_close'):.2f}, ma5={trend_ctx.get('ma5'):.2f}, "
+                                f"ma10={trend_ctx.get('ma10'):.2f}, ma20={trend_ctx.get('ma20'):.2f}â†’{trend_ctx.get('ma20_prev'):.2f})"
+                            )
+                        )
+                        continue
+
+            # --- ì¥ì¤‘ ì»¤íŠ¸ì˜¤í”„(KST): 14:40 ë„ë‹¬ ì‹œ "ì „ëŸ‰ë§¤ë„ ì—†ì´" ë¦¬í¬íŠ¸ ìƒì„± í›„ ì •ìƒ ì¢…ë£Œ ---
+            if is_open and now_dt_kst.time() >= SELL_FORCE_TIME:
+                logger.info(
+                    f"[â° ì»¤íŠ¸ì˜¤í”„] {SELL_FORCE_TIME.strftime('%H:%M')} ë„ë‹¬: ì „ëŸ‰ ë§¤ë„ ì—†ì´ ë¦¬í¬íŠ¸ ìƒì„± í›„ ì¢…ë£Œ"
+                )
+
+                save_state(holding, traded)
+
+                try:
+                    _report = ceo_report(datetime.now(KST), period="daily")
+                    logger.info(
+                        f"[ğŸ“„ CEO Report ìƒì„± ì™„ë£Œ] title={_report.get('title')}"
+                    )
+                except Exception as e:
+                    logger.error(f"[CEO Report ìƒì„± ì‹¤íŒ¨] {e}")
+
+                logger.info("[âœ… ì»¤íŠ¸ì˜¤í”„ ì™„ë£Œ: ë£¨í”„ ì •ìƒ ì¢…ë£Œ]")
+                break
+
+            save_state(holding, traded)
+            time.sleep(loop_sleep_sec)
+
+    except KeyboardInterrupt:
+        logger.info("[ğŸ›‘ ìˆ˜ë™ ì¢…ë£Œ]")
+    except Exception as e:
+        logger.exception(f"[FATAL] ë©”ì¸ ë£¨í”„ ì˜ˆì™¸ ë°œìƒ: {e}")
+
+
+if __name__ == "__main__":
+    main()
diff --git a/trader/signals.py b/trader/signals.py
index 69bb7c858d2ad33eb2f5a3454506d020ad102a8a..4810abcc946840a3ab5b814dc228f6039e265cba 100644
--- a/trader/signals.py
+++ b/trader/signals.py
@@ -193,75 +193,91 @@ def _fetch_balances(kis: KisAPI, ttl_sec: int = 15) -> List[Dict[str, Any]]:
             avg_price = _to_float(
                 row.get("avg_price") if "avg_price" in row else row.get("pchs_avg_pric")
             )
 
             normalized.append(
                 {
                     "code": code.zfill(6),
                     "name": row.get("name") or row.get("prdt_name"),
                     "qty": qty,
                     "sell_psbl_qty": sell_psbl_qty,
                     "avg_price": avg_price,
                     "current_price": _to_float(row.get("prpr") or row.get("price")),
                     "eval_amount": _to_int(row.get("evlu_amt")),
                     "raw": row,
                 }
             )
         except Exception as e:
             logger.warning(f"[BAL_STD_FAIL] ì”ê³  í–‰ íŒŒì‹± ì‹¤íŒ¨: {e}")
             continue
 
     _BALANCE_CACHE["ts"] = now
     _BALANCE_CACHE["balances"] = list(normalized)
     return normalized
 
 
-def _get_effective_ord_cash(kis: KisAPI) -> int:
+def _get_effective_ord_cash(kis: KisAPI, soft_cap: int | float | None = None) -> int:
     """
     ì˜¤ëŠ˜ ì£¼ë¬¸ ê°€ëŠ¥ ì˜ˆìˆ˜ê¸ˆì„ ê°€ì ¸ì˜¤ë˜,
     - 0 ì´í•˜ì´ê±°ë‚˜
     - ì¡°íšŒ ì‹¤íŒ¨ / None
     ì´ë©´ DAILY_CAPITALì„ fallbackìœ¼ë¡œ ì‚¬ìš©í•œë‹¤.
     (ëª¨ì˜íˆ¬ìì—ì„œ get_cash_available_todayê°€ í•­ìƒ 0ì„ ì£¼ëŠ” ê²½ìš° ë³´í˜¸)
+    soft_capì´ ì£¼ì–´ì§€ë©´ ì¡°íšŒëœ ê°’ê³¼ ë¹„êµí•´ ë” ì‘ì€ ê°’ì„ ì‚¬ìš©í•œë‹¤.
     """
     try:
         cash = kis.get_cash_available_today()
         if cash is None:
             raise ValueError("cash is None")
         cash = int(cash)
         logger.info(f"[BUDGET] today cash available(raw) = {cash:,} KRW")
     except Exception as e:
         logger.warning(
             f"[BUDGET] ì˜ˆìˆ˜ê¸ˆ ì¡°íšŒ ì‹¤íŒ¨/ë¬´íš¨({e}) â†’ DAILY_CAPITAL {DAILY_CAPITAL:,}ì› ì‚¬ìš©"
         )
-        return DAILY_CAPITAL
+        cash = DAILY_CAPITAL
 
     if cash <= 0:
         logger.warning(
             f"[BUDGET] today cash <= 0 â†’ DAILY_CAPITAL {DAILY_CAPITAL:,}ì› ì‚¬ìš©"
         )
-        return DAILY_CAPITAL
+        cash = DAILY_CAPITAL
+
+    if soft_cap is not None:
+        try:
+            cap_int = int(float(soft_cap))
+            if cap_int > 0:
+                if cash > cap_int:
+                    logger.info(
+                        "[BUDGET] applying soft cap %s â†’ cash clipped from %s to %s",
+                        f"{cap_int:,}",
+                        f"{cash:,}",
+                        f"{cap_int:,}",
+                    )
+                cash = min(cash, cap_int)
+        except Exception:
+            logger.warning("[BUDGET] invalid soft_cap provided: %s", soft_cap)
 
     return cash
 
 
 def _detect_pullback_reversal(
     kis: KisAPI,
     code: str,
     current_price: Optional[float] = None,
     lookback: int = PULLBACK_LOOKBACK,
     pullback_days: int = PULLBACK_DAYS,
     buffer_pct: float = PULLBACK_REVERSAL_BUFFER_PCT,
     reversal_buffer_pct: Optional[float] = None,  # â† ì¶”ê°€
 ) -> Dict[str, Any]:
     """
     ì‹ ê³ ê°€ ë‹¬ì„± ì´í›„ 3ì¼ ì—°ì† í•˜ë½ í›„ ë°˜ë“± ì—¬ë¶€ë¥¼ íŒì •í•œë‹¤.
     ...
     """
     # reversal_buffer_pctë¥¼ í‚¤ì›Œë“œë¡œ ë°›ì•˜ìœ¼ë©´ ê·¸ ê°’ì„ ìš°ì„  ì‚¬ìš©
     if reversal_buffer_pct is not None:
         buffer_pct = reversal_buffer_pct
 
     try:
         candles = _get_daily_candles_cached(
             kis, code, count=max(lookback, pullback_days + 5)
         )
diff --git a/trader/state_manager.py b/trader/state_manager.py
new file mode 100644
index 0000000000000000000000000000000000000000..a89e19b1a0e66d89d9c45853bd41b7d4d017155e
--- /dev/null
+++ b/trader/state_manager.py
@@ -0,0 +1,68 @@
+from __future__ import annotations
+
+import json
+import logging
+from pathlib import Path
+from typing import Any, Dict, Tuple
+
+from trader.config import LOG_DIR, STATE_FILE
+
+logger = logging.getLogger(__name__)
+
+
+_ENGINE_STATE_DIR = Path(__file__).parent / "engine_states"
+_ENGINE_STATE_DIR.mkdir(exist_ok=True)
+
+
+def _engine_state_file(engine_name: str) -> Path:
+    name = (engine_name or "").strip().lower()
+    if name in ("kosdaq", "kosdaq_alpha", "kosdaq_alpha_engine"):
+        return STATE_FILE
+    return _ENGINE_STATE_DIR / f"{name or 'engine'}.json"
+
+
+def load_state(
+    engine_name: str, *, include_meta: bool = False
+) -> Tuple[Dict[str, Any], Dict[str, Any]] | Tuple[Dict[str, Any], Dict[str, Any], Dict[str, Any]]:
+    state_path = _engine_state_file(engine_name)
+    if state_path.exists():
+        try:
+            with open(state_path, "r", encoding="utf-8") as f:
+                state = json.load(f)
+            holding = state.get("holding", {}) or {}
+            traded = state.get("traded", {}) or {}
+            meta = state.get("meta", {}) or {}
+            if include_meta:
+                return holding, traded, meta
+            return holding, traded
+        except Exception:
+            logger.exception("[STATE][%s] load failed", engine_name)
+    if include_meta:
+        return {}, {}, {}
+    return {}, {}
+
+
+def save_state(
+    engine_name: str,
+    holding: Dict[str, Any],
+    traded: Dict[str, Any],
+    meta: Dict[str, Any] | None = None,
+) -> None:
+    state_path = _engine_state_file(engine_name)
+    try:
+        state_path.parent.mkdir(parents=True, exist_ok=True)
+        payload = {"holding": holding, "traded": traded}
+        if meta:
+            payload["meta"] = meta
+        with open(state_path, "w", encoding="utf-8") as f:
+            json.dump(payload, f, ensure_ascii=False, indent=2)
+    except Exception:
+        logger.exception("[STATE][%s] save failed", engine_name)
+
+
+def state_path(engine_name: str) -> Path:
+    return _engine_state_file(engine_name)
+
+
+def log_dir() -> Path:
+    return LOG_DIR
diff --git a/trader/trader.py b/trader/trader.py
index 1a60b5e80e17419266740410633d80c4f3a7b21f..16de2145910bc107321f2375bafa6906df654a73 100644
--- a/trader/trader.py
+++ b/trader/trader.py
@@ -1,1205 +1,19 @@
 # -*- coding: utf-8 -*-
-"""ê±°ë˜ ë©”ì¸ ë£¨í”„.
-
-ê¸°ì¡´ trader.pyì˜ ì„¤ì •/ìœ í‹¸ì„ ë¶„ë¦¬í•˜ê³ , ë©”ì¸ ì§„ì…ì ë§Œ ë‚¨ê²¨ ì „ëµ ì¶”ê°€ê°€
-ì‰¬ìš´ êµ¬ì¡°ë¡œ ë³€ê²½í–ˆë‹¤.
-"""
+"""Thin entrypoint orchestrating KOSPI core + KOSDAQ alpha engines."""
 from __future__ import annotations
 
-import time
-from datetime import datetime, time as dtime, timedelta
-from typing import Any, Dict, List, Tuple, TYPE_CHECKING
-
-
-from .config import (
-    DAILY_CAPITAL,
-    FORCE_SELL_PASSES_CLOSE,
-    FORCE_SELL_PASSES_CUTOFF,
-    KST,
-    RATE_SLEEP_SEC,
-    SELL_ALL_BALANCES_AT_CUTOFF,
-    SELL_FORCE_TIME,
-    SLIPPAGE_ENTER_GUARD_PCT,
-    USE_PULLBACK_ENTRY,
-    PULLBACK_MAX_BUYS_PER_DAY,
-    _cfg,
-    logger,
-)
-from .core import *  # noqa: F401,F403 - ì „ëµ ìœ í‹¸ ì „ì²´ ë…¸ì¶œë¡œ í™•ì¥ì„± í™•ë³´
-
-if TYPE_CHECKING:
-    # core ìª½ì— êµ¬í˜„ë¼ ìˆëŠ” í—¬í¼ë“¤ì„ íƒ€ì…ì²´ì»¤ì—ê²Œë§Œ ëª…ì‹œì ìœ¼ë¡œ ì•Œë ¤ì¤€ë‹¤.
-    from .core import (
-        _this_iso_week_key,
-        _get_effective_ord_cash,
-        _to_float,
-        _to_int,
-        _weight_to_qty,
-        _classify_champion_grade,
-        _update_market_regime,
-        _notional_to_qty,
-        _fetch_balances,
-        _init_position_state_from_balance,
-        _sell_once,
-        _adaptive_exit,
-        _compute_daily_entry_context,
-        _compute_intraday_entry_context,
-        _safe_get_price,
-        _round_to_tick,
-        _init_position_state,
-        _detect_pullback_reversal,
-        _has_bullish_trend_structure,
-    )
-
-
-def main():
-    kis = KisAPI()
-
-    rebalance_date = get_rebalance_anchor_date()
-    logger.info(f"[â„¹ï¸ ë¦¬ë°¸ëŸ°ì‹± ê¸°ì¤€ì¼(KST)]: {rebalance_date} (anchor={REBALANCE_ANCHOR}, ref={WEEKLY_ANCHOR_REF})")
-    logger.info(
-        f"[â±ï¸ ì»¤íŠ¸ì˜¤í”„(KST)] SELL_FORCE_TIME={SELL_FORCE_TIME.strftime('%H:%M')} / ì „ì²´ì”ê³ ë§¤ë„={SELL_ALL_BALANCES_AT_CUTOFF} / "
-        f"íŒ¨ìŠ¤(ì»¤íŠ¸ì˜¤í”„/ë§ˆê°)={FORCE_SELL_PASSES_CUTOFF}/{FORCE_SELL_PASSES_CLOSE}"
-    )
-    logger.info(f"[ğŸ’° DAILY_CAPITAL] {DAILY_CAPITAL:,}ì›")
-    logger.info(f"[ğŸ›¡ï¸ SLIPPAGE_ENTER_GUARD_PCT] {SLIPPAGE_ENTER_GUARD_PCT:.2f}%")
-
-    # ìƒíƒœ ë³µêµ¬
-    state_loaded_at = datetime.now(KST)
-    state_loaded_date = state_loaded_at.strftime("%Y-%m-%d")
-    state_loaded_str = state_loaded_at.strftime("%Y-%m-%d %H:%M:%S")
-    state_loaded_midnight = f"{state_loaded_date} 00:00:00"
-
-    holding, traded = load_state()
-
-    if isinstance(traded, (set, list, tuple)):
-        logger.warning(
-            f"[STATE-MIGRATE] traded íƒ€ì… {type(traded)} â†’ dictë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜(ì¤‘ë³µ ì§„ì… ê°€ë“œ ìœ ì§€)"
-        )
-        traded = {
-            code: {"buy_time": state_loaded_midnight, "qty": 0, "price": 0.0}
-            for code in traded
-        }
-    elif not isinstance(traded, dict):
-        logger.warning(
-            f"[STATE-FORMAT] traded íƒ€ì… {type(traded)} ì§€ì› ì•ˆ í•¨ â†’ ë¹ˆ dictë¡œ ì¬ì„¤ì •"
-        )
-        traded = {}
-
-    def _traded_codes(traded_state: Any) -> List[str]:
-        if isinstance(traded_state, dict):
-            return list(traded_state.keys())
-        return []
-
-    def _traded_today(traded_state: Any, today_prefix: str) -> set:
-        if not isinstance(traded_state, dict):
-            return set()
-
-        today_codes = set()
-        for code, payload in traded_state.items():
-            payload = payload or {}
-            buy_time = payload.get("buy_time")
-            status = payload.get("status")
-            # pending/other ìƒíƒœëŠ” ì¬ì‹œë„ í—ˆìš©, filled/ê¸°ì¡´(None)ë§Œ ì¤‘ë³µ ë°©ì§€
-            if status not in (None, "filled"):
-                continue
-            if isinstance(buy_time, str) and buy_time.startswith(today_prefix):
-                today_codes.add(code)
-        return today_codes
-
-    def _record_trade(traded_state: Any, code: str, payload: Dict[str, Any]) -> None:
-        try:
-            traded_state[code] = payload
-        except Exception:
-            logger.warning(f"[TRADED-STATE] tradedì— ì½”ë“œ ì¶”ê°€ ì‹¤íŒ¨: type={type(traded_state)}")
-
-    def _cleanup_expired_pending(traded_state: dict, now_dt: datetime, ttl_sec: int = 300) -> None:
-        if not isinstance(traded_state, dict):
-            return
-
-        for code, payload in list(traded_state.items()):
-            payload = payload or {}
-            if payload.get("status") != "pending":
-                continue
-
-            ts = payload.get("pending_since") or payload.get("buy_time")
-            if not isinstance(ts, str):
-                continue
-
-            try:
-                pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(tzinfo=now_dt.tzinfo)
-                if (now_dt - pending_dt).total_seconds() > ttl_sec:
-                    logger.warning(f"[PENDING-EXPIRE] {code}: {ttl_sec}s ì´ˆê³¼ â†’ pending ì œê±°")
-                    traded_state.pop(code, None)
-            except Exception:
-                continue
-
-    def _pending_block(traded_state: dict, code: str, now_dt: datetime, block_sec: int = 45) -> bool:
-        if not isinstance(traded_state, dict):
-            return False
-        payload = traded_state.get(code) or {}
-        if payload.get("status") != "pending":
-            return False
-
-        ts = payload.get("pending_since") or payload.get("buy_time")
-        if not isinstance(ts, str):
-            return True
-
-        try:
-            pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(tzinfo=now_dt.tzinfo)
-            return (now_dt - pending_dt).total_seconds() <= block_sec
-        except Exception:
-            return True
-
-    def _is_balance_reflected(code: str, prev_qty: int = 0, delay_sec: float = 1.0) -> bool:
-        try:
-            time.sleep(delay_sec)
-            balances = _fetch_balances(kis, ttl_sec=0)
-        except Exception as e:
-            logger.warning(f"[BAL-REFRESH-FAIL] {code}: ì”ê³  í™•ì¸ ì‹¤íŒ¨ {e}")
-            return False
-
-        for row in balances:
-            try:
-                if str(row.get("code")).zfill(6) != str(code).zfill(6):
-                    continue
-                qty_here = _to_int(row.get("qty") or 0)
-                sellable_here = _to_int((row.get("sell_psbl_qty") or row.get("ord_psbl_qty")) or 0)
-                baseline_qty = max(0, int(prev_qty))
-                if qty_here > baseline_qty or sellable_here > baseline_qty:
-                    return True
-            except Exception:
-                continue
-
-        return False
-
-    def _is_order_success(res: Any) -> bool:
-        if not isinstance(res, dict):
-            return False
-        rt_cd = str(res.get("rt_cd") or res.get("rtCode") or "").strip()
-        return rt_cd in ("0", "0000", "OK")
-
-    def _extract_fill_price(res: Any, fallback_price: float) -> float:
-        if isinstance(res, dict):
-            output = res.get("output") or {}
-            for payload in (output, res):
-                for key in (
-                    # ì²´ê²°ê°€/í‰ê· ê°€ í›„ë³´
-                    "ccld_prc",
-                    "ccld_unpr",
-                    "tot_ccld_unpr",
-                    "tot_ccld_prc",
-                    "avg_price",
-                    "avg_prvs",
-                    "fill_price",
-                    # ì£¼ë¬¸ê°€(í›„ìˆœìœ„)
-                    "prdt_price",
-                    "ord_unpr",
-                    "ord_prc",
-                    "order_price",
-                ):
-                    val = None
-                    if isinstance(payload, dict):
-                        val = payload.get(key)
-                    if val not in (None, ""):
-                        try:
-                            return float(val)
-                        except Exception:
-                            continue
-        return float(fallback_price)
-
-    logger.info(f"[ìƒíƒœë³µêµ¬] holding: {list(holding.keys())}, traded: {_traded_codes(traded)}")
-
-    pullback_buys_today = 0
-    pullback_buy_date = datetime.now(KST).date()
-
-    # === [NEW] ì£¼ê°„ ë¦¬ë°¸ëŸ°ì‹± ê°•ì œ/ì¤‘ë³µ ë°©ì§€ ===
-    targets: List[Dict[str, Any]] = []
-    if REBALANCE_ANCHOR == "weekly":
-        if should_weekly_rebalance_now():
-            targets = fetch_rebalancing_targets(rebalance_date)
-            # ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ë¥¼ ìœ„í•´ ì¦‰ì‹œ ìŠ¤íƒ¬í”„(í•„ìš” ì‹œ FORCEë¡œ ì¬ì‹¤í–‰ ê°€ëŠ¥)
-            stamp_weekly_done()
-            logger.info(f"[REBALANCE] ì´ë²ˆ ì£¼ ë¦¬ë°¸ëŸ°ì‹± ì‹¤í–‰ ê¸°ë¡ ì €ì¥({_this_iso_week_key()})")
-        else:
-            logger.info("[REBALANCE] ì´ë²ˆ ì£¼ ì´ë¯¸ ì‹¤í–‰ë¨ â†’ ì‹ ê·œ ë¦¬ë°¸ëŸ°ì‹± ìƒëµ (ë³´ìœ  ê´€ë¦¬ë§Œ)")
-    else:
-        # today/monthly ë“± ë‹¤ë¥¸ ì•µì»¤ ëª¨ë“œëŠ” ê¸°ì¡´ ë°©ì‹ìœ¼ë¡œ ë°”ë¡œ í˜¸ì¶œ
-        targets = fetch_rebalancing_targets(rebalance_date)
-
-    # === [NEW] ì˜ˆì‚° ê°€ë“œ: ì˜ˆìˆ˜ê¸ˆì´ 0/ë¶€ì¡±ì´ë©´ ì‹ ê·œ ë§¤ìˆ˜ë§Œ ìŠ¤í‚µ ===
-    effective_cash = _get_effective_ord_cash(kis)
-    if effective_cash <= 0:
-        can_buy = False
-        logger.warning("[BUDGET] ìœ íš¨ ì˜ˆì‚° 0 â†’ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ(ë³´ìœ  ê´€ë¦¬ë§Œ ìˆ˜í–‰)")
-    else:
-        can_buy = True
-    logger.info(
-        f"[BUDGET] today effective cash = {effective_cash:,} KRW "
-        f"(env DAILY_CAPITAL={DAILY_CAPITAL:,})"
-    )
-
-    # ë¦¬ë°¸ëŸ°ì‹± ëŒ€ìƒ í›„ì²˜ë¦¬: qty ì—†ê³  weightë§Œ ìˆìœ¼ë©´ DAILY_CAPITALë¡œ ìˆ˜ëŸ‰ ê³„ì‚°
-    processed_targets: Dict[str, Any] = {}
-    for t in targets:
-        code = t.get("stock_code") or t.get("code")
-        if not code:
-            continue
-        name = t.get("name") or t.get("ì¢…ëª©ëª…")
-        k_best = t.get("best_k") or t.get("K") or t.get("k")
-        target_price = _to_float(t.get("ëª©í‘œê°€") or t.get("target_price"))
-        qty = _to_int(t.get("ë§¤ìˆ˜ìˆ˜ëŸ‰") or t.get("qty"), 0)
-        weight = t.get("weight")
-        strategy = t.get("strategy") or "ì „ì›” rolling K ìµœì í™”"
-        avg_return_pct = _to_float(t.get("avg_return_pct") or t.get("ìˆ˜ìµë¥ (%)"), 0.0)
-        win_rate_pct = _to_float(t.get("win_rate_pct") or t.get("ìŠ¹ë¥ (%)"), 0.0)
-        mdd_pct = _to_float(t.get("mdd_pct") or t.get("MDD(%)"), 0.0)
-        trades = _to_int(t.get("trades"), 0)
-        sharpe_m = _to_float(t.get("sharpe_m"), 0.0)
-        cumret_pct = _to_float(t.get("cumulative_return_pct") or t.get("ìˆ˜ìµë¥ (%)"), 0.0)
-
-        if qty <= 0 and weight is not None:
-            ref_px = _to_float(t.get("close")) or _to_float(t.get("prev_close"))
-            try:
-                qty = _weight_to_qty(kis, code, float(weight), DAILY_CAPITAL, ref_price=ref_px)
-            except Exception as e:
-                logger.warning("[REBALANCE] weightâ†’qty ë³€í™˜ ì‹¤íŒ¨ %s: %s", code, e)
-                qty = 0
-
-        processed_targets[code] = {
-            "code": code,
-            "name": name,
-            "best_k": k_best,
-            "target_price": target_price,
-            "qty": qty,
-            "strategy": strategy,
-            "avg_return_pct": avg_return_pct,
-            "win_rate_pct": win_rate_pct,
-            "mdd_pct": mdd_pct,
-            "trades": trades,
-            "sharpe_m": sharpe_m,
-            "cumulative_return_pct": cumret_pct,
-            "prev_open": t.get("prev_open"),
-            "prev_high": t.get("prev_high"),
-            "prev_low": t.get("prev_low"),
-            "prev_close": t.get("prev_close"),
-            "prev_volume": t.get("prev_volume"),
-        }
-
-    filtered_targets: Dict[str, Any] = {}
-    for code, info in processed_targets.items():
-        trades = _to_int(info.get("trades"), 0)
-        win_rate = _to_float(info.get("win_rate_pct"), 0.0)
-        mdd = abs(_to_float(info.get("mdd_pct"), 0.0) or 0.0)
-        sharpe = _to_float(info.get("sharpe_m"), 0.0)
-
-        if (
-            trades < CHAMPION_MIN_TRADES
-            or win_rate < CHAMPION_MIN_WINRATE
-            or mdd > CHAMPION_MAX_MDD
-            or sharpe < CHAMPION_MIN_SHARPE
-        ):
-            logger.info(
-                f"[CHAMPION_FILTER_SKIP] {code}: trades={trades}, win={win_rate:.1f}%, mdd={mdd:.1f}%, sharpe={sharpe:.2f}"
-            )
-            continue
-
-        filtered_targets[code] = info
-
-    processed_targets = filtered_targets
-
-    # ì±”í”¼ì–¸ ë“±ê¸‰í™” (A/B/C) â†’ ì‹¤ì œ ë§¤ìˆ˜ í›„ë³´ëŠ” Aê¸‰ë§Œ ì‚¬ìš©
-    graded_targets: Dict[str, Any] = {}
-    grade_counts = {"A": 0, "B": 0, "C": 0}
-    for code, info in processed_targets.items():
-        grade = _classify_champion_grade(info)
-        info["champion_grade"] = grade
-        graded_targets[code] = info
-        grade_counts[grade] = grade_counts.get(grade, 0) + 1
-
-    logger.info(
-        "[CHAMPION-GRADE] A:%d / B:%d / C:%d (A/Bê¸‰ ì‹¤ì œ ë§¤ìˆ˜)",
-        grade_counts.get("A", 0),
-        grade_counts.get("B", 0),
-        grade_counts.get("C", 0),
-    )
-
-    # ğŸ”½ ì—¬ê¸° í•„í„°ë¥¼ A â†’ A/B ë¡œ
-    processed_targets = {
-        k: v
-        for k, v in graded_targets.items()
-        if v.get("champion_grade") in ("A", "B")
-    }
-    # === [ì±”í”¼ì–¸ & ë ˆì§ ìƒì„¸ ë¡œê·¸] ===
-    try:
-        if isinstance(processed_targets, dict) and len(processed_targets) > 0:
-            # 1) ì±”í”¼ì–¸ 1ê°œ(1ìˆœìœ„)ë§Œ ë½‘ì•„ì„œ ë¡œê·¸ (processed_targetsê°€ dictì¼ ë•Œ)
-            first_code = next(iter(processed_targets.keys()))
-            champion_one = processed_targets.get(first_code)
-
-            # champion dict ì•ˆì— codeê°€ ì—†ìœ¼ë©´ ë³´ê°•
-            if isinstance(champion_one, dict) and "code" not in champion_one:
-                champion_one = {**champion_one, "code": first_code}
-
-            # 2) regime_stateëŠ” ì´ë¯¸ ë§Œë“  regime(ë˜ëŠ” _update_market_regime(kis) ê²°ê³¼)ë¥¼ ë„£ì–´ì•¼ í•¨
-            #    ì´ ë¸”ë¡ ì§ì „ì— regime = _update_market_regime(kis) ê°€ ìˆì–´ì•¼ í•¨
-            #    ì—†ìœ¼ë©´ ì—¬ê¸°ì„œ í•œ ë²ˆ êµ¬í•´ë„ ë¨:
-            try:
-                regime_state = regime  # regime ë³€ìˆ˜ê°€ ìœ„ì—ì„œ ë§Œë“¤ì–´ì ¸ ìˆìœ¼ë©´ ì´ê±¸ ì‚¬ìš©
-            except NameError:
-                regime_state = _update_market_regime(kis)
-
-            # 3) contextëŠ” ë¬¸ìì—´ë¡œ(í˜¹ì€ execution.pyë¥¼ Anyë¡œ ë°”ê¿¨ë‹¤ë©´ dictë„ ê°€ëŠ¥)
-            context = "rebalance_api"
-
-            log_champion_and_regime(logger, champion_one, regime_state, context)
-    except Exception as e:
-        logger.warning(f"[CHAMPION_LOG] ì±”í”¼ì–¸/ë ˆì§ ë¡œê·¸ ìƒì„± ì‹¤íŒ¨: {e}")
-
-    # í˜„ì¬ ë ˆì§ ê¸°ë°˜ ìë³¸ ìŠ¤ì¼€ì¼ë§ & ì±”í”¼ì–¸ ì„ íƒ
-    selected_targets: Dict[str, Any] = {}
-    regime = _update_market_regime(kis)
-    pct_change = regime.get("pct_change") or 0.0
-    mode = regime.get("mode") or "neutral"
-    stage = regime.get("bear_stage") or 0
-    regime_key = regime.get("key")
-    R20 = regime.get("R20")
-    D1 = regime.get("D1")
-
-    REGIME_CAP_TABLE = {
-        ("bull", 0): 1.0,
-        ("neutral", 0): 0.8,
-        ("bear", 0): 0.7,
-        ("bear", 1): 0.5,
-        ("bear", 2): 0.3,
-    }
-
-    REGIME_WEIGHTS = {
-        ("bull", 0): [0.22, 0.20, 0.18, 0.16, 0.14, 0.10],
-        ("neutral", 0): [0.20, 0.18, 0.16, 0.14, 0.12, 0.10, 0.10],
-        ("bear", 0): [0.18, 0.16, 0.14, 0.12, 0.10],
-        ("bear", 1): [0.16, 0.14, 0.12],
-        ("bear", 2): [0.14, 0.12, 0.10],
-    }
-
-    REGIME_MAX_ACTIVE = {
-        ("bull", 0): 6,
-        ("neutral", 0): 5,
-        ("bear", 0): 4,
-        ("bear", 1): 3,
-        ("bear", 2): 2,
-    }
-
-    REG_PARTIAL_S1 = float(_cfg("REG_PARTIAL_S1") or "0.3")
-    REG_PARTIAL_S2 = float(_cfg("REG_PARTIAL_S2") or "0.3")
-    TRAIL_PCT_BULL = float(_cfg("TRAIL_PCT_BULL") or "0.025")
-    TRAIL_PCT_BEAR = float(_cfg("TRAIL_PCT_BEAR") or "0.012")
-    TP_PROFIT_PCT_BULL = float(_cfg("TP_PROFIT_PCT_BULL") or "3.5")
-
-    cap_scale = REGIME_CAP_TABLE.get(regime.get("key"), 0.8)
-    ord_cash = _get_effective_ord_cash(kis)
-    capital_base = min(ord_cash, int(CAP_CAP * DAILY_CAPITAL))
-    capital_active = int(min(capital_base * cap_scale, DAILY_CAPITAL))
-    logger.info(
-        f"[REGIME-CAP] mode={mode} stage={stage} R20={R20 if R20 is not None else 'N/A'} "
-        f"D1={D1 if D1 is not None else 'N/A'} "
-        f"ord_cash(effective)={ord_cash:,} base={capital_base:,} active={capital_active:,} "
-        f"scale={cap_scale:.2f}"
-    )
-
-    # ë ˆì§ë³„ ìµœëŒ€ ë³´ìœ  ì¢…ëª© ìˆ˜
-    n_active = REGIME_MAX_ACTIVE.get(regime_key, REGIME_MAX_ACTIVE.get(("neutral", 0), 3))
-
-    scored: List[Tuple[str, float, bool]] = []
-
-    for code, info in processed_targets.items():
-        score = _to_float(info.get("composite_score"), 0.0) or 0.0
-
-        # ë‹¨ê¸° ëª¨ë©˜í…€ ê°•ì„¸ ì—¬ë¶€ (is_strong_momentum)ë¡œ ë²„í‚· êµ¬ë¶„
-        try:
-            strong = is_strong_momentum(kis, code)
-        except Exception as e:
-            logger.warning("[REBALANCE] ëª¨ë©˜í…€ íŒë³„ ì‹¤íŒ¨ %s: %s", code, e)
-            strong = False
-
-        scored.append((code, score, strong))
-
-    # ëª¨ë©˜í…€ strong ë²„í‚· ìš°ì„ , ê·¸ ë‹¤ìŒ ë‚˜ë¨¸ì§€ ì¤‘ì—ì„œ ì ìˆ˜ ìˆœìœ¼ë¡œ ì±„ìš°ê¸°
-    strong_bucket = [x for x in scored if x[2]]
-    weak_bucket = [x for x in scored if not x[2]]
-
-    strong_bucket.sort(key=lambda x: x[1], reverse=True)
-    weak_bucket.sort(key=lambda x: x[1], reverse=True)
-
-    picked: List[str] = []
-
-    # ëª¨ë©˜í…€ ê°• ë²„í‚·ì„ ìš°ì„  ì‚¬ìš©í•˜ë˜, ì „ì²´ ë³´ìœ  ì¢…ëª© ìˆ˜ëŠ” ë ˆì§ë³„ n_activeë¡œ ì œí•œ
-    for code, score, _ in strong_bucket:
-        if len(picked) >= n_active:
-            break
-        picked.append(code)
-
-    for code, score, _ in weak_bucket:
-        if len(picked) >= n_active:
-            break
-        picked.append(code)
-
-    # === [NEW] ë ˆì§ë³„ ì±”í”¼ì–¸ ë¹„ì¤‘ & Target Notional ê³„ì‚° ===
-    regime_weights = REGIME_WEIGHTS.get(regime_key, REGIME_WEIGHTS.get(("neutral", 0), [1.0]))
-    # ì„ íƒëœ ì¢…ëª© ìˆ˜ë§Œí¼ ë¹„ì¤‘ ìŠ¬ë¼ì´ìŠ¤
-    weights_for_picked: List[float] = list(regime_weights[: len(picked)])
-
-    for idx, code in enumerate(picked):
-        if code not in processed_targets:
-            continue
-        w = weights_for_picked[idx] if idx < len(weights_for_picked) else 0.0
-        t = processed_targets[code]
-        t["regime_weight"] = float(w)
-        t["capital_active"] = int(capital_active)
-        target_notional = int(round(capital_active * w))
-        t["target_notional"] = target_notional
-
-        ref_px = _to_float(t.get("close")) or _to_float(t.get("prev_close"))
-        planned_qty = _notional_to_qty(kis, code, target_notional, ref_price=ref_px)
-        t["qty"] = int(planned_qty)
-        t["ë§¤ìˆ˜ìˆ˜ëŸ‰"] = int(planned_qty)
-        processed_targets[code] = t
-
-    for code in picked:
-        if code in processed_targets:
-            selected_targets[code] = processed_targets[code]
-
-    logger.info(
-        "[REGIME-CHAMPIONS] mode=%s stage=%s n_active=%s picked=%s capital_active=%s",
-        mode,
-        stage,
-        n_active,
-        picked,
-        f"{capital_active:,}",
-    )
-
-    logger.info(
-        "[REBALANCE] ë ˆì§=%s pct=%.2f%%, í›„ë³´ %dê°œ ì¤‘ ìƒìœ„ %dì¢…ëª©ë§Œ ì„ íƒ: %s",
-        mode,
-        pct_change,
-        len(processed_targets),
-        len(selected_targets),
-        ",".join(selected_targets.keys()),
-    )
-
-    code_to_target: Dict[str, Any] = selected_targets
-
-    # ëˆŒë¦¼ëª© ìŠ¤ìº”ìš© ì½”ìŠ¤ë‹¥ ì‹œì´ ìƒìœ„ ë¦¬ìŠ¤íŠ¸ (ì±”í”¼ì–¸ê³¼ ë³„ë„ë¡œ ê´€ë¦¬)
-    pullback_watch: Dict[str, Dict[str, Any]] = {}
-    if USE_PULLBACK_ENTRY:
-        try:
-            pb_weight = max(0.0, min(PULLBACK_UNIT_WEIGHT, 1.0))
-            base_notional = int(round(capital_active * pb_weight))
-            pb_df = get_kosdaq_top_n(date_str=rebalance_date, n=PULLBACK_TOPN)
-            for _, row in pb_df.iterrows():
-                code = str(row.get("Code") or row.get("code") or "").zfill(6)
-                if not code:
-                    continue
-                pullback_watch[code] = {
-                    "code": code,
-                    "name": row.get("Name") or row.get("name"),
-                    "notional": base_notional,
-                }
-            logger.info(
-                f"[PULLBACK-WATCH] ì½”ìŠ¤ë‹¥ ì‹œì´ Top{PULLBACK_TOPN} {len(pullback_watch)}ì¢…ëª© ìŠ¤ìº” ì¤€ë¹„"
-            )
-        except Exception as e:
-            logger.warning(f"[PULLBACK-WATCH-FAIL] ì‹œì´ ìƒìœ„ ë¡œë“œ ì‹¤íŒ¨: {e}")
-
-    loop_sleep_sec = 2.5  # ë©”ì¸ ë£¨í”„ ëŒ€ê¸° ì‹œê°„(ì´ˆ)
-
-    try:
-        while True:
-            # === ì½”ìŠ¤ë‹¥ ë ˆì§ ì—…ë°ì´íŠ¸ ===
-            regime = _update_market_regime(kis)
-            regime_state = regime
-            pct_txt = f"{regime.get('pct_change'):.2f}%" if regime.get("pct_change") is not None else "N/A"
-            logger.info(f"[REGIME] mode={regime['mode']} stage={regime['bear_stage']} pct={pct_txt}")
-
-            # ì¥ ìƒíƒœ
-            now_dt_kst = datetime.now(KST)
-            is_open = kis.is_market_open()
-            now_str = now_dt_kst.strftime("%Y-%m-%d %H:%M:%S")
-            today_prefix = now_dt_kst.strftime("%Y-%m-%d")
-            _cleanup_expired_pending(traded, now_dt_kst, ttl_sec=300)
-            traded_today = _traded_today(traded, today_prefix)
-
-            if now_dt_kst.date() != pullback_buy_date:
-                pullback_buy_date = now_dt_kst.date()
-                pullback_buys_today = 0
-
-            if not is_open:
-                if not ALLOW_WHEN_CLOSED:
-                    logger.info("[CLOSED] ì¥ ì¢…ë£Œ â†’ 10ì´ˆ ëŒ€ê¸° í›„ ì¬í™•ì¸")
-                    time.sleep(10)
-                    continue
-                else:
-                    logger.warning("[CLOSED-DATA] ì¥ ì¢…ë£Œì§€ë§Œ í™˜ê²½ì„¤ì • í—ˆìš© â†’ ì‹œì„¸ ì¡°íšŒ í›„ ì§„í–‰")
-
-            if kis.should_cooldown(now_dt_kst):
-                logger.warning("[COOLDOWN] 2ì´ˆê°„ ëŒ€ê¸° (API ì œí•œ ë³´í˜¸)")
-                time.sleep(2)
-
-            # ì”ê³  ê°€ì ¸ì˜¤ê¸°
-            prev_holding = holding if isinstance(holding, dict) else {}
-            balances = _fetch_balances(kis)
-            holding = {}
-            for bal in balances:
-                code = bal.get("code")
-                qty = int(bal.get("qty", 0))
-                if qty <= 0:
-                    continue
-                price = float(bal.get("avg_price", 0.0))
-                holding[code] = {
-                    "qty": qty,
-                    "buy_price": price,
-                    "bear_s1_done": False,
-                    "bear_s2_done": False,
-                }
-                _init_position_state_from_balance(kis, holding, code, price, qty)
-
-            # ì”ê³  ê¸°ì¤€ìœ¼ë¡œ ë³´ìœ ì¢…ëª© ë§¤ë„ ê°€ëŠ¥ ìˆ˜ëŸ‰ ë§µ ìƒì„±
-            ord_psbl_map = {bal.get("code"): int(bal.get("sell_psbl_qty", 0)) for bal in balances}
-
-            if isinstance(traded, dict):
-                for code, payload in list(traded.items()):
-                    if (payload or {}).get("status") == "pending" and code in holding:
-                        traded[code]["status"] = "filled"
-
-            for code, info in list(holding.items()):
-                prev_qty = int((prev_holding.get(code) or {}).get("qty", info.get("qty", 0)))
-                balance_qty = int(info.get("qty", 0))
-                # ì”ê³ ê°€ ì¼ì‹œì ìœ¼ë¡œ ì¤„ì–´ë“  ì¼€ì´ìŠ¤ë§Œ ë³´í˜¸í•˜ê³ , ì •ìƒì ì¸ ìˆ˜ëŸ‰ ì¦ê°€ëŠ” ìœ ì§€í•œë‹¤.
-                if prev_qty > 0 and 0 < balance_qty < prev_qty:
-                    holding[code]["qty"] = prev_qty
-                    logger.info(
-                        f"[HOLDING-QTY-CLAMP] {code}: balance_qty={balance_qty} prev_qty={prev_qty} â†’ {prev_qty}"
-                    )
-
-            recent_keep_minutes = 5
-            for code, info in prev_holding.items():
-                if code in holding:
-                    continue
-                buy_time_str = None
-                if isinstance(traded, dict):
-                    buy_time_str = (traded.get(code) or {}).get("buy_time")
-                if buy_time_str:
-                    try:
-                        buy_dt = datetime.strptime(buy_time_str, "%Y-%m-%d %H:%M:%S")
-                        buy_dt = buy_dt.replace(tzinfo=now_dt_kst.tzinfo)
-                        if now_dt_kst - buy_dt <= timedelta(minutes=recent_keep_minutes):
-                            holding[code] = info
-                            ord_psbl_map.setdefault(code, int(info.get("qty", 0)))
-                            logger.info(
-                                f"[HOLDING-MERGE] {code} ìµœê·¼ ë§¤ìˆ˜({buy_time_str}) ë°˜ì˜ â†’ ì”ê³  ë¯¸ë°˜ì˜ ë³´í˜¸"
-                            )
-                    except Exception as e:
-                        logger.warning(f"[HOLDING-MERGE-FAIL] {code}: {e}")
-
-            logger.info(
-                f"[STATUS] holdings={holding} traded_today={sorted(traded_today)} ord_psbl={ord_psbl_map}"
-            )
-
-            # ì»¤íŠ¸ì˜¤í”„ íƒ€ì„ ë„ë‹¬ ì‹œ ê°•ì œë§¤ë„ ë£¨í‹´
-            if now_dt_kst.time() >= SELL_FORCE_TIME and SELL_ALL_BALANCES_AT_CUTOFF:
-                logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ë„ë‹¬: ì „ëŸ‰ë§¤ë„ ë£¨í‹´ ì‹¤í–‰]")
-                pass_count = FORCE_SELL_PASSES_CUTOFF
-                if now_dt_kst.time() >= dtime(hour=15, minute=0):
-                    pass_count = FORCE_SELL_PASSES_CLOSE
-                for code, qty in ord_psbl_map.items():
-                    if qty <= 0:
-                        continue
-                    exec_px, result = _sell_once(kis, code, qty, prefer_market=True)
-                    log_trade(
-                        {
-                            "datetime": now_str,
-                            "code": code,
-                            "name": None,
-                            "qty": int(qty),
-                            "K": None,
-                            "target_price": None,
-                            "strategy": "ê°•ì œë§¤ë„",
-                            "side": "SELL",
-                            "price": exec_px,
-                            "amount": int((exec_px or 0)) * int(qty),
-                            "result": result,
-                            "reason": "ì»¤íŠ¸ì˜¤í”„ ê°•ì œë§¤ë„",
-                        }
-                    )
-                    time.sleep(RATE_SLEEP_SEC)
-                for _ in range(pass_count - 1):
-                    logger.info(
-                        f"[ì»¤íŠ¸ì˜¤í”„ ì¶”ê°€íŒ¨ìŠ¤] {pass_count}íšŒ ì¤‘ ë‚¨ì€ íŒ¨ìŠ¤ ì‹¤í–‰ (ì”ê³ ë³€ë™ ê°ì§€ìš©)"
-                    )
-                    time.sleep(loop_sleep_sec)
-                    continue
-                logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ì¢…ë£Œ] ë£¨í”„ ì¢…ë£Œ")
-                break
-
-            # === (1) ì”ì—¬ ë¬¼ëŸ‰ ëŒ€ìƒ ìŠ¤íƒ‘/ë¦¬ë°¸ëŸ°ìŠ¤ ê´€ë¦¬ ===
-            for code in list(holding.keys()):
-                # ì‹ ê·œ ì§„ì… ê¸ˆì§€ ëª¨ë“œ
-                if code not in code_to_target:
-                    continue
-
-                # --- 1a) ê°•ì œ ë ˆì§ë³„ ì¶•ì†Œ ë¡œì§ ---
-                sellable_qty = ord_psbl_map.get(code, 0)
-                if sellable_qty <= 0:
-                    continue
-
-                regime_key = regime.get("key")
-                mode = regime.get("mode")
-                if regime_key and regime_key[0] == "bear":
-                    if regime["bear_stage"] >= 1 and not holding[code].get("bear_s1_done"):
-                        cut_qty = max(1, int(holding[code]["qty"] * REG_PARTIAL_S1))
-                        logger.info(
-                            f"[REGIME-REDUCE-S1] {code} ì•½ì„¸1ë‹¨ê³„ {REG_PARTIAL_S1 * 100:.0f}% ì¶•ì†Œ â†’ {cut_qty}"
-                        )
-                        exec_px, result = _sell_once(kis, code, cut_qty, prefer_market=True)
-                        holding[code]["qty"] -= int(cut_qty)
-                        holding[code]["bear_s1_done"] = True
-                        log_trade(
-                            {
-                                "datetime": now_str,
-                                "code": code,
-                                "name": None,
-                                "qty": int(cut_qty),
-                                "K": holding[code].get("k_value"),
-                                "target_price": holding[code].get("target_price_src"),
-                                "strategy": "ë ˆì§ì¶•ì†Œ",  # ì‹ ê·œ ì „ëµ êµ¬ë¶„ì„ ìœ„í•´ strategy í•„ë“œ í™œìš©
-                                "side": "SELL",
-                                "price": exec_px,
-                                "amount": int((exec_px or 0)) * int(cut_qty),
-                                "result": result,
-                                "reason": "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ",
-                            }
-                        )
-                        save_state(holding, traded)
-                        time.sleep(RATE_SLEEP_SEC)
-
-                    if regime["bear_stage"] >= 2 and not holding[code].get("bear_s2_done"):
-                        cut_qty = max(1, int(holding[code]["qty"] * REG_PARTIAL_S2))
-                        logger.info(
-                            f"[REGIME-REDUCE-S2] {code} ì•½ì„¸2ë‹¨ê³„ {REG_PARTIAL_S2 * 100:.0f}% ì¶•ì†Œ â†’ {cut_qty}"
-                        )
-                        exec_px, result = _sell_once(kis, code, cut_qty, prefer_market=True)
-                        holding[code]["qty"] -= int(cut_qty)
-                        holding[code]["bear_s2_done"] = True
-                        log_trade(
-                            {
-                                "datetime": now_str,
-                                "code": code,
-                                "name": None,
-                                "qty": int(cut_qty),
-                                "K": holding[code].get("k_value"),
-                                "target_price": holding[code].get("target_price_src"),
-                                "strategy": "ë ˆì§ì¶•ì†Œ",
-                                "side": "SELL",
-                                "price": exec_px,
-                                "amount": int((exec_px or 0)) * int(cut_qty),
-                                "result": result,
-                                "reason": "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ",
-                            }
-                        )
-                        save_state(holding, traded)
-                        time.sleep(RATE_SLEEP_SEC)
-
-                # --- 1b) TP/SL/íŠ¸ë ˆì¼ë§, VWAP ê°€ë“œ ---
-                _adaptive_exit(
-                    kis,
-                    holding,
-                    traded,
-                    code,
-                    ord_psbl_map,
-                    regime,
-                    now_dt_kst,
-                    now_str,
-                    R20,
-                    can_buy,
-                    PARTIAL1,
-                    PARTIAL2,
-                    TRAIL_PCT_BULL,
-                    TRAIL_PCT_BEAR,
-                    TP_PROFIT_PCT_BULL,
-                    DEFAULT_PROFIT_PCT,
-                    DEFAULT_LOSS_PCT,
-                    ATR_STOP,
-                    FAST_STOP,
-                )
-
-            # === (2) ì‹ ê·œ ì§„ì… ë¡œì§ (ì±”í”¼ì–¸) ===
-            for code, info in code_to_target.items():
-                if not can_buy:
-                    continue
-
-                if code in traded_today:
-                    continue
-
-                if code in holding:
-                    continue
-
-                target_qty = int(info.get("qty", 0))
-                if target_qty <= 0:
-                    logger.info(f"[REBALANCE] {code}: target_qty=0 â†’ ìŠ¤í‚µ")
-                    continue
-
-                target_price = info.get("target_price")
-                k_value = info.get("best_k")
-                strategy = info.get("strategy")
-                weight = _to_float(info.get("weight") or 0.0)
-
-                planned_notional = int(_to_float(info.get("target_notional") or 0.0) or 0)
-                logger.info(
-                    f"[TARGET] {code} qty={target_qty} tgt_px={target_price} notional={planned_notional} K={k_value}"
-                )
-
-                # [ì¤‘ë³µ ì§„ì… ë°©ì§€] ì´ë¯¸ ì£¼ë¬¸ëœ ì¢…ëª©ì¸ì§€ í™•ì¸
-                if code in traded_today:
-                    logger.info(f"[SKIP] {code}: ì´ë¯¸ ê¸ˆì¼ ê±°ë˜ë¨")
-                    continue
-
-                if _pending_block(traded, code, now_dt_kst, block_sec=45):
-                    logger.info(f"[SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘ â†’ ì¬ì£¼ë¬¸ ë°©ì§€")
-                    continue
-
-                # === GOOD/BAD íƒ€ì  í‰ê°€ ===
-                daily_ctx = _compute_daily_entry_context(kis, code, PULLBACK_LOOKBACK)
-                intra_ctx = _compute_intraday_entry_context(kis, code, fast=MOM_FAST, slow=MOM_SLOW)
-
-                if is_bad_entry(code, daily_ctx, intra_ctx, regime_state):
-                    logger.info(f"[ENTRY-SKIP] {code}: BAD íƒ€ì  ê°ì§€ â†’ ì´ë²ˆ ë£¨í”„ ë§¤ìˆ˜ ìŠ¤í‚µ")
-                    continue
-
-                if not is_good_entry(daily_ctx, intra_ctx):
-                    logger.info(
-                        f"[ENTRY-SKIP] {code}: GOOD íƒ€ì  ë¯¸ì¶©ì¡± â†’ ë‹¤ìŒ ë£¨í”„ì—ì„œ ì¬í™•ì¸"
-                    )
-                    continue
-
-                logger.info(f"[ENTRY-GOOD] {code}: GOOD íƒ€ì  í™•ì¸ â†’ ë§¤ìˆ˜ ì‹œë„")
-
-                # === VWAP ê°€ë“œ(ìŠ¬ë¦¬í”¼ì§€ ë°©ì–´) ===
-                try:
-                    guard_passed = vwap_guard(kis, code, SLIPPAGE_ENTER_GUARD_PCT)
-                except Exception as e:
-                    logger.warning(f"[VWAP_GUARD_FAIL] {code}: VWAP ê°€ë“œ ì˜¤ë¥˜ â†’ ì§„ì… ë³´ë¥˜ ({e})")
-                    continue
-
-                if not guard_passed:
-                    logger.info(f"[VWAP_GUARD] {code}: ìŠ¬ë¦¬í”¼ì§€ ìœ„í—˜ â†’ ë§¤ìˆ˜ ìŠ¤í‚µ")
-                    continue
-
-                current_price = _safe_get_price(kis, code)
-                if not current_price or current_price <= 0:
-                    logger.warning(f"[PRICE_FAIL] {code}: í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ")
-                    continue
-
-                qty = target_qty
-                trade_ctx = {
-                    "datetime": now_str,
-                    "code": code,
-                    "name": info.get("name"),
-                    "qty": int(qty),
-                    "K": k_value,
-                    "target_price": target_price,
-                    "strategy": strategy,
-                    "side": "BUY",
-                }
-
-                limit_px, mo_px = compute_entry_target(kis, info)
-                if limit_px is None and mo_px is None:
-                    logger.warning(f"[TARGET-PRICE] {code}: limit/mo ê°€ê²© ì‚°ì¶œ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ")
-                    continue
-
-                if limit_px and abs(limit_px - current_price) / current_price * 100 > SLIPPAGE_LIMIT_PCT:
-                    logger.info(
-                        f"[SLIPPAGE_LIMIT] {code}: í˜¸ê°€ä¹–é›¢ {abs(limit_px - current_price) / current_price * 100:.2f}% â†’ ìŠ¤í‚µ"
-                    )
-                    continue
-
-                logger.info(
-                    f"[BUY-TRY] {code}: qty={qty} limit={limit_px} mo={mo_px} target={target_price} k={k_value}"
-                )
-
-                prev_qty = int((holding.get(code) or {}).get("qty", 0))
-                result = place_buy_with_fallback(kis, code, qty, limit_px or _round_to_tick(current_price))
-                if not _is_order_success(result):
-                    logger.warning(f"[BUY-FAIL] {code}: result={result}")
-                    continue
-
-                exec_price = _extract_fill_price(result, current_price)
-                _record_trade(
-                    traded,
-                    code,
-                    {
-                        "buy_time": now_str,
-                        "qty": int(qty),
-                        "price": float(exec_price),
-                        "status": "pending",
-                        "pending_since": now_str,
-                    },
-                )
-                save_state(holding, traded)
-                if not _is_balance_reflected(code, prev_qty=prev_qty):
-                    logger.warning(
-                        f"[BUY-PENDING] {code}: ì”ê³ ì— ë°˜ì˜ë˜ì§€ ì•Šì•„ ìƒíƒœ ê¸°ë¡ ë³´ë¥˜(result={result})"
-                    )
-                    continue
-                traded[code]["status"] = "filled"
-                _record_trade(
-                    traded,
-                    code,
-                    {
-                        "buy_time": now_str,
-                        "qty": int(qty),
-                        "price": float(exec_price),
-                        "status": "filled",
-                        "pending_since": None,
-                    },
-                )
-
-                _init_position_state(
-                    kis,
-                    holding,
-                    code,
-                    float(exec_price),
-                    int(qty),
-                    k_value,
-                    target_price,
-                )
-
-                log_trade(
-                    {
-                        **trade_ctx,
-                        "price": float(exec_price),
-                        "amount": int(float(exec_price) * int(qty)),
-                        "result": result,
-                    }
-                )
-                effective_cash = _get_effective_ord_cash(kis)
-                if effective_cash <= 0:
-                    can_buy = False
-                save_state(holding, traded)
-                time.sleep(RATE_SLEEP_SEC)
-
-            # ====== ëˆŒë¦¼ëª© ì „ìš© ë§¤ìˆ˜ (ì±”í”¼ì–¸ê³¼ ë…ë¦½ì ìœ¼ë¡œ Top-N ì‹œì´ ë¦¬ìŠ¤íŠ¸ ìŠ¤ìº”) ======
-            if USE_PULLBACK_ENTRY and is_open:
-                if not can_buy:
-                    logger.info("[PULLBACK-SKIP] can_buy=False â†’ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ")
-                else:
-                    if pullback_watch:
-                        logger.info(f"[PULLBACK-SCAN] {len(pullback_watch)}ì¢…ëª© ê²€ì‚¬")
-
-                    for code, info in list(pullback_watch.items()):
-                        if pullback_buys_today >= PULLBACK_MAX_BUYS_PER_DAY:
-                            logger.info(
-                                f"[PULLBACK-LIMIT] í•˜ë£¨ ìµœëŒ€ {PULLBACK_MAX_BUYS_PER_DAY}ê±´ ë„ë‹¬ â†’ ìŠ¤ìº” ì¤‘ë‹¨"
-                            )
-                            break
-
-                        if code in traded_today or code in holding:
-                            continue  # ì±”í”¼ì–¸ ë£¨í”„ì™€ ë³„ë„ë¡œë§Œ ì²˜ë¦¬
-
-                        if _pending_block(traded, code, now_dt_kst, block_sec=45):
-                            logger.info(f"[PULLBACK-SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘")
-                            continue
-
-                        base_notional = int(info.get("notional") or 0)
-                        if base_notional <= 0:
-                            logger.info(f"[PULLBACK-SKIP] {code}: ì˜ˆì‚° 0")
-                            continue
-
-                        try:
-                            resp = _detect_pullback_reversal(
-                                kis,
-                                code,
-                                lookback=PULLBACK_LOOKBACK,
-                                pullback_days=PULLBACK_DAYS,
-                                reversal_buffer_pct=PULLBACK_REVERSAL_BUFFER_PCT,
-                            )
-
-                            pullback_ok = False
-                            trigger_price = None
-
-                            if isinstance(resp, dict):
-                                pullback_ok = bool(resp.get("setup")) and bool(
-                                    resp.get("reversing")
-                                )
-                                trigger_price = resp.get("reversal_price")
-                                if not pullback_ok:
-                                    reason = resp.get("reason")
-                                    if reason:
-                                        logger.info(
-                                            f"[PULLBACK-SKIP] {code}: íŒ¨í„´ ë¯¸ì¶©ì¡±(reason={reason})"
-                                        )
-                            elif isinstance(resp, tuple):
-                                if len(resp) >= 1:
-                                    pullback_ok = bool(resp[0])
-                                if len(resp) >= 2:
-                                    trigger_price = resp[1]
-                            else:
-                                pullback_ok = bool(resp)
-
-                        except Exception as e:
-                            logger.warning(f"[PULLBACK-FAIL] {code}: ìŠ¤ìº” ì‹¤íŒ¨ {e}")
-                            continue
-
-                        if not pullback_ok:
-                            continue
-
-                        if trigger_price is None:
-                            logger.info(f"[PULLBACK-SKIP] {code}: trigger_price None")
-                            continue
-
-                        qty = _notional_to_qty(kis, code, base_notional)
-                        if qty <= 0:
-                            logger.info(f"[PULLBACK-SKIP] {code}: ìˆ˜ëŸ‰ ì‚°ì¶œ 0")
-                            continue
-
-                        current_price = _safe_get_price(kis, code)
-                        if not current_price:
-                            logger.warning(f"[PULLBACK-PRICE] {code}: í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨")
-                            continue
-
-                        if trigger_price and current_price < trigger_price * 0.98:
-                            logger.info(
-                                f"[PULLBACK-DELAY] {code}: ê°€ê²©ì´ íŠ¸ë¦¬ê±° ëŒ€ë¹„ 2% ì´ìƒ í•˜ë½ â†’ ëŒ€ê¸° (cur={current_price}, trigger={trigger_price})"
-                            )
-                            continue
-
-                        prev_qty = int((holding.get(code) or {}).get("qty", 0))
-                        result = place_buy_with_fallback(
-                            kis,
-                            code,
-                            int(qty),
-                            _round_to_tick(trigger_price or current_price),
-                        )
-
-                        if not _is_order_success(result):
-                            logger.warning(f"[PULLBACK-BUY-FAIL] {code}: result={result}")
-                            continue
-
-                        exec_price = _extract_fill_price(result, trigger_price or current_price)
-                        _record_trade(
-                            traded,
-                            code,
-                            {
-                                "buy_time": now_str,
-                                "qty": int(qty),
-                                "price": float(exec_price),
-                                "status": "pending",
-                                "pending_since": now_str,
-                            },
-                        )
-                        save_state(holding, traded)
-                        if not _is_balance_reflected(code, prev_qty=prev_qty):
-                            logger.warning(
-                                f"[PULLBACK-PENDING] {code}: ì”ê³ ì— ë°˜ì˜ë˜ì§€ ì•Šì•„ ìƒíƒœ ê¸°ë¡ ë³´ë¥˜(result={result})"
-                            )
-                            continue
-
-                        traded[code]["status"] = "filled"
-                        holding[code] = {
-                            "qty": int(qty),
-                            "buy_price": float(exec_price),
-                            "bear_s1_done": False,
-                            "bear_s2_done": False,
-                        }
-                        _record_trade(
-                            traded,
-                            code,
-                            {
-                                "buy_time": now_str,
-                                "qty": int(qty),
-                                "price": float(exec_price),
-                                "status": "filled",
-                                "pending_since": None,
-                            },
-                        )
-                        pullback_buys_today += 1
-
-                        try:
-                            _init_position_state(
-                                kis,
-                                holding,
-                                code,
-                                float(exec_price),
-                                int(qty),
-                                None,
-                                trigger_price,
-                            )
-                        except Exception as e:
-                            logger.warning(f"[PULLBACK-INIT-FAIL] {code}: {e}")
-
-                        logger.info(
-                            f"[âœ… ëˆŒë¦¼ëª© ë§¤ìˆ˜] {code}, qty={qty}, price={exec_price}, trigger={trigger_price}, result={result}"
-                        )
-
-                        log_trade(
-                            {
-                                "datetime": now_str,
-                                "code": code,
-                                "name": info.get("name"),
-                                "qty": int(qty),
-                                "K": None,
-                                "target_price": trigger_price,
-                                "strategy": f"ì½”ìŠ¤ë‹¥ Top{PULLBACK_TOPN} ëˆŒë¦¼ëª©",
-                                "side": "BUY",
-                                "price": float(exec_price),
-                                "amount": int(float(exec_price) * int(qty)),
-                                "result": result,
-                            }
-                        )
-                        effective_cash = _get_effective_ord_cash(kis)
-                        if effective_cash <= 0:
-                            can_buy = False
-                        save_state(holding, traded)
-                        time.sleep(RATE_SLEEP_SEC)
-
-            # ====== (A) ë¹„íƒ€ê²Ÿ ë³´ìœ ë¶„ë„ ì¥ì¤‘ ëŠ¥ë™ê´€ë¦¬ ======
-            if is_open:
-                for code in list(holding.keys()):
-                    if code in code_to_target:
-                        continue  # ìœ„ ë£¨í”„ì—ì„œ ì´ë¯¸ ì²˜ë¦¬
-
-                    # ì•½ì„¸ ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)
-                    if regime["mode"] == "bear":
-                        sellable_here = ord_psbl_map.get(code, 0)
-                        if sellable_here > 0:
-                            if (
-                                regime["bear_stage"] >= 1
-                                and not holding[code].get("bear_s1_done")
-                            ):
-                                cut_qty = max(
-                                    1, int(holding[code]["qty"] * REG_PARTIAL_S1)
-                                )
-                                logger.info(
-                                    f"[REGIME-REDUCE-S1/ë¹„íƒ€ê²Ÿ] {code} ì•½ì„¸1ë‹¨ê³„ {REG_PARTIAL_S1 * 100:.0f}% ì¶•ì†Œ â†’ {cut_qty}"
-                                )
-                                exec_px, result = _sell_once(
-                                    kis, code, cut_qty, prefer_market=True
-                                )
-                                holding[code]["qty"] -= int(cut_qty)
-                                holding[code]["bear_s1_done"] = True
-                                log_trade(
-                                    {
-                                        "datetime": now_str,
-                                        "code": code,
-                                        "name": None,
-                                        "qty": int(cut_qty),
-                                        "K": holding[code].get("k_value"),
-                                        "target_price": holding[code].get(
-                                            "target_price_src"
-                                        ),
-                                        "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
-                                        "side": "SELL",
-                                        "price": exec_px,
-                                        "amount": int((exec_px or 0))
-                                        * int(cut_qty),
-                                        "result": result,
-                                        "reason": "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)",
-                                    }
-                                )
-                                save_state(holding, traded)
-                                time.sleep(RATE_SLEEP_SEC)
-
-                            if (
-                                regime["bear_stage"] >= 2
-                                and not holding[code].get("bear_s2_done")
-                            ):
-                                cut_qty = max(
-                                    1, int(holding[code]["qty"] * REG_PARTIAL_S2)
-                                )
-                                logger.info(
-                                    f"[REGIME-REDUCE-S2/ë¹„íƒ€ê²Ÿ] {code} ì•½ì„¸2ë‹¨ê³„ {REG_PARTIAL_S2 * 100:.0f}% ì¶•ì†Œ â†’ {cut_qty}"
-                                )
-                                exec_px, result = _sell_once(
-                                    kis, code, cut_qty, prefer_market=True
-                                )
-                                holding[code]["qty"] -= int(cut_qty)
-                                holding[code]["bear_s2_done"] = True
-                                log_trade(
-                                    {
-                                        "datetime": now_str,
-                                        "code": code,
-                                        "name": None,
-                                        "qty": int(cut_qty),
-                                        "K": holding[code].get("k_value"),
-                                        "target_price": holding[code].get(
-                                            "target_price_src"
-                                        ),
-                                        "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
-                                        "side": "SELL",
-                                        "price": exec_px,
-                                        "amount": int((exec_px or 0))
-                                        * int(cut_qty),
-                                        "result": result,
-                                        "reason": "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ(íƒ€ê²Ÿ)",
-                                    }
-                                )
-                                save_state(holding, traded)
-                                time.sleep(RATE_SLEEP_SEC)
-
-                    try:
-                        momentum_intact, trend_ctx = _has_bullish_trend_structure(kis, code)
-                    except NetTemporaryError:
-                        logger.warning(
-                            f"[20D_TREND_TEMP_SKIP] {code}: ë„¤íŠ¸ì›Œí¬ ì¼ì‹œ ì‹¤íŒ¨ â†’ ì´ë²ˆ ë£¨í”„ ìŠ¤í‚µ"
-                        )
-                        continue
-                    except DataEmptyError:
-                        logger.warning(
-                            f"[DATA_EMPTY] {code}: 0ìº”ë“¤ â†’ ë‹¤ìŒ ë£¨í”„ì—ì„œ ì¬í™•ì¸"
-                        )
-                        continue
-                    except DataShortError:
-                        logger.error(
-                            f"[DATA_SHORT] {code}: 21ê°œ ë¯¸ë§Œ â†’ ì´ë²ˆ ë£¨í”„ íŒë‹¨ ìŠ¤í‚µ"
-                        )
-                        continue
-
-                    if momentum_intact:
-                        logger.info(
-                            (
-                                f"[ëª¨ë©˜í…€ ë³´ìœ ] {code}: 5/10/20 ì •ë°°ì—´ & 20ì¼ì„  ìƒìŠ¹ & ì¢…ê°€>20ì¼ì„  ìœ ì§€ "
-                                f"(close={trend_ctx.get('last_close'):.2f}, ma5={trend_ctx.get('ma5'):.2f}, "
-                                f"ma10={trend_ctx.get('ma10'):.2f}, ma20={trend_ctx.get('ma20'):.2f}â†’{trend_ctx.get('ma20_prev'):.2f})"
-                            )
-                        )
-                        continue
-
-            # --- ì¥ì¤‘ ì»¤íŠ¸ì˜¤í”„(KST): 14:40 ë„ë‹¬ ì‹œ "ì „ëŸ‰ë§¤ë„ ì—†ì´" ë¦¬í¬íŠ¸ ìƒì„± í›„ ì •ìƒ ì¢…ë£Œ ---
-            if is_open and now_dt_kst.time() >= SELL_FORCE_TIME:
-                logger.info(
-                    f"[â° ì»¤íŠ¸ì˜¤í”„] {SELL_FORCE_TIME.strftime('%H:%M')} ë„ë‹¬: ì „ëŸ‰ ë§¤ë„ ì—†ì´ ë¦¬í¬íŠ¸ ìƒì„± í›„ ì¢…ë£Œ"
-                )
-
-                save_state(holding, traded)
+import logging
 
-                try:
-                    _report = ceo_report(datetime.now(KST), period="daily")
-                    logger.info(
-                        f"[ğŸ“„ CEO Report ìƒì„± ì™„ë£Œ] title={_report.get('title')}"
-                    )
-                except Exception as e:
-                    logger.error(f"[CEO Report ìƒì„± ì‹¤íŒ¨] {e}")
+from portfolio.portfolio_manager import PortfolioManager
 
-                logger.info("[âœ… ì»¤íŠ¸ì˜¤í”„ ì™„ë£Œ: ë£¨í”„ ì •ìƒ ì¢…ë£Œ]")
-                break
+logger = logging.getLogger(__name__)
 
-            save_state(holding, traded)
-            time.sleep(loop_sleep_sec)
 
-    except KeyboardInterrupt:
-        logger.info("[ğŸ›‘ ìˆ˜ë™ ì¢…ë£Œ]")
-    except Exception as e:
-        logger.exception(f"[FATAL] ë©”ì¸ ë£¨í”„ ì˜ˆì™¸ ë°œìƒ: {e}")
+def main() -> None:
+    mgr = PortfolioManager()
+    result = mgr.run_once()
+    logger.info("[TRADER] cycle complete %s", result)
 
 
 if __name__ == "__main__":
     main()
