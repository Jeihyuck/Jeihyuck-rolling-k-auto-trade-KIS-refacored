diff --git a/README.md b/README.md
index f90135ca11fccf603f586737e85be5d1e0bb30d0..155c6e1d80c7e3f5ba1325c2874ebee405d22e27 100644
--- a/README.md
+++ b/README.md
@@ -15,48 +15,48 @@ strategy/
 trader/
   trader.py (entrypoint)
   state_manager.py
   legacy_kosdaq_runner.py (previous KOSDAQ loop kept intact)
 ```
 
 ## Engine responsibilities
 - **KOSPI core engine**: KOSPI market-cap Top-N universe, equal-weight targets, periodic rebalance with market orders and KIS quotes.
 - **KOSDAQ alpha engine**: delegates to the legacy rolling-K/VWAP/pullback loop unchanged, using its original state file for backward compatibility.
 - **Capital split**: `PortfolioManager` divides `DAILY_CAPITAL` (or supplied total) into KOSPI and KOSDAQ ratios (default 60/40) and runs each engine independently.
 - **Performance**: portfolio-level PnL snapshots combine KIS cash/positions with engine allocation ratios for unified reporting without coupling the two engines.
   - Engine-level PnL is an attribution estimate based on capital split ratios because positions are pooled at the account level.
 
 ## How to run
 ```
 python -m trader.trader
 ```
 This initializes the portfolio manager, runs KOSPI rebalance if due, then executes the existing KOSDAQ intraday loop without interrupting either engine on errors. The KOSDAQ loop is blocking, so the entrypoint runs a single orchestrated cycle via `run_once()` rather than a repeating scheduler.
 
 WorkflowÎäî bot-state Î∏åÎûúÏπòÏóê bot_state/state.jsonÏùÑ Ïª§Î∞ãÌïòÏó¨ Îü∞ Í∞Ñ ÏÉÅÌÉúÎ•º Ïú†ÏßÄÌï©ÎãàÎã§.
 
 ## CI and live-trading safeguards
 - CI (pull_request) runs set `DISABLE_LIVE_TRADING=true` so all KIS API calls are blocked and only static checks execute.
 - The live trading workflow is restricted to the `main` branch and triggers only via schedule or manual dispatch with the branch guard enabled.
 
-## How ORPHAN recovery works
+## How legacy recovery works
 The KOSDAQ loop reconciles broker holdings into the position state each cycle. If a holding is missing from the state, the bot:
 1. Searches the recent trade logs for the latest BUY fill of the same code to recover the strategy ID and engine.
 2. Falls back to a rebalance bucket (`REB_YYYYMMDD`) if the code is in today‚Äôs targets.
 3. Otherwise assigns the holding to `MANUAL`.
 
-This avoids ORPHAN/UNKNOWN mappings and ensures every holding has an explicit sid bucket.
+This avoids legacy sid placeholders and ensures every holding has an explicit sid bucket.
 
 ## State schema
 Position state is stored in `trader/state/state.json` and normalized on load. Each strategy entry is guaranteed to include:
 ```
 {
   "code": "<6-digit code>",
   "sid": "<strategy or bucket id>",
   "engine": "<entry engine>",
   "qty": <int>,
   "avg_price": <float>,
   "entry_ts": "<ISO timestamp>",
   "high_watermark": <float>,
   "flags": { ... },
   "last_update_ts": "<ISO timestamp>"
 }
 ```
diff --git a/rolling_k_auto_trade_api/best_k_meta_strategy.py b/rolling_k_auto_trade_api/best_k_meta_strategy.py
index dc891043044f38a882941af6b6bef893d9241845..71e935cd3a646aa92a7e233ec42f0d92e30a2a69 100644
--- a/rolling_k_auto_trade_api/best_k_meta_strategy.py
+++ b/rolling_k_auto_trade_api/best_k_meta_strategy.py
@@ -527,51 +527,51 @@ def _calc_best_k_for_universe(
 def _normalize_weights(selected: List[Dict[str, Any]], forced_codes: List[str]) -> List[Dict[str, Any]]:
     if not selected:
         return []
 
     selected = assign_weights(selected)  # ÎÇ¥Î∂ÄÏóêÏÑú 'weight' Ï±ÑÏõåÏßê
 
     # Î≥¥Ïú†Î∂Ñ ÏµúÏÜå ÎπÑÏ§ë ÌïòÌïú Î≥¥Ï†ï (Ìï©Í≥Ñ 1 Ïú†ÏßÄ)
     if HELD_MIN_WEIGHT > 0:
         selected = _enforce_min_weight_for_forced(selected, forced_codes, min_weight=HELD_MIN_WEIGHT)
 
     # ÏÇ¨ÌõÑ Ï†ïÍ∑úÌôîÎ°ú weight Ìï©Í≥ÑÎ•º 1.0ÏúºÎ°ú Ïú†ÏßÄ
     total_weight = sum(float(it.get("weight") or 0) for it in selected)
     if total_weight > 0:
         for it in selected:
             it["weight"] = float(it.get("weight") or 0) / total_weight
     return selected
 
 
 def _normalize_weights_by_market(
     selected_all: List[Dict[str, Any]], forced_codes: List[str]
 ) -> Dict[str, List[Dict[str, Any]]]:
     """Normalize weights per market without cross-market renormalization."""
 
     grouped: Dict[str, List[Dict[str, Any]]] = {}
     for row in selected_all:
-        market = (row.get("market") or "UNKNOWN").upper()
+        market = (row.get("market") or "UNCLASSIFIED").upper()
         grouped.setdefault(market, []).append(row)
 
     for market, rows in grouped.items():
         grouped[market] = _normalize_weights(rows, forced_codes)
         weight_sum = sum(float(r.get("weight") or 0.0) for r in grouped[market])
         logger.info("[WEIGHT] %s weight_sum=%.6f count=%d", market, weight_sum, len(rows))
 
     return grouped
 
 
 def get_best_k_for_kosdaq_topn(rebalance_date_str: str) -> List[Dict[str, Any]]:
     """
     Î¶¨Î∞∏Îü∞Ïã± ÎåÄÏÉÅ Î¶¨Ïä§Ìä∏ ÏûëÏÑ±:
     - code/name/best_k/weight(+qty=None) + prev_* + Î™©ÌëúÍ∞Ä(close Ìè¨Ìï®)ÍπåÏßÄ Ï±ÑÏõÄ
     - KOSDAQ TopNÎßå Ìè¨Ìï® (KOSPIÎäî Î≥ÑÎèÑ ÏΩîÏñ¥ ÏóîÏßÑÏóêÏÑú Ï≤òÎ¶¨)
     """
     rebalance_date = datetime.strptime(rebalance_date_str, "%Y-%m-%d").date()
 
     kosdaq_df = get_kosdaq_top_n(rebalance_date_str, n=TOP_N)
     logger.info("üìà Ïú†ÎãàÎ≤ÑÏä§ ÏàòÏßë: KOSDAQ=%d (Top%d)", len(kosdaq_df), TOP_N)
     top_df = kosdaq_df.copy()
     forced_codes = _parse_force_include_codes(ALWAYS_INCLUDE_CODES)
     if forced_codes:
         top_df = _inject_forced_codes(top_df, forced_codes, ["KOSDAQ"])
 
@@ -609,51 +609,51 @@ def get_best_k_for_krx_topn(
             uni_df = _inject_forced_codes(uni_df, forced_codes, [market])
         if uni_df.empty:
             logger.warning("[WARN] %s TopN Í≤∞Í≥º ÏóÜÏùå ‚Üí Í±¥ÎÑàÎúÄ", market)
             continue
         logger.info("üìä %s ÏãúÏ¥ù TopN Ïú†ÎãàÎ≤ÑÏä§ ÏàòÎüâ: %dÍ∞ú (Í≥†Ïú†)", market, len(uni_df))
         selected = _calc_best_k_for_universe(uni_df, rebalance_date, forced_codes, market=market)
         logger.info("[SELECT] %s ÏµúÏ¢Ö ÏÑ†Ï†ï %dÍ∞ú", market, len(selected))
         all_selected.extend(selected)
 
     if not all_selected:
         return {"selected": [], "selected_by_market": {}} if return_by_market else []
 
     by_market = _normalize_weights_by_market(all_selected, forced_codes)
     merged_per_market: List[Dict[str, Any]] = []
     for rows in by_market.values():
         merged_per_market.extend(rows)
 
     merged_global: List[Dict[str, Any]] = [dict(r) for r in merged_per_market]
     total_weight = sum(float(it.get("weight") or 0.0) for it in merged_global)
     if total_weight > 0:
         for it in merged_global:
             it["weight"] = float(it.get("weight") or 0.0) / total_weight
 
     counts: Dict[str, int] = {}
     for row in merged_per_market:
-        mkt = row.get("market") or "UNKNOWN"
+        mkt = row.get("market") or "UNCLASSIFIED"
         counts[mkt] = counts.get(mkt, 0) + 1
     for mkt, cnt in counts.items():
         logger.info("[COUNT] %s selected_count=%d", mkt, cnt)
 
     if return_by_market:
         return {
             "selected": merged_global,
             "selected_by_market": by_market,
             "weight_scope": {"selected": "global", "selected_by_market": "per_market"},
         }
     return merged_global
 
 
 # Backward compatibility alias for callers that still want the KOSDAQ-only variant
 get_best_k_for_kosdaq_only = get_best_k_for_kosdaq_topn
 
 # -----------------------------
 # 5) API ÏßÑÏûÖÏ†ê: /rebalance/run/{date} ÏóêÏÑú Ìò∏Ï∂ú
 # -----------------------------
 def run_rebalance(
     date: str, force_order: bool = False, return_by_market: bool = False
 ) -> Dict[str, Any]:
     """
     /rebalance/run/{date} ÏóîÎìúÌè¨Ïù∏Ìä∏ÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂úÎêòÎäî ÏßÑÏûÖÏ†ê.
     Î∞òÌôò Ïä§ÌÇ§ÎßàÎäî trader.py/main.pyÍ∞Ä Í∏∞ÎåÄÌïòÎäî ÌòïÌÉúÎ°ú Î≥¥Ïû•ÌïúÎã§.
diff --git a/rolling_k_auto_trade_api/rebalance_api.py b/rolling_k_auto_trade_api/rebalance_api.py
index 79cdd619b11ac710fc0a715eca3917e1f529779a..1331569ebc8ded11c4ed24048aaec5026a490cc8 100644
--- a/rolling_k_auto_trade_api/rebalance_api.py
+++ b/rolling_k_auto_trade_api/rebalance_api.py
@@ -137,65 +137,65 @@ async def run_rebalance(date: str):
                 float(x.get("avg_return_pct", x.get("ÏàòÏùµÎ•†(%)", 0))),
                 float(x.get("win_rate_pct", x.get("ÏäπÎ•†(%)", 0))),
                 -float(abs(x.get("mdd_pct", x.get("MDD(%)", 0))))
             ),
             reverse=True,
         )[:TOP_K_LIMIT]
 
     logger.info(f"[SELECTED] ÌïÑÌÑ∞ ÌÜµÍ≥º Ï¢ÖÎ™© Ïàò = {len(selected)}Í∞ú")
     logger.debug(f"selected codes: {[s.get('code') or s.get('stock_code') for s in selected]}")
 
     if len(selected) == 0:
         latest_rebalance_result.update({"date": date, "selected_stocks": []})
         return {
             "status": "skipped",
             "reason": "no_qualified_candidates",
             "candidates": candidates,
             "selected": [],
         }
 
     has_weight = any("weight" in s for s in selected)
     if not has_weight:
         selected = _assign_weights(selected)
 
     selected_by_market_out: Dict[str, List[Dict[str, Any]]] = {}
     for info in selected:
-        mkt = (info.get("market") or "UNKNOWN").upper()
+        mkt = (info.get("market") or "UNCLASSIFIED").upper()
         selected_by_market_out.setdefault(mkt, []).append(info)
 
     for mkt, rows in selected_by_market_out.items():
         total_weight = sum(float(r.get("weight") or 0) for r in rows)
         if total_weight > 0:
             for r in rows:
                 r["weight"] = float(r.get("weight") or 0) / total_weight
 
     # ÏÑúÎ≤Ñ Ï∏° ÌïÑÌÑ∞ÎßÅ ÌõÑÏóêÎäî ÏãúÏû•Î≥Ñ Ï†ïÍ∑úÌôîÍ∞Ä Ï†ÅÏö©ÎêòÎØÄÎ°ú Ïä§ÏΩîÌîÑÎ•º Î™ÖÏãúÏ†ÅÏúºÎ°ú per_marketÎ°ú Í≥†Ï†ïÌïúÎã§.
     weight_scope = {"selected": "per_market", "selected_by_market": "per_market"}
 
     market_counts: Dict[str, int] = {}
     for info in selected:
-        mkt = (info.get("market") or "UNKNOWN").upper()
+        mkt = (info.get("market") or "UNCLASSIFIED").upper()
         market_counts[mkt] = market_counts.get(mkt, 0) + 1
     for mkt, cnt in market_counts.items():
         logger.info("[MARKET] %s selected_count=%d", mkt, cnt)
 
     enriched: List[Dict[str, Any]] = []
     for info in selected:
         code = info.get("stock_code") or info.get("code")
         name = info.get("name") or info.get("stock_name")
         row = dict(info)
         row.setdefault("code", code)
         row.setdefault("name", name)
         row.setdefault("market", info.get("market"))
         try:
             df = DataReader(code)
             if df is not None and len(df) >= 2:
                 prev = df.iloc[-2]
                 row["prev_open"] = float(prev.get("Open", 0))
                 row["prev_high"] = float(prev.get("High", 0))
                 row["prev_low"] = float(prev.get("Low", 0))
                 row["prev_close"] = float(prev.get("Close", 0))
                 row["prev_volume"] = float(prev.get("Volume", 0))
                 row["prev_turnover"] = float(prev.get("Close", 0)) * float(prev.get("Volume", 0))
         except Exception as e:
             logger.warning(f"[REBAL] OHLC enrich fail {code}: {e}")
         enriched.append(row)
diff --git a/strategy/kospi/signals.py b/strategy/kospi/signals.py
index 4d15968efb548ce7f0c74ac2cc3cd07726d4f776..df96d152a0ea6ab94f53ec877d46da03d6b109f2 100644
--- a/strategy/kospi/signals.py
+++ b/strategy/kospi/signals.py
@@ -1,95 +1,137 @@
 from __future__ import annotations
 
 import logging
 from datetime import datetime, time, timedelta, timezone
-from typing import Dict, List
+from typing import Dict, List, Tuple
 
 from rolling_k_auto_trade_api.adjust_price_to_tick import adjust_price_to_tick
 from rolling_k_auto_trade_api.kis_api import (
     inquire_balance,
     inquire_cash_balance,
     send_order,
     get_price_quote,
 )
+from trader.code_utils import normalize_code
 
 logger = logging.getLogger(__name__)
 
 KST = timezone(timedelta(hours=9))
 
 
-def _current_positions() -> Dict[str, Dict[str, float]]:
-    pos: Dict[str, Dict[str, float]] = {}
+def _current_positions() -> Dict[str, Dict[str, float | str | None]]:
+    pos: Dict[str, Dict[str, float | str | None]] = {}
     for row in inquire_balance():
-        code = str(row.get("pdno") or row.get("code") or "").zfill(6)
+        code = normalize_code(row.get("pdno") or row.get("code") or "")
+        if not code:
+            continue
         qty = int(float(row.get("hldg_qty") or row.get("qty") or 0))
         price = float(row.get("pchs_avg_pric") or row.get("avg_price") or 0)
-        pos[code] = {"qty": qty, "avg_price": price}
+        market = row.get("market") or row.get("mkt") or row.get("market_div")
+        pos[code] = {"qty": qty, "avg_price": price, "market": market}
     return pos
 
 
 def _buy_window_open() -> bool:
     now = datetime.now(tz=KST).time()
     return now >= time(9, 30)
 
 
+def _split_positions_for_kospi(
+    positions: Dict[str, Dict[str, float | str | None]],
+    target_map: Dict[str, Dict[str, float]],
+) -> Tuple[Dict[str, Dict[str, float | str | None]], List[str]]:
+    kospi_positions: Dict[str, Dict[str, float | str | None]] = {}
+    excluded: List[str] = []
+    for code, payload in positions.items():
+        code_key = normalize_code(code)
+        if not code_key:
+            continue
+        market = str(payload.get("market") or "").upper()
+        if market in {"KOSPI", "KSE"}:
+            kospi_positions[code_key] = payload
+            continue
+        if market in {"KOSDAQ", "KSQ"}:
+            excluded.append(code_key)
+            continue
+        if code_key in target_map:
+            kospi_positions[code_key] = payload
+            continue
+        excluded.append(code_key)
+    return kospi_positions, excluded
+
+
 def execute_rebalance(
     targets: List[Dict[str, float]],
     cash: float,
     tag: str,
     *,
     allow_buys: bool = True,
 ) -> List[Dict[str, str]]:
     fills: List[Dict[str, str]] = []
     positions = _current_positions()
-    target_map = {str(t.get("code") or "").zfill(6): t for t in targets}
-    all_codes = set(positions.keys()) | set(target_map.keys())
+    target_map = {normalize_code(t.get("code") or ""): t for t in targets if normalize_code(t.get("code") or "")}
+    kospi_positions, excluded_positions = _split_positions_for_kospi(
+        positions, target_map
+    )
+    all_codes = set(kospi_positions.keys()) | set(target_map.keys())
     buys = sells = 0
     available_cash = min(float(cash), float(inquire_cash_balance() or 0))
 
-    before_snapshot = {code: data.get("qty", 0) for code, data in positions.items() if data.get("qty")}
+    before_snapshot = {
+        code: data.get("qty", 0)
+        for code, data in kospi_positions.items()
+        if data.get("qty")
+    }
     target_snapshot = {
         code: int(float(payload.get("target_qty") or 0))
         for code, payload in target_map.items()
         if float(payload.get("target_qty") or 0) > 0
     }
     delta_snapshot = {
         code: target_snapshot.get(code, 0) - before_snapshot.get(code, 0)
         for code in sorted(all_codes)
         if before_snapshot.get(code, 0) != target_snapshot.get(code, 0)
     }
+    if excluded_positions:
+        logger.warning(
+            "%s[KOSPI_CORE][UNKNOWN_HOLDINGS] excluded=%s (targets_fallback=%s)",
+            tag + " " if tag else "",
+            sorted(excluded_positions),
+            sorted(set(excluded_positions) & set(target_map.keys())),
+        )
     logger.info(
         "%s[KOSPI_CORE][DIFF] before=%s targets=%s delta=%s",
         tag + " " if tag else "",
         before_snapshot,
         target_snapshot,
         delta_snapshot,
     )
 
     orders: List[Dict[str, float]] = []
     for code in sorted(all_codes):
-        current = positions.get(code, {})
+        current = kospi_positions.get(code, {})
         current_qty = int(current.get("qty") or 0)
         target = target_map.get(code)
         target_qty = int(target.get("target_qty") or 0) if target else 0
         weight = float(target.get("weight") or 0) if target else 0.0
         if not target:
             weight = 0.0
         try:
             quote = get_price_quote(code)
             mkt_price = float(quote.get("askp1") or quote.get("stck_prpr") or target.get("last_price") if target else 0)
         except Exception:
             logger.exception("%s quote fail for %s", tag, code)
             mkt_price = float(target.get("last_price") or 0 if target else 0)
         mkt_price = adjust_price_to_tick(mkt_price) if mkt_price else 0.0
 
         if weight <= 0 or target_qty <= 0:
             delta_qty = -current_qty
         else:
             delta_qty = target_qty - current_qty
 
         if delta_qty == 0:
             continue
         side = "buy" if delta_qty > 0 else "sell"
         qty = abs(delta_qty)
         orders.append(
             {
diff --git a/strategy/kospi/test_signals.py b/strategy/kospi/test_signals.py
new file mode 100644
index 0000000000000000000000000000000000000000..3f0b6e48339d410bdac644f4aae9d22688e16aab
--- /dev/null
+++ b/strategy/kospi/test_signals.py
@@ -0,0 +1,20 @@
+from strategy.kospi import signals
+
+
+def test_split_positions_unknown_fallback_to_target() -> None:
+    positions = {
+        "000001": {"qty": 5, "avg_price": 100.0, "market": None},
+        "000002": {"qty": 3, "avg_price": 200.0, "market": "KOSDAQ"},
+    }
+    targets = {"000001": {"target_qty": 5}}
+    kospi_positions, excluded = signals._split_positions_for_kospi(positions, targets)
+    assert "000001" in kospi_positions
+    assert "000002" not in kospi_positions
+    assert "000002" in excluded
+
+
+def test_split_positions_keeps_kosdaq_out_of_kospi() -> None:
+    positions = {"000010": {"qty": 1, "avg_price": 50.0, "market": "KOSDAQ"}}
+    kospi_positions, excluded = signals._split_positions_for_kospi(positions, {})
+    assert kospi_positions == {}
+    assert excluded == ["000010"]
diff --git a/trader/core_utils.py b/trader/core_utils.py
index 90fd298f5e797a4a46b53aa29503e28da7831bd1..893dfcbf534b57902024afc3296a252923ea1373 100644
--- a/trader/core_utils.py
+++ b/trader/core_utils.py
@@ -1,49 +1,49 @@
 # -*- coding: utf-8 -*-
 """Í∏∞Ï¥à Ïú†Ìã∏Î¶¨Ìã∞ÏôÄ ÏÉÅÌÉú Í¥ÄÎ¶¨ Ìï®Ïàò Î™®Ïùå."""
 from __future__ import annotations
 
 import json
-import os
 import random
 import time
 from datetime import datetime, timedelta
 from typing import Any, Dict, List, Optional, Tuple
 
 from .core_constants import (
     LOG_DIR,
     STATE_FILE,
     STATE_WEEKLY_PATH,
     WEEKLY_ANCHOR_REF,
     _cfg,
     _this_iso_week_key,
     KST,
     REBALANCE_ANCHOR,
     logger,
 )
 from .kis_wrapper import KisAPI
 from .code_utils import normalize_code
+from .state_io import atomic_write_json
 
 __all__ = [
     "_krx_tick",
     "_round_to_tick",
     "get_market",
     "_read_last_weekly",
     "_write_last_weekly",
     "should_weekly_rebalance_now",
     "stamp_weekly_done",
     "get_rebalance_anchor_date",
     "log_trade",
     "save_state",
     "save_state_atomic",
     "load_state",
     "_with_retry",
     "_to_int",
     "_to_float",
     "_log_realized_pnl",
     "_get_daily_candles_cached",
 ]
 
 
 def _krx_tick(price: float) -> int:
     p = float(price or 0)
     if p >= 500_000:
@@ -165,67 +165,66 @@ def get_rebalance_anchor_date(now: Optional[datetime] = None) -> str:
         if ref in ("last", "prev", "previous"):
             days_since_sun = (today.weekday() + 1) % 7
             anchor_date = today - timedelta(days=days_since_sun)
         else:
             days_to_sun = (6 - today.weekday()) % 7
             anchor_date = today + timedelta(days=days_to_sun)
         return anchor_date.strftime("%Y-%m-%d")
 
     if REBALANCE_ANCHOR == "today":
         return today.strftime("%Y-%m-%d")
 
     return today.replace(day=1).strftime("%Y-%m-%d")
 
 
 def log_trade(trade: dict) -> None:
     today = datetime.now(KST).strftime("%Y-%m-%d")
     logfile = LOG_DIR / f"trades_{today}.json"
     with open(logfile, "a", encoding="utf-8") as f:
         payload = dict(trade)
         if "code" in payload:
             payload["code"] = normalize_code(payload.get("code"))
         f.write(json.dumps(payload, ensure_ascii=False) + "\n")
 
 
 def save_state_atomic(holding: Dict[str, Any], traded: Dict[str, Any]) -> None:
-    STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
     payload = {"holding": holding, "traded": traded}
-    tmp_path = STATE_FILE.with_name(f"{STATE_FILE.name}.tmp")
-    with open(tmp_path, "w", encoding="utf-8") as f:
-        json.dump(payload, f, ensure_ascii=False, indent=2)
-    os.replace(tmp_path, STATE_FILE)
+    atomic_write_json(STATE_FILE, payload)
 
 
 def save_state(holding: Dict[str, Any], traded: Dict[str, Any]) -> None:
     save_state_atomic(holding, traded)
 
 
 def load_state() -> Tuple[Dict[str, Any], Dict[str, Any]]:
     if STATE_FILE.exists():
-        with open(STATE_FILE, "r", encoding="utf-8") as f:
-            state = json.load(f)
-        return state.get("holding", {}), state.get("traded", {})
+        try:
+            with open(STATE_FILE, "r", encoding="utf-8") as f:
+                state = json.load(f)
+            return state.get("holding", {}), state.get("traded", {})
+        except Exception as e:
+            logger.warning("[STATE] failed to load %s: %s", STATE_FILE, e)
     return {}, {}
 
 
 def _with_retry(func, *args, max_retries=5, base_delay=0.6, **kwargs):
     last_err = None
     for attempt in range(1, max_retries + 1):
         try:
             return func(*args, **kwargs)
         except Exception as e:
             last_err = e
             sleep_sec = base_delay * (1.6 ** (attempt - 1)) + random.uniform(0, 0.25)
             logger.error(
                 f"[Ïû¨ÏãúÎèÑ {attempt}/{max_retries}] {func.__name__} Ïã§Ìå®: {e} ‚Üí {sleep_sec:.2f}s ÎåÄÍ∏∞ ÌõÑ Ïû¨ÏãúÎèÑ"
             )
             time.sleep(sleep_sec)
     raise last_err
 
 
 def _to_int(val, default=0) -> int:
     try:
         return int(float(val))
     except Exception:
         return default
 
 
diff --git a/trader/execution.py b/trader/execution.py
index 6ca2dec4b0358b688d9872830f9934a25819d233..aa015bc55d4e6a438fbeca93e0d11a7a30ba7781 100644
--- a/trader/execution.py
+++ b/trader/execution.py
@@ -95,50 +95,52 @@ def _normalize_flags(payload: Dict[str, Any] | None) -> Dict[str, Any]:
     payload = payload or {}
     return {
         "bear_s1_done": bool(payload.get("bear_s1_done", False)),
         "bear_s2_done": bool(payload.get("bear_s2_done", False)),
     }
 
 
 def record_entry_state(
     *,
     state: Dict[str, Any],
     code: str,
     qty: int,
     avg_price: float,
     strategy_id: Any,
     engine: str,
     entry_reason: str,
     order_type: str | None,
     best_k: Any,
     tgt_px: Any,
     gap_pct_at_entry: Any,
     meta: Dict[str, Any] | None = None,
     flags: Dict[str, Any] | None = None,
     entry_time: str | None = None,
 ) -> Dict[str, Any]:
     code_key = normalize_code(code)
+    if not code_key:
+        return state
     sid_key = str(strategy_id)
     pos = state.setdefault("positions", {}).setdefault(
         code_key,
         {
             "strategies": {},
         },
     )
     strategies = pos.setdefault("strategies", {})
     existing = strategies.get(sid_key)
     if not isinstance(existing, dict):
         entry_flags = {
             "bear_s1_done": False,
             "bear_s2_done": False,
             "sold_p1": False,
             "sold_p2": False,
         }
         if flags:
             entry_flags.update(
                 {k: bool(flags.get(k)) for k in entry_flags.keys() if k in flags}
             )
         entry_meta = _normalize_meta(meta)
         entry_meta.setdefault("high", float(avg_price))
         entry_meta["high"] = max(float(entry_meta.get("high") or 0.0), float(avg_price))
         now_ts = entry_time or datetime.now(KST).isoformat()
         strategies[sid_key] = {
@@ -203,82 +205,86 @@ def record_entry_state(
                 "sold_p2": False,
             },
         )
         if flags:
             for key, value in flags.items():
                 if key in entry_flags:
                     entry_flags[key] = bool(value)
     logger.info(
         "[ENTRY] code=%s strategy=%s engine=%s best_k=%s tgt_px=%s saved_state=OK",
         code_key,
         strategy_id,
         engine,
         best_k,
         tgt_px,
     )
     return state
 
 
 def update_position_meta(
     state: Dict[str, Any],
     code: str,
     strategy_id: Any,
     meta_updates: Dict[str, Any] | None = None,
 ) -> Dict[str, Any]:
     code_key = normalize_code(code)
+    if not code_key:
+        return state
     sid_key = str(strategy_id)
     pos = state.get("positions", {}).get(code_key)
     if not isinstance(pos, dict):
         return state
     strategies = pos.get("strategies", {})
     entry = strategies.get(sid_key)
     if not isinstance(entry, dict):
         return state
     meta = entry.setdefault(
         "meta",
         {
             "pullback_peak_price": None,
             "pullback_reversal_price": None,
             "pullback_reason": None,
         },
     )
     if meta_updates:
         for key in ("pullback_peak_price", "pullback_reversal_price", "pullback_reason"):
             if key in meta_updates:
                 meta[key] = meta_updates.get(key)
     entry["last_update_ts"] = datetime.now(KST).isoformat()
     return state
 
 
 def update_position_flags(
     state: Dict[str, Any],
     code: str,
     strategy_id: Any,
     flag_updates: Dict[str, Any],
 ) -> Dict[str, Any]:
     assert strategy_id is not None, "strategy_id required for update_position_flags"
     code_key = normalize_code(code)
+    if not code_key:
+        return state
     pos = state.get("positions", {}).get(code_key)
     if not isinstance(pos, dict):
         return state
     strategies = pos.setdefault("strategies", {})
     entry = strategies.get(str(strategy_id))
     if not isinstance(entry, dict):
         return state
     flags = entry.setdefault(
         "flags",
         {"bear_s1_done": False, "bear_s2_done": False, "sold_p1": False, "sold_p2": False},
     )
     before_flags = dict(flags)
     for key in ("bear_s1_done", "bear_s2_done", "sold_p1", "sold_p2"):
         if key in flag_updates:
             flags[key] = bool(flag_updates.get(key))
     logger.info(
         "[FLAGS] code=%s flags_before=%s flags_after=%s",
         code_key,
         before_flags,
         flags,
     )
     entry["last_update_ts"] = datetime.now(KST).isoformat()
     return state
 
 def fetch_rebalancing_targets(date: str) -> list[dict[str, Any]]:
diff --git a/trader/ledger.py b/trader/ledger.py
index 0cd035c62d3af22dfb9ead47486d0a5d6a374c05..7d8ea0a3f40bd621410da24a9d1286e4381a7d4f 100644
--- a/trader/ledger.py
+++ b/trader/ledger.py
@@ -13,195 +13,211 @@ def _ensure_state(state: Dict[str, Any]) -> List[Dict[str, Any]]:
         lots = []
         state["lots"] = lots
     return lots
 
 
 def _norm_sid(value: int | str | None) -> int | str | None:
     if value is None:
         return None
     text = str(value)
     return int(text) if text.isdigit() else text
 
 
 def record_buy_fill(
     state: Dict[str, Any],
     *,
     lot_id: str,
     pdno: str,
     strategy_id: int | str,
     engine: str,
     entry_ts: str,
     entry_price: float,
     qty: int,
     meta: Dict[str, Any] | None,
 ) -> None:
     lots = _ensure_state(state)
+    code_key = normalize_code(pdno)
+    if not code_key:
+        return
     if any(lot.get("lot_id") == lot_id for lot in lots):
         return
     lots.append(
         {
             "lot_id": lot_id,
-            "pdno": normalize_code(pdno),
+            "pdno": code_key,
             "strategy_id": strategy_id,
             "engine": engine,
             "entry_ts": entry_ts,
             "entry_price": float(entry_price),
             "qty": int(qty),
             "remaining_qty": int(qty),
             "meta": meta or {},
         }
     )
 
 
 def apply_sell_fill_fifo(
     state: Dict[str, Any],
     *,
     pdno: str,
     qty_filled: int,
     sell_ts: str,
     strategy_id: int | str | None = None,
     allow_blocked: bool = False,
 ) -> None:
     lots = _ensure_state(state)
     remaining = int(qty_filled)
     if remaining <= 0:
         return
+    pdno_key = normalize_code(pdno)
+    if not pdno_key:
+        return
 
     req_sid = _norm_sid(strategy_id)
 
     def _consume(remaining_qty: int, sid_filter: int | str | None) -> int:
         for lot in lots:
-            if normalize_code(lot.get("pdno")) != normalize_code(pdno):
+            if normalize_code(lot.get("pdno")) != pdno_key:
                 continue
             if not allow_blocked and lot.get("meta", {}).get("sell_blocked") is True:
                 continue
 
             lot_sid = _norm_sid(lot.get("strategy_id"))
             if sid_filter is not None and lot_sid != sid_filter:
                 continue
 
             lot_remaining = int(lot.get("remaining_qty") or 0)
             if lot_remaining <= 0:
                 continue
 
             delta = min(lot_remaining, remaining_qty)
             lot["remaining_qty"] = int(lot_remaining - delta)
             if delta > 0:
                 lot["last_sell_ts"] = sell_ts
 
             remaining_qty -= delta
             if remaining_qty <= 0:
                 break
         return remaining_qty
 
     _consume(remaining, req_sid)
 
 
 def owned_lots_by_strategy(state: Dict[str, Any], strategy_id: int | str) -> List[Dict[str, Any]]:
     lots = _ensure_state(state)
     return [
         lot
         for lot in lots
         if int(lot.get("remaining_qty") or 0) > 0
         and _norm_sid(lot.get("strategy_id")) == _norm_sid(strategy_id)
     ]
 
 
 def remaining_qty_for_strategy(state: Dict[str, Any], pdno: str, strategy_id: int | str) -> int:
     lots = _ensure_state(state)
+    pdno_key = normalize_code(pdno)
+    if not pdno_key:
+        return 0
     total = 0
     for lot in lots:
-        if normalize_code(lot.get("pdno")) != normalize_code(pdno):
+        if normalize_code(lot.get("pdno")) != pdno_key:
             continue
         if int(lot.get("remaining_qty") or 0) <= 0:
             continue
         if _norm_sid(lot.get("strategy_id")) != _norm_sid(strategy_id):
             continue
         total += int(lot.get("remaining_qty") or 0)
     return total
 
 
 def dominant_strategy_for(state: Dict[str, Any], pdno: str) -> int | None:
     lots = _ensure_state(state)
+    pdno_key = normalize_code(pdno)
+    if not pdno_key:
+        return None
     totals: Dict[int, int] = {}
     for lot in lots:
-        if normalize_code(lot.get("pdno")) != normalize_code(pdno):
+        if normalize_code(lot.get("pdno")) != pdno_key:
             continue
         remaining = int(lot.get("remaining_qty") or 0)
         if remaining <= 0:
             continue
         sid = _norm_sid(lot.get("strategy_id"))
         if isinstance(sid, int) and 1 <= sid <= 5:
             totals[sid] = totals.get(sid, 0) + remaining
     if not totals:
         return None
     return max(totals.items(), key=lambda item: item[1])[0]
 
 
 def strategy_avg_price(
     state: Dict[str, Any], pdno: str, strategy_id: int | str
 ) -> float | None:
     lots = _ensure_state(state)
+    pdno_key = normalize_code(pdno)
+    if not pdno_key:
+        return None
     total_qty = 0
     total_cost = 0.0
     for lot in lots:
-        if normalize_code(lot.get("pdno")) != normalize_code(pdno):
+        if normalize_code(lot.get("pdno")) != pdno_key:
             continue
         if _norm_sid(lot.get("strategy_id")) != _norm_sid(strategy_id):
             continue
         remaining = int(lot.get("remaining_qty") or 0)
         if remaining <= 0:
             continue
         entry_price = float(lot.get("entry_price") or 0.0)
         total_qty += remaining
         total_cost += entry_price * remaining
     if total_qty <= 0:
         return None
     return total_cost / total_qty
 
 
 def reconcile_with_broker_holdings(state: Dict[str, Any], holdings: List[Dict[str, Any]]) -> None:
     lots = _ensure_state(state)
     holdings_map: Dict[str, Dict[str, Any]] = {}
     for row in holdings:
         code = normalize_code(row.get("code") or row.get("pdno") or "")
         if not code:
             continue
         qty = int(row.get("qty") or 0)
         avg_price = row.get("avg_price")
         existing = holdings_map.get(code)
         if existing:
             existing["qty"] += qty
             if existing.get("avg_price") is None:
                 existing["avg_price"] = avg_price
         else:
             holdings_map[code] = {"qty": qty, "avg_price": avg_price}
 
     now_ts = datetime.now(KST).isoformat()
 
     for lot in lots:
         if str(lot.get("strategy_id")) in {"ORPHAN", "UNKNOWN"}:
+            # legacy migration only: map deprecated sid to MANUAL
             lot["strategy_id"] = "MANUAL"
 
     for lot in lots:
         pdno = normalize_code(lot.get("pdno"))
         if pdno not in holdings_map or holdings_map[pdno]["qty"] <= 0:
             if int(lot.get("remaining_qty") or 0) > 0:
                 lot["remaining_qty"] = 0
 
     for pdno, payload in holdings_map.items():
         hold_qty = int(payload.get("qty") or 0)
         if hold_qty <= 0:
             continue
         total_remaining = sum(
             int(lot.get("remaining_qty") or 0)
             for lot in lots
             if normalize_code(lot.get("pdno")) == pdno
         )
         if total_remaining < hold_qty:
             diff = hold_qty - total_remaining
             lots.append(
                 {
                     "lot_id": f"{pdno}-RECON-{now_ts}",
                     "pdno": pdno,
                     "strategy_id": "MANUAL",
                     "engine": "reconcile",
diff --git a/trader/legacy_kosdaq_runner.py b/trader/legacy_kosdaq_runner.py
index 649fe24483164daf1faa61872be4524299ce2973..d8d5634aca88f6c018a2ad2c8699b1aecb2ace5c 100644
--- a/trader/legacy_kosdaq_runner.py
+++ b/trader/legacy_kosdaq_runner.py
@@ -137,50 +137,52 @@ def main(
     rebalance_date = get_rebalance_anchor_date()
     logger.info(
         f"[‚ÑπÔ∏è Î¶¨Î∞∏Îü∞Ïã± Í∏∞Ï§ÄÏùº(KST)]: {rebalance_date} (anchor={REBALANCE_ANCHOR}, ref={WEEKLY_ANCHOR_REF})"
     )
     logger.info(
         f"[‚è±Ô∏è Ïª§Ìä∏Ïò§ÌîÑ(KST)] SELL_FORCE_TIME={SELL_FORCE_TIME.strftime('%H:%M')} / Ï†ÑÏ≤¥ÏûîÍ≥†Îß§ÎèÑ={SELL_ALL_BALANCES_AT_CUTOFF} / "
         f"Ìå®Ïä§(Ïª§Ìä∏Ïò§ÌîÑ/ÎßàÍ∞ê)={FORCE_SELL_PASSES_CUTOFF}/{FORCE_SELL_PASSES_CLOSE}"
     )
     logger.info(
         f"[üí∞ CAPITAL] {effective_capital:,}Ïõê (configured DAILY_CAPITAL={DAILY_CAPITAL:,})"
     )
     logger.info(f"[üõ°Ô∏è SLIPPAGE_ENTER_GUARD_PCT] {SLIPPAGE_ENTER_GUARD_PCT:.2f}%")
 
     # ÏÉÅÌÉú Î≥µÍµ¨
     state_loaded_at = datetime.now(KST)
     state_loaded_date = state_loaded_at.strftime("%Y-%m-%d")
     state_loaded_str = state_loaded_at.strftime("%Y-%m-%d %H:%M:%S")
     state_loaded_midnight = f"{state_loaded_date} 00:00:00"
 
     holding, traded = load_state()
     lot_state_path = "bot_state/state.json"
     lot_state = load_lot_state(lot_state_path)
     position_state_path = str(STATE_PATH)
     position_state = load_position_state(position_state_path)
     position_state_dirty = False
+    sell_reconcile_needed = False
+    pending_buy_orders: list[dict[str, Any]] = []
     runtime_state = runtime_state_store.load_state()
     triggered_today: set[str] = set()
     s1_done_today: set[tuple[str, str]] = set()
     last_today_prefix: str | None = None
 
     if isinstance(traded, (set, list, tuple)):
         logger.warning(
             f"[STATE-MIGRATE] traded ÌÉÄÏûÖ {type(traded)} ‚Üí dictÎ°ú ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò(Ï§ëÎ≥µ ÏßÑÏûÖ Í∞ÄÎìú Ïú†ÏßÄ)"
         )
         traded = {
             code: {"buy_time": state_loaded_midnight, "qty": 0, "price": 0.0}
             for code in traded
         }
     elif not isinstance(traded, dict):
         logger.warning(
             f"[STATE-FORMAT] traded ÌÉÄÏûÖ {type(traded)} ÏßÄÏõê Ïïà Ìï® ‚Üí Îπà dictÎ°ú Ïû¨ÏÑ§Ï†ï"
         )
         traded = {}
     if isinstance(traded, dict):
         traded = {normalize_code(k): v for k, v in traded.items() if normalize_code(k)}
     if isinstance(holding, dict):
         holding = {normalize_code(k): v for k, v in holding.items() if normalize_code(k)}
 
     def _traded_codes(traded_state: Any) -> List[str]:
         if isinstance(traded_state, dict):
@@ -241,50 +243,205 @@ def main(
 
     def _save_position_state_now() -> None:
         nonlocal position_state_dirty
         if position_state_dirty:
             save_position_state(position_state_path, position_state)
             position_state_dirty = False
 
     def _lot_state_signature(state: dict) -> tuple:
         lots = state.get("lots")
         if not isinstance(lots, list):
             return tuple()
         return tuple(
             (
                 str(lot.get("lot_id")),
                 str(lot.get("pdno")),
                 int(lot.get("remaining_qty") or 0),
             )
             for lot in lots
         )
 
     def _maybe_save_lot_state(before_signature: tuple) -> None:
         after_signature = _lot_state_signature(lot_state)
         if after_signature != before_signature:
             save_lot_state(lot_state_path, lot_state)
 
+    def _refresh_balances_snapshot(reason: str) -> List[Dict[str, Any]]:
+        try:
+            balances = _fetch_balances(kis, ttl_sec=0)
+        except TypeError:
+            balances = _fetch_balances(kis)
+        logger.info("[BALANCE-REFRESH] reason=%s count=%s", reason, len(balances))
+        return balances
+
+    def _balance_qty(balances: List[Dict[str, Any]], code: str) -> int:
+        code_key = normalize_code(code)
+        if not code_key:
+            return 0
+        for row in balances:
+            if normalize_code(row.get("code") or row.get("pdno")) != code_key:
+                continue
+            return int(row.get("qty") or 0)
+        return 0
+
+    def _finalize_pending_buys(
+        pending_orders: List[Dict[str, Any]],
+        balances: List[Dict[str, Any]],
+    ) -> None:
+        nonlocal position_state, position_state_dirty
+        if not pending_orders:
+            return
+        for pending in list(pending_orders):
+            code = pending.get("code")
+            if not code:
+                pending_orders.remove(pending)
+                continue
+            prev_qty = int(pending.get("prev_qty") or 0)
+            new_qty = _balance_qty(balances, code)
+            delta_qty = max(0, int(new_qty) - int(prev_qty))
+            if delta_qty <= 0:
+                logger.warning(
+                    "[BUY-PENDING] %s: balance not updated yet (prev=%s new=%s)",
+                    normalize_code(code),
+                    prev_qty,
+                    new_qty,
+                )
+                continue
+
+            fill_qty = min(int(pending.get("qty") or 0), delta_qty)
+            exec_price = float(pending.get("exec_price") or 0.0)
+            strategy_id = pending.get("strategy_id")
+            trigger_label = pending.get("trigger_label")
+            k_value = pending.get("k_value")
+            target_price = pending.get("target_price")
+            gate = pending.get("gate") or {}
+            meta = pending.get("meta") or {}
+            trade_ctx = pending.get("trade_ctx") or {}
+            now_ts = pending.get("now_ts")
+            result = pending.get("result") or {}
+
+            traded[normalize_code(code)] = {
+                "buy_time": pending.get("pending_since") or now_ts,
+                "qty": int(fill_qty),
+                "price": float(exec_price),
+                "status": "filled",
+                "pending_since": None,
+            }
+            runtime_state_store.mark_fill(
+                runtime_state,
+                code,
+                "BUY",
+                strategy_id,
+                int(fill_qty),
+                float(exec_price),
+                now_ts or datetime.now(KST).isoformat(),
+                status="filled",
+            )
+            _save_runtime_state()
+
+            holding[normalize_code(code)] = {
+                "qty": int(new_qty),
+                "buy_price": float(exec_price),
+                "bear_s1_done": False,
+                "bear_s2_done": False,
+            }
+
+            _init_position_state(
+                kis,
+                holding,
+                code,
+                float(exec_price),
+                int(fill_qty),
+                k_value,
+                target_price,
+            )
+            position_state = record_entry_state(
+                state=position_state,
+                code=code,
+                qty=int(fill_qty),
+                avg_price=float(exec_price),
+                strategy_id=strategy_id,
+                engine=trigger_label,
+                entry_reason=pending.get("entry_reason") or "SETUP-OK + TRIGGER-YES",
+                order_type=pending.get("order_type") or "marketable_limit",
+                best_k=k_value,
+                tgt_px=target_price,
+                gap_pct_at_entry=pending.get("gap_pct_at_entry"),
+                meta=meta,
+                entry_time=now_ts,
+            )
+            position_state_dirty = True
+
+            lot_id = _build_lot_id(
+                result,
+                pending.get("lot_ts") or datetime.now(KST).strftime("%Y%m%d%H%M%S%f"),
+                code,
+            )
+            before_lot_signature = _lot_state_signature(lot_state)
+            record_buy_fill(
+                lot_state,
+                lot_id=lot_id,
+                pdno=code,
+                strategy_id=strategy_id,
+                engine=f"legacy_kosdaq_runner:sid{strategy_id}",
+                entry_ts=now_ts or datetime.now(KST).isoformat(),
+                entry_price=float(exec_price),
+                qty=int(fill_qty),
+                meta={
+                    "strategy_name": pending.get("strategy"),
+                    "entry_reason": pending.get("entry_reason") or "SETUP-OK + TRIGGER-YES",
+                    "strategy_gate": gate,
+                    "pullback_meta": meta,
+                    "k": k_value,
+                    "target_price": target_price,
+                    "best_k": k_value,
+                    "tgt_px": target_price,
+                    "engine": "legacy_kosdaq_runner",
+                    "rebalance_date": pending.get("rebalance_date"),
+                },
+            )
+            logger.info(
+                "[LEDGER][BUY] code=%s sid=%s lot_id=%s qty=%s",
+                normalize_code(code),
+                strategy_id,
+                lot_id,
+                fill_qty,
+            )
+            _maybe_save_lot_state(before_lot_signature)
+
+            log_trade(
+                {
+                    **trade_ctx,
+                    "price": float(exec_price),
+                    "amount": int(float(exec_price) * int(fill_qty)),
+                    "result": result,
+                }
+            )
+            pending_orders.remove(pending)
+        save_state(holding, traded)
+        _save_position_state_now()
+
     def _ensure_position_entry(
         code: str, strategy_id: int | str
     ) -> Dict[str, Any]:
         code_key = normalize_code(code)
         sid_key = str(strategy_id)
         pos = position_state.setdefault("positions", {}).setdefault(
             code_key,
             {
                 "strategies": {},
             },
         )
         entries = pos.setdefault("strategies", {})
         entry = entries.get(sid_key)
         if isinstance(entry, dict):
             return entry
         now_ts = datetime.now(KST).isoformat()
         entry = {
             "qty": int(remaining_qty_for_strategy(lot_state, code_key, sid_key)),
             "avg_price": float((holding.get(code) or {}).get("buy_price") or 0.0),
             "entry": {
                 "time": now_ts,
                 "strategy_id": sid_key,
                 "engine": "unknown",
                 "entry_reason": "RECONCILE",
                 "order_type": "unknown",
@@ -541,145 +698,104 @@ def main(
         if isinstance(result, dict):
             out = result.get("output") or {}
             order_no = (
                 out.get("ODNO")
                 or out.get("ord_no")
                 or out.get("order_no")
                 or result.get("ODNO")
                 or result.get("ord_no")
                 or result.get("order_no")
                 or ""
             )
             fill_seq = (
                 out.get("CCLD_SQ")
                 or out.get("ccld_sq")
                 or out.get("fill_seq")
                 or out.get("CCLD_NO")
                 or out.get("ccld_no")
                 or ""
             )
         if not order_no:
             order_no = f"NOORDER-{normalize_code(pdno)}-{fallback_ts}"
         if not fill_seq:
             fill_seq = "0"
         return f"{kis.CANO}-{kis.ACNT_PRDT_CD}-{order_no}-{fill_seq}"
 
-    def _estimate_sold_qty(
-        code: str, requested_qty: int, prev_qty: int, delay_sec: float = 1.0
-    ) -> int:
-        if requested_qty <= 0:
-            return 0
-        try:
-            time.sleep(delay_sec)
-            try:
-                balances = _fetch_balances(kis, ttl_sec=0)
-            except TypeError:
-                balances = _fetch_balances(kis)
-        except Exception:
-            return int(requested_qty)
-        for row in balances:
-            if normalize_code(row.get("code")) != normalize_code(code):
-                continue
-            new_qty = int(row.get("qty") or 0)
-            sold = max(0, int(prev_qty) - int(new_qty))
-            if sold <= 0:
-                return 0
-            return min(int(requested_qty), int(sold))
-        return int(requested_qty)
-
     def _sync_position_state_qty(code: str) -> None:
         nonlocal position_state_dirty
         code_key = normalize_code(code)
         pos = position_state.get("positions", {}).get(code_key)
         if not isinstance(pos, dict):
             return
         strategies = pos.get("strategies", {})
         if not isinstance(strategies, dict):
             return
         for sid in list(strategies.keys()):
             remaining = remaining_qty_for_strategy(lot_state, code_key, sid)
             if remaining <= 0:
                 strategies.pop(sid, None)
                 continue
             entry = strategies.get(sid)
             if not isinstance(entry, dict):
                 strategies.pop(sid, None)
                 continue
             if int(entry.get("qty") or 0) > int(remaining):
                 logger.warning(
                     "[STATE] qty exceeds ledger after sell: code=%s sid=%s state=%s ledger=%s",
                     code_key,
                     sid,
                     entry.get("qty"),
                     remaining,
                 )
             entry["qty"] = int(remaining)
         if not strategies:
             position_state.get("positions", {}).pop(code_key, None)
         position_state_dirty = True
 
     def _apply_sell_to_ledger_with_balance(
         code: str,
         requested_qty: int,
         sell_ts: str,
         result: Any,
         scope: str = "strategy",
         trigger_strategy_id: int | None = None,
         prev_qty_before: int | None = None,
         allow_blocked: bool = False,
     ) -> None:
+        nonlocal sell_reconcile_needed
         if not _is_order_success(result):
             return
         if scope != "strategy" and not (SELL_ALL_BALANCES_AT_CUTOFF or EMERGENCY_GLOBAL_SELL):
             raise RuntimeError(
                 f"[SELL-ALLOC] global scope used without force sell: code={code} scope={scope}"
             )
         prev_qty = int(
             prev_qty_before
             if prev_qty_before is not None
             else (holding.get(code) or {}).get("qty") or requested_qty
         )
-        sold_qty = 0
-        for delay_sec in (0.5, 1.0, 2.0):
-            sold_qty = _estimate_sold_qty(
-                code, requested_qty, prev_qty, delay_sec=delay_sec
-            )
-            if sold_qty > 0:
-                break
-        if sold_qty <= 0:
-            logger.warning(
-                "[SELL-ALLOC] sold_qty unresolved: code=%s requested=%s prev_qty=%s",
-                normalize_code(code),
-                requested_qty,
-                prev_qty,
-            )
-            try:
-                balances = _fetch_balances(kis, ttl_sec=0)
-            except TypeError:
-                balances = _fetch_balances(kis)
-            reconcile_with_broker_holdings(lot_state, balances)
-            return
+        sold_qty = min(int(requested_qty), int(prev_qty)) if prev_qty > 0 else int(requested_qty)
         if scope == "strategy" and trigger_strategy_id is None:
             raise RuntimeError(
                 f"[SELL-ALLOC] strategy scope requires trigger_strategy_id: code={code}"
             )
         if scope == "strategy":
             available_qty = remaining_qty_for_strategy(
                 lot_state, code, trigger_strategy_id
             )
             if available_qty < int(requested_qty):
                 raise RuntimeError(
                     "[SELL-ALLOC] insufficient strategy qty: code=%s sid=%s available=%s requested=%s"
                     % (normalize_code(code), trigger_strategy_id, available_qty, requested_qty)
                 )
         before_lot_signature = _lot_state_signature(lot_state)
         before_qty_total = _ledger_total_available_qty(code)
         before_qty_strategy = (
             remaining_qty_for_strategy(lot_state, code, trigger_strategy_id)
             if scope == "strategy"
             else before_qty_total
         )
         allocations = allocate_sell_qty(
             lot_state,
             code,
             int(sold_qty),
             scope=scope,
@@ -711,77 +827,63 @@ def main(
             "[SELL-ALLOC] code=%s requested_qty=%s scope=%s allocations=%s sold_qty=%s broker_qty_before=%s broker_qty_after=%s",
             normalize_code(code),
             int(requested_qty),
             scope,
             allocations,
             int(sold_qty),
             int(prev_qty),
             int(broker_qty_after),
         )
         sold_total = apply_sell_allocation(
             lot_state,
             code,
             allocations,
             sell_ts,
             allow_blocked=allow_blocked,
         )
         after_qty_total = _ledger_total_available_qty(code)
         after_qty_strategy = (
             remaining_qty_for_strategy(lot_state, code, trigger_strategy_id)
             if scope == "strategy"
             else after_qty_total
         )
         expected_before = before_qty_strategy
         expected_after = max(0, int(expected_before) - int(sold_total))
         if after_qty_strategy != expected_after:
-            resolved = False
-            for delay_sec in (0.5, 1.0, 2.0):
-                time.sleep(delay_sec)
-                retry_sold = _estimate_sold_qty(code, requested_qty, prev_qty, delay_sec=0)
-                retry_expected = max(0, int(expected_before) - int(retry_sold))
-                if after_qty_strategy == retry_expected:
-                    resolved = True
-                    break
-            if not resolved:
-                logger.warning(
-                    "[SELL-ALLOC] ledger mismatch: code=%s sid=%s before=%s sold=%s after=%s"
-                    % (
-                        normalize_code(code),
-                        trigger_strategy_id,
-                        expected_before,
-                        sold_total,
-                        after_qty_strategy,
-                    )
-                )
-                try:
-                    balances = _fetch_balances(kis, ttl_sec=0)
-                except TypeError:
-                    balances = _fetch_balances(kis)
-                reconcile_with_broker_holdings(lot_state, balances)
+            logger.warning(
+                "[SELL-ALLOC] ledger mismatch: code=%s sid=%s before=%s sold=%s after=%s",
+                normalize_code(code),
+                trigger_strategy_id,
+                expected_before,
+                sold_total,
+                after_qty_strategy,
+            )
+            sell_reconcile_needed = True
         _maybe_save_lot_state(before_lot_signature)
         _sync_position_state_qty(code)
         _save_position_state_now()
+        sell_reconcile_needed = True
 
     def _cleanup_expired_pending(
         traded_state: dict, now_dt: datetime, ttl_sec: int = 300
     ) -> set:
         expired: set[str] = set()
         if not isinstance(traded_state, dict):
             return expired
 
         for code, payload in list(traded_state.items()):
             payload = payload or {}
             if payload.get("status") != "pending":
                 continue
 
             ts = payload.get("pending_since") or payload.get("buy_time")
             if not isinstance(ts, str):
                 continue
 
             try:
                 pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(
                     tzinfo=now_dt.tzinfo
                 )
                 if (now_dt - pending_dt).total_seconds() > ttl_sec:
                     logger.warning(
                         f"[PENDING-EXPIRE] {code}: {ttl_sec}s Ï¥àÍ≥º ‚Üí pending Ï†úÍ±∞"
                     )
@@ -892,76 +994,50 @@ def main(
         except Exception:
             pass
         return "ERROR", None
 
     def _pending_block(
         traded_state: dict, code: str, now_dt: datetime, block_sec: int = 45
     ) -> bool:
         if not isinstance(traded_state, dict):
             return False
         payload = traded_state.get(code) or {}
         if payload.get("status") != "pending":
             return False
 
         ts = payload.get("pending_since") or payload.get("buy_time")
         if not isinstance(ts, str):
             return True
 
         try:
             pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(
                 tzinfo=now_dt.tzinfo
             )
             return (now_dt - pending_dt).total_seconds() <= block_sec
         except Exception:
             return True
 
-    def _is_balance_reflected(
-        code: str, prev_qty: int = 0, delay_sec: float = 1.0
-    ) -> bool:
-        try:
-            time.sleep(delay_sec)
-            balances = _fetch_balances(kis, ttl_sec=0)
-        except Exception as e:
-            logger.warning(f"[BAL-REFRESH-FAIL] {code}: ÏûîÍ≥† ÌôïÏù∏ Ïã§Ìå® {e}")
-            return False
-
-        for row in balances:
-            try:
-                if normalize_code(row.get("code")) != normalize_code(code):
-                    continue
-                qty_here = _to_int(row.get("qty") or 0)
-                sellable_here = _to_int(
-                    (row.get("sell_psbl_qty") or row.get("ord_psbl_qty")) or 0
-                )
-                baseline_qty = max(0, int(prev_qty))
-                if qty_here > baseline_qty or sellable_here > baseline_qty:
-                    return True
-            except Exception:
-                continue
-
-        return False
-
     def _subject_flow_gate(
         code: str,
         info: Dict[str, Any],
         current_price: float,
         target_price: float | None,
         vwap_val: float | None,
     ) -> tuple[bool, Dict[str, Any], float]:
         day_turnover_krw = _to_float(
             info.get("prev_turnover")
             or info.get("avg_turnover")
             or info.get("turnover"),
             0.0,
         )
         market = (info.get("market") or "KOSDAQ").upper()
         flow = get_subject_flow_with_fallback(
             kis, code, market, float(day_turnover_krw or 0.0)
         )
         score = flow.get("score") or {}
 
         turnover_guard = float(CHAMPION_A_RULES.get("min_turnover") or 0.0)
         ob_guard = 0.0
         ob_strength_val: float = 0.0
         try:
             ob_strength_val = float(
                 _to_float(kis.get_orderbook_strength(code), 0.0) or 0.0
@@ -2183,50 +2259,57 @@ def main(
                         )
                         time.sleep(loop_sleep_sec)
                         continue
                     logger.info("[‚è∞ Ïª§Ìä∏Ïò§ÌîÑ Ï¢ÖÎ£å] Î£®ÌîÑ Ï¢ÖÎ£å")
                     break
 
                 # === (1) ÏûîÏó¨ Î¨ºÎüâ ÎåÄÏÉÅ Ïä§ÌÉë/Î¶¨Î∞∏Îü∞Ïä§ Í¥ÄÎ¶¨ ===
                 for code in list(holding.keys()):
                     code_key = normalize_code(code)
                     pos_state = position_state.get("positions", {}).get(code_key)
                     entries = pos_state.get("strategies", {}) if isinstance(pos_state, dict) else {}
                     logger.info(
                         "[EXIT-CHECK] code=%s positions=%s",
                         code_key,
                         len(entries),
                     )
                     cur_price = _safe_get_price(kis, code_key)
                     for sid, entry in entries.items():
                         if not isinstance(entry, dict):
                             continue
                         avg_price = strategy_avg_price(lot_state, code_key, sid)
                         entry_meta = entry.get("meta", {}) or {}
                         high = float(entry.get("high_watermark") or entry_meta.get("high") or 0.0)
                         if avg_price is not None:
                             high = max(high, float(avg_price))
+                        if cur_price:
+                            high = max(high, float(cur_price))
+                            entry["high_watermark"] = high
+                            entry_meta["high"] = high
+                            entry["meta"] = entry_meta
+                            entry["last_update_ts"] = now_dt_kst.isoformat()
+                            position_state_dirty = True
                         flags = entry.get("flags", {}) or {}
                         avg_label = f"{avg_price:.2f}" if avg_price is not None else None
                         high_label = f"{high:.2f}" if high else None
                         pnl_pct = None
                         if cur_price and avg_price:
                             pnl_pct = (float(cur_price) - float(avg_price)) / float(avg_price) * 100.0
                         pnl_label = f"{pnl_pct:.2f}" if pnl_pct is not None else None
                         logger.info(
                             "  - sid=%s qty=%s avg=%s high=%s pnl%%=%s flags=%s engine=%s",
                             sid,
                             entry.get("qty"),
                             avg_label,
                             high_label,
                             pnl_label,
                             flags,
                             entry.get("engine") or entry.get("entry", {}).get("engine"),
                         )
                     # Ïã†Í∑ú ÏßÑÏûÖ Í∏àÏßÄ Î™®Îìú
                     if code not in code_to_target:
                         continue
 
                     # --- 1a) Í∞ïÏ†ú Î†àÏßêÎ≥Ñ Ï∂ïÏÜå Î°úÏßÅ ---
                     sellable_qty = ord_psbl_map.get(code, 0)
                     if sellable_qty <= 0:
                         continue
@@ -2394,50 +2477,82 @@ def main(
                                     now_dt_kst.isoformat(),
                                     result,
                                     scope="strategy",
                                     trigger_strategy_id=5,
                                     prev_qty_before=prev_qty_before,
                                 )
                                 runtime_state_store.mark_fill(
                                     runtime_state,
                                     code,
                                     "SELL",
                                     5,
                                     int(sell_qty),
                                     float(exec_px or 0.0),
                                     now_dt_kst.isoformat(),
                                     status="filled",
                                 )
                                 _save_runtime_state()
                                 save_state(holding, traded)
                                 time.sleep(RATE_SLEEP_SEC)
                                 logger.info(
                                     "[PULLBACK-STOP] code=%s current=%s reason=reversal_break",
                                     code,
                                     current_price,
                                 )
 
+                if sell_reconcile_needed:
+                    balances_after_sell = _refresh_balances_snapshot("sell_batch")
+                    holding = {}
+                    for bal in balances_after_sell:
+                        code = normalize_code(bal.get("code") or bal.get("pdno"))
+                        qty = int(bal.get("qty", 0))
+                        if qty <= 0:
+                            continue
+                        price = float(bal.get("avg_price", 0.0))
+                        holding[code] = {
+                            "qty": qty,
+                            "buy_price": price,
+                            "bear_s1_done": False,
+                            "bear_s2_done": False,
+                        }
+                        _init_position_state_from_balance(kis, holding, code, price, qty)
+                    reconcile_with_broker_holdings(lot_state, balances_after_sell)
+                    position_state = reconcile_with_broker(
+                        position_state, balances_after_sell, lot_state=lot_state
+                    )
+                    position_state = reconcile_positions(
+                        balances_after_sell,
+                        position_state,
+                        _load_trade_log(),
+                        processed_targets.keys(),
+                    )
+                    position_state_dirty = True
+                    sell_reconcile_needed = False
+                    _save_position_state_now()
+
+                _save_position_state_now()
+
                 # === (2) Ïã†Í∑ú ÏßÑÏûÖ Î°úÏßÅ (Ï±îÌîºÏñ∏) ===
                 for code, info in code_to_target.items():
                     if not can_buy:
                         continue
 
                     if code in traded_today:
                         continue
 
                     if code in holding and not ALLOW_PYRAMID:
                         continue
 
                     if code in triggered_today:
                         logger.info(f"[TRIGGER-SKIP] {code}: Í∏àÏùº Ïù¥ÎØ∏ Ìä∏Î¶¨Í±∞ Î∞úÏÉù")
                         continue
 
                     target_qty = int(info.get("qty", 0))
                     if target_qty <= 0:
                         logger.info(f"[REBALANCE] {code}: target_qty=0 ‚Üí Ïä§ÌÇµ")
                         continue
 
                     target_price = info.get("target_price")
                     k_value = info.get("best_k")
                     strategy = info.get("strategy")
                     weight = _to_float(info.get("weight") or 0.0)
 
@@ -2510,50 +2625,52 @@ def main(
                     )
                     daily_ctx = normalize_daily_ctx(daily_ctx)
                     intra_ctx = _compute_intraday_entry_context(
                         kis, code, fast=MOM_FAST, slow=MOM_SLOW
                     )
                     intra_ctx = normalize_intraday_ctx(intra_ctx)
 
                     momentum_confirmed = bool(
                         daily_ctx.get("strong_trend")
                         or intra_ctx.get("vwap_reclaim")
                         or intra_ctx.get("range_break")
                     )
 
                     if mode == "neutral" and not (
                         info.get("champion_grade") in ("A", "B") or momentum_confirmed
                     ):
                         logger.info(
                             f"[ENTRY-SKIP] {code}: neutral Î†àÏßêÏóêÏÑú ÎπÑÏ±îÌîºÏñ∏/Î™®Î©òÌÖÄ ÎØ∏ÌôïÏù∏ ‚Üí Ïã†Í∑ú ÏßÑÏûÖ Î≥¥Î•ò"
                         )
                         continue
 
                     setup_state = signals.evaluate_setup_gate(
                         daily_ctx, intra_ctx, regime_state=regime_state
                     )
                     if not setup_state.get("ok"):
+                        if not setup_state.get("reasons"):
+                            setup_state["reasons"] = ["setup_flag_false"]
                         logger.info(
                             "[SETUP-BAD] %s | reasons=%s | daily=%s intra=%s regime=%s",
                             code,
                             setup_state.get("reasons"),
                             daily_ctx,
                             intra_ctx,
                             regime_state,
                         )
                         continue
                     logger.info(
                         "[SETUP-OK] %s | daily=%s intra=%s regime=%s",
                         code,
                         daily_ctx,
                         intra_ctx,
                         regime_state,
                     )
 
                     # === Ï†ÑÎûµÎ≥Ñ ÏßÑÏûÖ Í≤åÏù¥Ìä∏ (Ï†ÑÎûµ 1~5) ===
                     strategy_id = _normalize_strategy_id(info.get("strategy_id") or _derive_strategy_id(info))
                     gate = strategy_entry_gate(
                         strategy_id,
                         info,
                         daily_ctx,
                         intra_ctx,
                         now_dt_kst=now_dt_kst,
@@ -2715,162 +2832,86 @@ def main(
                         int(qty),
                         float(current_price),
                         now_dt_kst.isoformat(),
                         status="submitted",
                     )
                     _save_runtime_state()
                     if not _is_order_success(result):
                         logger.warning(f"[BUY-FAIL] {code}: result={result}")
                         continue
 
                     triggered_today.add(code)
 
                     exec_price = _extract_fill_price(result, current_price)
                     _record_trade(
                         traded,
                         code,
                         {
                             "buy_time": now_str,
                             "qty": int(qty),
                             "price": float(exec_price),
                             "status": "pending",
                             "pending_since": now_str,
                         },
                     )
                     traded_today.add(code)
-                    save_state(holding, traded)
-                    if not _is_balance_reflected(code, prev_qty=prev_qty):
-                        logger.warning(
-                            f"[BUY-PENDING] {code}: ÏûîÍ≥†Ïóê Î∞òÏòÅÎêòÏßÄ ÏïäÏïÑ ÏÉÅÌÉú Í∏∞Î°ù Î≥¥Î•ò(result={result})"
-                        )
-                        continue
-                    traded[code]["status"] = "filled"
-                    _record_trade(
-                        traded,
-                        code,
+                    pending_buy_orders.append(
                         {
-                            "buy_time": now_str,
+                            "code": code,
                             "qty": int(qty),
-                            "price": float(exec_price),
-                            "status": "filled",
-                            "pending_since": None,
-                        },
-                    )
-                    runtime_state_store.mark_fill(
-                        runtime_state,
-                        code,
-                        "BUY",
-                        strategy_id,
-                        int(qty),
-                        float(exec_price),
-                        now_dt_kst.isoformat(),
-                        status="filled",
-                    )
-                    _save_runtime_state()
-
-                    _init_position_state(
-                        kis,
-                        holding,
-                        code,
-                        float(exec_price),
-                        int(qty),
-                        k_value,
-                        target_price,
-                    )
-                    position_state = record_entry_state(
-                        state=position_state,
-                        code=code,
-                        qty=int(qty),
-                        avg_price=float(exec_price),
-                        strategy_id=strategy_id,
-                        engine=trigger_label,
-                        entry_reason="SETUP-OK + TRIGGER-YES",
-                        order_type="marketable_limit",
-                        best_k=k_value,
-                        tgt_px=target_price,
-                        gap_pct_at_entry=trigger_state.get("gap_pct"),
-                        entry_time=now_dt_kst.isoformat(),
-                    )
-                    position_state_dirty = True
-                    _save_position_state_now()
-
-                    lot_id = _build_lot_id(
-                        result,
-                        now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
-                        code,
-                    )
-                    before_lot_signature = _lot_state_signature(lot_state)
-                    record_buy_fill(
-                        lot_state,
-                        lot_id=lot_id,
-                        pdno=code,
-                        strategy_id=strategy_id,
-                        engine=f"legacy_kosdaq_runner:sid{strategy_id}",
-                        entry_ts=now_dt_kst.isoformat(),
-                        entry_price=float(exec_price),
-                        qty=int(qty),
-                        meta={
-                            "strategy_name": strategy,
-                            "entry_reason": str(gate.get("entry_reason") or "SETUP-OK") + " + TRIGGER-YES",
-                            "strategy_gate": gate,
-                            "k": k_value,
+                            "exec_price": float(exec_price),
+                            "strategy_id": strategy_id,
+                            "trigger_label": trigger_label,
+                            "k_value": k_value,
                             "target_price": target_price,
-                            "best_k": k_value,
-                            "tgt_px": target_price,
-                            "engine": "legacy_kosdaq_runner",
-                            "rebalance_date": str(rebalance_date),
-                        },
-                    )
-                    logger.info(
-                        "[LEDGER][BUY] code=%s sid=%s lot_id=%s qty=%s",
-                        code,
-                        strategy_id,
-                        lot_id,
-                        qty,
-                    )
-                    _maybe_save_lot_state(before_lot_signature)
-                    if _lot_state_signature(lot_state) == before_lot_signature:
-                        raise RuntimeError(
-                            f"[LEDGER][BUY] failed to persist lot: code={code} sid={strategy_id}"
-                        )
-
-                    log_trade(
-                        {
-                            **trade_ctx,
-                            "price": float(exec_price),
-                            "amount": int(float(exec_price) * int(qty)),
+                            "gate": gate,
+                            "strategy": strategy,
+                            "trade_ctx": trade_ctx,
                             "result": result,
+                            "now_ts": now_dt_kst.isoformat(),
+                            "pending_since": now_str,
+                            "prev_qty": prev_qty,
+                            "entry_reason": "SETUP-OK + TRIGGER-YES",
+                            "order_type": "marketable_limit",
+                            "gap_pct_at_entry": trigger_state.get("gap_pct"),
+                            "rebalance_date": str(rebalance_date),
+                            "lot_ts": now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
                         }
                     )
+                    save_state(holding, traded)
                     effective_cash = _get_effective_ord_cash(
                         kis, soft_cap=effective_capital
                     )
                     if effective_cash <= 0:
                         can_buy = False
                     save_state(holding, traded)
                     time.sleep(RATE_SLEEP_SEC)
 
+                if pending_buy_orders:
+                    balances_after_buy = _refresh_balances_snapshot("buy_batch")
+                    _finalize_pending_buys(pending_buy_orders, balances_after_buy)
+
                 # ====== ÎàåÎ¶ºÎ™© Ï†ÑÏö© Îß§Ïàò (Ï±îÌîºÏñ∏Í≥º ÎèÖÎ¶ΩÏ†ÅÏúºÎ°ú Top-N ÏãúÏ¥ù Î¶¨Ïä§Ìä∏ Ïä§Ï∫î) ======
                 if USE_PULLBACK_ENTRY and is_open:
                     if not can_buy:
                         logger.info("[PULLBACK-SKIP] can_buy=False ‚Üí Ïã†Í∑ú Îß§Ïàò Ïä§ÌÇµ")
                     else:
                         if pullback_watch:
                             logger.info(f"[PULLBACK-SCAN] {len(pullback_watch)}Ï¢ÖÎ™© Í≤ÄÏÇ¨")
 
                         for code, info in list(pullback_watch.items()):
                             if pullback_buys_today >= PULLBACK_MAX_BUYS_PER_DAY:
                                 logger.info(
                                     f"[PULLBACK-LIMIT] ÌïòÎ£® ÏµúÎåÄ {PULLBACK_MAX_BUYS_PER_DAY}Í±¥ ÎèÑÎã¨ ‚Üí Ïä§Ï∫î Ï§ëÎã®"
                                 )
                                 break
 
                             if code in traded_today or code in holding:
                                 continue  # Ï±îÌîºÏñ∏ Î£®ÌîÑÏôÄ Î≥ÑÎèÑÎ°úÎßå Ï≤òÎ¶¨
 
                             if remaining_qty_for_strategy(lot_state, code, 5) > 0:
                                 logger.info(
                                     "[ENTRY-SKIP] already owned in ledger: code=%s sid=5",
                                     code,
                                 )
                                 continue
 
@@ -3000,198 +3041,104 @@ def main(
                             _save_runtime_state()
 
                             if not _is_order_success(result):
                                 logger.warning(
                                     f"[PULLBACK-BUY-FAIL] {code}: result={result}"
                                 )
                                 continue
 
                             triggered_today.add(code)
                             exec_price = _extract_fill_price(
                                 result, trigger_price or current_price
                             )
                             _record_trade(
                                 traded,
                                 code,
                                 {
                                     "buy_time": now_str,
                                     "qty": int(qty),
                                     "price": float(exec_price),
                                     "status": "pending",
                                     "pending_since": now_str,
                                 },
                             )
                             traded_today.add(code)
                             save_state(holding, traded)
-                            if not _is_balance_reflected(code, prev_qty=prev_qty):
-                                logger.warning(
-                                    f"[PULLBACK-PENDING] {code}: ÏûîÍ≥†Ïóê Î∞òÏòÅÎêòÏßÄ ÏïäÏïÑ ÏÉÅÌÉú Í∏∞Î°ù Î≥¥Î•ò(result={result})"
-                                )
-                                continue
-
-                            traded[code]["status"] = "filled"
-                            holding[code] = {
-                                "qty": int(qty),
-                                "buy_price": float(exec_price),
-                                "bear_s1_done": False,
-                                "bear_s2_done": False,
-                            }
-                            _record_trade(
-                                traded,
-                                code,
-                                {
-                                    "buy_time": now_str,
-                                    "qty": int(qty),
-                                    "price": float(exec_price),
-                                    "status": "filled",
-                                    "pending_since": None,
-                                },
-                            )
-                            runtime_state_store.mark_fill(
-                                runtime_state,
-                                code,
-                                "BUY",
-                                5,
-                                int(qty),
-                                float(exec_price),
-                                now_dt_kst.isoformat(),
-                                status="filled",
-                            )
-                            _save_runtime_state()
-                            pullback_buys_today += 1
-
-                            try:
-                                _init_position_state(
-                                    kis,
-                                    holding,
-                                    code,
-                                    float(exec_price),
-                                    int(qty),
-                                    None,
-                                    trigger_price,
-                                )
-                            except Exception as e:
-                                logger.warning(f"[PULLBACK-INIT-FAIL] {code}: {e}")
-
                             pullback_meta = {}
                             if isinstance(resp, dict):
                                 pullback_meta = {
                                     "pullback_peak_price": resp.get("peak_price"),
                                     "pullback_reversal_price": resp.get("reversal_price"),
                                     "pullback_reason": resp.get("reason"),
                                 }
-                            position_state = record_entry_state(
-                                state=position_state,
-                                code=code,
-                                qty=int(qty),
-                                avg_price=float(exec_price),
-                                strategy_id=5,
-                                engine="pullback",
-                                entry_reason="PULLBACK-SETUP + REVERSAL",
-                                order_type="marketable_limit",
-                                best_k=None,
-                                tgt_px=trigger_price,
-                                gap_pct_at_entry=None,
-                                meta=pullback_meta,
-                                entry_time=now_dt_kst.isoformat(),
-                            )
-                            position_state_dirty = True
-                            _save_position_state_now()
-
-                            lot_id = _build_lot_id(
-                                result,
-                                now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
-                                code,
-                            )
-                            before_lot_signature = _lot_state_signature(lot_state)
-                            record_buy_fill(
-                                lot_state,
-                                lot_id=lot_id,
-                                pdno=code,
-                                strategy_id=5,
-                                engine=f"legacy_kosdaq_runner:sid{strategy_id}",
-                                entry_ts=now_dt_kst.isoformat(),
-                                entry_price=float(exec_price),
-                                qty=int(qty),
-                                meta={
-                                    "strategy_name": f"ÏΩîÏä§Îã• Top{PULLBACK_TOPN} ÎàåÎ¶ºÎ™©",
-                                    "entry_reason": "PULLBACK-SETUP + REVERSAL",
-                                    "k": None,
-                                    "target_price": trigger_price,
-                                    "best_k": None,
-                                    "tgt_px": trigger_price,
-                                    "pullback_peak_price": resp.get("peak_price")
-                                    if isinstance(resp, dict)
-                                    else None,
-                                    "pullback_reversal_price": resp.get("reversal_price")
-                                    if isinstance(resp, dict)
-                                    else None,
-                                    "engine": "legacy_kosdaq_runner",
-                                    "rebalance_date": str(rebalance_date),
-                                },
-                            )
-                            logger.info(
-                                "[LEDGER][BUY] code=%s sid=%s lot_id=%s qty=%s",
-                                code,
-                                5,
-                                lot_id,
-                                qty,
-                            )
-                            _maybe_save_lot_state(before_lot_signature)
-                            if _lot_state_signature(lot_state) == before_lot_signature:
-                                raise RuntimeError(
-                                    f"[LEDGER][BUY] failed to persist lot: code={code} sid=5"
-                                )
-
-                            logger.info(
-                                f"[‚úÖ ÎàåÎ¶ºÎ™© Îß§Ïàò] {code}, qty={qty}, price={exec_price}, trigger={trigger_price}, result={result}"
-                            )
-
-                            log_trade(
+                            pending_buy_orders.append(
                                 {
-                                    "datetime": now_str,
                                     "code": code,
-                                    "name": info.get("name"),
                                     "qty": int(qty),
-                                    "K": None,
+                                    "exec_price": float(exec_price),
+                                    "strategy_id": 5,
+                                    "trigger_label": "pullback",
+                                    "k_value": None,
                                     "target_price": trigger_price,
+                                    "gate": {},
                                     "strategy": f"ÏΩîÏä§Îã• Top{PULLBACK_TOPN} ÎàåÎ¶ºÎ™©",
-                                    "strategy_id": 5,
-                                    "side": "BUY",
-                                    "price": float(exec_price),
-                                    "amount": int(float(exec_price) * int(qty)),
+                                    "trade_ctx": {
+                                        "datetime": now_str,
+                                        "code": code,
+                                        "name": info.get("name"),
+                                        "qty": int(qty),
+                                        "K": None,
+                                        "target_price": trigger_price,
+                                        "strategy": f"ÏΩîÏä§Îã• Top{PULLBACK_TOPN} ÎàåÎ¶ºÎ™©",
+                                        "strategy_id": 5,
+                                        "side": "BUY",
+                                    },
                                     "result": result,
+                                    "now_ts": now_dt_kst.isoformat(),
+                                    "pending_since": now_str,
+                                    "prev_qty": prev_qty,
+                                    "entry_reason": "PULLBACK-SETUP + REVERSAL",
+                                    "order_type": "marketable_limit",
+                                    "gap_pct_at_entry": None,
+                                    "rebalance_date": str(rebalance_date),
+                                    "lot_ts": now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
+                                    "meta": pullback_meta,
                                 }
                             )
+                            pullback_buys_today += 1
                             effective_cash = _get_effective_ord_cash(
                                 kis, soft_cap=effective_capital
                             )
                             if effective_cash <= 0:
                                 can_buy = False
                             save_state(holding, traded)
                             time.sleep(RATE_SLEEP_SEC)
 
+                if pending_buy_orders:
+                    balances_after_pullback = _refresh_balances_snapshot("pullback_buy_batch")
+                    _finalize_pending_buys(pending_buy_orders, balances_after_pullback)
+
                 # ====== (A) ÎπÑÌÉÄÍ≤ü Î≥¥Ïú†Î∂ÑÎèÑ Ïû•Ï§ë Îä•ÎèôÍ¥ÄÎ¶¨ ======
                 if is_open:
                     for code in list(holding.keys()):
                         if code in code_to_target:
                             continue  # ÏúÑ Î£®ÌîÑÏóêÏÑú Ïù¥ÎØ∏ Ï≤òÎ¶¨
 
                         # ÏïΩÏÑ∏ Îã®Í≥Ñ Ï∂ïÏÜå(ÎπÑÌÉÄÍ≤ü)
                         if regime["mode"] == "bear":
                             _run_bear_reduction(code, is_target=False, regime=regime)
 
                         try:
                             momentum_intact, trend_ctx = _has_bullish_trend_structure(
                                 kis, code
                             )
                         except NetTemporaryError:
                             logger.warning(
                                 f"[20D_TREND_TEMP_SKIP] {code}: ÎÑ§Ìä∏ÏõåÌÅ¨ ÏùºÏãú Ïã§Ìå® ‚Üí Ïù¥Î≤à Î£®ÌîÑ Ïä§ÌÇµ"
                             )
                             continue
                         except DataEmptyError:
                             logger.warning(
                                 f"[DATA_EMPTY] {code}: 0Ï∫îÎì§ ‚Üí Îã§Ïùå Î£®ÌîÑÏóêÏÑú Ïû¨ÌôïÏù∏"
                             )
                             continue
                         except DataShortError:
diff --git a/trader/lot_state_store.py b/trader/lot_state_store.py
index c9abbef01fcad350102e566107b42f8206ac791b..7b6747de9a14efdb3380e7d6b5a48507e3691b5d 100644
--- a/trader/lot_state_store.py
+++ b/trader/lot_state_store.py
@@ -1,40 +1,37 @@
 from __future__ import annotations
 
 import json
 import logging
-import os
 from pathlib import Path
 from typing import Any, Dict
 
+from .state_io import atomic_write_json
+
 logger = logging.getLogger(__name__)
 
 
 def load_lot_state(path_json: str) -> Dict[str, Any]:
     path = Path(path_json)
     if not path.exists():
         return {"lots": []}
     try:
         with open(path, "r", encoding="utf-8") as f:
             state = json.load(f)
         if not isinstance(state, dict):
             logger.warning("[LOT_STATE] invalid format: %s", type(state))
             return {"lots": []}
         state.setdefault("lots", [])
         return state
     except Exception:
         logger.exception("[LOT_STATE] failed to load %s", path_json)
         return {"lots": []}
 
 
 def save_lot_state(path_json: str, state: Dict[str, Any]) -> None:
     path = Path(path_json)
     try:
-        path.parent.mkdir(parents=True, exist_ok=True)
         payload = dict(state)
         payload.setdefault("lots", [])
-        tmp_path = path.with_name(f"{path.name}.tmp")
-        with open(tmp_path, "w", encoding="utf-8") as f:
-            json.dump(payload, f, ensure_ascii=False, indent=2)
-        os.replace(tmp_path, path)
+        atomic_write_json(path, payload)
     except Exception:
         logger.exception("[LOT_STATE] failed to save %s", path_json)
diff --git a/trader/position_state_store.py b/trader/position_state_store.py
index 40eea91801b5e681a7a4bc3a114f09298a698873..48e649b321fd522aea72bd9f84af899dd04df4f0 100644
--- a/trader/position_state_store.py
+++ b/trader/position_state_store.py
@@ -1,37 +1,38 @@
 from __future__ import annotations
 
 import json
 import logging
 import os
 from datetime import datetime
 from pathlib import Path
 import re
 from typing import Any, Dict, Iterable
 
-from .config import KST
+from .config import KST, STATE_PATH
 from .code_utils import normalize_code
+from .state_io import atomic_write_json
 
 logger = logging.getLogger(__name__)
 
 SCHEMA_VERSION = 2
 
 
 def _empty_state() -> Dict[str, Any]:
     return {
         "schema_version": SCHEMA_VERSION,
         "updated_at": None,
         "positions": {},
         "memory": {"last_price": {}, "last_seen": {}},
     }
 
 
 def _coerce_state(state: Dict[str, Any]) -> Dict[str, Any]:
     if not isinstance(state, dict):
         return _empty_state()
     state["schema_version"] = SCHEMA_VERSION
     state.setdefault("updated_at", None)
     positions = state.get("positions")
     if not isinstance(positions, dict):
         positions = {}
         state["positions"] = positions
     memory = state.get("memory")
@@ -61,65 +62,66 @@ def _coerce_state(state: Dict[str, Any]) -> Dict[str, Any]:
                         continue
                     strategies[str(sid)] = {
                         "qty": int(entry.get("qty") or 0),
                         "avg_price": float(entry.get("avg_price") or 0.0),
                         "entry": entry.get("entry") or {},
                         "meta": entry.get("meta") or {},
                         "flags": {
                             "bear_s1_done": bool(flags.get("bear_s1_done", False)),
                             "bear_s2_done": bool(flags.get("bear_s2_done", False)),
                             "sold_p1": bool(entry.get("sold_p1", False)),
                             "sold_p2": bool(entry.get("sold_p2", False)),
                         },
                     }
             positions[code_key] = {"strategies": strategies}
         else:
             payload.setdefault("strategies", {})
         strategies = positions[code_key].get("strategies")
         if not isinstance(strategies, dict):
             positions[code_key]["strategies"] = {}
             strategies = positions[code_key]["strategies"]
         for sid, entry in list(strategies.items()):
             if not isinstance(entry, dict):
                 strategies.pop(sid, None)
                 continue
             if sid in {"ORPHAN", "UNKNOWN"}:
+                # legacy migration only: map deprecated sid to MANUAL
                 strategies.pop(sid, None)
                 sid = "MANUAL"
                 strategies.setdefault(sid, entry)
             entry.setdefault("qty", 0)
             entry.setdefault("avg_price", 0.0)
             entry.setdefault("entry", {})
             entry.setdefault("meta", {})
             meta = entry["meta"]
             avg_price = float(entry.get("avg_price") or 0.0)
             if not meta.get("high") or float(meta.get("high") or 0.0) <= 0:
                 meta["high"] = avg_price
             meta["high"] = max(float(meta.get("high") or 0.0), avg_price)
             entry.setdefault("code", code_key)
             entry.setdefault("sid", str(sid))
-            entry.setdefault("engine", entry.get("entry", {}).get("engine"))
+            entry.setdefault("engine", entry.get("entry", {}).get("engine") or "reconcile")
             entry.setdefault("entry_ts", entry.get("entry", {}).get("time"))
             entry.setdefault("high_watermark", float(meta.get("high") or avg_price))
             entry["high_watermark"] = max(
                 float(entry.get("high_watermark") or 0.0),
                 float(meta.get("high") or 0.0),
                 avg_price,
             )
             entry.setdefault("last_update_ts", entry.get("entry", {}).get("time"))
             entry.setdefault(
                 "flags",
                 {"bear_s1_done": False, "bear_s2_done": False, "sold_p1": False, "sold_p2": False},
             )
     return state
 
 
 def migrate_position_state(state: Dict[str, Any]) -> Dict[str, Any]:
     if not isinstance(state, dict):
         return _empty_state()
     schema_version = int(state.get("schema_version") or 1)
     if schema_version >= SCHEMA_VERSION:
         return state
     positions = state.get("positions")
     if not isinstance(positions, dict):
         state["positions"] = {}
         state["schema_version"] = SCHEMA_VERSION
@@ -189,61 +191,67 @@ def load_position_state(path: str) -> Dict[str, Any]:
         with open(path_obj, "r", encoding="utf-8") as f:
             payload = json.load(f)
         migrated = migrate_position_state(payload)
         state = _coerce_state(migrated)
         if int(payload.get("schema_version") or 1) < SCHEMA_VERSION:
             save_position_state(path, state)
         logger.info(
             "[STATE] loaded path=%s positions=%s updated_at=%s",
             path_obj,
             len(state.get("positions", {})),
             state.get("updated_at"),
         )
         return state
     except json.JSONDecodeError:
         logger.warning("[STATE] corrupted json, backing up: %s", path_obj)
         _backup_corrupt(path_obj)
         return _empty_state()
     except Exception:
         logger.exception("[STATE] failed to load %s", path_obj)
         return _empty_state()
 
 
 def save_position_state(path: str, state: Dict[str, Any]) -> None:
     path_obj = Path(path)
     try:
-        path_obj.parent.mkdir(parents=True, exist_ok=True)
         payload = _coerce_state(dict(state))
         payload["updated_at"] = datetime.now(KST).isoformat()
-        tmp_path = path_obj.with_name(f"{path_obj.name}.tmp")
-        with open(tmp_path, "w", encoding="utf-8") as f:
-            json.dump(payload, f, ensure_ascii=False, indent=2)
-        os.replace(tmp_path, path_obj)
+        atomic_write_json(path_obj, payload)
     except Exception:
         logger.exception("[STATE] failed to save %s", path_obj)
 
 
+def load_state(path: str | None = None) -> Dict[str, Any]:
+    path_value = path or str(STATE_PATH)
+    return load_position_state(path_value)
+
+
+def save_state_atomic(state: Dict[str, Any], path: str | None = None) -> None:
+    path_value = path or str(STATE_PATH)
+    save_position_state(path_value, state)
+
+
 def _orphan_entry(code: str, qty: int, avg_price: float | None) -> Dict[str, Any]:
     now_ts = datetime.now(KST).isoformat()
     return {
         "qty": int(qty),
         "avg_price": float(avg_price or 0.0),
         "entry": {
             "time": now_ts,
             "strategy_id": "MANUAL",
             "engine": "unknown",
             "entry_reason": "RECONCILE",
             "order_type": "unknown",
             "best_k": None,
             "tgt_px": None,
             "gap_pct_at_entry": None,
         },
         "meta": {
             "pullback_peak_price": None,
             "pullback_reversal_price": None,
             "pullback_reason": None,
         },
         "code": code,
         "sid": "MANUAL",
         "engine": "unknown",
         "entry_ts": now_ts,
         "high_watermark": float(avg_price or 0.0),
@@ -472,50 +480,51 @@ def reconcile_positions(
                     "strategy_id": sid_key,
                     "engine": engine,
                     "entry_reason": "RECONCILE",
                     "order_type": "unknown",
                     "best_k": None,
                     "tgt_px": None,
                     "gap_pct_at_entry": None,
                 },
                 "meta": {},
                 "flags": {
                     "bear_s1_done": False,
                     "bear_s2_done": False,
                     "sold_p1": False,
                     "sold_p2": False,
                 },
                 "code": code_key,
                 "sid": sid_key,
                 "engine": engine,
                 "entry_ts": now_ts,
                 "high_watermark": float(avg_price),
                 "last_update_ts": now_ts,
             }
 
         for sid in list(strategies.keys()):
             if sid in {"ORPHAN", "UNKNOWN"}:
+                # legacy migration only: map deprecated sid to MANUAL
                 strategies.pop(sid, None)
                 sid_key, engine = _fallback_sid()
                 now_ts = datetime.now(KST).isoformat()
                 strategies[sid_key] = {
                     "qty": int(qty),
                     "avg_price": float(avg_price),
                     "entry": {
                         "time": now_ts,
                         "strategy_id": sid_key,
                         "engine": engine,
                         "entry_reason": "RECONCILE",
                         "order_type": "unknown",
                         "best_k": None,
                         "tgt_px": None,
                         "gap_pct_at_entry": None,
                     },
                     "meta": {},
                     "flags": {
                         "bear_s1_done": False,
                         "bear_s2_done": False,
                         "sold_p1": False,
                         "sold_p2": False,
                     },
                     "code": code_key,
                     "sid": sid_key,
diff --git a/trader/state_io.py b/trader/state_io.py
new file mode 100644
index 0000000000000000000000000000000000000000..e8616bc64ec201c7cd1d4374013aa3868352d7f0
--- /dev/null
+++ b/trader/state_io.py
@@ -0,0 +1,16 @@
+from __future__ import annotations
+
+import json
+import os
+from pathlib import Path
+from typing import Any, Dict
+
+
+def atomic_write_json(path: Path, payload: Dict[str, Any]) -> None:
+    path.parent.mkdir(parents=True, exist_ok=True)
+    tmp_path = path.with_name(f"{path.name}.tmp")
+    with open(tmp_path, "w", encoding="utf-8") as f:
+        json.dump(payload, f, ensure_ascii=False, indent=2)
+        f.flush()
+        os.fsync(f.fileno())
+    os.replace(tmp_path, path)
diff --git a/trader/state_store.py b/trader/state_store.py
index 0034136ef116f93ccc222c9b7afdaa0b33b4d8ce..ce91e77bc163f6693a7aa821f135d31d5c3bd445 100644
--- a/trader/state_store.py
+++ b/trader/state_store.py
@@ -1,84 +1,80 @@
 from __future__ import annotations
 
 import json
 import logging
-import os
 from datetime import datetime
 from pathlib import Path
 from typing import Any, Dict
 
 from .config import KST
 from .code_utils import normalize_code
+from .state_io import atomic_write_json
 
 logger = logging.getLogger(__name__)
 
 SCHEMA_VERSION = 1
 RUNTIME_STATE_DIR = Path(".runtime")
 RUNTIME_STATE_PATH = RUNTIME_STATE_DIR / "state.json"
 
 
 def _default_runtime_state() -> Dict[str, Any]:
     return {
         "schema_version": SCHEMA_VERSION,
         "updated_at": None,
         "positions": {},
         "orders": {},
     }
 
 
 def load_state() -> Dict[str, Any]:
     if not RUNTIME_STATE_PATH.exists():
         return _default_runtime_state()
     try:
         with open(RUNTIME_STATE_PATH, "r", encoding="utf-8") as f:
             state = json.load(f)
         if not isinstance(state, dict):
             logger.warning("[RUNTIME_STATE] invalid state format: %s", type(state))
             return _default_runtime_state()
         state.setdefault("schema_version", SCHEMA_VERSION)
         state.setdefault("positions", {})
         state.setdefault("orders", {})
         state.setdefault("updated_at", None)
         return state
     except Exception:
         logger.exception("[RUNTIME_STATE] failed to load %s", RUNTIME_STATE_PATH)
         return _default_runtime_state()
 
 
 def save_state(state: Dict[str, Any]) -> None:
     try:
-        RUNTIME_STATE_DIR.mkdir(parents=True, exist_ok=True)
         payload = dict(state)
         payload.setdefault("schema_version", SCHEMA_VERSION)
         payload.setdefault("positions", {})
         payload.setdefault("orders", {})
         payload["updated_at"] = datetime.now(KST).isoformat()
-        tmp_path = RUNTIME_STATE_PATH.with_name(f"{RUNTIME_STATE_PATH.name}.tmp")
-        with open(tmp_path, "w", encoding="utf-8") as f:
-            json.dump(payload, f, ensure_ascii=False, indent=2)
-        os.replace(tmp_path, RUNTIME_STATE_PATH)
+        atomic_write_json(RUNTIME_STATE_PATH, payload)
     except Exception:
         logger.exception("[RUNTIME_STATE] failed to save %s", RUNTIME_STATE_PATH)
 
 
 def get_position(state: Dict[str, Any], symbol: str) -> Dict[str, Any] | None:
     positions = state.get("positions", {})
     if not isinstance(positions, dict):
         return None
     return positions.get(normalize_code(symbol))
 
 
 def upsert_position(state: Dict[str, Any], symbol: str, fields: Dict[str, Any]) -> None:
     positions = state.setdefault("positions", {})
     key = normalize_code(symbol)
     pos = positions.setdefault(key, {})
     for field, value in fields.items():
         pos[field] = value
 
 
 def _order_bucket(state: Dict[str, Any], symbol: str, side: str) -> Dict[str, Any]:
     orders = state.setdefault("orders", {})
     symbol_key = normalize_code(symbol)
     symbol_bucket = orders.setdefault(symbol_key, {})
     return symbol_bucket.setdefault(side.upper(), {})
 
diff --git a/trader/subject_flow.py b/trader/subject_flow.py
index 60146e61d94170c4379ee32ea1fbf7e1531d7538..bc3a5e5de194a0adc96a21a2c0b92f95ffc8714f 100644
--- a/trader/subject_flow.py
+++ b/trader/subject_flow.py
@@ -97,51 +97,51 @@ def _log_flow(
         float(score.get("smart_money_ratio") or 0.0),
         score.get("orgn"),
         score.get("frgn"),
         score.get("prsn"),
         float(turnover or 0.0),
         degraded,
         error,
     )
 
 
 def get_subject_flow_with_fallback(
     kis: Any,
     code: str,
     market: str,
     day_turnover_krw: float,
 ) -> Dict[str, Any]:
     """Fetch investor flow with cache/fallback; never raises."""
     policy = SUBJECT_FLOW_FAIL_POLICY.upper()
     empty_policy = SUBJECT_FLOW_EMPTY_POLICY.upper()
     used = "none"
     degraded = False
     score: Dict[str, Any] | None = None
     inv: Dict[str, Any] | None = None
     error: str | None = None
     flow_ok = False
-    decision = "UNKNOWN"
+    decision = "UNCLASSIFIED"
     turnover_guard_mult = 1.0
     ob_strength_add = 0.0
 
     try:
         today = now_kst().strftime("%Y%m%d")
         key = (today, code)
         cached = _cache_get(key)
         if cached:
             used = "cache"
             inv = cached.get("inv")
             score = cached.get("score")
             if cached.get("ok") and score:
                 flow_ok = subject_flow_gate(market, float(score.get("smart_money_ratio") or 0))
                 decision = "CACHE_OK"
                 _log_flow(
                     code=code,
                     market=market,
                     ok=flow_ok,
                     used=used,
                     policy=policy,
                     score=score,
                     turnover=day_turnover_krw,
                     degraded=False,
                     error=None,
                 )
@@ -161,51 +161,51 @@ def get_subject_flow_with_fallback(
         if _current_call_count() >= SUBJECT_FLOW_MAX_CALLS_PER_RUN:
             error = "CALL_LIMIT"
             policy = "CACHE"
         else:
             _increment_call_count()
             resp: Dict[str, Any] = kis.inquire_investor(code, market)
             used = "live"
             if resp.get("ok"):
                 inv = resp.get("inv") or {}
                 orgn = _safe_num(inv.get("orgn_ntby_tr_pbmn"))
                 frgn = _safe_num(inv.get("frgn_ntby_tr_pbmn"))
                 prsn = _safe_num(inv.get("prsn_ntby_tr_pbmn"))
                 inv.update({
                     "orgn_ntby_tr_pbmn": orgn,
                     "frgn_ntby_tr_pbmn": frgn,
                     "prsn_ntby_tr_pbmn": prsn,
                 })
                 if empty_policy == "TREAT_AS_FAIL" and (orgn == 0 and frgn == 0 and prsn == 0):
                     error = "EMPTY_FLOW"
                 else:
                     score = smart_money_score(inv, day_turnover_krw)
                     flow_ok = subject_flow_gate(market, score["smart_money_ratio"])
                     decision = "LIVE_OK"
                     _cache_set(key, {"ok": True, "inv": inv, "score": score})
             else:
-                error = str(resp.get("error") or "UNKNOWN_ERROR")
+                error = str(resp.get("error") or "UNCLASSIFIED_ERROR")
 
         if score and used == "live":
             _log_flow(
                 code=code,
                 market=market,
                 ok=flow_ok,
                 used=used,
                 policy=policy,
                 score=score,
                 turnover=day_turnover_krw,
                 degraded=False,
                 error=None,
             )
             return {
                 "flow_ok": flow_ok,
                 "decision": decision,
                 "used": used,
                 "policy": policy,
                 "score": score,
                 "inv": inv,
                 "degraded": degraded,
                 "turnover_guard_mult": turnover_guard_mult,
                 "ob_strength_add": ob_strength_add,
                 "cache_hit": False,
             }
