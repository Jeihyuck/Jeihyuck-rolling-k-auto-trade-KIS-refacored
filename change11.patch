diff --git a/.github/workflows/trade-monitor.yml b/.github/workflows/trade-monitor.yml
index 84fee0459eb15ebeae2d2ab9dc1180eb4e240120..c3511bfb68bcc232d4f142c07f0752e27c48d753 100644
--- a/.github/workflows/trade-monitor.yml
+++ b/.github/workflows/trade-monitor.yml
@@ -101,50 +101,62 @@ jobs:
       # í•œêµ­íˆ¬ìì¦ê¶Œ ì—‘ì…€ ê¸°ì¤€ ì£¼ì‹ë‹¹ì¼ë¶„ë´‰ì¡°íšŒ TR_ID (FHKST03010200)
       KIS_TR_ID_INTRADAY_CHART: "FHKST03010200"
       KIS_TR_ID_INTRADAY_CHART_REAL: "FHKST03010200"
 
       # === FastAPI ë¦¬ë°¸ëŸ°ì‹± ì„œë²„(ì„ ì • í•„í„°) ===
       MIN_TRADES: "5"
       MAX_MDD_PCT: "30"
       MIN_WINRATE: "50"
       MIN_CUMRET: "2"
       TOP_K_LIMIT: "20"
       TOTAL_CAPITAL: "10000000"
       MIN_QTY_PER_TICKET: "1"
       K_MIN: "0.1"
       K_MAX: "0.9"
       K_STEP: "0.1"
       ALLOW_AFTER_HOURS: "0"
       REBALANCE_OUT_DIR: "rebalance_results"
 
     steps:
       - uses: actions/checkout@v4
         with:
           fetch-depth: 0
           persist-credentials: true
           token: ${{ secrets.GITHUB_TOKEN }}
 
+      - name: Restore bot_state from bot-state branch
+        if: github.event_name != 'pull_request'
+        run: |
+          git fetch origin bot-state:bot-state || true
+          if git show-ref --verify --quiet refs/heads/bot-state; then
+            git checkout bot-state -- bot_state || true
+          fi
+          mkdir -p trader/state
+          if [ -d bot_state/trader_state ]; then
+            cp -a bot_state/trader_state/. trader/state/ || true
+          fi
+
       - name: Restore state cache (fallback only)
         uses: actions/cache/restore@v4
         with:
           path: |
             bot_state/state.json
             trader/state/state.json
           key: trader-state-${{ github.ref_name }}
           restore-keys: |
             trader-state-${{ github.ref_name }}-
       - name: Save state cache (dispatch only)
         if: github.event_name == 'workflow_dispatch'
         uses: actions/cache/save@v4
         with:
           path: |
             bot_state/state.json
             trader/state/state.json
           key: trader-state-${{ github.ref_name }}
 
       - name: Set git identity
         run: |
           git config user.name "trade-bot"
           git config user.email "trade-bot@users.noreply.github.com"
 
       - uses: actions/setup-python@v5
         with:
@@ -214,50 +226,79 @@ jobs:
         run: |
           python -m compileall trader rolling_k_auto_trade_api
       - name: trader ìë™ë§¤ë§¤ ë¡œì§ ì‹¤í–‰
         env:
           PYTHONPATH: ${{ github.workspace }}
         run: |
           python -m trader.trader
 
       - name: CEO ë¦¬í¬íŠ¸ ìë™ ìƒì„±
         if: always()
         env:
           PYTHONPATH: ${{ github.workspace }}
         run: |
           python -m trader.report_ceo || true
 
       - name: Verify CEO report exists
         if: always()
         run: |
           ls -al trader/logs || true
 
       - name: Push state (plain)
         if: github.event_name != 'pull_request'
         run: |
           test -f scripts/state_push_plain.sh && bash scripts/state_push_plain.sh || true
 
+      - name: Persist trader state to bot-state branch
+        if: github.event_name != 'pull_request'
+        run: |
+          set -e
+          TMP_DIR="$(mktemp -d)"
+          mkdir -p "$TMP_DIR/state" "$TMP_DIR/fills"
+          if [ -d trader/state ]; then
+            cp -a trader/state/. "$TMP_DIR/state/" || true
+          fi
+          if [ -d trader/fills ]; then
+            cp -a trader/fills/. "$TMP_DIR/fills/" || true
+          fi
+          git fetch origin bot-state:bot-state || true
+          if git show-ref --verify --quiet refs/heads/bot-state; then
+            git checkout bot-state
+          else
+            git checkout -b bot-state
+          fi
+          mkdir -p bot_state/trader_state
+          cp -a "$TMP_DIR/state/." bot_state/trader_state/ || true
+          cp -a "$TMP_DIR/fills/." bot_state/trader_state/ || true
+          git add -f bot_state/trader_state/*
+          if git diff --cached --quiet; then
+            echo "No bot_state changes to commit."
+            exit 0
+          fi
+          git commit -m "Update trader state"
+          git push origin bot-state
+
       - name: Save state snapshot as artifact (audit only)
         if: always()
         uses: actions/upload-artifact@v4
         with:
           name: trader-state-${{ github.run_id }}
           path: |
             trader/state/state.json
             bot_state/state.json
             trader/logs/CEO_Report_*.md
             trader/logs/ledger.jsonl
           retention-days: 30
 
       - name: Rebalance JSON artifact ì—…ë¡œë“œ
         if: always()
         uses: actions/upload-artifact@v4
         with:
           name: rebalance-results
           path: rebalance_results/*.json
           if-no-files-found: warn
           retention-days: 60
 
       - name: Trades ë¡œê·¸ ì—…ë¡œë“œ
         if: always()
         uses: actions/upload-artifact@v4
         with:
diff --git a/rolling_k_auto_trade_api/best_k_meta_strategy.py b/rolling_k_auto_trade_api/best_k_meta_strategy.py
index 71e935cd3a646aa92a7e233ec42f0d92e30a2a69..d4e2c548801ecb960951893513274913c7e50c7c 100644
--- a/rolling_k_auto_trade_api/best_k_meta_strategy.py
+++ b/rolling_k_auto_trade_api/best_k_meta_strategy.py
@@ -6,99 +6,91 @@
 - ì›”/ë¶„ê¸°/ì—°ê°„ K-grid(ê³ ì •/ATRë™ì )
 - ëª©í‘œê°€: ì „ì¼ ë³€ë™í­*K + í‹±ë³´ì •
 - best_k/Sharpe/ìŠ¹ë¥ /ìˆ˜ìµë¥ /MDD/ê±°ë˜ìˆ˜ í•„í„° + assign_weights
 - ë³´ìœ ì¢…ëª© ê°•ì œí¬í•¨/ë¹„ì¤‘í•˜í•œ/rolling í†µí•©
 - FastAPI(trader.py/main.py)ì—ì„œ /rebalance/run/{date}ê°€ í˜¸ì¶œí•  run_rebalance() ì œê³µ
 """
 
 from __future__ import annotations
 
 import logging
 import math
 import os
 from datetime import datetime, timedelta, date
 from functools import lru_cache
 from typing import Any, Dict, Iterable, List, Optional
 
 import numpy as np
 import pandas as pd
 import FinanceDataReader as fdr
 from pykrx.stock import (
     get_market_cap_by_ticker,
     get_nearest_business_day_in_a_week,
 )
 
 from trader.rkmax_utils import get_best_k_meta, assign_weights, _enforce_min_weight_for_forced
+from trader.strategy_ids import SID_BREAKOUT, SID_SWING
 from .simulate_with_k_and_get_metrics import simulate_with_k_and_get_metrics
 from rolling_k_auto_trade_api.adjust_price_to_tick import adjust_price_to_tick
 
 logger = logging.getLogger(__name__)
 def _infer_strategy_from_metrics(
     *,
     avg_return: float,
     win_rate: float,
     mdd: float,
     trades: int,
     sharpe_m: float,
     forced: bool = False,
 ) -> tuple[int, str]:
-    """Infer strategy_id(1~4) from backtest/meta metrics.
+    """Infer strategy_id from backtest/meta metrics.
 
     ëª©ì :
-    - trader/legacy_kosdaq_runner.pyê°€ ì „ëµë³„ íŠ¸ë¦¬ê±° ê²Œì´íŠ¸(1~4)ë¥¼ ì‹¤ì œë¡œ ë¶„ê¸°í•  ìˆ˜ ìˆë„ë¡
-      ë¦¬ë°¸ëŸ°ì‹± ê²°ê³¼ì— strategy_id/strategy ë¼ë²¨ì„ ì£¼ì…í•œë‹¤.
-    - ì „ëµ5(ëˆŒë¦¼ëª©)ëŠ” USE_PULLBACK_ENTRY ê²½ë¡œë¡œ ë³„ë„ ì‹¤í–‰ë˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” 1~4ë§Œ í• ë‹¹í•œë‹¤.
+    - ë¦¬ë°¸ëŸ°ì‹± ê²°ê³¼ì— strategy_id/strategy ë¼ë²¨ì„ ì£¼ì…í•œë‹¤.
+    - ì „ëµ2/3ì€ ìƒí™© íŠ¸ë¦¬ê±°ì—ì„œë§Œ ì‚¬ìš©í•˜ë¯€ë¡œ ì—¬ê¸°ì„œ í• ë‹¹í•˜ì§€ ì•ŠëŠ”ë‹¤.
 
     NOTE: ì´ ë¡œì§ì€ 'ì „ëµì„ ì‹¤ì œë¡œ ëŒë¦´ ìˆ˜ ìˆê²Œ ë§Œë“œëŠ” ë¼ìš°íŒ…'ì´ ëª©ì ì´ë©°,
           ìµœì¢… ìˆ˜ìµ ìµœì í™”ëŠ” ë³„ë„ì˜ íŠœë‹(ì„ê³„ê°’/ê°€ì¤‘ì¹˜)ë¡œ ê°œì„  ê°€ëŠ¥í•˜ë‹¤.
     """
     try:
         avg_return = float(avg_return or 0.0)
         win_rate = float(win_rate or 0.0)
         mdd = float(mdd or 0.0)
         sharpe_m = float(sharpe_m or 0.0)
         trades = int(trades or 0)
     except Exception:
-        return 1, "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)"
+        return SID_BREAKOUT, "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)"
 
     # ê°•ì œ í¬í•¨(ë³´ìœ  ìœ ì§€ ë“±)ì¸ ê²½ìš°: ê³¼í•œ í•„í„°ë¥¼ í”¼í•˜ê¸° ìœ„í•´ ê¸°ë³¸ì „ëµìœ¼ë¡œ ë‘”ë‹¤
     if forced:
-        return 1, "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)"
+        return SID_BREAKOUT, "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)"
 
     # Champion/Close-betting ì„±ê²©: ë¦¬ìŠ¤í¬ê°€ ë‚®ê³ (ë‚®ì€ MDD), ì„±ê³¼/ìƒ¤í”„ê°€ ë†’ì€ ì¢…ëª©
     if sharpe_m >= 2.0 and avg_return > 0.0 and mdd <= 8.0 and trades >= 4:
-        return 4, "ì „ëµ4: Champion/ì¢…ê°€ë² íŒ…"
+        return SID_SWING, "ì „ëµ5: ìŠ¤ìœ™(ì±”í”¼ì–¸)"
 
-    # VWAP reclaim ì„±ê²©: ìŠ¹ë¥ ì´ ë†’ê³  ê±°ë˜ê°€ ì ë‹¹íˆ ë°œìƒ
-    if win_rate >= 60.0 and trades >= 6:
-        return 3, "ì „ëµ3: VWAP ë¦¬í´ë ˆì„"
-
-    # Range/Box breakout ì„±ê²©: ê±°ë˜ ë¹ˆë„ê°€ ë†’ì€ í¸
-    if trades >= 12:
-        return 2, "ì „ëµ2: ë°•ìŠ¤/ì „ê³ ì  ëŒíŒŒ"
-
-    return 1, "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)"
+    return SID_BREAKOUT, "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)"
 
 # -----------------------------
 # í™˜ê²½ íŒŒë¼ë¯¸í„° (íŠœë‹ ê°€ëŠ¥)
 # -----------------------------
 K_MIN = float(os.getenv("K_MIN", "0.1"))
 K_MAX = float(os.getenv("K_MAX", "1.0"))
 K_STEP = float(os.getenv("K_STEP", "0.1"))
 K_GRID_MODE = os.getenv("K_GRID_MODE", "fixed").lower()  # fixed|fine|atr
 K_STEP_FINE = float(os.getenv("K_STEP_FINE", "0.05"))
 K_DYNAMIC_STEP_MIN = float(os.getenv("K_DYNAMIC_STEP_MIN", "0.03"))
 K_DYNAMIC_STEP_MAX = float(os.getenv("K_DYNAMIC_STEP_MAX", "0.10"))
 K_DYNAMIC_STEP_MULT = float(os.getenv("K_DYNAMIC_STEP_MULT", "1.5"))
 
 MIN_TRADES = int(os.getenv("MIN_TRADES", "5"))
 MAX_MDD_PCT = float(os.getenv("MAX_MDD_PCT", "30"))
 REQUIRE_POS_RET = os.getenv("REQUIRE_POS_RET", "true").lower() == "true"
 
 TOP_N = int(os.getenv("TOP_N", "50"))
 
 ALWAYS_INCLUDE_CODES = {
     c.strip() for c in os.getenv("ALWAYS_INCLUDE_CODES", "").replace(" ", "").split(",") if c.strip()
 }
 KEEP_HELD_BYPASS_FILTERS = os.getenv("KEEP_HELD_BYPASS_FILTERS", "true").lower() == "true"
 HELD_MIN_WEIGHT = float(os.getenv("HELD_MIN_WEIGHT", "0.01"))
 
@@ -349,112 +341,112 @@ def _inject_forced_codes(universe_df: pd.DataFrame, forced_codes: List[str], mar
             ignore_index=True,
         )
     uni = universe_df.copy()
     uni = pd.concat([uni[["Code", "Name", "Marcap"]], force_df.assign(Marcap=np.nan)], ignore_index=True)
     uni = uni.drop_duplicates(subset=["Code"], keep="first")
     return uni
 
 def _calc_best_k_for_universe(
     universe_df: pd.DataFrame,
     rebalance_date: date,
     forced_codes: List[str],
     market: str,
 ) -> List[Dict[str, Any]]:
     results: Dict[str, Dict[str, Any]] = {}
 
     for _, stock in universe_df.iterrows():
         code, name = str(stock["Code"]).zfill(6), stock.get("Name")
         try:
             segments = get_price_data_segments(code, rebalance_date)
             month_data = segments["month"]
 
             if not month_data:
                 logger.debug(f"[SKIP] {name}({code}) ì „ì›” ë°ì´í„° ì—†ìŒ")
                 if code in forced_codes and KEEP_HELD_BYPASS_FILTERS:
                     results[code] = {
-                        "code": code, "name": name, "market": market, "best_k": 0.5, "strategy_id": 1, "strategy": "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)",
+                        "code": code, "name": name, "market": market, "best_k": 0.5, "strategy_id": SID_BREAKOUT, "strategy": "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)",
                         "avg_return_pct": 0.0, "win_rate_pct": 0.0,
                         "mdd_pct": 0.0, "trades": 0, "cumulative_return_pct": 0.0,
                         "avg_holding_days": 0.0, "sharpe_m": 0.0,
                         "ëª©í‘œê°€": None, "close": None,
                         "prev_open": None, "prev_high": None, "prev_low": None, "prev_close": None, "prev_volume": None, "prev_turnover": None,
                         "forced_include": True, "filtered_reason": "NO_DATA",
                         "qty": None, "weight": None, "k_grid_mode": K_GRID_MODE,
                     }
                 continue
 
             # K grid â†’ best_k ì„ íƒ
             k_range = _build_k_range(code, month_data)
             m_metrics = simulate_k_range_for(code, month_data, k_range=k_range)
             best_k = get_best_k_meta([], [], m_metrics)
 
             # ì„±ëŠ¥ ì§€í‘œ(ì›”)
             month_perf = simulate_with_k_and_get_metrics(code, best_k, month_data)
             avg_return = float(month_perf.get("avg_return_pct", 0.0))
             win_rate = float(month_perf.get("win_rate_pct", 0.0))
             mdd = float(abs(month_perf.get("mdd_pct", 0.0)))
             trades = int(month_perf.get("trades", 0))
             cumret = float(month_perf.get("cumulative_return_pct", 0.0))
             sharpe_m = float(month_perf.get("sharpe_m", 0.0))
             avg_hold = float(month_perf.get("avg_holding_days", 0.0))
 
             # ë°ì´í„° ë¶€ì¡± or í•„í„°ë§
             if trades < MIN_TRADES:
                 logger.debug(f"[SKIP] {name}({code}) trades<{MIN_TRADES}")
                 if code in forced_codes and KEEP_HELD_BYPASS_FILTERS:
                     results[code] = {
-                        "code": code, "name": name, "market": market, "best_k": best_k, "strategy_id": 1, "strategy": "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)",
+                        "code": code, "name": name, "market": market, "best_k": best_k, "strategy_id": SID_BREAKOUT, "strategy": "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)",
                         "avg_return_pct": avg_return, "win_rate_pct": win_rate,
                         "mdd_pct": mdd, "trades": trades, "cumulative_return_pct": cumret,
                         "avg_holding_days": avg_hold, "sharpe_m": sharpe_m,
                         "ëª©í‘œê°€": None, "close": None,
                         "prev_open": None, "prev_high": None, "prev_low": None, "prev_close": None, "prev_volume": None, "prev_turnover": None,
                         "forced_include": True, "filtered_reason": "LOW_TRADES",
                         "qty": None, "weight": None, "k_grid_mode": K_GRID_MODE,
                     }
                 continue
 
             if mdd > MAX_MDD_PCT:
                 logger.debug(f"[SKIP] {name}({code}) mdd>{MAX_MDD_PCT}")
                 if code in forced_codes and KEEP_HELD_BYPASS_FILTERS:
                     results[code] = {
-                        "code": code, "name": name, "market": market, "best_k": best_k, "strategy_id": 1, "strategy": "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)",
+                        "code": code, "name": name, "market": market, "best_k": best_k, "strategy_id": SID_BREAKOUT, "strategy": "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)",
                         "avg_return_pct": avg_return, "win_rate_pct": win_rate,
                         "mdd_pct": mdd, "trades": trades, "cumulative_return_pct": cumret,
                         "avg_holding_days": avg_hold, "sharpe_m": sharpe_m,
                         "ëª©í‘œê°€": None, "close": None,
                         "prev_open": None, "prev_high": None, "prev_low": None, "prev_close": None, "prev_volume": None, "prev_turnover": None,
                         "forced_include": True, "filtered_reason": "HIGH_MDD",
                         "qty": None, "weight": None, "k_grid_mode": K_GRID_MODE,
                     }
                 continue
 
             if REQUIRE_POS_RET and avg_return <= 0:
                 logger.debug(f"[SKIP] {name}({code}) avg_return<=0")
                 if code in forced_codes and KEEP_HELD_BYPASS_FILTERS:
                     results[code] = {
-                        "code": code, "name": name, "market": market, "best_k": best_k, "strategy_id": 1, "strategy": "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)",
+                        "code": code, "name": name, "market": market, "best_k": best_k, "strategy_id": SID_BREAKOUT, "strategy": "ì „ëµ1: ëŒíŒŒ(ê¸°ë³¸)",
                         "avg_return_pct": avg_return, "win_rate_pct": win_rate,
                         "mdd_pct": mdd, "trades": trades, "cumulative_return_pct": cumret,
                         "avg_holding_days": avg_hold, "sharpe_m": sharpe_m,
                         "ëª©í‘œê°€": None, "close": None,
                         "prev_open": None, "prev_high": None, "prev_low": None, "prev_close": None, "prev_volume": None, "prev_turnover": None,
                         "forced_include": True, "filtered_reason": "NEG_RETURN",
                         "qty": None, "weight": None, "k_grid_mode": K_GRID_MODE,
                     }
                 continue
 
             # ì „ì¼ OHLCV ë¡œë“œ: 1) month_data ë§ˆì§€ë§‰ ìº”ë“¤, 2) segs["prev"]
             prev_candle = None
             if month_data:
                 prev_candle = month_data[-1]
             elif segments.get("prev"):
                 prev_candle = segments["prev"][-1]
 
             prev_open = _safe_float(prev_candle.get("open") if prev_candle else None, None)
             prev_high = _safe_float(prev_candle.get("high") if prev_candle else None, None)
             prev_low = _safe_float(prev_candle.get("low") if prev_candle else None, None)
             prev_close = _safe_float(prev_candle.get("close") if prev_candle else None, None)
             prev_volume = _safe_float(prev_candle.get("volume") if prev_candle else None, None)
             prev_turnover = None
             try:
                 if prev_close is not None and prev_volume is not None:
diff --git a/trader/config.py b/trader/config.py
index 1cb5e4a1d3b75e79f6ab76af4a358ca89d781a01..f2a876becf33582d9a1666095d0c22e792502dff 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -14,90 +14,99 @@ from typing import Dict
 from zoneinfo import ZoneInfo
 
 # =========================
 # [CONFIG] .env ì—†ì´ë„ ë™ì‘
 # - ì•„ë˜ ê°’ì„ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©
 # - (ì„ íƒ) ë™ì¼ í‚¤ë¥¼ í™˜ê²½ë³€ìˆ˜ë¡œ ë„˜ê¸°ë©´ override
 # =========================
 CONFIG = {
     "SELL_FORCE_TIME": "14:40",
     "SELL_ALL_BALANCES_AT_CUTOFF": "false",  # "true"ë©´ ì»¤íŠ¸ì˜¤í”„ì— ì „ì²´ ì”ê³  í¬í•¨ ê°•ì œë§¤ë„ ë£¨í‹´ ì‚¬ìš©
     "API_RATE_SLEEP_SEC": "0.5",
     "FORCE_SELL_PASSES_CUTOFF": "2",
     "FORCE_SELL_PASSES_CLOSE": "4",
     "FORCE_SELL_BLOCKED_LOTS": "0",
     "PARTIAL1": "0.5",
     "PARTIAL2": "0.3",
     "TRAIL_PCT": "0.02",
     "FAST_STOP": "0.01",
     "ATR_STOP": "1.5",
     "TIME_STOP_HHMM": "13:00",
     "DEFAULT_PROFIT_PCT": "3.0",
     "DEFAULT_LOSS_PCT": "-5.0",
     "MANUAL_HARD_STOP_LOSS_PCT": "5.0",
     "MANUAL_TRAILING_STOP_PCT": "2.0",
     "MANUAL_MAX_HOLDING_DAYS": "5",
+    "MANUAL_STOP_LOSS_PCT": "-3.0",
+    "MANUAL_TAKE_PROFIT1_PCT": "5.0",
+    "MANUAL_TAKE_PROFIT2_PCT": "8.0",
+    "MANUAL_TP1_SELL_FRAC": "0.5",
+    "MANUAL_TRAIL_START_PCT": "4.0",
+    "MANUAL_TRAIL_STOP_PCT": "2.0",
+    "MANUAL_MAX_HOLD_DAYS": "20",
+    "MANUAL_TIME_CUT_PNL_MAX": "1.0",
     "DAILY_CAPITAL": "250000000",
     "CAP_CAP": "0.8",
     "SLIPPAGE_LIMIT_PCT": "0.25",
     "SLIPPAGE_ENTER_GUARD_PCT": "2.5",
+    "MAX_CHASE_PCT": "2.0",
     "VWAP_TOL": "0.003",  # ğŸ”¸ VWAP í—ˆìš© ì˜¤ì°¨(ê¸°ë³¸ 0.3%)
     "W_MAX_ONE": "0.25",
     "W_MIN_ONE": "0.03",
     "REBALANCE_ANCHOR": "weekly",             # weekly | today | monthly
     "WEEKLY_ANCHOR_REF": "last",              # NEW: 'last'(ì§ì „ ì¼ìš”ì¼) | 'next'(ë‹¤ìŒ ì¼ìš”ì¼)
     "MOMENTUM_OVERRIDES_FORCE_SELL": "true",
     # ë ˆì§(ì½”ìŠ¤ë‹¥) íŒŒë¼ë¯¸í„°
     "KOSDAQ_INDEX_CODE": "KOSDAQ",
     "KOSDAQ_ETF_FALLBACK": "229200",
     "REG_BULL_MIN_UP_PCT": "0.5",
     "REG_BULL_MIN_MINUTES": "10",
     "REG_BEAR_VWAP_MINUTES": "10",
     "REG_BEAR_DROP_FROM_HIGH": "0.7",
     "REG_BEAR_STAGE1_MINUTES": "20",
     "REG_BEAR_STAGE2_ADD_DROP": "0.5",
     "REG_PARTIAL_S1": "0.30",
     "REG_PARTIAL_S2": "0.30",
     "BASE_QTY_MODE": "initial",  # initial | current
     "TRAIL_PCT_BULL": "0.025",
     "TRAIL_PCT_BEAR": "0.012",
     "TP_PROFIT_PCT_BULL": "3.5",
     # ì‹ ê³ ê°€ ëŒíŒŒ í›„ 3ì¼ ëˆŒë¦¼ + ë°˜ë“± ë§¤ìˆ˜ìš© íŒŒë¼ë¯¸í„°
     "USE_PULLBACK_ENTRY": "true",          # trueë©´ 'ì‹ ê³ ê°€ â†’ 3ì¼ ì—°ì† í•˜ë½ â†’ ë°˜ë“±' íŒ¨í„´ ì¶©ì¡± ì‹œì—ë§Œ ëˆŒë¦¼ëª© ì§„ì… í—ˆìš©
     "PULLBACK_LOOKBACK": "60",             # ì‹ ê³ ê°€ íƒìƒ‰ ë²”ìœ„(ê±°ë˜ì¼ ê¸°ì¤€)
     "PULLBACK_DAYS": "3",                  # ì—°ì† í•˜ë½ ì¼ìˆ˜
     "PULLBACK_REVERSAL_BUFFER_PCT": "0.2", # ë˜ëŒë¦¼ í™•ì¸ ì—¬ìœ (%): ì§ì „ í•˜ë½ì¼ ê³ ê°€ ëŒ€ë¹„ ì—¬ìœ ìœ¨
     "PULLBACK_TOPN": "50",                 # ëˆŒë¦¼ëª© ìŠ¤ìº”ìš© ì½”ìŠ¤ë‹¥ ì‹œì´ ìƒìœ„ ì¢…ëª© ìˆ˜
     "PULLBACK_UNIT_WEIGHT": "0.03",        # ëˆŒë¦¼ëª© ë§¤ìˆ˜ 1ê±´ë‹¹ ìë³¸ ë°°ë¶„(í™œì„± ìë³¸ ë¹„ìœ¨)
     "PULLBACK_MAX_BUYS_PER_DAY": "5",      # ëˆŒë¦¼ëª© í•˜ë£¨ ìµœëŒ€ ì‹ ê·œ ë§¤ìˆ˜ ê±´ìˆ˜
 
 # ì „ëµ4(ì¢…ê°€ë² íŒ…) & ì „ëµë³„ í•„í„° ì˜µì…˜
 "CLOSE_BETTING_START": "14:30",        # ì „ëµ4 ì§„ì… ì‹œì‘ ì‹œê°„(HH:MM)
 "CLOSE_BETTING_END": "15:10",          # ì „ëµ4 ì§„ì… ì¢…ë£Œ ì‹œê°„(HH:MM)
 "CLOSE_BETTING_QTY_SCALE": "0.5",      # ì „ëµ4 ì§„ì… ìˆ˜ëŸ‰ ìŠ¤ì¼€ì¼(0.1~1.0)
 "CLOSE_BETTING_REQUIRE_GRADE": "AB",   # ì „ëµ4 ì±”í”¼ì–¸ ë“±ê¸‰ ìš”êµ¬: A ë˜ëŠ” AB
-"STRICT_CHAMPION_STRATEGY_IDS": "4",   # CHAMPION_* í•„í„°ë¥¼ ì—„ê²© ì ìš©í•  ì „ëµ IDë“¤(ì‰¼í‘œêµ¬ë¶„)
+"STRICT_CHAMPION_STRATEGY_IDS": "5",   # CHAMPION_* í•„í„°ë¥¼ ì—„ê²© ì ìš©í•  ì „ëµ IDë“¤(ì‰¼í‘œêµ¬ë¶„)
     # ì±”í”¼ì–¸ í›„ë³´ í•„í„°
     "CHAMPION_MIN_TRADES": "5",            # ìµœì†Œ ê±°ë˜ìˆ˜
     "CHAMPION_MIN_WINRATE": "45.0",        # ìµœì†Œ ìŠ¹ë¥ (%)
     "CHAMPION_MAX_MDD": "30.0",            # ìµœëŒ€ í—ˆìš© MDD(%)
     "CHAMPION_MIN_SHARPE": "0.0",          # ìµœì†Œ ìƒ¤í”„ ë¹„ìœ¨
     "NEUTRAL_ENTRY_SCALE": "0.6",          # ì¤‘ë¦½ ë ˆì§ ì‹ ê·œ/ì¬ì§„ì… ìŠ¤ì¼€ì¼ë§ ë¹„ìœ¨
     # ê¸°íƒ€
     "MARKET_DATA_WHEN_CLOSED": "false",
     "FORCE_WEEKLY_REBALANCE": "0",
     # NEW: 1ë¶„ë´‰ VWAP ëª¨ë©˜í…€ íŒŒë¼ë¯¸í„°
     "MOM_FAST": "5",        # 1ë¶„ë´‰ fast MA ê¸¸ì´
     "MOM_SLOW": "20",       # 1ë¶„ë´‰ slow MA ê¸¸ì´
     "MOM_TH_PCT": "0.5",    # fast/slow ê´´ë¦¬ ì„ê³„ê°’(%) â€“ 0.5% ì´ìƒì´ë©´ ê°•ì„¸ë¡œ ë³¸ë‹¤
     # Subject flow gate ê¸°ë³¸ê°’
     "MIN_SMART_MONEY_RATIO_KOSPI": "0.02",
     "MIN_SMART_MONEY_RATIO_KOSDAQ": "0.03",
     "SUBJECT_FLOW_TIMEOUT_SEC": "1.2",
     "SUBJECT_FLOW_RETRY": "1",
     "SUBJECT_FLOW_CACHE_TTL_SEC": "60",
     "SUBJECT_FLOW_FAIL_POLICY": "CACHE",
     "SUBJECT_FLOW_EMPTY_POLICY": "TREAT_AS_FAIL",
     "SUBJECT_FLOW_DEGRADED_TURNOVER_MULT": "1.5",
     "SUBJECT_FLOW_DEGRADED_OB_ADD": "10",
     "SUBJECT_FLOW_MAX_CALLS_PER_RUN": "200",
     "EMERGENCY_GLOBAL_SELL": "false",
@@ -126,54 +135,63 @@ MARKET_MAP: Dict[str, str] = {
 }
 
 # ë°ì´í„° ì—†ìŒ 1ì°¨ ê°ì§€ ìƒíƒœ ì €ì¥(ì—°ì† DATA_EMPTY í™•ì¸ìš©)
 EXCLUDE_STATE: Dict[str, Dict[str, bool]] = {}
 
 KST = ZoneInfo("Asia/Seoul")
 
 SELL_FORCE_TIME_STR = _cfg("SELL_FORCE_TIME").strip()
 SELL_ALL_BALANCES_AT_CUTOFF = _cfg("SELL_ALL_BALANCES_AT_CUTOFF").lower() == "true"
 EMERGENCY_GLOBAL_SELL = _cfg("EMERGENCY_GLOBAL_SELL").lower() in ("1", "true", "yes")
 RATE_SLEEP_SEC = float(_cfg("API_RATE_SLEEP_SEC"))
 FORCE_SELL_PASSES_CUTOFF = int(_cfg("FORCE_SELL_PASSES_CUTOFF"))
 FORCE_SELL_PASSES_CLOSE = int(_cfg("FORCE_SELL_PASSES_CLOSE"))
 FORCE_SELL_BLOCKED_LOTS = _cfg("FORCE_SELL_BLOCKED_LOTS").lower() in ("1", "true", "yes")
 PARTIAL1 = float(_cfg("PARTIAL1"))
 PARTIAL2 = float(_cfg("PARTIAL2"))
 TRAIL_PCT = float(_cfg("TRAIL_PCT"))
 FAST_STOP = float(_cfg("FAST_STOP"))
 ATR_STOP = float(_cfg("ATR_STOP"))
 TIME_STOP_HHMM = _cfg("TIME_STOP_HHMM")
 DEFAULT_PROFIT_PCT = float(_cfg("DEFAULT_PROFIT_PCT"))
 DEFAULT_LOSS_PCT = float(_cfg("DEFAULT_LOSS_PCT"))
 MANUAL_HARD_STOP_LOSS_PCT = float(_cfg("MANUAL_HARD_STOP_LOSS_PCT"))
 MANUAL_TRAILING_STOP_PCT = float(_cfg("MANUAL_TRAILING_STOP_PCT"))
 MANUAL_MAX_HOLDING_DAYS = int(_cfg("MANUAL_MAX_HOLDING_DAYS") or "5")
+MANUAL_STOP_LOSS_PCT = float(_cfg("MANUAL_STOP_LOSS_PCT") or "-3.0")
+MANUAL_TAKE_PROFIT1_PCT = float(_cfg("MANUAL_TAKE_PROFIT1_PCT") or "5.0")
+MANUAL_TAKE_PROFIT2_PCT = float(_cfg("MANUAL_TAKE_PROFIT2_PCT") or "8.0")
+MANUAL_TP1_SELL_FRAC = float(_cfg("MANUAL_TP1_SELL_FRAC") or "0.5")
+MANUAL_TRAIL_START_PCT = float(_cfg("MANUAL_TRAIL_START_PCT") or "4.0")
+MANUAL_TRAIL_STOP_PCT = float(_cfg("MANUAL_TRAIL_STOP_PCT") or "2.0")
+MANUAL_MAX_HOLD_DAYS = int(_cfg("MANUAL_MAX_HOLD_DAYS") or "20")
+MANUAL_TIME_CUT_PNL_MAX = float(_cfg("MANUAL_TIME_CUT_PNL_MAX") or "1.0")
 DAILY_CAPITAL = int(_cfg("DAILY_CAPITAL"))
 CAP_CAP = float(_cfg("CAP_CAP"))
 SLIPPAGE_LIMIT_PCT = float(_cfg("SLIPPAGE_LIMIT_PCT"))
 SLIPPAGE_ENTER_GUARD_PCT = float(_cfg("SLIPPAGE_ENTER_GUARD_PCT"))
+MAX_CHASE_PCT = float(_cfg("MAX_CHASE_PCT") or "2.0")
 VWAP_TOL = float(_cfg("VWAP_TOL"))  # ğŸ”¸ VWAP í—ˆìš© ì˜¤ì°¨(ì˜ˆ: 0.003 = -0.3%ê¹Œì§€ í—ˆìš©)
 W_MAX_ONE = float(_cfg("W_MAX_ONE"))
 W_MIN_ONE = float(_cfg("W_MIN_ONE"))
 ALLOW_PYRAMID = (_cfg("ALLOW_PYRAMID") or "false").lower() == "true"
 REBALANCE_ANCHOR = _cfg("REBALANCE_ANCHOR")
 WEEKLY_ANCHOR_REF = _cfg("WEEKLY_ANCHOR_REF").lower()
 MOMENTUM_OVERRIDES_FORCE_SELL = _cfg("MOMENTUM_OVERRIDES_FORCE_SELL").lower() == "true"
 BASE_QTY_MODE = (_cfg("BASE_QTY_MODE") or "initial").lower()
 if BASE_QTY_MODE not in {"initial", "current"}:
     logging.getLogger(__name__).warning(
         f"[CONFIG] BASE_QTY_MODE={BASE_QTY_MODE} ì§€ì› ì•ˆ í•¨ â†’ initialë¡œ ëŒ€ì²´"
     )
     BASE_QTY_MODE = "initial"
 
 # NEW: 1ë¶„ë´‰ ëª¨ë©˜í…€ íŒŒë¼ë¯¸í„°
 MOM_FAST = int(_cfg("MOM_FAST") or "5")
 MOM_SLOW = int(_cfg("MOM_SLOW") or "20")
 MOM_TH_PCT = float(_cfg("MOM_TH_PCT") or "0.5")
 # subject flow
 MIN_SMART_MONEY_RATIO_KOSPI = float(_cfg("MIN_SMART_MONEY_RATIO_KOSPI") or "0.02")
 MIN_SMART_MONEY_RATIO_KOSDAQ = float(_cfg("MIN_SMART_MONEY_RATIO_KOSDAQ") or "0.03")
 SUBJECT_FLOW_TIMEOUT_SEC = float(_cfg("SUBJECT_FLOW_TIMEOUT_SEC") or "1.2")
 SUBJECT_FLOW_RETRY = int(_cfg("SUBJECT_FLOW_RETRY") or "1")
 SUBJECT_FLOW_CACHE_TTL_SEC = float(_cfg("SUBJECT_FLOW_CACHE_TTL_SEC") or "60")
 SUBJECT_FLOW_FAIL_POLICY = (_cfg("SUBJECT_FLOW_FAIL_POLICY") or "CACHE").upper()
diff --git a/trader/core_constants.py b/trader/core_constants.py
index eceb6625d67f7a587441006348c4075f79ba6205..bf5bbe781cd494c97f40dc5b7fb93052d3206714 100644
--- a/trader/core_constants.py
+++ b/trader/core_constants.py
@@ -11,50 +11,51 @@ from . import config
 logger = config.logger
 _cfg = config._cfg
 LOG_DIR = config.LOG_DIR
 STATE_FILE = config.STATE_FILE
 MARKET_MAP = config.MARKET_MAP
 EXCLUDE_STATE = config.EXCLUDE_STATE
 KST = config.KST
 SELL_FORCE_TIME_STR = config.SELL_FORCE_TIME_STR
 SELL_FORCE_TIME = config.SELL_FORCE_TIME
 SELL_ALL_BALANCES_AT_CUTOFF = config.SELL_ALL_BALANCES_AT_CUTOFF
 RATE_SLEEP_SEC = config.RATE_SLEEP_SEC
 FORCE_SELL_PASSES_CUTOFF = config.FORCE_SELL_PASSES_CUTOFF
 FORCE_SELL_PASSES_CLOSE = config.FORCE_SELL_PASSES_CLOSE
 PARTIAL1 = config.PARTIAL1
 PARTIAL2 = config.PARTIAL2
 TRAIL_PCT = config.TRAIL_PCT
 FAST_STOP = config.FAST_STOP
 ATR_STOP = config.ATR_STOP
 TIME_STOP_TIME = config.TIME_STOP_TIME
 DEFAULT_PROFIT_PCT = config.DEFAULT_PROFIT_PCT
 DEFAULT_LOSS_PCT = config.DEFAULT_LOSS_PCT
 DAILY_CAPITAL = config.DAILY_CAPITAL
 CAP_CAP = config.CAP_CAP
 SLIPPAGE_LIMIT_PCT = config.SLIPPAGE_LIMIT_PCT
 SLIPPAGE_ENTER_GUARD_PCT = config.SLIPPAGE_ENTER_GUARD_PCT
+MAX_CHASE_PCT = config.MAX_CHASE_PCT
 VWAP_TOL = config.VWAP_TOL
 W_MAX_ONE = config.W_MAX_ONE
 W_MIN_ONE = config.W_MIN_ONE
 REBALANCE_ANCHOR = config.REBALANCE_ANCHOR
 WEEKLY_ANCHOR_REF = config.WEEKLY_ANCHOR_REF
 MOMENTUM_OVERRIDES_FORCE_SELL = config.MOMENTUM_OVERRIDES_FORCE_SELL
 MOM_FAST = config.MOM_FAST
 MOM_SLOW = config.MOM_SLOW
 MOM_TH_PCT = config.MOM_TH_PCT
 USE_PULLBACK_ENTRY = config.USE_PULLBACK_ENTRY
 PULLBACK_LOOKBACK = config.PULLBACK_LOOKBACK
 PULLBACK_DAYS = config.PULLBACK_DAYS
 PULLBACK_REVERSAL_BUFFER_PCT = config.PULLBACK_REVERSAL_BUFFER_PCT
 PULLBACK_TOPN = config.PULLBACK_TOPN
 PULLBACK_UNIT_WEIGHT = config.PULLBACK_UNIT_WEIGHT
 CHAMPION_MIN_TRADES = config.CHAMPION_MIN_TRADES
 CHAMPION_MIN_WINRATE = config.CHAMPION_MIN_WINRATE
 CHAMPION_MAX_MDD = config.CHAMPION_MAX_MDD
 CHAMPION_MIN_SHARPE = config.CHAMPION_MIN_SHARPE
 CHAMPION_A_RULES = config.CHAMPION_A_RULES
 GOOD_ENTRY_PULLBACK_RANGE = config.GOOD_ENTRY_PULLBACK_RANGE
 GOOD_ENTRY_MA20_RANGE = config.GOOD_ENTRY_MA20_RANGE
 GOOD_ENTRY_MAX_FROM_PEAK = config.GOOD_ENTRY_MAX_FROM_PEAK
 GOOD_ENTRY_MIN_RR = config.GOOD_ENTRY_MIN_RR
 GOOD_ENTRY_MIN_INTRADAY_SIG = config.GOOD_ENTRY_MIN_INTRADAY_SIG
@@ -71,60 +72,60 @@ __all__ = [
     "logger",
     "_cfg",
     "LOG_DIR",
     "STATE_FILE",
     "MARKET_MAP",
     "EXCLUDE_STATE",
     "KST",
     "SELL_FORCE_TIME_STR",
     "SELL_FORCE_TIME",
     "SELL_ALL_BALANCES_AT_CUTOFF",
     "RATE_SLEEP_SEC",
     "FORCE_SELL_PASSES_CUTOFF",
     "FORCE_SELL_PASSES_CLOSE",
     "PARTIAL1",
     "PARTIAL2",
     "TRAIL_PCT",
     "FAST_STOP",
     "ATR_STOP",
     "TIME_STOP_TIME",
     "DEFAULT_PROFIT_PCT",
     "DEFAULT_LOSS_PCT",
     "DAILY_CAPITAL",
     "CAP_CAP",
     "SLIPPAGE_LIMIT_PCT",
     "SLIPPAGE_ENTER_GUARD_PCT",
+    "MAX_CHASE_PCT",
     "VWAP_TOL",
     "W_MAX_ONE",
     "W_MIN_ONE",
     "REBALANCE_ANCHOR",
     "WEEKLY_ANCHOR_REF",
     "MOMENTUM_OVERRIDES_FORCE_SELL",
     "MOM_FAST",
     "MOM_SLOW",
     "MOM_TH_PCT",
     "USE_PULLBACK_ENTRY",
     "PULLBACK_LOOKBACK",
     "PULLBACK_DAYS",
     "PULLBACK_REVERSAL_BUFFER_PCT",
     "PULLBACK_TOPN",
     "PULLBACK_UNIT_WEIGHT",
     "CHAMPION_MIN_TRADES",
     "CHAMPION_MIN_WINRATE",
     "CHAMPION_MAX_MDD",
     "CHAMPION_MIN_SHARPE",
     "CHAMPION_A_RULES",
     "GOOD_ENTRY_PULLBACK_RANGE",
     "GOOD_ENTRY_MA20_RANGE",
     "GOOD_ENTRY_MAX_FROM_PEAK",
     "GOOD_ENTRY_MIN_RR",
     "GOOD_ENTRY_MIN_INTRADAY_SIG",
     "BAD_ENTRY_MAX_MA20_DIST",
     "BAD_ENTRY_MAX_PULLBACK",
     "BAD_ENTRY_MAX_BELOW_VWAP_RATIO",
     "NEUTRAL_ENTRY_SCALE",
     "ALLOW_WHEN_CLOSED",
     "ALLOW_PYRAMID",
     "STATE_WEEKLY_PATH",
     "_this_iso_week_key",
 ]
-
diff --git a/trader/kis_wrapper.py b/trader/kis_wrapper.py
index e607bd4565f95c72d48867461b8b7e8216dd6566..3a5e03bf2be672a4234d989ea4ab3ae726d6c601 100644
--- a/trader/kis_wrapper.py
+++ b/trader/kis_wrapper.py
@@ -779,124 +779,148 @@ class KisAPI:
             if not trs:
                 return None
             return sum(trs[-window:]) / float(window)
         except Exception as e:
             logger.warning(f"[ATR] ê³„ì‚° ì‹¤íŒ¨ code={code}: {e}")
             return None
 
     def get_intraday_candles_today(self, code: str, start_hhmm: str = "090000") -> List[Dict[str, Any]]:
         """KIS ì£¼ì‹ë‹¹ì¼ë¶„ë´‰ì¡°íšŒ (FHKST03010200 / inquire-time-itemchartprice)
         - FID_COND_MRKT_DIV_CODE: 'J'
         - FID_INPUT_ISCD: 6ìë¦¬ ì¢…ëª©ì½”ë“œ('A' ì œê±°)
         - FID_INPUT_HOUR_1: ì‹œì‘ ì‹œê°„(HHMMSS), ì˜ˆ: '090000'
         - FID_PW_DATA_INCU_YN: 'Y'
         - FID_ETC_CLS_CODE: ''
         """
         market_code = "J"
         iscd = normalize_code(code)
         if not iscd:
             return []
 
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-time-itemchartprice"
         self._limiter.wait("intraday")
 
         last_err = None
 
+        start_candidates = [start_hhmm, "091000", "092000"]
+        start_candidates = [
+            s for i, s in enumerate(start_candidates) if s and s not in start_candidates[:i]
+        ]
+        retry_counts = [120, 80, 40]
+
         for tr in _pick_tr(self.env, "INTRADAY_CHART"):
             headers = self._headers(tr)
             headers.setdefault("accept", "*/*")
             headers.setdefault("tr_cont", "N")
             headers.setdefault("Connection", "keep-alive")
 
-            params = {
-                "fid_cond_mrkt_div_code": market_code,
-                "fid_input_iscd": iscd,
-                "fid_input_hour_1": start_hhmm,
-                "fid_pw_data_incu_yn": "Y",
-                "fid_etc_cls_code": "",
-            }
-
-            for attempt in range(1, 4):
-                try:
-                    resp = self._safe_request(
-                        "GET", url, headers=headers, params=params, timeout=(3.0, 7.0)
-                    )
-                    resp.raise_for_status()
-                    data = resp.json()
-                    logger.debug("[INTRADAY_RAW_JSON] %s TR=%s attempt=%d â†’ %s", iscd, tr, attempt, data)
-                except requests.exceptions.SSLError as e:
-                    last_err = e
-                    logger.warning("[NET:SSL_ERROR] INTRADAY %s attempt=%s %s", iscd, attempt, e)
-                    time.sleep(0.4 * attempt)
-                    continue
-                except requests.exceptions.RequestException as e:
-                    last_err = e
-                    logger.warning("[NET:REQ_ERROR] INTRADAY %s attempt=%s %s", iscd, attempt, e)
-                    time.sleep(0.4 * attempt)
-                    continue
-                except ValueError as e:
-                    last_err = e
-                    logger.warning("[NET:JSON_DECODE] INTRADAY %s attempt=%s %s", iscd, attempt, e)
-                    time.sleep(0.35 + random.uniform(0, 0.15))
-                    continue
+            for start_idx, start in enumerate(start_candidates):
+                for attempt in range(1, 4):
+                    req_count = retry_counts[min(attempt - 1, len(retry_counts) - 1)]
+                    params = {
+                        "fid_cond_mrkt_div_code": market_code,
+                        "fid_input_iscd": iscd,
+                        "fid_input_hour_1": start,
+                        "fid_pw_data_incu_yn": "Y",
+                        "fid_etc_cls_code": "",
+                    }
+                    try:
+                        resp = self._safe_request(
+                            "GET", url, headers=headers, params=params, timeout=(3.0, 7.0)
+                        )
+                        resp.raise_for_status()
+                        data = resp.json()
+                        logger.debug(
+                            "[INTRADAY_RAW_JSON] %s TR=%s attempt=%d start=%s â†’ %s",
+                            iscd,
+                            tr,
+                            attempt,
+                            start,
+                            data,
+                        )
+                    except requests.exceptions.SSLError as e:
+                        last_err = e
+                        logger.warning("[NET:SSL_ERROR] INTRADAY %s attempt=%s %s", iscd, attempt, e)
+                        time.sleep(0.4 * attempt)
+                        continue
+                    except requests.exceptions.RequestException as e:
+                        last_err = e
+                        logger.warning("[NET:REQ_ERROR] INTRADAY %s attempt=%s %s", iscd, attempt, e)
+                        time.sleep(0.4 * attempt)
+                        continue
+                    except ValueError as e:
+                        last_err = e
+                        logger.warning("[NET:JSON_DECODE] INTRADAY %s attempt=%s %s", iscd, attempt, e)
+                        time.sleep(0.35 + random.uniform(0, 0.15))
+                        continue
                 except Exception as e:
                     last_err = e
                     logger.warning("[NET:UNEXPECTED] INTRADAY %s attempt=%s %s", iscd, attempt, e)
                     time.sleep(0.4 * attempt)
                     continue
 
                 if "ì´ˆë‹¹ ê±°ë˜ê±´ìˆ˜" in str(data.get("msg1") or ""):
                     time.sleep(0.35 + random.uniform(0, 0.15))
                     continue
 
-                arr = data.get("output2") or []
-                if resp.status_code == 200 and arr:
-                    rows: List[Dict[str, Any]] = []
-                    for r in arr:
-                        try:
-                            hhmmss = r.get("stck_cntg_hour")
-                            price = r.get("stck_prpr")
-                            vol = r.get("cntg_vol")
-                            if hhmmss and price is not None and vol is not None:
-                                rows.append({
-                                    "time": str(hhmmss),
-                                    "price": float(price),
-                                    "volume": float(vol),
-                                })
-                        except Exception as e:
-                            logger.debug("[INTRADAY_ROW_SKIP] %s rec=%s err=%s", iscd, r, e)
-
-                    rows.sort(key=lambda x: x["time"])
-                    if len(rows) == 0:
-                        raise DataEmptyError(f"A{iscd} 0 intraday candles")
-                    return rows
-
-                last_err = RuntimeError(
-                    f"BAD_RESP rt_cd={data.get('rt_cd')} msg={data.get('msg1')}"
-                )
-                logger.warning("[INTRADAY_BAD_RESP] %s %s", iscd, data)
-                time.sleep(0.4 + random.uniform(0, 0.2))
+                    arr = data.get("output2") or []
+                    if resp.status_code == 200 and arr:
+                        rows: List[Dict[str, Any]] = []
+                        for r in arr:
+                            try:
+                                hhmmss = r.get("stck_cntg_hour")
+                                price = r.get("stck_prpr")
+                                vol = r.get("cntg_vol")
+                                if hhmmss and price is not None and vol is not None:
+                                    rows.append({
+                                        "time": str(hhmmss),
+                                        "price": float(price),
+                                        "volume": float(vol),
+                                    })
+                            except Exception as e:
+                                logger.debug("[INTRADAY_ROW_SKIP] %s rec=%s err=%s", iscd, r, e)
+
+                        rows.sort(key=lambda x: x["time"])
+                        if len(rows) == 0:
+                            raise DataEmptyError(f"A{iscd} 0 intraday candles")
+                        return rows
+
+                    msg = f"{data.get('msg_cd') or ''}:{data.get('msg1') or ''}".strip(":")
+                    logger.warning(
+                        "[INTRADAY-FETCH-FAIL] code=%s http=%s rt_cd=%s msg=%s output2_len=%s retry=%s count=%s",
+                        iscd,
+                        resp.status_code,
+                        data.get("rt_cd"),
+                        msg,
+                        len(arr),
+                        attempt + (start_idx * 3),
+                        req_count,
+                    )
+                    last_err = RuntimeError(
+                        f"BAD_RESP rt_cd={data.get('rt_cd')} msg={data.get('msg1')}"
+                    )
+                    time.sleep(0.4 + random.uniform(0, 0.2))
 
         if last_err:
             raise last_err
         raise RuntimeError(f"INTRADAY_FAIL A{iscd}")
 
     def get_vwap_today(self, code: str, start_hhmm: str = "090000") -> float | None:
         """ë‹¹ì¼ ë¶„ë´‰ ê¸°ì¤€ ì²´ê²° ê°€ê²©/ê±°ë˜ëŸ‰ìœ¼ë¡œ ë‹¨ìˆœ VWAP ê³„ì‚°."""
         try:
             candles = self.get_intraday_candles_today(code, start_hhmm=start_hhmm)
         except DataEmptyError:
             return None
         except Exception as e:
             logger.warning("[VWAP_FAIL] %s %s", code, e)
             return None
 
         total_vol = 0.0
         total_tr = 0.0
         for c in candles:
             try:
                 v = float(c.get("volume") or 0.0)
                 p = float(c.get("price") or 0.0)
             except Exception:
                 continue
             if v <= 0 or p <= 0:
                 continue
diff --git a/trader/ledger.py b/trader/ledger.py
index 7d8ea0a3f40bd621410da24a9d1286e4381a7d4f..7335374515dbc7fbbca0e0787ee1e7e7c7b85bb2 100644
--- a/trader/ledger.py
+++ b/trader/ledger.py
@@ -1,32 +1,33 @@
 from __future__ import annotations
 
 from datetime import datetime
 from typing import Any, Dict, List
 
 from .config import KST
 from .code_utils import normalize_code
+from .strategy_ids import STRATEGY_INT_IDS
 
 
 def _ensure_state(state: Dict[str, Any]) -> List[Dict[str, Any]]:
     lots = state.get("lots")
     if not isinstance(lots, list):
         lots = []
         state["lots"] = lots
     return lots
 
 
 def _norm_sid(value: int | str | None) -> int | str | None:
     if value is None:
         return None
     text = str(value)
     return int(text) if text.isdigit() else text
 
 
 def record_buy_fill(
     state: Dict[str, Any],
     *,
     lot_id: str,
     pdno: str,
     strategy_id: int | str,
     engine: str,
     entry_ts: str,
@@ -120,51 +121,51 @@ def remaining_qty_for_strategy(state: Dict[str, Any], pdno: str, strategy_id: in
     total = 0
     for lot in lots:
         if normalize_code(lot.get("pdno")) != pdno_key:
             continue
         if int(lot.get("remaining_qty") or 0) <= 0:
             continue
         if _norm_sid(lot.get("strategy_id")) != _norm_sid(strategy_id):
             continue
         total += int(lot.get("remaining_qty") or 0)
     return total
 
 
 def dominant_strategy_for(state: Dict[str, Any], pdno: str) -> int | None:
     lots = _ensure_state(state)
     pdno_key = normalize_code(pdno)
     if not pdno_key:
         return None
     totals: Dict[int, int] = {}
     for lot in lots:
         if normalize_code(lot.get("pdno")) != pdno_key:
             continue
         remaining = int(lot.get("remaining_qty") or 0)
         if remaining <= 0:
             continue
         sid = _norm_sid(lot.get("strategy_id"))
-        if isinstance(sid, int) and 1 <= sid <= 5:
+        if isinstance(sid, int) and sid in STRATEGY_INT_IDS:
             totals[sid] = totals.get(sid, 0) + remaining
     if not totals:
         return None
     return max(totals.items(), key=lambda item: item[1])[0]
 
 
 def strategy_avg_price(
     state: Dict[str, Any], pdno: str, strategy_id: int | str
 ) -> float | None:
     lots = _ensure_state(state)
     pdno_key = normalize_code(pdno)
     if not pdno_key:
         return None
     total_qty = 0
     total_cost = 0.0
     for lot in lots:
         if normalize_code(lot.get("pdno")) != pdno_key:
             continue
         if _norm_sid(lot.get("strategy_id")) != _norm_sid(strategy_id):
             continue
         remaining = int(lot.get("remaining_qty") or 0)
         if remaining <= 0:
             continue
         entry_price = float(lot.get("entry_price") or 0.0)
         total_qty += remaining
diff --git a/trader/legacy_kosdaq_runner.py b/trader/legacy_kosdaq_runner.py
index d8d5634aca88f6c018a2ad2c8699b1aecb2ace5c..20a68d9f0db227977b23696b8fa5a13b2b407733 100644
--- a/trader/legacy_kosdaq_runner.py
+++ b/trader/legacy_kosdaq_runner.py
@@ -9,115 +9,144 @@ from __future__ import annotations
 import json
 import re
 import time
 import os
 from datetime import date, datetime, time as dtime, timedelta
 from typing import Any, Dict, List, Tuple, TYPE_CHECKING
 
 
 try:
     from .config import (
         DAILY_CAPITAL,
         FAST_STOP,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         FORCE_SELL_BLOCKED_LOTS,
         ALLOW_WHEN_CLOSED,
         ALLOW_PYRAMID,
         BASE_QTY_MODE,
         KST,
         LOG_DIR,
         RATE_SLEEP_SEC,
         EMERGENCY_GLOBAL_SELL,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
+        MAX_CHASE_PCT,
+        VWAP_TOL,
         STATE_PATH,
         STRATEGY_REDUCTION_PRIORITY,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         MANUAL_HARD_STOP_LOSS_PCT,
         MANUAL_TRAILING_STOP_PCT,
         MANUAL_MAX_HOLDING_DAYS,
+        MANUAL_STOP_LOSS_PCT,
+        MANUAL_TAKE_PROFIT1_PCT,
+        MANUAL_TAKE_PROFIT2_PCT,
+        MANUAL_TP1_SELL_FRAC,
+        MANUAL_TRAIL_START_PCT,
+        MANUAL_TRAIL_STOP_PCT,
+        MANUAL_MAX_HOLD_DAYS,
+        MANUAL_TIME_CUT_PNL_MAX,
         _cfg,
         logger,
     )
 except ImportError:
     # ALLOW_WHEN_CLOSEDê°€ ëˆ„ë½ë¼ë„ ëŸ¬ë„ˆê°€ ì¦‰ì‹œ ì¤‘ë‹¨ë˜ì§€ ì•Šë„ë¡ ì•ˆì „í•œ ê¸°ë³¸ê°’ì„ ì œê³µí•œë‹¤.
     from .config import (
         DAILY_CAPITAL,
         FAST_STOP,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         FORCE_SELL_BLOCKED_LOTS,
         KST,
         LOG_DIR,
         BASE_QTY_MODE,
         RATE_SLEEP_SEC,
         EMERGENCY_GLOBAL_SELL,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
+        MAX_CHASE_PCT,
+        VWAP_TOL,
         STATE_PATH,
         STRATEGY_REDUCTION_PRIORITY,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         MANUAL_HARD_STOP_LOSS_PCT,
         MANUAL_TRAILING_STOP_PCT,
         MANUAL_MAX_HOLDING_DAYS,
+        MANUAL_STOP_LOSS_PCT,
+        MANUAL_TAKE_PROFIT1_PCT,
+        MANUAL_TAKE_PROFIT2_PCT,
+        MANUAL_TP1_SELL_FRAC,
+        MANUAL_TRAIL_START_PCT,
+        MANUAL_TRAIL_STOP_PCT,
+        MANUAL_MAX_HOLD_DAYS,
+        MANUAL_TIME_CUT_PNL_MAX,
         _cfg,
         logger,
     )
 
     ALLOW_WHEN_CLOSED = False
     logger.warning("[CONFIG] ALLOW_WHEN_CLOSED missing; defaulting to False")
     ALLOW_PYRAMID = False
     logger.warning("[CONFIG] ALLOW_PYRAMID missing; defaulting to False")
 from . import signals
 from trader.time_utils import MARKET_CLOSE, MARKET_OPEN, is_trading_day
 from trader.subject_flow import get_subject_flow_with_fallback, reset_flow_call_count
 from trader.execution import record_entry_state
 from trader.strategy_rules import strategy_entry_gate, strategy_trigger_label
 from trader.exit_allocation import allocate_sell_qty, apply_sell_allocation
 from trader.code_utils import normalize_code
 from trader.ledger import (
     record_buy_fill,
     remaining_qty_for_strategy,
     reconcile_with_broker_holdings,
     strategy_avg_price,
 )
 from trader.ctx_schema import normalize_daily_ctx, normalize_intraday_ctx
 from trader import state_store as runtime_state_store
 from trader.lot_state_store import load_lot_state, save_lot_state
 from trader.position_state_store import (
     load_position_state,
     reconcile_with_broker,
     reconcile_positions,
     save_position_state,
 )
+from trader.strategy_ids import (
+    INTRADAY_EXIT_IDS,
+    SID_BREAKOUT,
+    SID_LASTHOUR,
+    SID_PULLBACK,
+    SID_SWING,
+    STRATEGY_INT_IDS,
+)
+from trader import guards
 from .core import *  # noqa: F401,F403 - ì „ëµ ìœ í‹¸ ì „ì²´ ë…¸ì¶œë¡œ í™•ì¥ì„± í™•ë³´
 
 if TYPE_CHECKING:
     # core ìª½ì— êµ¬í˜„ë¼ ìˆëŠ” í—¬í¼ë“¤ì„ íƒ€ì…ì²´ì»¤ì—ê²Œë§Œ ëª…ì‹œì ìœ¼ë¡œ ì•Œë ¤ì¤€ë‹¤.
     from .core import (
         _this_iso_week_key,
         _get_effective_ord_cash,
         _to_float,
         _to_int,
         _weight_to_qty,
         _classify_champion_grade,
         _update_market_regime,
         _notional_to_qty,
         _fetch_balances,
         _init_position_state_from_balance,
         _sell_once,
         _adaptive_exit,
         _compute_daily_entry_context,
         _compute_intraday_entry_context,
         _safe_get_price,
         _round_to_tick,
         _init_position_state,
         _detect_pullback_reversal,
         _has_bullish_trend_structure,
     )
@@ -140,53 +169,57 @@ def main(
     )
     logger.info(
         f"[â±ï¸ ì»¤íŠ¸ì˜¤í”„(KST)] SELL_FORCE_TIME={SELL_FORCE_TIME.strftime('%H:%M')} / ì „ì²´ì”ê³ ë§¤ë„={SELL_ALL_BALANCES_AT_CUTOFF} / "
         f"íŒ¨ìŠ¤(ì»¤íŠ¸ì˜¤í”„/ë§ˆê°)={FORCE_SELL_PASSES_CUTOFF}/{FORCE_SELL_PASSES_CLOSE}"
     )
     logger.info(
         f"[ğŸ’° CAPITAL] {effective_capital:,}ì› (configured DAILY_CAPITAL={DAILY_CAPITAL:,})"
     )
     logger.info(f"[ğŸ›¡ï¸ SLIPPAGE_ENTER_GUARD_PCT] {SLIPPAGE_ENTER_GUARD_PCT:.2f}%")
 
     # ìƒíƒœ ë³µêµ¬
     state_loaded_at = datetime.now(KST)
     state_loaded_date = state_loaded_at.strftime("%Y-%m-%d")
     state_loaded_str = state_loaded_at.strftime("%Y-%m-%d %H:%M:%S")
     state_loaded_midnight = f"{state_loaded_date} 00:00:00"
 
     holding, traded = load_state()
     lot_state_path = "bot_state/state.json"
     lot_state = load_lot_state(lot_state_path)
     position_state_path = str(STATE_PATH)
     position_state = load_position_state(position_state_path)
     position_state_dirty = False
     sell_reconcile_needed = False
     pending_buy_orders: list[dict[str, Any]] = []
     runtime_state = runtime_state_store.load_state()
+    breakout_watch = runtime_state_store.load_breakout_watch()
+    breakout_watch_dirty = False
     triggered_today: set[str] = set()
     s1_done_today: set[tuple[str, str]] = set()
     last_today_prefix: str | None = None
+    gate_retry_after: dict[str, float] = {}
+    reentry_state: dict[str, datetime] = {}
 
     if isinstance(traded, (set, list, tuple)):
         logger.warning(
             f"[STATE-MIGRATE] traded íƒ€ì… {type(traded)} â†’ dictë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜(ì¤‘ë³µ ì§„ì… ê°€ë“œ ìœ ì§€)"
         )
         traded = {
             code: {"buy_time": state_loaded_midnight, "qty": 0, "price": 0.0}
             for code in traded
         }
     elif not isinstance(traded, dict):
         logger.warning(
             f"[STATE-FORMAT] traded íƒ€ì… {type(traded)} ì§€ì› ì•ˆ í•¨ â†’ ë¹ˆ dictë¡œ ì¬ì„¤ì •"
         )
         traded = {}
     if isinstance(traded, dict):
         traded = {normalize_code(k): v for k, v in traded.items() if normalize_code(k)}
     if isinstance(holding, dict):
         holding = {normalize_code(k): v for k, v in holding.items() if normalize_code(k)}
 
     def _traded_codes(traded_state: Any) -> List[str]:
         if isinstance(traded_state, dict):
             return list(traded_state.keys())
         return []
 
     def _traded_today(traded_state: Any, today_prefix: str) -> set:
@@ -219,50 +252,60 @@ def main(
         for offset in range(days):
             day = today - timedelta(days=offset)
             path = LOG_DIR / f"trades_{day.strftime('%Y-%m-%d')}.json"
             if not path.exists():
                 continue
             try:
                 with open(path, "r", encoding="utf-8") as f:
                     for line in f:
                         line = line.strip()
                         if not line:
                             continue
                         try:
                             logs.append(json.loads(line))
                         except json.JSONDecodeError:
                             continue
             except Exception:
                 logger.exception("[TRADE_LOG] failed to read %s", path)
         return logs
 
     def _save_runtime_state() -> None:
         try:
             runtime_state_store.save_state(runtime_state)
         except Exception:
             logger.exception("[RUNTIME_STATE] save failed")
 
+    def _save_breakout_watch() -> None:
+        nonlocal breakout_watch_dirty
+        if not breakout_watch_dirty:
+            return
+        try:
+            runtime_state_store.save_breakout_watch(breakout_watch)
+            breakout_watch_dirty = False
+        except Exception:
+            logger.exception("[BREAKOUT_WATCH] save failed")
+
     def _save_position_state_now() -> None:
         nonlocal position_state_dirty
         if position_state_dirty:
             save_position_state(position_state_path, position_state)
             position_state_dirty = False
 
     def _lot_state_signature(state: dict) -> tuple:
         lots = state.get("lots")
         if not isinstance(lots, list):
             return tuple()
         return tuple(
             (
                 str(lot.get("lot_id")),
                 str(lot.get("pdno")),
                 int(lot.get("remaining_qty") or 0),
             )
             for lot in lots
         )
 
     def _maybe_save_lot_state(before_signature: tuple) -> None:
         after_signature = _lot_state_signature(lot_state)
         if after_signature != before_signature:
             save_lot_state(lot_state_path, lot_state)
 
     def _refresh_balances_snapshot(reason: str) -> List[Dict[str, Any]]:
@@ -348,50 +391,55 @@ def main(
             _init_position_state(
                 kis,
                 holding,
                 code,
                 float(exec_price),
                 int(fill_qty),
                 k_value,
                 target_price,
             )
             position_state = record_entry_state(
                 state=position_state,
                 code=code,
                 qty=int(fill_qty),
                 avg_price=float(exec_price),
                 strategy_id=strategy_id,
                 engine=trigger_label,
                 entry_reason=pending.get("entry_reason") or "SETUP-OK + TRIGGER-YES",
                 order_type=pending.get("order_type") or "marketable_limit",
                 best_k=k_value,
                 tgt_px=target_price,
                 gap_pct_at_entry=pending.get("gap_pct_at_entry"),
                 meta=meta,
                 entry_time=now_ts,
             )
             position_state_dirty = True
+            code_key = normalize_code(code)
+            if code_key in breakout_watch:
+                breakout_watch.pop(code_key, None)
+                breakout_watch_dirty = True
+                _save_breakout_watch()
 
             lot_id = _build_lot_id(
                 result,
                 pending.get("lot_ts") or datetime.now(KST).strftime("%Y%m%d%H%M%S%f"),
                 code,
             )
             before_lot_signature = _lot_state_signature(lot_state)
             record_buy_fill(
                 lot_state,
                 lot_id=lot_id,
                 pdno=code,
                 strategy_id=strategy_id,
                 engine=f"legacy_kosdaq_runner:sid{strategy_id}",
                 entry_ts=now_ts or datetime.now(KST).isoformat(),
                 entry_price=float(exec_price),
                 qty=int(fill_qty),
                 meta={
                     "strategy_name": pending.get("strategy"),
                     "entry_reason": pending.get("entry_reason") or "SETUP-OK + TRIGGER-YES",
                     "strategy_gate": gate,
                     "pullback_meta": meta,
                     "k": k_value,
                     "target_price": target_price,
                     "best_k": k_value,
                     "tgt_px": target_price,
@@ -475,140 +523,195 @@ def main(
         entries = pos.setdefault("strategies", {})
         entry = entries.setdefault(str(strategy_id), {})
         entry_flags = entry.setdefault(
             "flags",
             {"bear_s1_done": False, "bear_s2_done": False, "sold_p1": False, "sold_p2": False},
         )
         flags_before = dict(entry_flags)
         for key, value in flags.items():
             entry_flags[key] = bool(value)
         logger.info(
             "[FLAGS] code=%s flags_before=%s flags_after=%s",
             normalize_code(code),
             flags_before,
             entry_flags,
         )
         position_state_dirty = True
 
     def _update_last_price_memory(code: str, current_price: float, now_ts: str) -> None:
         nonlocal position_state_dirty
         memory = position_state.setdefault("memory", {})
         code_key = normalize_code(code)
         memory.setdefault("last_price", {})[code_key] = float(current_price)
         memory.setdefault("last_seen", {})[code_key] = now_ts
         position_state_dirty = True
 
+    def _record_breakout_watch(
+        code: str,
+        *,
+        target_price: float | None,
+        reason: str,
+        now_ts: str,
+        eligible: bool = True,
+    ) -> None:
+        nonlocal breakout_watch_dirty
+        code_key = normalize_code(code)
+        if not code_key:
+            return
+        entry = breakout_watch.get(code_key) or {}
+        entry_date = now_ts.split("T")[0] if "T" in now_ts else now_ts.split(" ")[0]
+        entry.setdefault("first_seen_ts", now_ts)
+        entry["date"] = entry_date
+        entry["target_price"] = target_price
+        entry["breakout_seen"] = True
+        entry["reason"] = reason
+        entry["eligible"] = bool(eligible)
+        breakout_watch[code_key] = entry
+        breakout_watch_dirty = True
+        _save_breakout_watch()
+
     def _pullback_stop_hit(
-        code: str, current_price: float, strategy_id: int | str = 5
+        code: str, current_price: float, strategy_id: int | str = SID_PULLBACK
     ) -> bool:
         pos = position_state.get("positions", {}).get(normalize_code(code))
         if not isinstance(pos, dict):
             return False
         entries = pos.get("strategies", {})
         entry = entries.get(str(strategy_id))
         if not isinstance(entry, dict):
             return False
         meta = entry.get("meta", {}) or {}
         reversal_price = meta.get("pullback_reversal_price")
         if reversal_price is None:
             return False
         try:
             return float(current_price) < float(reversal_price) * (1 - FAST_STOP)
         except Exception:
             return False
 
     def _manual_exit_intent(
         code_key: str,
         entry: Dict[str, Any],
         available_qty: int,
         avg_price: float,
         now_dt: datetime,
         rebalance_anchor: str,
     ) -> Tuple[str | None, int]:
         cur_price = _safe_get_price(kis, code_key)
         if cur_price is None or cur_price <= 0:
             return None, 0
+        flags = entry.setdefault("flags", {})
         high_val = float(entry.get("high_watermark") or entry.get("meta", {}).get("high") or avg_price)
         high_val = max(high_val, float(cur_price))
         entry["high_watermark"] = high_val
         entry.setdefault("meta", {})["high"] = high_val
         entry["last_update_ts"] = now_dt.isoformat()
 
         pnl_pct = (float(cur_price) - float(avg_price)) / float(avg_price) * 100.0
-        if MANUAL_HARD_STOP_LOSS_PCT and pnl_pct <= -abs(MANUAL_HARD_STOP_LOSS_PCT):
-            return "manual_hard_stop", int(available_qty)
-
-        trail_pct = abs(MANUAL_TRAILING_STOP_PCT or 0.0)
-        if trail_pct and float(cur_price) <= high_val * (1 - trail_pct / 100.0):
-            return "manual_trailing_stop", int(available_qty)
+        if MANUAL_STOP_LOSS_PCT and pnl_pct <= float(MANUAL_STOP_LOSS_PCT):
+            logger.info("[MANUAL-SL] code=%s pnl=%.2f%% sell=100%%", code_key, pnl_pct)
+            return "manual_sl", int(available_qty)
+
+        tp1_pct = float(MANUAL_TAKE_PROFIT1_PCT or 0.0)
+        tp2_pct = float(MANUAL_TAKE_PROFIT2_PCT or 0.0)
+        tp1_frac = float(MANUAL_TP1_SELL_FRAC or 0.0)
+        if tp2_pct and pnl_pct >= tp2_pct and not flags.get("sold_p2"):
+            logger.info("[MANUAL-TP2] code=%s pnl=%.2f%% sell=100%%", code_key, pnl_pct)
+            return "manual_tp2", int(available_qty)
+        if tp1_pct and pnl_pct >= tp1_pct and not flags.get("sold_p1") and tp1_frac > 0:
+            sell_qty = max(1, int(round(float(available_qty) * tp1_frac)))
+            sell_qty = min(int(available_qty), int(sell_qty))
+            logger.info("[MANUAL-TP1] code=%s pnl=%.2f%% sell=%.0f%%", code_key, pnl_pct, tp1_frac * 100)
+            return "manual_tp1", int(sell_qty)
+
+        trail_start = float(MANUAL_TRAIL_START_PCT or 0.0)
+        trail_stop = float(MANUAL_TRAIL_STOP_PCT or 0.0)
+        peak_pnl_pct = (float(high_val) - float(avg_price)) / float(avg_price) * 100.0
+        if trail_start and trail_stop and peak_pnl_pct >= trail_start:
+            drawdown_pct = (float(high_val) - float(cur_price)) / float(high_val) * 100.0
+            if drawdown_pct >= trail_stop:
+                logger.info(
+                    "[MANUAL-TRAIL] code=%s peak=%.2f%% drawdown=%.2f%% sell=100%%",
+                    code_key,
+                    peak_pnl_pct,
+                    drawdown_pct,
+                )
+                return "manual_trail", int(available_qty)
 
-        if MANUAL_MAX_HOLDING_DAYS:
+        if MANUAL_MAX_HOLD_DAYS:
             try:
                 entry_ts = entry.get("entry_ts") or entry.get("entry", {}).get("time")
                 entry_dt = datetime.fromisoformat(entry_ts) if entry_ts else None
             except Exception:
                 entry_dt = None
             if entry_dt:
-                if (now_dt.date() - entry_dt.date()).days >= MANUAL_MAX_HOLDING_DAYS:
-                    return "manual_time_cut", int(available_qty)
-                try:
-                    rebalance_dt = date.fromisoformat(rebalance_anchor)
-                    if entry_dt.date() < rebalance_dt:
-                        return "manual_rebalance_cut", int(available_qty)
-                except Exception:
-                    pass
+                if (now_dt.date() - entry_dt.date()).days >= MANUAL_MAX_HOLD_DAYS:
+                    if pnl_pct < float(MANUAL_TIME_CUT_PNL_MAX or 0.0):
+                        return "manual_time_cut", int(available_qty)
 
         return None, 0
 
     def _build_exit_intents(code: str, regime_mode: str) -> list[dict[str, Any]]:
         nonlocal position_state_dirty
         intents: list[dict[str, Any]] = []
         code_key = normalize_code(code)
         pos_state = position_state.get("positions", {}).get(code_key)
         if not isinstance(pos_state, dict):
             return intents
         strategies = pos_state.get("strategies", {})
         if not isinstance(strategies, dict):
             return intents
+        now_dt = datetime.now(KST)
         for sid, entry in strategies.items():
             if not isinstance(entry, dict):
                 continue
             available_qty = remaining_qty_for_strategy(lot_state, code_key, sid)
             if available_qty <= 0:
                 continue
+            sid_int = int(sid) if str(sid).isdigit() else None
+            if sid_int in INTRADAY_EXIT_IDS and now_dt.time() >= SELL_FORCE_TIME:
+                intents.append(
+                    {
+                        "code": code_key,
+                        "strategy_id": sid,
+                        "sell_qty": int(available_qty),
+                        "reason": "force_exit_time",
+                    }
+                )
+                continue
             avg_price = strategy_avg_price(lot_state, code_key, sid)
             if avg_price is None:
                 continue
             flags = entry.get("flags", {}) or {}
             meta = entry.get("meta", {}) or {}
             high_value = float(meta.get("high") or 0.0)
             if not high_value or high_value <= 0:
                 high_value = float(avg_price)
             high_value = max(high_value, float(avg_price))
             meta["high"] = high_value
             entry["high_watermark"] = max(float(entry.get("high_watermark") or 0.0), high_value)
-            entry["last_update_ts"] = datetime.now(KST).isoformat()
+            entry["last_update_ts"] = now_dt.isoformat()
             pos_view = {
                 "qty": int(available_qty),
                 "buy_price": float(avg_price),
                 "high": high_value,
                 "sold_p1": bool(flags.get("sold_p1", False)),
                 "sold_p2": bool(flags.get("sold_p2", False)),
                 "name": entry.get("entry", {}).get("name"),
                 "k_value": entry.get("entry", {}).get("best_k"),
                 "target_price_src": entry.get("entry", {}).get("tgt_px"),
             }
             if str(sid) in {"MANUAL", "LEGACY"}:
                 reason, sell_qty = _manual_exit_intent(
                     code_key,
                     entry,
                     int(available_qty),
                     float(avg_price),
                     datetime.now(KST),
                     str(rebalance_date),
                 )
             else:
                 reason, sell_qty = _adaptive_exit(
                     kis,
                     code_key,
                     pos_view,
                     regime_mode=regime_mode,
@@ -632,87 +735,87 @@ def main(
             entry["flags"] = flags
             position_state_dirty = True
         return intents
 
     def _remaining_qty_for(pdno: str) -> int:
         return sum(
             int(lot.get("remaining_qty") or 0)
             for lot in lot_state.get("lots", [])
             if normalize_code(lot.get("pdno")) == normalize_code(pdno)
         )
 
     def _ledger_total_available_qty(code: str) -> int:
         return sum(
             int(lot.get("remaining_qty") or 0)
             for lot in lot_state.get("lots", [])
             if normalize_code(lot.get("pdno")) == normalize_code(code)
         )
 
     def _cap_sell_qty(code: str, requested_qty: int) -> int:
         return min(int(requested_qty), int(_ledger_total_available_qty(code)))
 
     def _normalize_strategy_id(value: Any) -> int:
         try:
             strategy_num = int(value)
         except Exception:
-            return 1
-        if 1 <= strategy_num <= 5:
+            return SID_BREAKOUT
+        if strategy_num in STRATEGY_INT_IDS:
             return strategy_num
-        return 1
+        return SID_BREAKOUT
 
     def _derive_strategy_id(payload: Dict[str, Any]) -> int:
         raw = (
             payload.get("strategy_id")
             or payload.get("strategyId")
             or payload.get("strategy_no")
             or payload.get("strategyNo")
         )
         if raw is not None and str(raw).isdigit():
             strategy_id = _normalize_strategy_id(raw)
             if strategy_id != int(raw):
                 logger.info(
                     "[STRATEGY_ID_NORMALIZE] raw=%s -> %s (clamped)",
                     raw,
                     strategy_id,
                 )
             return strategy_id
         name = str(payload.get("strategy") or "")
         name_lower = name.lower()
         match = re.search(r"(?:ì „ëµ|strategy)\s*([1-5])", name_lower)
         if match:
             strategy_id = _normalize_strategy_id(match.group(1))
             logger.info(
                 "[STRATEGY_ID_DERIVE] source=strategy_name(%s) -> %s",
                 name,
                 strategy_id,
             )
             return strategy_id
         if "pullback" in name_lower or "ëˆŒë¦¼ëª©" in name:
-            logger.info("[STRATEGY_ID_DERIVE] source=pullback -> 5")
-            return 5
-        logger.info("[STRATEGY_ID_DERIVE] source=default -> 1")
-        return 1
+            logger.info("[STRATEGY_ID_DERIVE] source=pullback -> %s", SID_PULLBACK)
+            return SID_PULLBACK
+        logger.info("[STRATEGY_ID_DERIVE] source=default -> %s", SID_BREAKOUT)
+        return SID_BREAKOUT
 
     def _build_lot_id(result: Any, fallback_ts: str, pdno: str) -> str:
         order_no = ""
         fill_seq = ""
         if isinstance(result, dict):
             out = result.get("output") or {}
             order_no = (
                 out.get("ODNO")
                 or out.get("ord_no")
                 or out.get("order_no")
                 or result.get("ODNO")
                 or result.get("ord_no")
                 or result.get("order_no")
                 or ""
             )
             fill_seq = (
                 out.get("CCLD_SQ")
                 or out.get("ccld_sq")
                 or out.get("fill_seq")
                 or out.get("CCLD_NO")
                 or out.get("ccld_no")
                 or ""
             )
         if not order_no:
             order_no = f"NOORDER-{normalize_code(pdno)}-{fallback_ts}"
@@ -1206,66 +1309,66 @@ def main(
 
         processed_targets[code] = {
             "code": code,
             "name": name,
             "best_k": k_best,
             "target_price": target_price,
             "qty": qty,
             "strategy": strategy,
             "strategy_id": strategy_id,
             "avg_return_pct": avg_return_pct,
             "win_rate_pct": win_rate_pct,
             "mdd_pct": mdd_pct,
             "trades": trades,
             "sharpe_m": sharpe_m,
             "cumulative_return_pct": cumret_pct,
             "prev_open": t.get("prev_open"),
             "prev_high": t.get("prev_high"),
             "prev_low": t.get("prev_low"),
             "prev_close": t.get("prev_close"),
             "prev_volume": t.get("prev_volume"),
         }
 
     # === ì „ëµë³„ í•„í„°ë§ (ì „ëµ 1~5 ë¶„ë¦¬) ===
     # NOTE:
     # - ê¸°ì¡´ ì½”ë“œê°€ ëª¨ë“  ì¢…ëª©ì— 'ì±”í”¼ì–¸ í•„í„°'ë¥¼ ê°•ì œ ì ìš©í•˜ë©´ì„œ ì „ëµ 1~3 ì§„ì…ì´ ì‚¬ì‹¤ìƒ ë§‰íˆëŠ” ë¬¸ì œê°€ ìˆì—ˆìŒ.
-    # - ê¸°ë³¸ê°’ì€ ì „ëµ 4(ì±”í”¼ì–¸)ì—ë§Œ CHAMPION_* í•„í„°ë¥¼ ì ìš©í•˜ê³ , ë‚˜ë¨¸ì§€(1~3)ëŠ” ë©”íƒ€ ì§€í‘œë¥¼ ì°¸ê³ ë§Œ í•˜ë„ë¡ í•œë‹¤.
-    strict_sid_env = _cfg("STRICT_CHAMPION_STRATEGY_IDS") or "4"
+    # - ê¸°ë³¸ê°’ì€ ì „ëµ 5(ì±”í”¼ì–¸/ìŠ¤ìœ™)ì—ë§Œ CHAMPION_* í•„í„°ë¥¼ ì ìš©í•˜ê³ , ë‚˜ë¨¸ì§€(1~3)ëŠ” ë©”íƒ€ ì§€í‘œë¥¼ ì°¸ê³ ë§Œ í•˜ë„ë¡ í•œë‹¤.
+    strict_sid_env = _cfg("STRICT_CHAMPION_STRATEGY_IDS") or "5"
     strict_sids = {
         int(x.strip()) for x in str(strict_sid_env).split(",") if x.strip().isdigit()
-    } or {4}
+    } or {SID_SWING}
 
     filtered_targets: Dict[str, Any] = {}
     for code, info in processed_targets.items():
         sid = _normalize_strategy_id(info.get("strategy_id") or _derive_strategy_id(info))
 
         trades = _to_int(info.get("trades"), 0)
         win_rate = _to_float(info.get("win_rate_pct"), 0.0)
         mdd = abs(_to_float(info.get("mdd_pct"), 0.0) or 0.0)
         sharpe = _to_float(info.get("sharpe_m"), 0.0)
 
-        # ì „ëµ4(ì±”í”¼ì–¸) ë“± 'ì—„ê²© í•„í„°' ëŒ€ìƒë§Œ CHAMPION_* ê¸°ì¤€ìœ¼ë¡œ ì»·
+        # ì „ëµ5(ì±”í”¼ì–¸/ìŠ¤ìœ™) ë“± 'ì—„ê²© í•„í„°' ëŒ€ìƒë§Œ CHAMPION_* ê¸°ì¤€ìœ¼ë¡œ ì»·
         if sid in strict_sids:
             if (
                 trades < CHAMPION_MIN_TRADES
                 or win_rate < CHAMPION_MIN_WINRATE
                 or mdd > CHAMPION_MAX_MDD
                 or sharpe < CHAMPION_MIN_SHARPE
             ):
                 logger.info(
                     "[STRATEGY_FILTER_SKIP] sid=%s code=%s trades=%s win=%.1f%% mdd=%.1f%% sharpe=%.2f",
                     sid,
                     code,
                     trades,
                     win_rate,
                     mdd,
                     sharpe,
                 )
                 continue
 
         filtered_targets[code] = info
 
         processed_targets = filtered_targets
 
         # ì±”í”¼ì–¸ ë“±ê¸‰í™” (A/B/C) â†’ ì‹¤ì œ ë§¤ìˆ˜ í›„ë³´ëŠ” Aê¸‰ë§Œ ì‚¬ìš©
         graded_targets: Dict[str, Any] = {}
         grade_counts = {"A": 0, "B": 0, "C": 0}
@@ -1427,100 +1530,85 @@ def main(
 
         for code in picked:
             if code in processed_targets:
                 selected_targets[code] = processed_targets[code]
 
         logger.info(
             "[REGIME-CHAMPIONS] mode=%s stage=%s n_active=%s picked=%s capital_active=%s",
             mode,
             stage,
             n_active,
             picked,
             f"{capital_active:,}",
         )
 
         logger.info(
             "[REBALANCE] ë ˆì§=%s pct=%.2f%%, í›„ë³´ %dê°œ ì¤‘ ìƒìœ„ %dì¢…ëª©ë§Œ ì„ íƒ: %s",
             mode,
             pct_change,
             len(processed_targets),
             len(selected_targets),
             ",".join(selected_targets.keys()),
         )
 
         code_to_target: Dict[str, Any] = selected_targets
 
-        # ëˆŒë¦¼ëª© ìŠ¤ìº”ìš© ì½”ìŠ¤ë‹¥ ì‹œì´ ìƒìœ„ ë¦¬ìŠ¤íŠ¸ (ì±”í”¼ì–¸ê³¼ ë³„ë„ë¡œ ê´€ë¦¬)
-        pullback_watch: Dict[str, Dict[str, Any]] = {}
-        if USE_PULLBACK_ENTRY:
-            try:
-                pb_weight = max(0.0, min(PULLBACK_UNIT_WEIGHT, 1.0))
-                base_notional = int(round(capital_active * pb_weight))
-                pb_df = get_kosdaq_top_n(date_str=rebalance_date, n=PULLBACK_TOPN)
-                for _, row in pb_df.iterrows():
-                    code = normalize_code(row.get("Code") or row.get("code") or "")
-                    if not code:
-                        continue
-                    pullback_watch[code] = {
-                        "code": code,
-                        "name": row.get("Name") or row.get("name"),
-                        "notional": base_notional,
-                    }
-                logger.info(
-                    f"[PULLBACK-WATCH] ì½”ìŠ¤ë‹¥ ì‹œì´ Top{PULLBACK_TOPN} {len(pullback_watch)}ì¢…ëª© ìŠ¤ìº” ì¤€ë¹„"
-                )
-            except Exception as e:
-                logger.warning(f"[PULLBACK-WATCH-FAIL] ì‹œì´ ìƒìœ„ ë¡œë“œ ì‹¤íŒ¨: {e}")
 
         loop_sleep_sec = 2.5  # ë©”ì¸ ë£¨í”„ ëŒ€ê¸° ì‹œê°„(ì´ˆ)
         max_closed_checks = 3
         closed_checks = 0
 
         try:
             while True:
                 # === ì½”ìŠ¤ë‹¥ ë ˆì§ ì—…ë°ì´íŠ¸ ===
                 regime = _update_market_regime(kis)
                 regime_state = regime
                 pct_txt = (
                     f"{regime.get('pct_change'):.2f}%"
                     if regime.get("pct_change") is not None
                     else "N/A"
                 )
                 logger.info(
                     f"[REGIME] mode={regime['mode']} stage={regime['bear_stage']} pct={pct_txt}"
                 )
 
                 # ì¥ ìƒíƒœ
                 now_dt_kst = datetime.now(KST)
                 is_open = kis.is_market_open()
+                open_ts = datetime.combine(now_dt_kst.date(), MARKET_OPEN, tzinfo=KST)
                 now_str = now_dt_kst.strftime("%Y-%m-%d %H:%M:%S")
                 today_prefix = now_dt_kst.strftime("%Y-%m-%d")
                 _ensure_guard_state(now_dt_kst.date())
                 if last_today_prefix != today_prefix:
                     triggered_today.clear()
                     s1_done_today.clear()
                     last_today_prefix = today_prefix
+                    for code in list(breakout_watch.keys()):
+                        if breakout_watch.get(code, {}).get("date") != today_prefix:
+                            breakout_watch.pop(code, None)
+                            breakout_watch_dirty = True
+                    _save_breakout_watch()
                 expired_pending = _cleanup_expired_pending(traded, now_dt_kst, ttl_sec=300)
                 if expired_pending:
                     triggered_today.difference_update(expired_pending)
                 traded_today: set[str] = set()
                 regime_s1_summary = {
                     "sent_qty": 0,
                     "sent_orders": 0,
                     "skipped": 0,
                     "total_qty": 0,
                     "by_stock": {},
                 }
 
                 def _log_s1_action(
                     code: str,
                     strategy_id: int | str,
                     status: str,
                     base_qty: int,
                     target_qty: int,
                     sold_today: int,
                     remaining: int,
                     sell_qty: int,
                     reason_msg: str | None = None,
                 ) -> None:
                     key = f"{normalize_code(code)}:{strategy_id}"
                     regime_s1_summary["by_stock"][key] = {
@@ -1569,51 +1657,51 @@ def main(
                         f"sold={sold_today} remaining={remaining} sell_qty={sell_qty}"
                     )
                     if reason_msg:
                         msg += f" reason={reason_msg}"
                     if status == "ERROR":
                         logger.error(msg)
                     else:
                         logger.info(msg)
 
                 def _strategy_ids_for_code(code: str) -> list[str]:
                     code_key = normalize_code(code)
                     totals: dict[str, int] = {}
                     lots = lot_state.get("lots", [])
                     if isinstance(lots, list):
                         for lot in lots:
                             if normalize_code(lot.get("pdno")) != code_key:
                                 continue
                             remaining = int(lot.get("remaining_qty") or 0)
                             if remaining <= 0:
                                 continue
                             sid = lot.get("strategy_id")
                             if sid is None:
                                 continue
                             if str(sid).isdigit():
                                 sid_int = int(sid)
-                                if 1 <= sid_int <= 5:
+                                if sid_int in STRATEGY_INT_IDS:
                                     totals[str(sid_int)] = totals.get(str(sid_int), 0) + remaining
                     ordered: list[str] = []
                     for sid in STRATEGY_REDUCTION_PRIORITY:
                         key = str(sid)
                         if key in totals:
                             ordered.append(key)
                     for sid in sorted(totals.keys()):
                         if sid not in ordered:
                             ordered.append(sid)
                     return ordered
 
                 def _run_bear_reduction(
                     code: str,
                     *,
                     is_target: bool,
                     regime: dict[str, Any],
                 ) -> None:
                     sellable_qty = ord_psbl_map.get(code, 0)
                     if sellable_qty <= 0:
                         return
                     for sid in _strategy_ids_for_code(code):
                         remaining_strategy = remaining_qty_for_strategy(lot_state, code, sid)
                         if remaining_strategy <= 0:
                             continue
                         entry = _ensure_position_entry(code, sid)
@@ -2374,145 +2462,152 @@ def main(
                         log_trade(
                             {
                                 "datetime": now_str,
                                 "code": code,
                                 "name": None,
                                 "qty": int(sell_qty),
                                 "K": None,
                                 "target_price": None,
                                 "strategy": f"adaptive_exit_{sid}",
                                 "side": "SELL",
                                 "price": exec_px,
                                 "amount": int((exec_px or 0)) * int(sell_qty),
                                 "result": result,
                                 "reason": intent.get("reason"),
                             }
                         )
                         _apply_sell_to_ledger_with_balance(
                             code,
                             int(sell_qty),
                             now_dt_kst.isoformat(),
                             result,
                             scope="strategy",
                             trigger_strategy_id=int(sid) if sid is not None and str(sid).isdigit() else sid,
                             prev_qty_before=prev_qty_before,
                         )
+                        if intent.get("reason") == "manual_tp1":
+                            _set_position_flags(code, sid, sold_p1=True)
+                        elif intent.get("reason") == "manual_tp2":
+                            _set_position_flags(code, sid, sold_p1=True, sold_p2=True)
                         runtime_state_store.mark_fill(
                             runtime_state,
                             code,
                             "SELL",
                             sid,
                             int(sell_qty),
                             float(exec_px or 0.0),
                             now_dt_kst.isoformat(),
                             status="filled",
                         )
                         _save_runtime_state()
+                        reentry_state[normalize_code(code)] = now_dt_kst
                         save_state(holding, traded)
                         time.sleep(RATE_SLEEP_SEC)
 
                     if not exit_intents:
                         try:
                             current_price = _safe_get_price(kis, code)
                         except Exception:
                             current_price = None
                         if current_price and _pullback_stop_hit(code, current_price):
                             sellable_qty = ord_psbl_map.get(code, 0)
-                            pb_avail = remaining_qty_for_strategy(lot_state, code, 5)
+                            pb_avail = remaining_qty_for_strategy(lot_state, code, SID_PULLBACK)
                             sell_qty = min(int(sellable_qty), int(pb_avail))
                             if sell_qty > 0:
                                 prev_qty_before = int(
                                     (holding.get(code) or {}).get("qty") or 0
                                 )
                                 if dry_run:
                                     logger.info(
-                                        "[DRY-RUN][SELL] code=%s qty=%s strategy_id=5 reason=pullback_reversal_break",
+                                        "[DRY-RUN][SELL] code=%s qty=%s strategy_id=%s reason=pullback_reversal_break",
                                         code,
                                         sell_qty,
+                                        SID_PULLBACK,
                                     )
                                     runtime_state_store.mark_order(
                                         runtime_state,
                                         code,
                                         "SELL",
-                                        5,
+                                        SID_PULLBACK,
                                         int(sell_qty),
                                         float(holding.get(code, {}).get("buy_price") or 0.0),
                                         now_dt_kst.isoformat(),
                                         status="submitted(dry)",
                                     )
                                     _save_runtime_state()
                                     continue
                                 exec_px, result = _sell_once(
                                     kis, code, sell_qty, prefer_market=True
                                 )
                                 runtime_state_store.mark_order(
                                     runtime_state,
                                     code,
                                     "SELL",
-                                    5,
+                                    SID_PULLBACK,
                                     int(sell_qty),
                                     float(exec_px or 0.0),
                                     now_dt_kst.isoformat(),
                                     status="submitted",
                                 )
                                 _save_runtime_state()
                                 log_trade(
                                     {
                                         "datetime": now_str,
                                         "code": code,
                                         "name": None,
                                         "qty": int(sell_qty),
                                         "K": None,
                                         "target_price": None,
                                         "strategy": "ëˆŒë¦¼ëª© ì†ì ˆ",
                                         "side": "SELL",
                                         "price": exec_px,
                                         "amount": int((exec_px or 0)) * int(sell_qty),
                                         "result": result,
                                         "reason": "pullback_reversal_break",
                                     }
                                 )
                                 _apply_sell_to_ledger_with_balance(
                                     code,
                                     int(sell_qty),
                                     now_dt_kst.isoformat(),
                                     result,
                                     scope="strategy",
-                                    trigger_strategy_id=5,
+                                    trigger_strategy_id=SID_PULLBACK,
                                     prev_qty_before=prev_qty_before,
                                 )
                                 runtime_state_store.mark_fill(
                                     runtime_state,
                                     code,
                                     "SELL",
-                                    5,
+                                    SID_PULLBACK,
                                     int(sell_qty),
                                     float(exec_px or 0.0),
                                     now_dt_kst.isoformat(),
                                     status="filled",
                                 )
                                 _save_runtime_state()
+                                reentry_state[normalize_code(code)] = now_dt_kst
                                 save_state(holding, traded)
                                 time.sleep(RATE_SLEEP_SEC)
                                 logger.info(
                                     "[PULLBACK-STOP] code=%s current=%s reason=reversal_break",
                                     code,
                                     current_price,
                                 )
 
                 if sell_reconcile_needed:
                     balances_after_sell = _refresh_balances_snapshot("sell_batch")
                     holding = {}
                     for bal in balances_after_sell:
                         code = normalize_code(bal.get("code") or bal.get("pdno"))
                         qty = int(bal.get("qty", 0))
                         if qty <= 0:
                             continue
                         price = float(bal.get("avg_price", 0.0))
                         holding[code] = {
                             "qty": qty,
                             "buy_price": price,
                             "bear_s1_done": False,
                             "bear_s2_done": False,
                         }
                         _init_position_state_from_balance(kis, holding, code, price, qty)
                     reconcile_with_broker_holdings(lot_state, balances_after_sell)
@@ -2524,50 +2619,56 @@ def main(
                         position_state,
                         _load_trade_log(),
                         processed_targets.keys(),
                     )
                     position_state_dirty = True
                     sell_reconcile_needed = False
                     _save_position_state_now()
 
                 _save_position_state_now()
 
                 # === (2) ì‹ ê·œ ì§„ì… ë¡œì§ (ì±”í”¼ì–¸) ===
                 for code, info in code_to_target.items():
                     if not can_buy:
                         continue
 
                     if code in traded_today:
                         continue
 
                     if code in holding and not ALLOW_PYRAMID:
                         continue
 
                     if code in triggered_today:
                         logger.info(f"[TRIGGER-SKIP] {code}: ê¸ˆì¼ ì´ë¯¸ íŠ¸ë¦¬ê±° ë°œìƒ")
                         continue
 
+                    next_retry_ts = gate_retry_after.get(code)
+                    if next_retry_ts and time.time() < next_retry_ts:
+                        continue
+                    if next_retry_ts:
+                        gate_retry_after.pop(code, None)
+
                     target_qty = int(info.get("qty", 0))
                     if target_qty <= 0:
                         logger.info(f"[REBALANCE] {code}: target_qty=0 â†’ ìŠ¤í‚µ")
                         continue
 
                     target_price = info.get("target_price")
                     k_value = info.get("best_k")
                     strategy = info.get("strategy")
                     weight = _to_float(info.get("weight") or 0.0)
 
                     planned_notional = int(
                         _to_float(info.get("target_notional") or 0.0) or 0
                     )
                     logger.info(
                         f"[TARGET] {code} qty={target_qty} tgt_px={target_price} notional={planned_notional} K={k_value}"
                     )
 
                     # [ì¤‘ë³µ ì§„ì… ë°©ì§€] ì´ë¯¸ ì£¼ë¬¸ëœ ì¢…ëª©ì¸ì§€ í™•ì¸
                     if code in traded_today:
                         logger.info(f"[SKIP] {code}: ì´ë¯¸ ê¸ˆì¼ ê±°ë˜ë¨")
                         continue
 
                     # strategy_idëŠ” ìœ„ì—ì„œ strategy_entry_gateì—ì„œ ì´ë¯¸ ì •ê·œí™”/ê²°ì •ë¨
                     if strategy_id is not None and remaining_qty_for_strategy(
                         lot_state, code, strategy_id
@@ -2625,56 +2726,65 @@ def main(
                     )
                     daily_ctx = normalize_daily_ctx(daily_ctx)
                     intra_ctx = _compute_intraday_entry_context(
                         kis, code, fast=MOM_FAST, slow=MOM_SLOW
                     )
                     intra_ctx = normalize_intraday_ctx(intra_ctx)
 
                     momentum_confirmed = bool(
                         daily_ctx.get("strong_trend")
                         or intra_ctx.get("vwap_reclaim")
                         or intra_ctx.get("range_break")
                     )
 
                     if mode == "neutral" and not (
                         info.get("champion_grade") in ("A", "B") or momentum_confirmed
                     ):
                         logger.info(
                             f"[ENTRY-SKIP] {code}: neutral ë ˆì§ì—ì„œ ë¹„ì±”í”¼ì–¸/ëª¨ë©˜í…€ ë¯¸í™•ì¸ â†’ ì‹ ê·œ ì§„ì… ë³´ë¥˜"
                         )
                         continue
 
                     setup_state = signals.evaluate_setup_gate(
                         daily_ctx, intra_ctx, regime_state=regime_state
                     )
                     if not setup_state.get("ok"):
-                        if not setup_state.get("reasons"):
-                            setup_state["reasons"] = ["setup_flag_false"]
+                        reasons = setup_state.get("reasons") or []
+                        if not reasons:
+                            reasons = ["setup_flag_false"]
+                        if setup_state.get("retryable") and "intraday_unavailable" in reasons:
+                            gate_retry_after[code] = time.time() + 90
+                            logger.info(
+                                "[GATE-RETRY] code=%s intraday_available=%s -> retry scheduled",
+                                code,
+                                intra_ctx.get("intraday_available"),
+                            )
+                            continue
                         logger.info(
                             "[SETUP-BAD] %s | reasons=%s | daily=%s intra=%s regime=%s",
                             code,
-                            setup_state.get("reasons"),
+                            reasons,
                             daily_ctx,
                             intra_ctx,
                             regime_state,
                         )
                         continue
                     logger.info(
                         "[SETUP-OK] %s | daily=%s intra=%s regime=%s",
                         code,
                         daily_ctx,
                         intra_ctx,
                         regime_state,
                     )
 
                     # === ì „ëµë³„ ì§„ì… ê²Œì´íŠ¸ (ì „ëµ 1~5) ===
                     strategy_id = _normalize_strategy_id(info.get("strategy_id") or _derive_strategy_id(info))
                     gate = strategy_entry_gate(
                         strategy_id,
                         info,
                         daily_ctx,
                         intra_ctx,
                         now_dt_kst=now_dt_kst,
                         regime_state=regime_state,
                     )
                     if not gate.get("ok"):
                         logger.info(
@@ -2696,50 +2806,70 @@ def main(
                         trigger_name=trigger_label,
                     )
                     if not trigger_state.get("ok"):
                         logger.info(
                             "[TRIGGER-NO] %s | trigger=%s current=%s tgt_px=%s gap_pct=%s missing=%s signals=%s",
                             code,
                             trigger_state.get("trigger_name"),
                             trigger_state.get("current_price"),
                             trigger_state.get("target_price"),
                             trigger_state.get("gap_pct"),
                             trigger_state.get("missing_conditions"),
                             trigger_state.get("trigger_signals"),
                         )
                         continue
                     logger.info(
                         "[TRIGGER-OK] %s | trigger=%s current=%s tgt_px=%s gap_pct=%s signals=%s rr=%.2f",
                         code,
                         trigger_state.get("trigger_name"),
                         trigger_state.get("current_price"),
                         trigger_state.get("target_price"),
                         trigger_state.get("gap_pct"),
                         trigger_state.get("trigger_signals"),
                         trigger_state.get("risk_reward") or 0.0,
                     )
 
+                    if guards.should_no_trade(open_ts, now_dt_kst):
+                        logger.info("[GOVERNOR-BLOCK] code=%s reason=no_trade_window", code)
+                        continue
+                    code_key = normalize_code(code)
+                    if code_key in reentry_state and not guards.can_reenter(
+                        {"last_exit": {code_key: {"time": reentry_state[code_key]}}},
+                        code_key,
+                        now_dt_kst,
+                    ):
+                        logger.info("[GOVERNOR-BLOCK] code=%s reason=reenter_cooldown", code)
+                        continue
+                    daily_loss_pct = float(runtime_state.get("daily_loss_pct") or 0.0)
+                    if daily_loss_pct <= -abs(guards.MAX_DRAWDOWN_DAY_PCT):
+                        logger.info(
+                            "[GOVERNOR-BLOCK] code=%s reason=daily_loss_cut loss=%.2f%%",
+                            code,
+                            daily_loss_pct,
+                        )
+                        continue
+
                     flow_ok, flow_ctx, ob_strength = _subject_flow_gate(
                         code,
                         info,
                         float(current_price),
                         target_price,
                         intraday_ctx.get("vwap"),
                     )
                     if not flow_ok:
                         continue
 
                     # === VWAP ê°€ë“œ(ìŠ¬ë¦¬í”¼ì§€ ë°©ì–´) ===
                     try:
                         guard_passed = vwap_guard(kis, code, SLIPPAGE_ENTER_GUARD_PCT)
                     except Exception as e:
                         logger.warning(
                             f"[VWAP_GUARD_FAIL] {code}: VWAP ê°€ë“œ ì˜¤ë¥˜ â†’ ì§„ì… ë³´ë¥˜ ({e})"
                         )
                         continue
 
                     if not guard_passed:
                         logger.info(f"[VWAP_GUARD] {code}: ìŠ¬ë¦¬í”¼ì§€ ìœ„í—˜ â†’ ë§¤ìˆ˜ ìŠ¤í‚µ")
                         continue
 
                     qty = target_qty
                     if mode == "neutral":
@@ -2756,52 +2886,72 @@ def main(
                     except Exception:
                         qty_scale = 1.0
                     if qty_scale and qty_scale != 1.0:
                         scaled_qty2 = max(1, int(qty * qty_scale))
                         if scaled_qty2 != qty:
                             logger.info(
                                 "[ENTRY-SIZE][SID] %s: sid=%s qty %sâ†’%s (scale=%.2f)",
                                 code,
                                 strategy_id,
                                 qty,
                                 scaled_qty2,
                                 qty_scale,
                             )
                         qty = scaled_qty2
                     trade_ctx = {
                         "datetime": now_str,
                         "code": code,
                         "name": info.get("name"),
                         "qty": int(qty),
                         "K": k_value,
                         "target_price": target_price,
                         "strategy": strategy,
                         "strategy_id": info.get("strategy_id"),
                         "side": "BUY",
                     }
-
-                    limit_px, mo_px = compute_entry_target(kis, info)
+                    limit_px = None
+                    mo_px = None
+                    if strategy_id == SID_BREAKOUT and target_price:
+                        chase_limit = float(target_price) * (1 + MAX_CHASE_PCT / 100.0)
+                        if current_price > chase_limit:
+                            _record_breakout_watch(
+                                code,
+                                target_price=float(target_price),
+                                reason="chase_exceeded",
+                                now_ts=now_dt_kst.isoformat(),
+                                eligible=True,
+                            )
+                            logger.info(
+                                "[GOVERNOR-BLOCK] code=%s reason=chase_exceeded last=%.2f limit=%.2f",
+                                code,
+                                float(current_price),
+                                chase_limit,
+                            )
+                            continue
+                        limit_px = min(float(current_price), chase_limit)
+                    else:
+                        limit_px, mo_px = compute_entry_target(kis, info)
                     if limit_px is None and mo_px is None:
                         logger.warning(
                             f"[TARGET-PRICE] {code}: limit/mo ê°€ê²© ì‚°ì¶œ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ"
                         )
                         continue
 
                     if (
                         limit_px
                         and abs(limit_px - current_price) / current_price * 100
                         > SLIPPAGE_LIMIT_PCT
                     ):
                         logger.info(
                             f"[SLIPPAGE_LIMIT] {code}: í˜¸ê°€ä¹–é›¢ {abs(limit_px - current_price) / current_price * 100:.2f}% â†’ ìŠ¤í‚µ"
                         )
                         continue
 
                     logger.info(
                         f"[BUY-TRY] {code}: qty={qty} limit={limit_px} mo={mo_px} target={target_price} k={k_value}"
                     )
 
                     prev_qty = int((holding.get(code) or {}).get("qty", 0))
                     if dry_run:
                         logger.info(
                             "[DRY-RUN][BUY] code=%s qty=%s price=%s strategy_id=%s",
                             code,
@@ -2868,277 +3018,496 @@ def main(
                             "trade_ctx": trade_ctx,
                             "result": result,
                             "now_ts": now_dt_kst.isoformat(),
                             "pending_since": now_str,
                             "prev_qty": prev_qty,
                             "entry_reason": "SETUP-OK + TRIGGER-YES",
                             "order_type": "marketable_limit",
                             "gap_pct_at_entry": trigger_state.get("gap_pct"),
                             "rebalance_date": str(rebalance_date),
                             "lot_ts": now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
                         }
                     )
                     save_state(holding, traded)
                     effective_cash = _get_effective_ord_cash(
                         kis, soft_cap=effective_capital
                     )
                     if effective_cash <= 0:
                         can_buy = False
                     save_state(holding, traded)
                     time.sleep(RATE_SLEEP_SEC)
 
                 if pending_buy_orders:
                     balances_after_buy = _refresh_balances_snapshot("buy_batch")
                     _finalize_pending_buys(pending_buy_orders, balances_after_buy)
 
-                # ====== ëˆŒë¦¼ëª© ì „ìš© ë§¤ìˆ˜ (ì±”í”¼ì–¸ê³¼ ë…ë¦½ì ìœ¼ë¡œ Top-N ì‹œì´ ë¦¬ìŠ¤íŠ¸ ìŠ¤ìº”) ======
-                if USE_PULLBACK_ENTRY and is_open:
+                # ====== ì „ëµ2: ëŒíŒŒ í›„ ëˆŒë¦¼ ì¬ì§„ì… (breakout_watch ê¸°ë°˜) ======
+                if USE_PULLBACK_ENTRY and is_open and breakout_watch:
                     if not can_buy:
                         logger.info("[PULLBACK-SKIP] can_buy=False â†’ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ")
                     else:
-                        if pullback_watch:
-                            logger.info(f"[PULLBACK-SCAN] {len(pullback_watch)}ì¢…ëª© ê²€ì‚¬")
-
-                        for code, info in list(pullback_watch.items()):
+                        for code, watch in list(breakout_watch.items()):
                             if pullback_buys_today >= PULLBACK_MAX_BUYS_PER_DAY:
                                 logger.info(
                                     f"[PULLBACK-LIMIT] í•˜ë£¨ ìµœëŒ€ {PULLBACK_MAX_BUYS_PER_DAY}ê±´ ë„ë‹¬ â†’ ìŠ¤ìº” ì¤‘ë‹¨"
                                 )
                                 break
-
+                            if watch.get("date") != today_prefix:
+                                continue
+                            if not watch.get("eligible", True):
+                                continue
                             if code in traded_today or code in holding:
-                                continue  # ì±”í”¼ì–¸ ë£¨í”„ì™€ ë³„ë„ë¡œë§Œ ì²˜ë¦¬
-
-                            if remaining_qty_for_strategy(lot_state, code, 5) > 0:
-                                logger.info(
-                                    "[ENTRY-SKIP] already owned in ledger: code=%s sid=5",
-                                    code,
-                                )
                                 continue
-
+                            if remaining_qty_for_strategy(lot_state, code, SID_PULLBACK) > 0:
+                                continue
                             if _pending_block(traded, code, now_dt_kst, block_sec=45):
                                 logger.info(
                                     f"[PULLBACK-SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘"
                                 )
                                 continue
                             if runtime_state_store.should_block_order(
                                 runtime_state, code, "BUY", now_dt_kst.isoformat()
                             ):
                                 logger.info(
                                     "[IDEMPOTENT-SKIP] %s BUY blocked within window",
                                     code,
                                 )
                                 continue
 
-                            base_notional = int(info.get("notional") or 0)
+                            info = code_to_target.get(code) or {}
+                            base_notional = int(info.get("target_notional") or 0)
                             if base_notional <= 0:
-                                logger.info(f"[PULLBACK-SKIP] {code}: ì˜ˆì‚° 0")
                                 continue
 
-                            try:
-                                resp = _detect_pullback_reversal(
-                                    kis,
+                            price_res = _safe_get_price(kis, code, with_source=True)
+                            if isinstance(price_res, tuple):
+                                current_price, price_source = price_res
+                            else:
+                                current_price, price_source = price_res, None
+                            if not current_price:
+                                logger.warning(f"[PULLBACK-PRICE] {code}: í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨")
+                                continue
+
+                            candles = signals._get_intraday_1min(
+                                kis, code, count=max(120, MOM_SLOW * 3)
+                            )
+                            if not candles:
+                                gate_retry_after[code] = time.time() + 90
+                                logger.info(
+                                    "[GATE-RETRY] code=%s intraday_available=False -> retry scheduled",
                                     code,
-                                    lookback=PULLBACK_LOOKBACK,
-                                    pullback_days=PULLBACK_DAYS,
-                                    reversal_buffer_pct=PULLBACK_REVERSAL_BUFFER_PCT,
                                 )
-
-                                pullback_ok = False
-                                trigger_price = None
-
-                                if isinstance(resp, dict):
-                                    pullback_ok = bool(resp.get("setup")) and bool(
-                                        resp.get("reversing")
-                                    )
-                                    trigger_price = resp.get("reversal_price")
-                                    if not pullback_ok:
-                                        reason = resp.get("reason")
-                                        if reason:
-                                            logger.info(
-                                                f"[PULLBACK-SKIP] {code}: íŒ¨í„´ ë¯¸ì¶©ì¡±(reason={reason})"
-                                            )
-                                elif isinstance(resp, tuple):
-                                    if len(resp) >= 1:
-                                        pullback_ok = bool(resp[0])
-                                    if len(resp) >= 2:
-                                        trigger_price = resp[1]
-                                else:
-                                    pullback_ok = bool(resp)
-
-                            except Exception as e:
-                                logger.warning(f"[PULLBACK-FAIL] {code}: ìŠ¤ìº” ì‹¤íŒ¨ {e}")
                                 continue
 
-                            if not pullback_ok:
+                            vwap_val = signals._compute_vwap_from_1min(candles)
+                            last_candle = candles[-1]
+                            last_close = _to_float(last_candle.get("close") or last_candle.get("price"), None)
+                            if not vwap_val or not last_close:
                                 continue
 
-                            if trigger_price is None:
-                                logger.info(f"[PULLBACK-SKIP] {code}: trigger_price None")
-                                continue
+                            since_candles = candles
+                            first_seen_ts = watch.get("first_seen_ts")
+                            if isinstance(first_seen_ts, str):
+                                try:
+                                    ts = datetime.fromisoformat(first_seen_ts)
+                                    cutoff = ts.strftime("%H%M%S")
+                                    filtered = [
+                                        c for c in candles
+                                        if str(c.get("time") or "") >= cutoff
+                                    ]
+                                    if filtered:
+                                        since_candles = filtered
+                                except Exception:
+                                    pass
+
+                            lows = [
+                                _to_float(c.get("low") or c.get("close") or c.get("price"), None)
+                                for c in since_candles
+                            ]
+                            lows = [v for v in lows if v is not None]
+                            cond_a = (
+                                bool(lows)
+                                and min(lows) <= float(vwap_val) * (1 - VWAP_TOL)
+                                and float(last_close) >= float(vwap_val)
+                            )
 
-                            qty = _notional_to_qty(kis, code, base_notional)
-                            if qty <= 0:
-                                logger.info(f"[PULLBACK-SKIP] {code}: ìˆ˜ëŸ‰ ì‚°ì¶œ 0")
+                            cond_b = False
+                            candles_5m = signals.aggregate_1m_to_5m(since_candles)
+                            if len(candles_5m) >= 2:
+                                prev = candles_5m[-2]
+                                prev_high = _to_float(prev.get("high"), None)
+                                lows_5m = [
+                                    _to_float(c.get("low"), None) for c in candles_5m[:-1]
+                                ]
+                                lows_5m = [v for v in lows_5m if v is not None]
+                                if prev_high and lows_5m:
+                                    cond_b = float(last_close) >= float(prev_high) and min(lows_5m) < float(prev_high)
+
+                            if not (cond_a or cond_b):
                                 continue
 
-                            current_price = _safe_get_price(kis, code)
-                            if not current_price:
-                                logger.warning(f"[PULLBACK-PRICE] {code}: í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨")
+                            daily_ctx = normalize_daily_ctx(
+                                _compute_daily_entry_context(
+                                    kis, code, current_price, price_source
+                                )
+                            )
+                            intra_ctx = normalize_intraday_ctx(
+                                _compute_intraday_entry_context(
+                                    kis, code, fast=MOM_FAST, slow=MOM_SLOW
+                                )
+                            )
+                            trigger_state = signals.evaluate_trigger_gate(
+                                daily_ctx,
+                                intra_ctx,
+                                prev_price=None,
+                                target_price=None,
+                                trigger_name="breakout_cross",
+                            )
+                            if len(trigger_state.get("trigger_signals") or []) < 2:
                                 continue
 
-                            if trigger_price and current_price < trigger_price * 0.98:
+                            target_price = watch.get("target_price")
+                            if not target_price:
+                                continue
+                            chase_limit = float(target_price) * (1 + MAX_CHASE_PCT / 100.0)
+                            if current_price > chase_limit:
                                 logger.info(
-                                    f"[PULLBACK-DELAY] {code}: ê°€ê²©ì´ íŠ¸ë¦¬ê±° ëŒ€ë¹„ 2% ì´ìƒ í•˜ë½ â†’ ëŒ€ê¸° (cur={current_price}, trigger={trigger_price})"
+                                    "[GOVERNOR-BLOCK] code=%s reason=chase_exceeded last=%.2f limit=%.2f",
+                                    code,
+                                    float(current_price),
+                                    chase_limit,
                                 )
                                 continue
 
+                            qty = _notional_to_qty(kis, code, base_notional)
+                            if qty <= 0:
+                                continue
+
+                            limit_px = min(float(current_price), chase_limit)
                             flow_ok, flow_ctx, ob_strength = _subject_flow_gate(
                                 code,
                                 info,
                                 float(current_price),
-                                trigger_price,
-                                None,
+                                target_price,
+                                vwap_val,
                             )
                             if not flow_ok:
                                 continue
 
+                            pullback_reason = "vwap_reclaim" if cond_a else "five_min_reclaim"
                             prev_qty = int((holding.get(code) or {}).get("qty", 0))
                             if dry_run:
                                 logger.info(
-                                    "[DRY-RUN][BUY] code=%s qty=%s price=%s strategy_id=5",
+                                    "[DRY-RUN][BUY] code=%s qty=%s price=%s strategy_id=%s",
                                     code,
                                     int(qty),
-                                    trigger_price or current_price,
+                                    limit_px,
+                                    SID_PULLBACK,
                                 )
                                 runtime_state_store.mark_order(
                                     runtime_state,
                                     code,
                                     "BUY",
-                                    5,
+                                    SID_PULLBACK,
                                     int(qty),
-                                    float(trigger_price or current_price),
+                                    float(limit_px),
                                     now_dt_kst.isoformat(),
                                     status="submitted(dry)",
                                 )
                                 _save_runtime_state()
                                 continue
                             result = place_buy_with_fallback(
                                 kis,
                                 code,
                                 int(qty),
-                                _round_to_tick(trigger_price or current_price),
+                                _round_to_tick(limit_px),
                             )
                             runtime_state_store.mark_order(
                                 runtime_state,
                                 code,
                                 "BUY",
-                                5,
+                                SID_PULLBACK,
                                 int(qty),
-                                float(trigger_price or current_price),
+                                float(limit_px),
                                 now_dt_kst.isoformat(),
                                 status="submitted",
                             )
                             _save_runtime_state()
-
                             if not _is_order_success(result):
                                 logger.warning(
                                     f"[PULLBACK-BUY-FAIL] {code}: result={result}"
                                 )
                                 continue
 
                             triggered_today.add(code)
-                            exec_price = _extract_fill_price(
-                                result, trigger_price or current_price
-                            )
+                            exec_price = _extract_fill_price(result, limit_px)
                             _record_trade(
                                 traded,
                                 code,
                                 {
                                     "buy_time": now_str,
                                     "qty": int(qty),
                                     "price": float(exec_price),
                                     "status": "pending",
                                     "pending_since": now_str,
                                 },
                             )
                             traded_today.add(code)
                             save_state(holding, traded)
-                            pullback_meta = {}
-                            if isinstance(resp, dict):
-                                pullback_meta = {
-                                    "pullback_peak_price": resp.get("peak_price"),
-                                    "pullback_reversal_price": resp.get("reversal_price"),
-                                    "pullback_reason": resp.get("reason"),
-                                }
                             pending_buy_orders.append(
                                 {
                                     "code": code,
                                     "qty": int(qty),
                                     "exec_price": float(exec_price),
-                                    "strategy_id": 5,
-                                    "trigger_label": "pullback",
-                                    "k_value": None,
-                                    "target_price": trigger_price,
+                                    "strategy_id": SID_PULLBACK,
+                                    "trigger_label": "pullback_reentry",
+                                    "k_value": info.get("best_k"),
+                                    "target_price": target_price,
                                     "gate": {},
-                                    "strategy": f"ì½”ìŠ¤ë‹¥ Top{PULLBACK_TOPN} ëˆŒë¦¼ëª©",
+                                    "strategy": "ì „ëµ2: ëˆŒë¦¼ ì¬ì§„ì…",
                                     "trade_ctx": {
                                         "datetime": now_str,
                                         "code": code,
                                         "name": info.get("name"),
                                         "qty": int(qty),
-                                        "K": None,
-                                        "target_price": trigger_price,
-                                        "strategy": f"ì½”ìŠ¤ë‹¥ Top{PULLBACK_TOPN} ëˆŒë¦¼ëª©",
-                                        "strategy_id": 5,
+                                        "K": info.get("best_k"),
+                                        "target_price": target_price,
+                                        "strategy": "ì „ëµ2: ëˆŒë¦¼ ì¬ì§„ì…",
+                                        "strategy_id": SID_PULLBACK,
                                         "side": "BUY",
                                     },
                                     "result": result,
                                     "now_ts": now_dt_kst.isoformat(),
                                     "pending_since": now_str,
                                     "prev_qty": prev_qty,
-                                    "entry_reason": "PULLBACK-SETUP + REVERSAL",
+                                    "entry_reason": "PULLBACK-INTRADAY",
                                     "order_type": "marketable_limit",
                                     "gap_pct_at_entry": None,
                                     "rebalance_date": str(rebalance_date),
                                     "lot_ts": now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
-                                    "meta": pullback_meta,
+                                    "meta": {
+                                        "pullback_reversal_price": vwap_val,
+                                        "pullback_reason": pullback_reason,
+                                    },
                                 }
                             )
                             pullback_buys_today += 1
                             effective_cash = _get_effective_ord_cash(
                                 kis, soft_cap=effective_capital
                             )
                             if effective_cash <= 0:
                                 can_buy = False
                             save_state(holding, traded)
                             time.sleep(RATE_SLEEP_SEC)
 
                 if pending_buy_orders:
                     balances_after_pullback = _refresh_balances_snapshot("pullback_buy_batch")
                     _finalize_pending_buys(pending_buy_orders, balances_after_pullback)
 
+                # ====== ì „ëµ3: ë¼ìŠ¤íŠ¸ì•„ì›Œ ë² íŒ… (14:10~14:35) ======
+                last_hour_start = dtime(14, 10)
+                last_hour_end = dtime(14, 35)
+                if is_open and last_hour_start <= now_dt_kst.time() <= last_hour_end:
+                    last_hour_codes = set(code_to_target.keys()) | set(breakout_watch.keys())
+                    for code in sorted(last_hour_codes):
+                        if code in holding or code in traded_today or code in triggered_today:
+                            continue
+                        if remaining_qty_for_strategy(lot_state, code, SID_LASTHOUR) > 0:
+                            continue
+                        info = code_to_target.get(code) or {"code": code}
+                        base_notional = int(info.get("target_notional") or 0)
+                        if base_notional <= 0:
+                            continue
+                        price_res = _safe_get_price(kis, code, with_source=True)
+                        if isinstance(price_res, tuple):
+                            current_price, price_source = price_res
+                        else:
+                            current_price, price_source = price_res, None
+                        if not current_price:
+                            continue
+                        candles = signals._get_intraday_1min(
+                            kis, code, count=max(120, MOM_SLOW * 3)
+                        )
+                        if not candles:
+                            continue
+                        vwap_val = signals._compute_vwap_from_1min(candles)
+                        if not vwap_val or float(current_price) < float(vwap_val):
+                            continue
+                        highs = [
+                            _to_float(c.get("high") or c.get("close") or c.get("price"), None)
+                            for c in candles
+                        ]
+                        lows = [
+                            _to_float(c.get("low") or c.get("close") or c.get("price"), None)
+                            for c in candles
+                        ]
+                        highs = [v for v in highs if v is not None]
+                        lows = [v for v in lows if v is not None]
+                        if not highs or not lows:
+                            continue
+                        day_high = max(highs)
+                        day_low = min(lows)
+                        if day_high <= day_low:
+                            continue
+                        range_pos = (float(current_price) - day_low) / (day_high - day_low)
+                        if range_pos < 0.7:
+                            continue
+
+                        daily_ctx = normalize_daily_ctx(
+                            _compute_daily_entry_context(
+                                kis, code, current_price, price_source
+                            )
+                        )
+                        intra_ctx = normalize_intraday_ctx(
+                            _compute_intraday_entry_context(
+                                kis, code, fast=MOM_FAST, slow=MOM_SLOW
+                            )
+                        )
+                        trigger_state = signals.evaluate_trigger_gate(
+                            daily_ctx,
+                            intra_ctx,
+                            prev_price=None,
+                            target_price=None,
+                            trigger_name="close_betting",
+                        )
+                        if len(trigger_state.get("trigger_signals") or []) < 2:
+                            continue
+
+                        flow_ok, flow_ctx, ob_strength = _subject_flow_gate(
+                            code,
+                            info,
+                            float(current_price),
+                            None,
+                            vwap_val,
+                        )
+                        if not flow_ok:
+                            continue
+
+                        qty = _notional_to_qty(kis, code, int(base_notional * 0.4))
+                        if qty <= 0:
+                            continue
+
+                        if guards.should_no_trade(open_ts, now_dt_kst):
+                            logger.info("[GOVERNOR-BLOCK] code=%s reason=no_trade_window", code)
+                            continue
+                        code_key = normalize_code(code)
+                        if code_key in reentry_state and not guards.can_reenter(
+                            {"last_exit": {code_key: {"time": reentry_state[code_key]}}},
+                            code_key,
+                            now_dt_kst,
+                        ):
+                            logger.info("[GOVERNOR-BLOCK] code=%s reason=reenter_cooldown", code)
+                            continue
+
+                        limit_px = _round_to_tick(float(current_price))
+                        if dry_run:
+                            logger.info(
+                                "[DRY-RUN][BUY] code=%s qty=%s price=%s strategy_id=%s",
+                                code,
+                                int(qty),
+                                limit_px,
+                                SID_LASTHOUR,
+                            )
+                            runtime_state_store.mark_order(
+                                runtime_state,
+                                code,
+                                "BUY",
+                                SID_LASTHOUR,
+                                int(qty),
+                                float(limit_px),
+                                now_dt_kst.isoformat(),
+                                status="submitted(dry)",
+                            )
+                            _save_runtime_state()
+                            continue
+                        result = place_buy_with_fallback(
+                            kis, code, int(qty), limit_px
+                        )
+                        runtime_state_store.mark_order(
+                            runtime_state,
+                            code,
+                            "BUY",
+                            SID_LASTHOUR,
+                            int(qty),
+                            float(limit_px),
+                            now_dt_kst.isoformat(),
+                            status="submitted",
+                        )
+                        _save_runtime_state()
+                        if not _is_order_success(result):
+                            continue
+
+                        triggered_today.add(code)
+                        exec_price = _extract_fill_price(result, limit_px)
+                        _record_trade(
+                            traded,
+                            code,
+                            {
+                                "buy_time": now_str,
+                                "qty": int(qty),
+                                "price": float(exec_price),
+                                "status": "pending",
+                                "pending_since": now_str,
+                            },
+                        )
+                        traded_today.add(code)
+                        pending_buy_orders.append(
+                            {
+                                "code": code,
+                                "qty": int(qty),
+                                "exec_price": float(exec_price),
+                                "strategy_id": SID_LASTHOUR,
+                                "trigger_label": "close_betting",
+                                "k_value": info.get("best_k"),
+                                "target_price": None,
+                                "gate": {},
+                                "strategy": "ì „ëµ3: ë¼ìŠ¤íŠ¸ì•„ì›Œ",
+                                "trade_ctx": {
+                                    "datetime": now_str,
+                                    "code": code,
+                                    "name": info.get("name"),
+                                    "qty": int(qty),
+                                    "K": info.get("best_k"),
+                                    "target_price": None,
+                                    "strategy": "ì „ëµ3: ë¼ìŠ¤íŠ¸ì•„ì›Œ",
+                                    "strategy_id": SID_LASTHOUR,
+                                    "side": "BUY",
+                                },
+                                "result": result,
+                                "now_ts": now_dt_kst.isoformat(),
+                                "pending_since": now_str,
+                                "prev_qty": int((holding.get(code) or {}).get("qty", 0)),
+                                "entry_reason": "LAST-HOUR",
+                                "order_type": "marketable_limit",
+                                "gap_pct_at_entry": None,
+                                "rebalance_date": str(rebalance_date),
+                                "lot_ts": now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
+                            }
+                        )
+                        save_state(holding, traded)
+                        time.sleep(RATE_SLEEP_SEC)
+
                 # ====== (A) ë¹„íƒ€ê²Ÿ ë³´ìœ ë¶„ë„ ì¥ì¤‘ ëŠ¥ë™ê´€ë¦¬ ======
                 if is_open:
                     for code in list(holding.keys()):
                         if code in code_to_target:
                             continue  # ìœ„ ë£¨í”„ì—ì„œ ì´ë¯¸ ì²˜ë¦¬
 
                         # ì•½ì„¸ ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)
                         if regime["mode"] == "bear":
                             _run_bear_reduction(code, is_target=False, regime=regime)
 
                         try:
                             momentum_intact, trend_ctx = _has_bullish_trend_structure(
                                 kis, code
                             )
                         except NetTemporaryError:
                             logger.warning(
                                 f"[20D_TREND_TEMP_SKIP] {code}: ë„¤íŠ¸ì›Œí¬ ì¼ì‹œ ì‹¤íŒ¨ â†’ ì´ë²ˆ ë£¨í”„ ìŠ¤í‚µ"
                             )
                             continue
                         except DataEmptyError:
                             logger.warning(
                                 f"[DATA_EMPTY] {code}: 0ìº”ë“¤ â†’ ë‹¤ìŒ ë£¨í”„ì—ì„œ ì¬í™•ì¸"
                             )
                             continue
                         except DataShortError:
diff --git a/trader/position_state_store.py b/trader/position_state_store.py
index 48e649b321fd522aea72bd9f84af899dd04df4f0..5430f857e317cc9d8798b71f0d2da68d02bf4cea 100644
--- a/trader/position_state_store.py
+++ b/trader/position_state_store.py
@@ -1,37 +1,38 @@
 from __future__ import annotations
 
 import json
 import logging
 import os
 from datetime import datetime
 from pathlib import Path
 import re
 from typing import Any, Dict, Iterable
 
 from .config import KST, STATE_PATH
 from .code_utils import normalize_code
+from .strategy_ids import SID_BREAKOUT, STRATEGY_INT_IDS
 from .state_io import atomic_write_json
 
 logger = logging.getLogger(__name__)
 
 SCHEMA_VERSION = 2
 
 
 def _empty_state() -> Dict[str, Any]:
     return {
         "schema_version": SCHEMA_VERSION,
         "updated_at": None,
         "positions": {},
         "memory": {"last_price": {}, "last_seen": {}},
     }
 
 
 def _coerce_state(state: Dict[str, Any]) -> Dict[str, Any]:
     if not isinstance(state, dict):
         return _empty_state()
     state["schema_version"] = SCHEMA_VERSION
     state.setdefault("updated_at", None)
     positions = state.get("positions")
     if not isinstance(positions, dict):
         positions = {}
         state["positions"] = positions
@@ -385,51 +386,51 @@ def reconcile_with_broker(
             entry["qty"] = int(qty)
             entry.setdefault("code", code_key)
             entry.setdefault("sid", str(sid))
             entry.setdefault("engine", entry.get("entry", {}).get("engine"))
             entry.setdefault("entry_ts", entry.get("entry", {}).get("time"))
             entry.setdefault("high_watermark", float(entry.get("avg_price") or 0.0))
             entry["last_update_ts"] = datetime.now(KST).isoformat()
         active_codes.add(code_key)
 
     for code in list(positions.keys()):
         if code not in active_codes:
             positions.pop(code, None)
             memory.get("last_price", {}).pop(code, None)
             memory.get("last_seen", {}).pop(code, None)
 
     return state
 
 
 def _normalize_strategy_id(value: Any) -> str | None:
     if value is None:
         return None
     try:
         num = int(value)
     except Exception:
         num = None
-    if num is not None and 1 <= num <= 5:
+    if num is not None and num in STRATEGY_INT_IDS:
         return str(num)
     text = str(value).strip()
     if text.upper().startswith("STRAT_"):
         text = text.split("_", 1)[-1]
     match = re.search(r"([1-5])", text)
     if match:
         return match.group(1)
     return None
 
 
 def _latest_trade_sid(
     trade_log: Iterable[Dict[str, Any]], code: str
 ) -> tuple[str | None, str | None]:
     code_key = normalize_code(code)
     for entry in reversed(list(trade_log)):
         if normalize_code(entry.get("code")) != code_key:
             continue
         if str(entry.get("side") or "").upper() != "BUY":
             continue
         status = str(entry.get("status") or "").lower()
         result = entry.get("result") or {}
         if status not in ("", "filled") and not (
             isinstance(result, dict) and result.get("rt_cd") == "0"
         ):
             continue
@@ -553,44 +554,44 @@ def reconcile_positions(
                 diff = int(qty) - adjusted_total
                 if diff and entries:
                     entries[0]["qty"] = int(entries[0].get("qty") or 0) + diff
 
         for sid_key, entry in strategies.items():
             entry.setdefault("code", code_key)
             entry.setdefault("sid", str(sid_key))
             entry.setdefault("engine", entry.get("entry", {}).get("engine") or "reconcile")
             entry.setdefault("entry_ts", entry.get("entry", {}).get("time"))
             entry.setdefault(
                 "high_watermark",
                 max(float(entry.get("high_watermark") or 0.0), float(avg_price or 0.0)),
             )
             entry["last_update_ts"] = datetime.now(KST).isoformat()
             entry.setdefault(
                 "flags",
                 {"bear_s1_done": False, "bear_s2_done": False, "sold_p1": False, "sold_p2": False},
             )
 
     return state
 
 
 def run_reconcile_self_checks() -> None:
     state = _empty_state()
     lot_state = {
-        "lots": [{"pdno": "000001", "strategy_id": 1, "remaining_qty": 5}]
+        "lots": [{"pdno": "000001", "strategy_id": SID_BREAKOUT, "remaining_qty": 5}]
     }
     state["positions"]["000001"] = {
         "strategies": {
-            "1": {
+            str(SID_BREAKOUT): {
                 "qty": 7,
                 "avg_price": 100.0,
                 "entry": {},
                 "meta": {},
                 "flags": {},
             }
         }
     }
     state = reconcile_with_broker(state, [], lot_state=lot_state)
-    assert state["positions"]["000001"]["strategies"]["1"]["qty"] == 5
+    assert state["positions"]["000001"]["strategies"][str(SID_BREAKOUT)]["qty"] == 5
 
 
 if __name__ == "__main__":
     run_reconcile_self_checks()
diff --git a/trader/signals.py b/trader/signals.py
index f9f288b6166aa72a186c22b18e45b2cba06c9801..58a8e7df8d7fd34b6a1ce8687ce2b355b9044dfe 100644
--- a/trader/signals.py
+++ b/trader/signals.py
@@ -34,50 +34,51 @@ from .core_constants import (
     USE_PULLBACK_ENTRY,
     VWAP_TOL,
     logger,
     DAILY_CAPITAL,
     W_MIN_ONE,
     W_MAX_ONE,
 )
 from .core_utils import _get_daily_candles_cached, _to_float, _to_int, _with_retry
 from .kis_wrapper import KisAPI, NetTemporaryError, DataEmptyError, DataShortError
 from .metrics import vwap_guard
 from .code_utils import normalize_code
 
 __all__ = [
     "_safe_get_price",
     "_fetch_balances",
     "_get_effective_ord_cash",
     "_get_daily_candles_cached",
     "_detect_pullback_reversal",
     "_classify_champion_grade",
     "_compute_daily_entry_context",
     "_compute_intraday_entry_context",
     "is_bad_entry",
     "is_good_entry",
     "evaluate_setup_gate",
     "evaluate_trigger_gate",
+    "aggregate_1m_to_5m",
     "_get_intraday_1min",
     "_compute_vwap_from_1min",
     "_compute_intraday_momentum",
     "is_strong_momentum_vwap",
     "get_20d_return_pct",
     "is_strong_momentum",
     "_percentile_rank",
     "_has_bullish_trend_structure",
     "_weight_to_qty",
     "_notional_to_qty",
     "_get_atr",
 ]
 
 # === [ANCHOR: PRICE_CACHE] í˜„ì¬ê°€ ìºì‹œ & ì„œí‚·ë¸Œë ˆì´ì»¤ ===
 _LAST_PRICE_CACHE: Dict[str, Dict[str, Any]] = {}  # code -> {"px": float, "ts": epoch}
 _PRICE_CB: Dict[str, Dict[str, float]] = {}          # code -> {"fail": int, "until": epoch}
 
 # === [ANCHOR: BALANCE_CACHE] ì”ê³  ìºì‹± (ë£¨í”„ 15ì´ˆ ë‹¨ì¼ í˜¸ì¶œ) ===
 _BALANCE_CACHE: Dict[str, Any] = {"ts": 0.0, "balances": []}
 
 def _safe_get_price(
     kis: KisAPI,
     code: str,
     ttl_sec: int = 5,
     stale_ok_sec: int = 30,
@@ -766,100 +767,104 @@ def is_bad_entry(
             code,
             " / ".join(reasons),
             daily_ctx,
             intraday_ctx,
             regime_state,
         )
         return True
 
     logger.info(
         "[ENTRY-OK] %s | daily=%s intra=%s regime=%s",
         code,
         daily_ctx,
         intraday_ctx,
         regime_state,
     )
     return False
 
 
 def evaluate_setup_gate(
     daily_ctx: Dict[str, Any],
     intraday_ctx: Dict[str, Any],
     regime_state: Optional[Dict[str, Any]] = None,
 ) -> Dict[str, Any]:
     missing_conditions: List[str] = []
     reasons = _collect_bad_entry_reasons(daily_ctx, intraday_ctx, regime_state)
+    retryable = False
 
     if daily_ctx.get("data_insufficient"):
         daily_count = daily_ctx.get("daily_count")
         if daily_count is not None and int(daily_count) < 21:
             reasons.append("data_insufficient_daily_<21")
         elif daily_count is not None:
             reasons.append(f"data_insufficient_daily_{daily_count}")
         else:
             reasons.append("data_insufficient_daily_unknown")
 
     if daily_ctx.get("prev_close") in (None, 0):
         reasons.append("prev_close_missing")
 
     if not intraday_ctx or not intraday_ctx.get("intraday_available"):
         reasons.append("intraday_unavailable")
+        retryable = True
     elif not intraday_ctx.get("vwap_enabled"):
         reasons.append("intraday_unavailable")
+        retryable = True
 
     down_streak = daily_ctx.get("down_streak")
     if down_streak is not None and int(down_streak) < 2:
         reasons.append("down_streak_insufficient")
 
     pullback = daily_ctx.get("pullback_depth_pct")
     if pullback is not None:
         try:
             pullback_val = float(pullback)
             max_pb = float(daily_ctx.get("max_pullback_pct") or BAD_ENTRY_MAX_PULLBACK)
             if pullback_val > max_pb:
                 reasons.append("pullback_depth_too_high")
         except Exception:
             reasons.append("pullback_depth_invalid")
 
     ma20_ratio = daily_ctx.get("ma20_ratio")
     if ma20_ratio is not None:
         try:
             if float(ma20_ratio) < GOOD_ENTRY_MA20_RANGE[0]:
                 reasons.append("ma20_below")
         except Exception:
             reasons.append("ma20_invalid")
 
     if not daily_ctx.get("strong_trend"):
         reasons.append("not_strong_trend")
 
     ok = bool(daily_ctx.get("setup_ok")) and not reasons
     if not ok and not reasons:
         reasons = ["setup_flag_false"]
     return {
         "ok": ok,
         "missing_conditions": missing_conditions,
         "reasons": reasons,
+        "retryable": retryable,
     }
 
 
 def evaluate_trigger_gate(
     daily_ctx: Dict[str, Any],
     intraday_ctx: Dict[str, Any],
     *,
     prev_high: Optional[float] = None,
     prev_price: Optional[float] = None,
     target_price: Optional[float] = None,
     trigger_name: str = "breakout_cross",
 ) -> Dict[str, Any]:
     missing_conditions: List[str] = []
     signals: List[str] = []
 
     cur_px = _to_float(daily_ctx.get("current_price"), None)
     atr = _to_float(daily_ctx.get("atr"), 0.0)
     ma_risk = _to_float(daily_ctx.get("ma20_risk"), 0.0)
     risk = max(atr, ma_risk, (cur_px or 0) * 0.03)
     reward = max(0.0, (daily_ctx.get("peak_price") or 0) - (cur_px or 0)) + atr
     risk_reward = reward / risk if risk else None
 
     if intraday_ctx.get("vwap_reclaim"):
         signals.append("vwap")
     if intraday_ctx.get("range_break"):
@@ -1019,50 +1024,96 @@ def _compute_vwap_from_1min(candles: List[Dict[str, Any]]) -> Optional[float]:
         if price <= 0 or vol <= 0:
             continue
         pv += price * vol
         vol_sum += vol
     if vol_sum <= 0:
         return None
     return pv / vol_sum
 
 def _compute_intraday_momentum(candles: List[Dict[str, Any]], fast: int = MOM_FAST, slow: int = MOM_SLOW) -> float:
     closes: List[float] = []
     for c in candles:
         try:
             px = float(c.get("close") or c.get("trade_price") or c.get("price") or 0.0)
         except Exception:
             continue
         if px > 0:
             closes.append(px)
     if len(closes) < max(fast, slow):
         return 0.0
     fast_ma = sum(closes[-fast:]) / float(fast)
     slow_ma = sum(closes[-slow:]) / float(slow)
     if slow_ma <= 0:
         return 0.0
     return (fast_ma - slow_ma) / slow_ma * 100.0
 
+
+def aggregate_1m_to_5m(candles_1m: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
+    if not candles_1m:
+        return []
+    candles = list(candles_1m)
+    if candles and "time" in candles[0]:
+        candles = sorted(candles, key=lambda c: str(c.get("time") or ""))
+    aggregated: List[Dict[str, Any]] = []
+    bucket: List[Dict[str, Any]] = []
+    for candle in candles:
+        bucket.append(candle)
+        if len(bucket) < 5:
+            continue
+        open_px = _to_float(
+            bucket[0].get("open") or bucket[0].get("close") or bucket[0].get("price"),
+            None,
+        )
+        close_px = _to_float(
+            bucket[-1].get("close") or bucket[-1].get("price"),
+            None,
+        )
+        highs = [
+            _to_float(c.get("high") or c.get("close") or c.get("price"), 0.0)
+            for c in bucket
+        ]
+        lows = [
+            _to_float(c.get("low") or c.get("close") or c.get("price"), 0.0)
+            for c in bucket
+        ]
+        volumes = [
+            _to_float(c.get("volume") or c.get("trade_volume") or 0.0, 0.0)
+            for c in bucket
+        ]
+        aggregated.append(
+            {
+                "time": bucket[-1].get("time"),
+                "open": open_px,
+                "high": max(highs) if highs else None,
+                "low": min(lows) if lows else None,
+                "close": close_px,
+                "volume": sum(volumes),
+            }
+        )
+        bucket = []
+    return aggregated
+
 def is_strong_momentum_vwap(kis: KisAPI, code: str) -> bool:
     """
     1ë¶„ë´‰ VWAP + ë‹¨ê¸° ëª¨ë©˜í…€ ê¸°ë°˜ ëª¨ë©˜í…€ ê°•ì„¸ íŒì •.
     - ìµœê·¼ ê°€ê²©ì´ VWAP ìœ„
     - fast/slow ëª¨ë©˜í…€ >= MOM_TH_PCT
     """
     try:
         if hasattr(kis, "is_market_open") and not kis.is_market_open() and not ALLOW_WHEN_CLOSED:
             return False
     except Exception:
         pass
 
     candles = _get_intraday_1min(kis, code, count=max(MOM_SLOW * 3, 60))
     if not candles:
         return False
 
     try:
         last_candle = candles[-1]
         last_price = float(last_candle.get("close") or last_candle.get("trade_price") or last_candle.get("price") or 0.0)
     except Exception:
         return False
     if last_price <= 0:
         return False
 
     vwap_val = _compute_vwap_from_1min(candles)
diff --git a/trader/state_store.py b/trader/state_store.py
index ce91e77bc163f6693a7aa821f135d31d5c3bd445..8a36b7be668709915f7fc164bfcbac5ca2515868 100644
--- a/trader/state_store.py
+++ b/trader/state_store.py
@@ -1,42 +1,44 @@
 from __future__ import annotations
 
 import json
 import logging
+import os
 from datetime import datetime
 from pathlib import Path
 from typing import Any, Dict
 
 from .config import KST
 from .code_utils import normalize_code
 from .state_io import atomic_write_json
 
 logger = logging.getLogger(__name__)
 
 SCHEMA_VERSION = 1
 RUNTIME_STATE_DIR = Path(".runtime")
 RUNTIME_STATE_PATH = RUNTIME_STATE_DIR / "state.json"
+BREAKOUT_WATCH_PATH = Path(__file__).parent / "state" / "breakout_watch.json"
 
 
 def _default_runtime_state() -> Dict[str, Any]:
     return {
         "schema_version": SCHEMA_VERSION,
         "updated_at": None,
         "positions": {},
         "orders": {},
     }
 
 
 def load_state() -> Dict[str, Any]:
     if not RUNTIME_STATE_PATH.exists():
         return _default_runtime_state()
     try:
         with open(RUNTIME_STATE_PATH, "r", encoding="utf-8") as f:
             state = json.load(f)
         if not isinstance(state, dict):
             logger.warning("[RUNTIME_STATE] invalid state format: %s", type(state))
             return _default_runtime_state()
         state.setdefault("schema_version", SCHEMA_VERSION)
         state.setdefault("positions", {})
         state.setdefault("orders", {})
         state.setdefault("updated_at", None)
         return state
@@ -219,25 +221,45 @@ def load_lot_state(path_json: str) -> Dict[str, Any]:
             logger.warning("[STATE_STORE] invalid state format: %s", type(state))
             return _default_lot_state()
         state.setdefault("version", SCHEMA_VERSION)
         state.setdefault("lots", [])
         state.setdefault("updated_at", None)
         return state
     except Exception:
         logger.exception("[STATE_STORE] failed to load %s", path_json)
         return _default_lot_state()
 
 
 def save_lot_state(path_json: str, state: Dict[str, Any]) -> None:
     path = Path(path_json)
     try:
         path.parent.mkdir(parents=True, exist_ok=True)
         payload = dict(state)
         payload.setdefault("version", SCHEMA_VERSION)
         payload.setdefault("lots", [])
         payload["updated_at"] = datetime.now(KST).isoformat()
         tmp_path = path.with_name(f"{path.name}.tmp")
         with open(tmp_path, "w", encoding="utf-8") as f:
             json.dump(payload, f, ensure_ascii=False, indent=2)
         os.replace(tmp_path, path)
     except Exception:
         logger.exception("[STATE_STORE] failed to save %s", path_json)
+
+
+def load_breakout_watch() -> Dict[str, Any]:
+    if not BREAKOUT_WATCH_PATH.exists():
+        return {}
+    try:
+        with open(BREAKOUT_WATCH_PATH, "r", encoding="utf-8") as f:
+            payload = json.load(f)
+        return payload if isinstance(payload, dict) else {}
+    except Exception:
+        logger.exception("[BREAKOUT_WATCH] failed to load %s", BREAKOUT_WATCH_PATH)
+        return {}
+
+
+def save_breakout_watch(state: Dict[str, Any]) -> None:
+    try:
+        BREAKOUT_WATCH_PATH.parent.mkdir(parents=True, exist_ok=True)
+        atomic_write_json(BREAKOUT_WATCH_PATH, state or {})
+    except Exception:
+        logger.exception("[BREAKOUT_WATCH] failed to save %s", BREAKOUT_WATCH_PATH)
diff --git a/trader/strategy_ids.py b/trader/strategy_ids.py
new file mode 100644
index 0000000000000000000000000000000000000000..0e053246ee7b2ed72dab39844c5d99c78f22598b
--- /dev/null
+++ b/trader/strategy_ids.py
@@ -0,0 +1,13 @@
+"""Strategy ID constants."""
+from __future__ import annotations
+
+SID_BREAKOUT = 1
+SID_PULLBACK = 2
+SID_LASTHOUR = 3
+SID_GOVERNOR = 4
+SID_SWING = 5
+SID_MANUAL = "MANUAL"
+
+STRATEGY_INT_IDS = {SID_BREAKOUT, SID_PULLBACK, SID_LASTHOUR, SID_GOVERNOR, SID_SWING}
+INTRADAY_BREAKOUT_IDS = {SID_BREAKOUT, SID_PULLBACK}
+INTRADAY_EXIT_IDS = {SID_BREAKOUT, SID_PULLBACK, SID_LASTHOUR}
diff --git a/trader/strategy_rules.py b/trader/strategy_rules.py
index 5a6d7e7b64b40abd75495b093ee35fafcba6b328..0518a8197989555a14f34d214f4600f99c748580 100644
--- a/trader/strategy_rules.py
+++ b/trader/strategy_rules.py
@@ -1,132 +1,152 @@
 from __future__ import annotations
 
 import os
 from dataclasses import dataclass
 from datetime import datetime, time
 from typing import Any, Dict, List, Optional
 
+from .strategy_ids import (
+    INTRADAY_BREAKOUT_IDS,
+    SID_BREAKOUT,
+    SID_LASTHOUR,
+    SID_PULLBACK,
+    SID_SWING,
+)
+
 
 def _parse_hhmm(val: str, default: time) -> time:
     try:
         s = str(val).strip()
         if not s:
             return default
         hh, mm = s.split(":")
         return time(int(hh), int(mm))
     except Exception:
         return default
 
 
+def is_close_betting_strategy(strategy_id: int | None) -> bool:
+    sid = int(strategy_id or SID_BREAKOUT)
+    return sid == SID_LASTHOUR
+
+
+def use_pullback_engine(strategy_id: int | None) -> bool:
+    sid = int(strategy_id or SID_BREAKOUT)
+    return sid == SID_PULLBACK
+
+
+def is_breakout_strategy(strategy_id: int | None) -> bool:
+    sid = int(strategy_id or SID_BREAKOUT)
+    return sid in INTRADAY_BREAKOUT_IDS
+
+
 def strategy_trigger_label(strategy_id: int | None, strategy_name: Any = None) -> str:
     """ì „ëµ ID ê¸°ë°˜ trigger label.
     - signals.evaluate_trigger_gate()ê°€ ì´í•´í•˜ëŠ” trigger_nameì„ ë°˜í™˜í•œë‹¤.
     """
-    sid = int(strategy_id or 1)
-    if sid == 5:
+    sid = int(strategy_id or SID_BREAKOUT)
+    if sid == SID_PULLBACK:
         return "pullback_rebound"
-    if sid == 4:
+    if sid == SID_LASTHOUR:
         return "close_betting"
     return "breakout_cross"
 
 
 def strategy_entry_gate(
     strategy_id: int | None,
     info: Dict[str, Any],
     daily_ctx: Dict[str, Any],
     intraday_ctx: Dict[str, Any],
     *,
     now_dt_kst: datetime,
     regime_state: Optional[Dict[str, Any]] = None,
 ) -> Dict[str, Any]:
     """ì „ëµ 1~5 ì§„ì… ê²Œì´íŠ¸.
 
     ë°˜í™˜:
       ok: bool
       reasons: list[str]
       trigger_label: str
       qty_scale: float
       entry_reason: str
     """
-    sid = int(strategy_id or 1)
+    sid = int(strategy_id or SID_BREAKOUT)
     reasons: List[str] = []
 
-    # ì „ëµ5ëŠ” legacy_kosdaq_runnerì—ì„œ ë³„ë„ pullback ì—”ì§„ìœ¼ë¡œ ì²˜ë¦¬.
-    if sid == 5:
+    # ì „ëµ2ëŠ” legacy_kosdaq_runnerì—ì„œ ë³„ë„ pullback ì—”ì§„ìœ¼ë¡œ ì²˜ë¦¬.
+    if sid == SID_PULLBACK:
         return {
             "ok": False,
             "reasons": ["use_pullback_engine"],
             "trigger_label": "pullback_rebound",
             "qty_scale": 0.0,
-            "entry_reason": "S5_PULLBACK_ENGINE",
+            "entry_reason": "S2_PULLBACK_ENGINE",
         }
 
     trigger_label = strategy_trigger_label(sid, info.get("strategy"))
     qty_scale = 1.0
     entry_reason = f"S{sid}"
 
     # ê³µí†µ ì°¸ê³  ê°’
     champion_grade = str(info.get("champion_grade") or "").upper()
     strong_trend = bool(daily_ctx.get("strong_trend"))
     vwap_reclaim = bool(intraday_ctx.get("vwap_reclaim"))
     range_break = bool(intraday_ctx.get("range_break"))
     prev_high_retest = bool(intraday_ctx.get("prev_high_retest"))
     volume_spike = bool(intraday_ctx.get("volume_spike"))
 
     # === ì „ëµë³„ ê·œì¹™ ===
-    if sid == 1:
+    if sid == SID_BREAKOUT:
         # ê¸°ë³¸ ëŒíŒŒ: setup_gate + trigger_gate í†µê³¼ê°€ í•µì‹¬ (ì¶”ê°€ ì œì•½ ì—†ìŒ)
         entry_reason = "S1_BREAKOUT"
 
-    elif sid == 2:
+    elif sid == SID_PULLBACK:
         # ê°•í•œ ëŒíŒŒ(ë²”ìœ„/ì „ê³ ì  ì¬ëŒíŒŒ ì¤‘ í•˜ë‚˜ëŠ” í•„ìˆ˜)
         if not (range_break or prev_high_retest):
             reasons.append("need_range_or_prevhigh_retest")
         entry_reason = "S2_RANGE_BREAK"
 
-    elif sid == 3:
-        # VWAP ë¦¬í´ë ˆì„(ìƒìŠ¹ ì „í™˜) í•„ìˆ˜
-        if not vwap_reclaim:
-            reasons.append("need_vwap_reclaim")
-        entry_reason = "S3_VWAP_RECLAIM"
-
-    elif sid == 4:
+    elif sid == SID_LASTHOUR:
         # ì¢…ê°€ë² íŒ…: ì‹œê°„ ì¡°ê±´ + ìµœì†Œ ëª¨ë©˜í…€ + (ê¸°ë³¸) ì±”í”¼ì–¸ ë“±ê¸‰
         start = _parse_hhmm(os.getenv("CLOSE_BETTING_START", "14:30"), time(14, 30))
         end = _parse_hhmm(os.getenv("CLOSE_BETTING_END", "15:10"), time(15, 10))
         if not (start <= now_dt_kst.time() <= end):
             reasons.append(f"time_window({start.strftime('%H:%M')}-{end.strftime('%H:%M')})")
 
         require_grade = os.getenv("CLOSE_BETTING_REQUIRE_GRADE", "AB").upper()
         if require_grade and champion_grade:
             if require_grade == "A" and champion_grade != "A":
                 reasons.append("need_champion_A")
             elif require_grade == "AB" and champion_grade not in ("A", "B"):
                 reasons.append("need_champion_A_or_B")
         elif require_grade and not champion_grade:
             # gradeê°€ ì—†ìœ¼ë©´ ì•ˆì „í•˜ê²Œ ì°¨ë‹¨(ë¦¬ë°¸ëŸ°ì‹± ì‘ë‹µ/ê°€ê³µ ëˆ„ë½ ê°ì§€)
             reasons.append("missing_champion_grade")
 
         # ìµœì†Œ ëª¨ë©˜í…€: strong_trend ë˜ëŠ” (vwap_reclaim/ë²”ìœ„ëŒíŒŒ/ê±°ë˜ëŸ‰ìŠ¤íŒŒì´í¬)
         if not (strong_trend or vwap_reclaim or range_break or volume_spike):
             reasons.append("need_momentum_confirm")
 
         # ë¦¬ìŠ¤í¬ ì¶•ì†Œ(ê¸°ë³¸ 0.5)
         try:
             qty_scale = float(os.getenv("CLOSE_BETTING_QTY_SCALE", "0.5"))
         except Exception:
             qty_scale = 0.5
         qty_scale = max(0.1, min(qty_scale, 1.0))
-        entry_reason = "S4_CLOSE_BETTING"
+        entry_reason = "S3_LAST_HOUR"
+
+    elif sid == SID_SWING:
+        entry_reason = "S5_SWING"
 
     else:
         # ì•Œ ìˆ˜ ì—†ëŠ” IDëŠ” ì „ëµ1ë¡œ ì•ˆì „ ì²˜ë¦¬
         entry_reason = "S1_BREAKOUT"
 
     ok = len(reasons) == 0
     return {
         "ok": ok,
         "reasons": reasons,
         "trigger_label": trigger_label,
         "qty_scale": qty_scale,
         "entry_reason": entry_reason,
     }
