diff --git a/.github/workflows/trade-runner.yml b/.github/workflows/trade-runner.yml
index 81b05fb5b0d90f6a0b8f90075182b5c0c760851d..cae7b384ed586daa7314e11e7525997b37a39f05 100644
--- a/.github/workflows/trade-runner.yml
+++ b/.github/workflows/trade-runner.yml
@@ -1,115 +1,105 @@
 name: PB1 Trade Runner
 
 permissions:
   contents: write
 
 concurrency:
   group: trade-bot-state
   cancel-in-progress: false
 
 on:
   push:
-    branches: [ main, nullim ]
+    branches: [ main, nullim, trader_r1 ]
     paths-ignore:
       - "bot_state/**"
   workflow_dispatch:
   schedule:
-    # ⏰ UTC cron (KST = UTC+9)
-    - cron: "50-59/5 23 * * *"   # 08:50-08:59 KST
-    - cron: "*/5 0-1 * * *"       # 09:00-10:59 KST
-    - cron: "0 2 * * *"           # 11:00 KST boundary
-    - cron: "*/5 5 * * *"         # 14:00-14:59 KST
-    - cron: "0-30/5 6 * * *"      # 15:00-15:30 KST
+    # =========================
+    # Weekdays (KST Mon-Fri) : run only during market hours (08:50~15:30 KST), every 5 min
+    # KST 08:50~08:55  => UTC 23:50~23:55 (previous UTC day)  [Sun~Thu UTC]
+    - cron: "50-59/5 23 * * 0-4"
+    # KST 09:00~14:55  => UTC 00:00~05:55 (same UTC day)      [Mon~Fri UTC]
+    - cron: "*/5 0-5 * * 1-5"
+    # KST 15:00~15:30  => UTC 06:00~06:30 (same UTC day)      [Mon~Fri UTC]
+    - cron: "0-30/5 6 * * 1-5"
+
+    # =========================
+    # Weekend (KST Sat-Sun) : DIAG every 5 min for the entire weekend day (00:00~23:55 KST)
+    # KST Sat 00:00~08:55 => UTC Fri 15:00~23:55
+    - cron: "*/5 15-23 * * 5"
+    # KST Sat 09:00~Sun 08:55 => UTC Sat 00:00~23:55 (covers full UTC Saturday)
+    - cron: "*/5 * * * 6"
+    # KST Sun 09:00~23:55 => UTC Sun 00:00~14:55
+    - cron: "*/5 0-14 * * 0"
 
 jobs:
   run-trade:
     if: github.ref != 'refs/heads/bot-state' && github.event_name != 'pull_request'
     runs-on: ubuntu-latest
     # Note: cancel-in-progress=false relies on lock file; timeout increased to allow pre-open waits.
-    timeout-minutes: 180
+    timeout-minutes: 360
     env:
       BOTSTATE_BRANCH: bot-state
+      BOTSTATE_WORKTREE_DIR: "_botstate"
       STRATEGY_MODE: "LIVE"
       LIVE_TRADING_ENABLED: "1"
       DISABLE_LIVE_TRADING: "0"
       DRY_RUN: "0"
       EXPECT_LIVE_TRADING: "1"
       EXPECT_KIS_ENV: "practice"
       PB1_ENTRY_ENABLED: "1"
       KIS_ENV: "practice"
       API_BASE_URL: "https://openapivts.koreainvestment.com:29443"
       KIS_APP_KEY: ${{ secrets.KIS_APP_KEY != '' && secrets.KIS_APP_KEY || secrets.APP_KEY }}
       KIS_APP_SECRET: ${{ secrets.KIS_APP_SECRET != '' && secrets.KIS_APP_SECRET || secrets.APP_SECRET }}
       APP_KEY: ${{ secrets.KIS_APP_KEY != '' && secrets.KIS_APP_KEY || secrets.APP_KEY }}
       APP_SECRET: ${{ secrets.KIS_APP_SECRET != '' && secrets.KIS_APP_SECRET || secrets.APP_SECRET }}
       CANO: ${{ secrets.CANO }}
       ACNT_PRDT_CD: ${{ secrets.ACNT_PRDT_CD }}
       STATE_RECONCILE_APPLY: "1"
       MORNING_WINDOW_START: "08:50"
       MORNING_WINDOW_END: "11:00"
       MORNING_EXIT_START: "09:00"
       MORNING_EXIT_END: "09:20"
       AFTERNOON_WINDOW_START: "14:00"
       AFTERNOON_WINDOW_END: "15:30"
       CLOSE_AUCTION_START: "15:20"
       CLOSE_AUCTION_END: "15:30"
+      MARKET_OPEN_HHMM: "08:50"
+      MARKET_CLOSE_HHMM: "15:30"
+      PB1_WAIT_FOR_WINDOW: "1"
+      PB1_MAX_WAIT_FOR_WINDOW_MIN: "240"
       LEDGER_BASE_DIR: "bot_state/trader_ledger"
       LEDGER_LOOKBACK_DAYS: "120"
       BOTSTATE_LOCK_TTL_SEC: "1800"
       PYTHONUNBUFFERED: "1"
-      MAX_WAIT_BEFORE_MORNING_MIN: "120"
     steps:
       - uses: actions/checkout@v4
         with:
           fetch-depth: 0
           persist-credentials: true
           token: ${{ secrets.GITHUB_TOKEN }}
 
       - name: Set git identity
         run: |
           git config user.name "trade-bot"
           git config user.email "trade-bot@users.noreply.github.com"
 
       - uses: actions/setup-python@v5
         with:
           python-version: "3.11"
 
       - name: Install dependencies
         run: |
           python -m pip install --upgrade pip
           pip install -r requirements.txt
 
-      - name: Resolve trading day and safety flags
-        env:
-          PYTHONPATH: ${{ github.workspace }}
-        run: |
-          python - <<'PY'
-          import os
-          from trader.time_utils import is_trading_day, now_kst
-
-          today_trading = is_trading_day(now_kst())
-          kis_env = os.environ.get("KIS_ENV", "")
-          reconcile_apply = "1" if kis_env == "practice" else "0"
-          with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as f:
-              if today_trading:
-                  f.write("PB1_ENTRY_ENABLED=1\n")
-                  f.write("DISABLE_LIVE_TRADING=0\n")
-                  f.write("DRY_RUN=0\n")
-              else:
-                  f.write("PB1_ENTRY_ENABLED=0\n")
-                  f.write("DISABLE_LIVE_TRADING=1\n")
-                  f.write("DRY_RUN=1\n")
-                  f.write("DIAGNOSTIC_FORCE_RUN=1\n")
-              f.write(f"STATE_RECONCILE_APPLY={reconcile_apply}\n")
-          print(f"trading_day={today_trading}")
-          PY
-
       - name: Compile modules
         run: |
           python -m compileall trader
 
       - name: Run PB1 only
         env:
           PYTHONPATH: ${{ github.workspace }}
         run: |
           python -m trader.pb1_runner --window auto --phase auto --target-branch ${BOTSTATE_BRANCH}
diff --git a/tests/test_pb1_runner_wait.py b/tests/test_pb1_runner_wait.py
new file mode 100644
index 0000000000000000000000000000000000000000..9a41d6809c9b0ef7ad8c219eecd7a3909a2d11f2
--- /dev/null
+++ b/tests/test_pb1_runner_wait.py
@@ -0,0 +1,106 @@
+from datetime import datetime
+from zoneinfo import ZoneInfo
+from types import SimpleNamespace
+
+import trader.pb1_runner as pb1_runner
+from trader.pb1_runner import _next_window_start, _parse_hhmm_to_time
+
+
+def test_next_window_start_returns_next_in_day() -> None:
+    now = datetime(2024, 1, 2, 8, 30, tzinfo=ZoneInfo("Asia/Seoul"))
+    starts = [_parse_hhmm_to_time("08:50"), _parse_hhmm_to_time("14:00"), _parse_hhmm_to_time("15:20")]
+
+    target = _next_window_start(now, starts)
+
+    assert target is not None
+    assert target.hour == 8 and target.minute == 50
+    assert target.tzinfo == now.tzinfo
+
+
+def test_next_window_start_none_when_past_all_windows() -> None:
+    now = datetime(2024, 1, 2, 16, 5, tzinfo=ZoneInfo("Asia/Seoul"))
+    starts = [_parse_hhmm_to_time("08:50"), _parse_hhmm_to_time("14:00"), _parse_hhmm_to_time("15:20")]
+
+    target = _next_window_start(now, starts)
+
+    assert target is None
+
+
+def test_wait_branch_does_not_crash(monkeypatch) -> None:
+    # Arrange times to enter wait then proceed
+    times = [
+        datetime(2024, 1, 2, 8, 40, tzinfo=ZoneInfo("Asia/Seoul")),
+        datetime(2024, 1, 2, 8, 45, tzinfo=ZoneInfo("Asia/Seoul")),
+        datetime(2024, 1, 2, 8, 50, tzinfo=ZoneInfo("Asia/Seoul")),
+    ]
+
+    def fake_now():
+        return times.pop(0) if times else datetime(2024, 1, 2, 8, 50, tzinfo=ZoneInfo("Asia/Seoul"))
+
+    monkeypatch.setattr(pb1_runner, "now_kst", fake_now)
+    monkeypatch.setenv("GITHUB_EVENT_NAME", "push")
+    monkeypatch.setenv("STRATEGY_MODE", "LIVE")
+    monkeypatch.delenv("EXPECT_LIVE_TRADING", raising=False)
+    monkeypatch.setattr(pb1_runner, "acquire_lock", lambda *_, **__: False)
+    monkeypatch.setattr(pb1_runner, "KisAPI", lambda *_, **__: SimpleNamespace(env="practice", get_balance=lambda: {}))
+    monkeypatch.setattr(
+        pb1_runner,
+        "parse_args",
+        lambda: SimpleNamespace(window="auto", phase="auto", target_branch="bot-state"),
+    )
+
+    slept = []
+
+    def fake_sleep(seconds):
+        slept.append(seconds)
+
+    monkeypatch.setattr(pb1_runner.time_mod, "sleep", fake_sleep)
+    monkeypatch.setattr(pb1_runner, "setup_worktree", lambda *_, **__: None)
+    monkeypatch.setattr(pb1_runner, "resolve_botstate_worktree_dir", lambda: pb1_runner.Path("/tmp"))
+    monkeypatch.setattr(pb1_runner, "is_trading_day", lambda _: True)
+
+    # Act / Assert: should exit cleanly without raising
+    pb1_runner.main()
+    assert slept, "wait path should invoke sleep"
+
+
+def test_expect_live_guard_skipped_in_diag(monkeypatch) -> None:
+    now = datetime(2024, 1, 2, 16, 10, tzinfo=ZoneInfo("Asia/Seoul"))
+    monkeypatch.setattr(pb1_runner, "now_kst", lambda: now)
+    monkeypatch.setenv("GITHUB_EVENT_NAME", "workflow_dispatch")
+    monkeypatch.setenv("STRATEGY_MODE", "LIVE")
+    monkeypatch.setenv("EXPECT_LIVE_TRADING", "1")
+    monkeypatch.setenv("KIS_ENV", "practice")
+    monkeypatch.setenv("API_BASE_URL", "https://openapivts.koreainvestment.com:29443")
+    monkeypatch.setattr(pb1_runner, "acquire_lock", lambda *_, **__: False)
+    monkeypatch.setattr(pb1_runner, "setup_worktree", lambda *_, **__: None)
+    monkeypatch.setattr(pb1_runner, "resolve_botstate_worktree_dir", lambda: pb1_runner.Path("/tmp"))
+    monkeypatch.setattr(
+        pb1_runner,
+        "parse_args",
+        lambda: SimpleNamespace(window="auto", phase="auto", target_branch="bot-state"),
+    )
+
+    pb1_runner.main()  # should not raise even with EXPECT_LIVE_TRADING=1 in diag path
+
+
+def test_schedule_event_does_not_wait(monkeypatch) -> None:
+    now = datetime(2024, 1, 2, 8, 30, tzinfo=ZoneInfo("Asia/Seoul"))
+    monkeypatch.setattr(pb1_runner, "now_kst", lambda: now)
+    monkeypatch.setenv("GITHUB_EVENT_NAME", "schedule")
+    monkeypatch.setenv("STRATEGY_MODE", "LIVE")
+    monkeypatch.setattr(pb1_runner, "acquire_lock", lambda *_, **__: False)
+    monkeypatch.setattr(pb1_runner, "setup_worktree", lambda *_, **__: None)
+    monkeypatch.setattr(pb1_runner, "resolve_botstate_worktree_dir", lambda: pb1_runner.Path("/tmp"))
+    monkeypatch.setattr(
+        pb1_runner,
+        "parse_args",
+        lambda: SimpleNamespace(window="auto", phase="auto", target_branch="bot-state"),
+    )
+
+    def sleep_fail(_):
+        raise AssertionError("schedule run should not sleep")
+
+    monkeypatch.setattr(pb1_runner.time_mod, "sleep", sleep_fail)
+
+    pb1_runner.main()
diff --git a/trader/config.py b/trader/config.py
index 58ab7201fcb9da3117a1b0dcbdb867f4d321c75f..5ff2f98a6196a3b7c536c4ae25d22c39f53fafc1 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -110,50 +110,54 @@ CONFIG = {
     "STRATEGY_MAX_OPEN_INTENTS": "20",
     "STRATEGY_MAX_POSITION_PCT": "0.10",
     "STRATEGY_ALLOW_SELL_ONLY": "false",
     "STRATEGY_WEIGHTS": "",
     "DISABLE_KOSDAQ_LOOP": "false",
     "DISABLE_KOSPI_ENGINE": "false",
     "ACTIVE_STRATEGIES": "1",  # CSV of strategy IDs eligible for managed exits/entries
     "ALLOW_ADOPT_UNMANAGED": "false",
     "STATE_PATH": "trader/state/state.json",
     # PB1 close-pullback defaults
     "ENABLE_BREAKOUT": "false",
     "LEDGER_LOOKBACK_DAYS": "120",
     "BOTSTATE_LOCK_TTL_SEC": "1800",
     "LEDGER_BASE_DIR": "bot_state/trader_ledger",
     "PB1_ENTRY_ENABLED": "true",
     "MORNING_WINDOW_START": "08:50",
     "MORNING_WINDOW_END": "11:00",
     "MORNING_EXIT_START": "09:00",
     "MORNING_EXIT_END": "09:20",
     "AFTERNOON_WINDOW_START": "14:00",
     "AFTERNOON_WINDOW_END": "15:30",
     "CLOSE_AUCTION_START": "15:20",
     "CLOSE_AUCTION_END": "15:30",
     "PB1_REQUIRE_VOLUME": "0",
     "PB1_FORCE_ENTRY_ON_PUSH": "1",
+    "PB1_WAIT_FOR_WINDOW": "1",
+    "PB1_MAX_WAIT_FOR_WINDOW_MIN": "240",
+    "MARKET_OPEN_HHMM": "08:50",
+    "MARKET_CLOSE_HHMM": "15:30",
     "PB1_PULLBACK_BAND_KOSPI": "3,8",
     "PB1_PULLBACK_BAND_KOSDAQ": "4,10",
     "PB1_VOL_CONTRACTION_MAX": "0.80",
     "PB1_VOLU_CONTRACTION_MAX": "0.75",
     "PB1_SWING_TREND_MIN": "1.05",
     "PB1_SWING_VOL_CONTRACTION_MAX": "0.80",
     "PB1_SWING_VOLU_CONTRACTION_MAX": "0.75",
     "PB1_R_FLOOR_PCT": "2.0",
     "PB1_DAY_TP_R": "0.8",
     "PB1_DAY_SL_R": "0.6",
     "KOSPI_HARD_STOP_PCT": "7.0",
     "KOSDAQ_HARD_STOP_PCT": "8.0",
     "PB1_SWING_TRAIL_MA": "20",
     "PB1_TIME_STOP_DAYS": "10",
 }
 
 
 def _cfg(key: str) -> str:
     """환경변수 > CONFIG 기본값"""
     return os.getenv(key, CONFIG.get(key, ""))
 
 
 def _default_bool(key: str, fallback: bool = False) -> bool:
     raw_default = str(CONFIG.get(key, "")).strip().lower()
     if raw_default in TRUE_VALUES:
@@ -409,46 +413,50 @@ def _parse_hhmm(hhmm: str) -> dtime:
     except Exception:
         logger.warning(f"[설정경고] SELL_FORCE_TIME 형식 오류 → 기본값 14:40 적용: {hhmm}")
         return dtime(hour=14, minute=40)
 
 
 SELL_FORCE_TIME = _parse_hhmm(SELL_FORCE_TIME_STR)
 TIME_STOP_TIME = _parse_hhmm(TIME_STOP_HHMM)
 ALLOW_WHEN_CLOSED = _cfg_bool("MARKET_DATA_WHEN_CLOSED")
 DISABLE_KOSDAQ_LOOP = _cfg_bool("DISABLE_KOSDAQ_LOOP")
 DISABLE_KOSPI_ENGINE = _cfg_bool("DISABLE_KOSPI_ENGINE")
 ENABLE_BREAKOUT = _cfg_bool("ENABLE_BREAKOUT")
 PB1_ENTRY_ENABLED = _cfg_bool("PB1_ENTRY_ENABLED", fallback=True)
 LEDGER_LOOKBACK_DAYS = int(_cfg("LEDGER_LOOKBACK_DAYS") or "120")
 BOTSTATE_LOCK_TTL_SEC = int(_cfg("BOTSTATE_LOCK_TTL_SEC") or "900")
 LEDGER_BASE_DIR = Path(_cfg("LEDGER_BASE_DIR") or "bot_state/trader_ledger")
 MORNING_WINDOW_START = _cfg("MORNING_WINDOW_START") or "08:50"
 MORNING_WINDOW_END = _cfg("MORNING_WINDOW_END") or "11:00"
 MORNING_EXIT_START = _cfg("MORNING_EXIT_START") or "09:00"
 MORNING_EXIT_END = _cfg("MORNING_EXIT_END") or "09:20"
 AFTERNOON_WINDOW_START = _cfg("AFTERNOON_WINDOW_START") or "14:00"
 AFTERNOON_WINDOW_END = _cfg("AFTERNOON_WINDOW_END") or "15:30"
 CLOSE_AUCTION_START = _cfg("CLOSE_AUCTION_START") or "15:20"
 CLOSE_AUCTION_END = _cfg("CLOSE_AUCTION_END") or "15:30"
 PB1_REQUIRE_VOLUME = _cfg_bool("PB1_REQUIRE_VOLUME", fallback=False)
 PB1_FORCE_ENTRY_ON_PUSH = _cfg_bool("PB1_FORCE_ENTRY_ON_PUSH", fallback=True)
+PB1_WAIT_FOR_WINDOW = _cfg_bool("PB1_WAIT_FOR_WINDOW", fallback=True)
+PB1_MAX_WAIT_FOR_WINDOW_MIN = int(_cfg("PB1_MAX_WAIT_FOR_WINDOW_MIN") or "240")
+MARKET_OPEN_HHMM = _cfg("MARKET_OPEN_HHMM") or "08:50"
+MARKET_CLOSE_HHMM = _cfg("MARKET_CLOSE_HHMM") or "15:30"
 PB1_PULLBACK_BAND_KOSPI = tuple(float(x.strip()) for x in (_cfg("PB1_PULLBACK_BAND_KOSPI") or "3,8").split(","))
 PB1_PULLBACK_BAND_KOSDAQ = tuple(float(x.strip()) for x in (_cfg("PB1_PULLBACK_BAND_KOSDAQ") or "4,10").split(","))
 PB1_VOL_CONTRACTION_MAX = float(_cfg("PB1_VOL_CONTRACTION_MAX") or "0.80")
 PB1_VOLU_CONTRACTION_MAX = float(_cfg("PB1_VOLU_CONTRACTION_MAX") or "0.75")
 PB1_SWING_TREND_MIN = float(_cfg("PB1_SWING_TREND_MIN") or "1.05")
 PB1_SWING_VOL_CONTRACTION_MAX = float(_cfg("PB1_SWING_VOL_CONTRACTION_MAX") or "0.80")
 PB1_SWING_VOLU_CONTRACTION_MAX = float(_cfg("PB1_SWING_VOLU_CONTRACTION_MAX") or "0.75")
 PB1_R_FLOOR_PCT = float(_cfg("PB1_R_FLOOR_PCT") or "2.0")
 PB1_DAY_TP_R = float(_cfg("PB1_DAY_TP_R") or "0.8")
 PB1_DAY_SL_R = float(_cfg("PB1_DAY_SL_R") or "0.6")
 KOSPI_HARD_STOP_PCT = float(_cfg("KOSPI_HARD_STOP_PCT") or "7.0")
 KOSDAQ_HARD_STOP_PCT = float(_cfg("KOSDAQ_HARD_STOP_PCT") or "8.0")
 PB1_SWING_TRAIL_MA = int(_cfg("PB1_SWING_TRAIL_MA") or "20")
 PB1_TIME_STOP_DAYS = int(_cfg("PB1_TIME_STOP_DAYS") or "10")
 
 # === [NEW] 주간 리밸런싱 강제 트리거 상태 파일 ===
 STATE_WEEKLY_PATH = Path(__file__).parent / "state_weekly.json"
 
 def _this_iso_week_key(now=None):
     now = now or datetime.now(KST)
     return f"{now.year}-W{now.isocalendar().week:02d}"
diff --git a/trader/pb1_runner.py b/trader/pb1_runner.py
index 321da9d529d8449ea3af5983fbc87a317450336f..e9351d8bcf8b41678b17bc00040a2ec3ac4d9371 100644
--- a/trader/pb1_runner.py
+++ b/trader/pb1_runner.py
@@ -1,280 +1,382 @@
 from __future__ import annotations
 
 import argparse
 import logging
 import os
-import time
-from datetime import datetime, timedelta
+import time as time_mod
+from datetime import datetime, time as dtime
 from pathlib import Path
 
 from trader.kis_wrapper import KisAPI
 from trader.time_utils import is_trading_day, now_kst
 from trader.config import (
     BOTSTATE_LOCK_TTL_SEC,
     DIAGNOSTIC_MODE,
     DIAGNOSTIC_ONLY,
     MORNING_WINDOW_START,
     MORNING_WINDOW_END,
     MORNING_EXIT_START,
     MORNING_EXIT_END,
     AFTERNOON_WINDOW_START,
     AFTERNOON_WINDOW_END,
     CLOSE_AUCTION_START,
     CLOSE_AUCTION_END,
     PB1_FORCE_ENTRY_ON_PUSH,
+    PB1_WAIT_FOR_WINDOW,
+    PB1_MAX_WAIT_FOR_WINDOW_MIN,
+    MARKET_OPEN_HHMM,
+    MARKET_CLOSE_HHMM,
 )
 from trader.utils.env import env_bool, parse_env_flag, resolve_mode
 from trader.botstate_sync import (
     acquire_lock,
     release_lock,
     setup_worktree,
     persist_run_files,
     resolve_botstate_worktree_dir,
 )
 from trader.pb1_engine import PB1Engine
-from trader.window_router import decide_window
+from trader.window_router import WindowDecision, decide_window
 
 logger = logging.getLogger(__name__)
 
 
 def truthy(value: object) -> bool:
     return str(value).strip().lower() in {"1", "true", "yes", "y", "on"}
 
 
+def _parse_hhmm_to_time(hhmm: str) -> time:
+    hh, mm = hhmm.split(":")
+    return dtime(hour=int(hh), minute=int(mm))
+
+
+def _next_window_start(now: datetime, window_starts: list[dtime]) -> datetime | None:
+    sorted_starts = sorted(window_starts)
+    for start in sorted_starts:
+        if now.time() < start:
+            return now.replace(hour=start.hour, minute=start.minute, second=0, microsecond=0)
+    return None
+
+
+def _market_session(now: datetime) -> tuple[datetime, datetime]:
+    open_t = _parse_hhmm_to_time(MARKET_OPEN_HHMM)
+    close_t = _parse_hhmm_to_time(MARKET_CLOSE_HHMM)
+    return (
+        now.replace(hour=open_t.hour, minute=open_t.minute, second=0, microsecond=0),
+        now.replace(hour=close_t.hour, minute=close_t.minute, second=0, microsecond=0),
+    )
+
+
 def parse_args() -> argparse.Namespace:
     parser = argparse.ArgumentParser(description="PB1 close pullback runner")
     parser.add_argument("--window", default="auto", choices=["auto", "morning", "afternoon"], help="Execution window override")
     parser.add_argument("--phase", default="auto", choices=["auto", "entry", "exit", "verify"], help="Phase override")
     parser.add_argument("--target-branch", default=os.getenv("BOTSTATE_BRANCH", "bot-state"), help="Bot-state target branch")
     return parser.parse_args()
 
 
 def main() -> None:
     args = parse_args()
     now = now_kst()
     event_name = os.getenv("GITHUB_EVENT_NAME", "") or ""
     event_name_lower = event_name.lower()
     trading_day = is_trading_day(now)
     non_trading_day = not trading_day
+    diag_env_flag = (
+        env_bool("DIAGNOSTIC_FORCE_RUN", False)
+        or env_bool("DIAGNOSTIC_ONLY", DIAGNOSTIC_ONLY)
+        or env_bool("DIAGNOSTIC_MODE", DIAGNOSTIC_MODE)
+    )
+    _, market_close_dt = _market_session(now)
+    market_close_time = market_close_dt.time()
+    wait_enabled = env_bool("PB1_WAIT_FOR_WINDOW", PB1_WAIT_FOR_WINDOW)
+    if event_name_lower == "schedule":
+        wait_enabled = False
+    max_wait_s = int(PB1_MAX_WAIT_FOR_WINDOW_MIN) * 60
+    window = decide_window(now=now, override=args.window)
+    window_name_for_log = window.name if window else "none"
+    phase_for_log = window.phase if window and hasattr(window, "phase") else "none"
+    target_start = None
+
+    os.environ.setdefault("MORNING_WINDOW_START", MORNING_WINDOW_START)
+    os.environ.setdefault("MORNING_WINDOW_END", MORNING_WINDOW_END)
+    os.environ.setdefault("MORNING_EXIT_START", MORNING_EXIT_START)
+    os.environ.setdefault("MORNING_EXIT_END", MORNING_EXIT_END)
+    os.environ.setdefault("AFTERNOON_WINDOW_START", AFTERNOON_WINDOW_START)
+    os.environ.setdefault("AFTERNOON_WINDOW_END", AFTERNOON_WINDOW_END)
+    os.environ.setdefault("CLOSE_AUCTION_START", CLOSE_AUCTION_START)
+    os.environ.setdefault("CLOSE_AUCTION_END", CLOSE_AUCTION_END)
+
+    worktree_dir = resolve_botstate_worktree_dir()
+    setup_worktree(Path.cwd(), worktree_dir, target_branch=args.target_branch)
+
+    force_diag = diag_env_flag or not trading_day or now.time() >= market_close_time
+    if not force_diag and window is None and trading_day and now.time() < market_close_time:
+        window_starts = [
+            _parse_hhmm_to_time(MORNING_WINDOW_START),
+            _parse_hhmm_to_time(AFTERNOON_WINDOW_START),
+            _parse_hhmm_to_time(CLOSE_AUCTION_START),
+        ]
+        target_start = _next_window_start(now, window_starts)
+        if target_start is None:
+            force_diag = True
+        elif not wait_enabled:
+            logger.info(
+                "[PB1][RUN-PLAN] event=%s now_kst=%s trading_day=%s action=skip target_start=%s max_wait_s=%s window=%s phase=%s",
+                event_name_lower or "unknown",
+                now.isoformat(),
+                trading_day,
+                target_start.isoformat(),
+                max_wait_s,
+                window_name_for_log,
+                phase_for_log,
+            )
+            return
+        else:
+            wait_seconds = int((target_start - now).total_seconds())
+            if wait_seconds > max_wait_s:
+                logger.info(
+                    "[PB1][RUN-PLAN] event=%s now_kst=%s trading_day=%s action=skip target_start=%s max_wait_s=%s window=%s phase=%s",
+                    event_name_lower or "unknown",
+                    now.isoformat(),
+                    trading_day,
+                    target_start.isoformat(),
+                    max_wait_s,
+                    window_name_for_log,
+                    phase_for_log,
+                )
+                return
+
+    plan_window_name = window_name_for_log
+    plan_phase_for_log = phase_for_log
+    if force_diag and window is None:
+        plan_window_name = "diagnostic"
+        plan_phase_for_log = "verify"
+
+    action = "diag" if force_diag else "run" if window else "wait"
+    logger.info(
+        "[PB1][RUN-PLAN] event=%s now_kst=%s trading_day=%s action=%s target_start=%s max_wait_s=%s window=%s phase=%s",
+        event_name_lower or "unknown",
+        now.isoformat(),
+        trading_day,
+        action,
+        target_start.isoformat() if target_start else "none",
+        max_wait_s,
+        plan_window_name,
+        plan_phase_for_log,
+    )
+
+    if action == "wait" and target_start:
+        while True:
+            now = now_kst()
+            remaining = (target_start - now).total_seconds()
+            if remaining <= 0:
+                break
+            if remaining > max_wait_s:
+                logger.info(
+                    "[PB1][RUN-PLAN] action=skip reason=wait_exceeds_max target_start=%s remaining_s=%.0f max_wait_s=%s",
+                    target_start.isoformat(),
+                    remaining,
+                    max_wait_s,
+                )
+                return
+            sleep_for = min(30, remaining)
+            logger.info("[PB1][WAIT] until=%s remaining_s=%.0f sleep=%.0f", target_start.isoformat(), remaining, sleep_for)
+            time_mod.sleep(sleep_for)
+        now = now_kst()
+        trading_day = is_trading_day(now)
+        non_trading_day = not trading_day
+        force_diag = diag_env_flag or not trading_day or now.time() >= market_close_time
+        window = decide_window(now=now, override=args.window)
+        window_name_for_log = window.name if window else "none"
+        phase_for_log = window.phase if window and hasattr(window, "phase") else "none"
+        if window is None and not force_diag:
+            logger.info("[PB1][WINDOW] outside active windows override=%s now=%s", args.window, now)
+            return
+        action = "diag" if force_diag else "run"
+
     dry_run_flag = parse_env_flag("DRY_RUN", default=False)
     disable_live_flag = parse_env_flag("DISABLE_LIVE_TRADING", default=False)
     live_trading_flag = parse_env_flag("LIVE_TRADING_ENABLED", default=False)
     expect_live_flag = env_bool("EXPECT_LIVE_TRADING", False)
     mode = resolve_mode(os.getenv("STRATEGY_MODE", ""))
     dry_run_reasons: list[str] = []
     if non_trading_day:
         dry_run_reasons.append("non_trading_day")
         os.environ["PB1_ENTRY_ENABLED"] = "0"
         os.environ["DIAGNOSTIC_FORCE_RUN"] = "1"
         os.environ["DISABLE_LIVE_TRADING"] = "1"
         os.environ["DRY_RUN"] = "1"
         os.environ["LIVE_TRADING_ENABLED"] = "0"
-    diag_enabled = (
-        env_bool("DIAGNOSTIC_FORCE_RUN", False)
-        or env_bool("DIAGNOSTIC_ONLY", DIAGNOSTIC_ONLY)
-        or env_bool("DIAGNOSTIC_MODE", DIAGNOSTIC_MODE)
-    )
+    diag_enabled = force_diag or diag_env_flag
+    if force_diag and not non_trading_day and now.time() >= market_close_time:
+        dry_run_reasons.append("market_closed")
     if diag_enabled:
         dry_run_reasons.append("diagnostic_mode")
     if mode == "INTENT_ONLY":
         dry_run_reasons.append("STRATEGY_MODE=INTENT_ONLY")
     if parse_env_flag("DISABLE_LIVE_TRADING", default=disable_live_flag.value).value:
         dry_run_reasons.append("DISABLE_LIVE_TRADING=1")
     live_trading_flag = parse_env_flag("LIVE_TRADING_ENABLED", default=live_trading_flag.value)
     disable_live_flag = parse_env_flag("DISABLE_LIVE_TRADING", default=disable_live_flag.value)
     dry_run_flag = parse_env_flag("DRY_RUN", default=dry_run_flag.value)
     if not live_trading_flag.value and mode == "LIVE":
         dry_run_reasons.append("LIVE_TRADING_ENABLED=0")
     if dry_run_flag.value:
         dry_run_reasons.append("DRY_RUN=1")
     for flag in (dry_run_flag, disable_live_flag, live_trading_flag):
         if not flag.valid:
             dry_run_reasons.append(f"{flag.name}=invalid({flag.raw})")
 
     dry_run = bool(dry_run_reasons)
     dry_run_reason = ",".join(dry_run_reasons) if dry_run_reasons else "live"
 
     logger.info(
         "[PB1][DRY_RUN_RESOLVE] event=%s dry_run=%s reasons=%s",
         event_name_lower or "unknown",
         dry_run,
         dry_run_reasons or ["live"],
     )
 
     expect_kis_env = os.getenv("EXPECT_KIS_ENV")
     kis_env_raw = (os.getenv("KIS_ENV") or "").strip()
     kis_env = kis_env_raw.lower()
     api_base_url = (os.getenv("API_BASE_URL") or "").lower()
-    guard_live = expect_live_flag and trading_day and not diag_enabled and not dry_run
+    guard_live = expect_live_flag and not diag_enabled and trading_day and not dry_run
     if guard_live:
         guard_failures: list[str] = []
         if dry_run:
             guard_failures.append("dry_run")
         if not live_trading_flag.value or not live_trading_flag.valid:
             guard_failures.append("LIVE_TRADING_ENABLED!=1")
         if disable_live_flag.value or not disable_live_flag.valid:
             guard_failures.append("DISABLE_LIVE_TRADING!=0")
         if mode != "LIVE":
             guard_failures.append("STRATEGY_MODE!=LIVE")
         if kis_env != "practice":
             guard_failures.append("KIS_ENV!=practice")
         if "openapivts" not in api_base_url:
             guard_failures.append("API_BASE_URL missing openapivts")
         if expect_kis_env and kis_env_raw != expect_kis_env:
             guard_failures.append("EXPECT_KIS_ENV mismatch")
         if guard_failures:
             raise SystemExit(f"EXPECT_LIVE_TRADING=1 guards failed: {guard_failures}")
 
     def _apply_env_flags(dry: bool) -> None:
         os.environ["DRY_RUN"] = "1" if dry else "0"
         os.environ["DISABLE_LIVE_TRADING"] = "1" if (dry or disable_live_flag.value or non_trading_day) else "0"
         os.environ["LIVE_TRADING_ENABLED"] = "1" if (live_trading_flag.value and not non_trading_day) else "0"
         os.environ["STRATEGY_MODE"] = mode
 
     _apply_env_flags(dry_run)
 
-    def _sleep_until_morning_window() -> bool:
+    phase_override_arg = args.phase
+    if (
+        window
+        and event_name_lower == "push"
+        and phase_override_arg == "auto"
+        and window.name == "afternoon"
+        and env_bool("PB1_FORCE_ENTRY_ON_PUSH", PB1_FORCE_ENTRY_ON_PUSH)
+    ):
         try:
-            hh, mm = MORNING_WINDOW_START.split(":")
-            start_dt = now.replace(hour=int(hh), minute=int(mm), second=0, microsecond=0)
+            start = datetime.fromisoformat(f"{now.date()}T{AFTERNOON_WINDOW_START}")
+            end = datetime.fromisoformat(f"{now.date()}T{AFTERNOON_WINDOW_END}")
+            in_afternoon = start.time() <= now.time() < end.time()
         except Exception:
-            return True
-        delta = start_dt - now
-        if delta.total_seconds() <= 0:
-            return True
-        if not trading_day or event_name_lower not in {"push", "workflow_dispatch"}:
-            return True
-        max_wait_min = int(os.getenv("MAX_WAIT_BEFORE_MORNING_MIN", "120") or "120")
-        if delta > timedelta(minutes=max_wait_min):
-            logger.info("[PB1][WAIT-SKIP] delta_min=%.1f max_wait_min=%s -> exit early", delta.total_seconds() / 60, max_wait_min)
-            return False
-        logger.info("[PB1][WAIT] waiting until morning window start delta_sec=%.0f", delta.total_seconds())
-        time.sleep(delta.total_seconds())
-        return True
-
-    if not _sleep_until_morning_window():
-        return
-    now = now_kst()
+            in_afternoon = False
+        if trading_day and in_afternoon and window.phase == "prep":
+            logger.info("[PB1][PHASE_OVERRIDE] event=push from=prep to=entry reason=PB1_FORCE_ENTRY_ON_PUSH")
+            phase_override_arg = "entry"
 
-    os.environ.setdefault("MORNING_WINDOW_START", MORNING_WINDOW_START)
-    os.environ.setdefault("MORNING_WINDOW_END", MORNING_WINDOW_END)
-    os.environ.setdefault("MORNING_EXIT_START", MORNING_EXIT_START)
-    os.environ.setdefault("MORNING_EXIT_END", MORNING_EXIT_END)
-    os.environ.setdefault("AFTERNOON_WINDOW_START", AFTERNOON_WINDOW_START)
-    os.environ.setdefault("AFTERNOON_WINDOW_END", AFTERNOON_WINDOW_END)
-    os.environ.setdefault("CLOSE_AUCTION_START", CLOSE_AUCTION_START)
-    os.environ.setdefault("CLOSE_AUCTION_END", CLOSE_AUCTION_END)
+    if action == "diag":
+        dry_run = True
+        dry_run_reason = dry_run_reason if dry_run_reason else "diagnostic"
+        dry_run_reasons = dry_run_reasons or ["diagnostic"]
+        diag_enabled = True
+        if args.phase == "auto":
+            phase_override_arg = "verify"
+        window = window or WindowDecision(name="diagnostic", phase=phase_override_arg or "verify")
+        _apply_env_flags(dry_run)
 
-    worktree_dir = resolve_botstate_worktree_dir()
-    setup_worktree(Path.cwd(), worktree_dir, target_branch=args.target_branch)
+    window_name_for_log = window.name if window else "none"
+    phase_for_log = window.phase if window and hasattr(window, "phase") else "none"
+
+    logger.info(
+        "[PB1][RUN-START] event=%s now_kst=%s trading_day=%s window=%s phase=%s DRY_RUN=%s DISABLE_LIVE_TRADING=%s LIVE_TRADING_ENABLED=%s STRATEGY_MODE=%s PB1_ENTRY_ENABLED=%s reasons=%s",
+        event_name_lower or "unknown",
+        now.isoformat(),
+        trading_day,
+        window_name_for_log,
+        phase_for_log,
+        dry_run,
+        os.getenv("DISABLE_LIVE_TRADING"),
+        os.getenv("LIVE_TRADING_ENABLED"),
+        os.getenv("STRATEGY_MODE"),
+        os.getenv("PB1_ENTRY_ENABLED"),
+        dry_run_reasons or ["live"],
+    )
+
+    if non_trading_day:
+        logger.info("[PB1][SKIP] non-trading-day(%s) → diagnostics/dry-run reason=%s", now.date(), dry_run_reason)
+        if diag_enabled:
+            logger.warning("[PB1][DIAG] non-trading-day(%s) but running diagnostics", now.date())
 
     owner = os.getenv("GITHUB_ACTOR", "local")
     run_id = os.getenv("GITHUB_RUN_ID", "local")
     lock_acquired = acquire_lock(worktree_dir, owner=owner, run_id=run_id, ttl_sec=BOTSTATE_LOCK_TTL_SEC)
     if not lock_acquired:
         logger.warning("[BOTSTATE][LOCKED] owner=%s run_id=%s", owner, run_id)
         return
 
     os.environ["STATE_PATH"] = str(worktree_dir / "trader" / "state" / "state.json")
     from trader import state_store as runtime_state_store
     state_dir = Path(os.environ["STATE_PATH"]).parent
     state_dir.mkdir(parents=True, exist_ok=True)
     state_target_path = Path(os.environ["STATE_PATH"])
 
     runtime_state = {}
     kis: KisAPI | None = None
     try:
         runtime_state = runtime_state_store.load_state()
         kis = KisAPI()
         balance = kis.get_balance()
         runtime_state = runtime_state_store.reconcile_with_kis_balance(runtime_state, balance, active_strategies={1})
         runtime_state_store.save_state(runtime_state)
     except Exception:
         logger.exception("[PB1] runtime state reconcile failed")
         runtime_state = runtime_state or runtime_state_store.load_state()
         dry_run_reasons.append("kis_init_failed")
         dry_run_reason = ",".join(dry_run_reasons)
         dry_run = True
         _apply_env_flags(dry_run)
 
     if DIAGNOSTIC_ONLY:
         logger.info("[PB1][DIAG] diagnostic_only mode -> exit")
         release_lock(worktree_dir, run_id=run_id)
         return
 
-    window = decide_window(now=now, override=args.window)
-    if window is None and diag_enabled:
-        window_name_for_log = "diagnostic"
-        phase_for_log = "verify"
-    else:
-        phase_for_log = window.phase if window and hasattr(window, "phase") else "none"
-        window_name_for_log = window.name if window else "none"
-    logger.info(
-        "[PB1][RUN-START] event=%s now_kst=%s trading_day=%s window=%s phase=%s DRY_RUN=%s DISABLE_LIVE_TRADING=%s LIVE_TRADING_ENABLED=%s STRATEGY_MODE=%s PB1_ENTRY_ENABLED=%s reasons=%s",
-        event_name_lower or "unknown",
-        now.isoformat(),
-        trading_day,
-        window_name_for_log,
-        phase_for_log,
-        dry_run,
-        os.getenv("DISABLE_LIVE_TRADING"),
-        os.getenv("LIVE_TRADING_ENABLED"),
-        os.getenv("STRATEGY_MODE"),
-        os.getenv("PB1_ENTRY_ENABLED"),
-        dry_run_reasons or ["live"],
-    )
-    if window is None and not diag_enabled:
-        logger.info("[PB1][WINDOW] outside active windows override=%s now=%s", args.window, now)
-        release_lock(worktree_dir, run_id=run_id)
-        return
-    if window is None and diag_enabled:
-        window = window  # keep None, but allow diagnostic flow below
-
-    if non_trading_day:
-        logger.info("[PB1][SKIP] non-trading-day(%s) → diagnostics/dry-run reason=%s", now.date(), dry_run_reason)
-        if diag_enabled:
-            logger.warning("[PB1][DIAG] non-trading-day(%s) but running diagnostics", now.date())
-
-    phase_override_arg = args.phase
-    if (
-        window
-        and event_name_lower == "push"
-        and phase_override_arg == "auto"
-        and window.name == "afternoon"
-        and env_bool("PB1_FORCE_ENTRY_ON_PUSH", PB1_FORCE_ENTRY_ON_PUSH)
-    ):
-        try:
-            start = datetime.fromisoformat(f"{now.date()}T{AFTERNOON_WINDOW_START}")
-            end = datetime.fromisoformat(f"{now.date()}T{AFTERNOON_WINDOW_END}")
-            in_afternoon = start.time() <= now.time() < end.time()
-        except Exception:
-            in_afternoon = False
-        if trading_day and in_afternoon and window.phase == "prep":
-            logger.info("[PB1][PHASE_OVERRIDE] event=push from=prep to=entry reason=PB1_FORCE_ENTRY_ON_PUSH")
-            phase_override_arg = "entry"
-
     touched: list[Path] = []
     try:
         engine = PB1Engine(
             kis=kis,
             worktree_dir=worktree_dir,
             window=window,
             phase_override=phase_override_arg,
             dry_run=dry_run,
             env="paper" if dry_run else kis.env if kis else "paper",
             run_id=run_id,
         )
         touched = engine.run()
         if state_target_path.exists():
             touched.append(state_target_path)
         logger.info("[PB1] run complete touched=%s", touched)
         persist_run_files(
             worktree_dir,
             touched,
             message=f"pb1 ledger run_id={run_id} window={window.name} phase={engine.phase}",
         )
     finally:
         release_lock(worktree_dir, run_id=run_id)
 
 
 if __name__ == "__main__":
