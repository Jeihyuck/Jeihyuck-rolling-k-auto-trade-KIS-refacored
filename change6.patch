diff --git a/.github/workflows/trade-monitor.yml b/.github/workflows/trade-monitor.yml
index 42646c70c60249f42147af9c5cee00d3faf8f438..9c2474574ced92e5c2a061a27301e2aea60894ca 100644
--- a/.github/workflows/trade-monitor.yml
+++ b/.github/workflows/trade-monitor.yml
@@ -70,55 +70,58 @@ jobs:
       W_MIN_ONE: "0.03"
 
       REBALANCE_ANCHOR: "weekly"
       FORCE_WEEKLY_REBALANCE: "0"
       MOMENTUM_OVERRIDES_FORCE_SELL: "true"
 
       # 레짐/지수
       KOSDAQ_INDEX_CODE: "KOSDAQ"
       KOSDAQ_ETF_FALLBACK: "229200"
 
       REG_BULL_MIN_UP_PCT: "0.5"
       REG_BULL_MIN_MINUTES: "10"
       REG_BEAR_VWAP_MINUTES: "10"
       REG_BEAR_DROP_FROM_HIGH: "0.7"
       REG_BEAR_STAGE1_MINUTES: "20"
       REG_BEAR_STAGE2_ADD_DROP: "0.5"
 
       REG_PARTIAL_S1: "0.30"
       REG_PARTIAL_S2: "0.30"
 
       TRAIL_PCT_BULL: "0.025"
       TRAIL_PCT_BEAR: "0.012"
       TP_PROFIT_PCT_BULL: "3.5"
 
       MARKET_DATA_WHEN_CLOSED: "false"
-      DIAGNOSTIC_ONLY: "true"
-      DIAGNOSTIC_FORCE_RUN: "true"
+      DIAGNOSTIC_ONLY: "0"
+      DIAGNOSTIC_FORCE_RUN: "0"
+      DIAGNOSTIC_ENABLED: "0"
       DISABLE_KOSDAQ_LOOP: "true"
       DISABLE_KOSPI_ENGINE: "true"
-      DISABLE_LIVE_TRADING: "true"
+      DISABLE_LIVE_TRADING: "0"
+      ACTIVE_STRATEGIES: "1"
+      ALLOW_ADOPT_UNMANAGED: "0"
 
       # 배분/속도
       DAILY_CAPITAL: "250000000"
       API_RATE_SLEEP_SEC: "0.3"
 
       # === VWAP 분봉 TR (선택: 코드에 기본값 이미 있으므로 생략해도 동작) ===
       # 한국투자증권 엑셀 기준 주식당일분봉조회 TR_ID (FHKST03010200)
       KIS_TR_ID_INTRADAY_CHART: "FHKST03010200"
       KIS_TR_ID_INTRADAY_CHART_REAL: "FHKST03010200"
 
       # === FastAPI 리밸런싱 서버(선정 필터) ===
       MIN_TRADES: "5"
       MAX_MDD_PCT: "30"
       MIN_WINRATE: "50"
       MIN_CUMRET: "2"
       TOP_K_LIMIT: "20"
       TOTAL_CAPITAL: "10000000"
       MIN_QTY_PER_TICKET: "1"
       K_MIN: "0.1"
       K_MAX: "0.9"
       K_STEP: "0.1"
       ALLOW_AFTER_HOURS: "0"
       REBALANCE_OUT_DIR: "rebalance_results"
 
     steps:
diff --git a/strategy/manager.py b/strategy/manager.py
index f34f8f0f686ad643d3ef85cb3ab7d76d960bb16e..397f6d80e8ef044f57bd6f131f19d777fb7c1245 100644
--- a/strategy/manager.py
+++ b/strategy/manager.py
@@ -1,126 +1,140 @@
 from __future__ import annotations
 
 import logging
 import math
 from dataclasses import asdict, dataclass
 from datetime import datetime
 from typing import Any, Dict, List, Tuple
 
 import trader.state_store as state_store
 from strategy.base import BaseStrategy
 from strategy.strategies import (
     BreakoutStrategy,
     MeanReversionStrategy,
     MomentumStrategy,
     PullbackStrategy,
     VolatilityStrategy,
 )
 from strategy.types import OrderIntent
 from trader.config import (
+    ACTIVE_STRATEGIES,
+    ALLOW_ADOPT_UNMANAGED,
     DAILY_CAPITAL,
     ENABLED_STRATEGIES_SET,
     KST,
     STRATEGY_MAX_POSITION_PCT,
     STRATEGY_WEIGHTS,
+    UNMANAGED_STRATEGY_ID,
 )
+from trader import state_store as runtime_state_store
 
 logger = logging.getLogger(__name__)
 
 
 @dataclass
 class StrategySlot:
     name: str
     sid: int
     weight: float
     strategy: BaseStrategy
 
 
 class StrategyManager:
     def __init__(self, total_capital: float | None = None) -> None:
         self.total_capital = float(total_capital or DAILY_CAPITAL)
         self._seq = 0
         self._zero_weight_warned: set[str] = set()
         self.slots: list[StrategySlot] = self._register_strategies()
 
     def _register_strategies(self) -> list[StrategySlot]:
         return [
             StrategySlot("breakout", 1, float(STRATEGY_WEIGHTS.get("breakout", 0.0)), BreakoutStrategy()),
             StrategySlot("pullback", 2, float(STRATEGY_WEIGHTS.get("pullback", 0.0)), PullbackStrategy()),
             StrategySlot("momentum", 3, float(STRATEGY_WEIGHTS.get("momentum", 0.0)), MomentumStrategy()),
             StrategySlot(
                 "mean_reversion",
                 4,
                 float(STRATEGY_WEIGHTS.get("mean_reversion", 0.0)),
                 MeanReversionStrategy(),
             ),
             StrategySlot(
                 "volatility",
                 5,
                 float(STRATEGY_WEIGHTS.get("volatility", 0.0)),
                 VolatilityStrategy(),
             ),
         ]
 
     def enabled_slots(self) -> list[StrategySlot]:
         enabled: list[StrategySlot] = []
         for slot in self.slots:
+            if slot.sid not in ACTIVE_STRATEGIES:
+                logger.info(
+                    "[STRATEGY_MANAGER] strategy %s sid=%s not in active_strategies=%s -> skipped",
+                    slot.name,
+                    slot.sid,
+                    sorted(ACTIVE_STRATEGIES),
+                )
+                continue
             if slot.name not in ENABLED_STRATEGIES_SET:
                 continue
             if float(slot.weight) <= 0:
                 if slot.name not in self._zero_weight_warned:
                     logger.info(
                         "[STRATEGY_MANAGER] strategy %s enabled but weight=0 -> skipped", slot.name
                     )
                     self._zero_weight_warned.add(slot.name)
                 continue
             enabled.append(slot)
         return enabled
 
     def _next_intent_id(self, strategy: str, side: str, symbol: str, ts: str) -> str:
         self._seq += 1
         return f"{ts}-{strategy}-{side}-{symbol}-{self._seq}"
 
     def _last_price(self, symbol: str, market_data: Dict[str, Any]) -> float | None:
         prices = market_data.get("prices") if isinstance(market_data, dict) else None
         if isinstance(prices, dict):
             data = prices.get(symbol) or prices.get(str(symbol).zfill(6)) or {}
             try:
                 return float(data.get("last_price") or data.get("price") or 0.0)
             except Exception:
                 return None
         return None
 
     def _size_position(self, weight: float, price: float) -> int:
         if price <= 0 or weight <= 0:
             return 0
         allocated_capital = self.total_capital * float(weight)
         max_cap = allocated_capital * STRATEGY_MAX_POSITION_PCT
         qty = math.floor(max_cap / price) if price else 0
         return max(qty, 0)
 
     def _position_matches_strategy(self, position: Dict[str, Any], slot: StrategySlot) -> bool:
+        if not bool(position.get("managed")):
+            return False
         strategy_id = position.get("strategy_id")
         if strategy_id is None:
             return False
         strategy_key = str(strategy_id).lower()
         return strategy_key in {slot.name, str(slot.sid)}
 
     def _build_intent(
         self,
         slot: StrategySlot,
         side: str,
         symbol: str,
         qty: int,
         order_type: str = "MARKET",
         limit_price: float | None = None,
         reason: str = "",
         meta: Dict[str, Any] | None = None,
     ) -> OrderIntent:
         ts = datetime.now(KST).isoformat()
         intent_id = self._next_intent_id(slot.name, side, symbol, ts)
         return OrderIntent(
             intent_id=intent_id,
             ts=ts,
             strategy=slot.name,
             sid=slot.sid,
             side=side.upper(),
@@ -129,78 +143,112 @@ class StrategyManager:
             order_type=order_type.upper(),
             limit_price=limit_price,
             reason=reason or f"{slot.name}_{side.lower()}",
             meta=meta or {},
         )
 
     def _entry_intents_for_slot(
         self,
         slot: StrategySlot,
         market_data: Dict[str, Any],
         portfolio_state: Dict[str, Any],
     ) -> list[OrderIntent]:
         strategy = slot.strategy
         if not strategy.should_enter(market_data, portfolio_state):
             return []
         entry = strategy.compute_entry(market_data, portfolio_state) or {}
         if not isinstance(entry, dict):
             return []
         symbol = entry.get("symbol")
         if not symbol:
             return []
         price = entry.get("price") or self._last_price(symbol, market_data)
         qty = self._size_position(slot.weight, float(price or 0))
         if qty <= 0:
             return []
+        pos = (portfolio_state.get("positions") or {}).get(str(symbol).zfill(6)) if isinstance(portfolio_state, dict) else None
+        if slot.sid == 1 and isinstance(pos, dict) and not bool(pos.get("managed")):
+            if not ALLOW_ADOPT_UNMANAGED:
+                logger.info(
+                    "[UNMANAGED-SKIP-ENTRY] code=%s reason=ALREADY_HELD_UNMANAGED strategy_id=%s",
+                    str(symbol).zfill(6),
+                    pos.get("strategy_id"),
+                )
+                return []
+            pos["strategy_id"] = slot.sid
+            pos["managed"] = True
+            pos["position_key"] = f"{str(symbol).zfill(6)}:{slot.sid}"
+            pos.setdefault("opened_at", pos.get("opened_at") or datetime.now(KST).isoformat())
+            pos["updated_at"] = datetime.now(KST).isoformat()
+            try:
+                state = portfolio_state or runtime_state_store.load_state()
+                state.setdefault("positions", {})[str(symbol).zfill(6)] = pos
+                runtime_state_store.save_state(state)
+                logger.info(
+                    "[UNMANAGED-ADOPT] code=%s adopted_by_strategy=%s allow_adopt_unmanaged=%s",
+                    str(symbol).zfill(6),
+                    slot.sid,
+                    ALLOW_ADOPT_UNMANAGED,
+                )
+            except Exception:
+                logger.exception("[UNMANAGED-ADOPT][FAIL] code=%s strategy=%s", str(symbol).zfill(6), slot.sid)
         order_type = entry.get("order_type") or "MARKET"
         limit_price = entry.get("limit_price")
         reason = entry.get("reason") or f"{slot.name}_entry"
         meta = entry.get("meta")
         return [
             self._build_intent(
                 slot,
                 "BUY",
                 symbol,
                 qty,
                 order_type=order_type,
                 limit_price=limit_price,
                 reason=reason,
                 meta=meta,
             )
         ]
 
     def _exit_intents_for_slot(
         self,
         slot: StrategySlot,
         market_data: Dict[str, Any],
         portfolio_state: Dict[str, Any],
     ) -> list[OrderIntent]:
         intents: list[OrderIntent] = []
         positions = portfolio_state.get("positions", {}) if isinstance(portfolio_state, dict) else {}
         for symbol, position in positions.items():
             if not isinstance(position, dict):
                 continue
+            if not bool(position.get("managed")):
+                logger.info(
+                    "[UNMANAGED-SKIP-EXIT] code=%s qty=%s strategy_id=%s reason=UNMANAGED_HOLDING",
+                    symbol,
+                    position.get("qty"),
+                    position.get("strategy_id"),
+                )
+                continue
             if not self._position_matches_strategy(position, slot):
                 continue
             qty = int(position.get("qty") or 0)
             if qty <= 0:
                 continue
             if not slot.strategy.should_exit(position, market_data, portfolio_state):
                 continue
             exit_payload = slot.strategy.compute_exit(position, market_data, portfolio_state) or {}
             if not isinstance(exit_payload, dict):
                 continue
             price = exit_payload.get("price") or self._last_price(symbol, market_data)
             if price and price > 0:
                 qty = min(qty, int(exit_payload.get("qty") or qty))
             order_type = exit_payload.get("order_type") or "MARKET"
             limit_price = exit_payload.get("limit_price")
             reason = exit_payload.get("reason") or f"{slot.name}_exit"
             intents.append(
                 self._build_intent(
                     slot,
                     "SELL",
                     symbol,
                     qty,
                     order_type=order_type,
                     limit_price=limit_price,
                     reason=reason,
diff --git a/trader/config.py b/trader/config.py
index e92ce52cdb6728f51e42069c58ec664f0fc77c4f..78a415521a71edca8c847d27a9fcc537503518a3 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -89,50 +89,52 @@ CONFIG = {
     "SUBJECT_FLOW_EMPTY_POLICY": "TREAT_AS_FAIL",
     "SUBJECT_FLOW_DEGRADED_TURNOVER_MULT": "1.5",
     "SUBJECT_FLOW_DEGRADED_OB_ADD": "10",
     "SUBJECT_FLOW_MAX_CALLS_PER_RUN": "200",
     "EMERGENCY_GLOBAL_SELL": "false",
     "STRATEGY_REDUCTION_PRIORITY": "5,4,3,2,1",
     # Diagnostics
     "DIAGNOSTIC_MODE": "false",
     "DIAGNOSTIC_ONLY": "false",
     "DIAGNOSTIC_FORCE_RUN": "false",
     "DIAGNOSTIC_DUMP_PATH": "trader/state/diagnostics",
     "DIAGNOSTIC_TARGET_MARKETS": "",
     "DIAGNOSTIC_MAX_SYMBOLS": "200",
     # === Strategy intent/exec defaults ===
     "ENABLED_STRATEGIES": "",
     "STRATEGY_MODE": "INTENT_ONLY",  # INTENT_ONLY | LIVE
     "STRATEGY_DRY_RUN": "true",
     "STRATEGY_INTENTS_PATH": "trader/state/strategy_intents.jsonl",
     "STRATEGY_INTENTS_STATE_PATH": "trader/state/strategy_intents_state.json",
     "STRATEGY_MAX_OPEN_INTENTS": "20",
     "STRATEGY_MAX_POSITION_PCT": "0.10",
     "STRATEGY_ALLOW_SELL_ONLY": "false",
     "STRATEGY_WEIGHTS": "",
     "DISABLE_KOSDAQ_LOOP": "false",
     "DISABLE_KOSPI_ENGINE": "false",
+    "ACTIVE_STRATEGIES": "1",  # CSV of strategy IDs eligible for managed exits/entries
+    "ALLOW_ADOPT_UNMANAGED": "false",
 }
 
 
 def _cfg(key: str) -> str:
     """환경변수 > CONFIG 기본값"""
     return os.getenv(key, CONFIG.get(key, ""))
 
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 LOG_DIR = Path(__file__).parent / "logs"
 LOG_DIR.mkdir(exist_ok=True)
 STATE_FILE = Path(__file__).parent / "trade_state.json"  # legacy; position state uses STATE_PATH
 STATE_DIR = Path(__file__).parent / "state"
 STATE_PATH = STATE_DIR / "state.json"
 STATE_DIR.mkdir(parents=True, exist_ok=True)
 
 # 종목별 시장코드 고정 맵 (실전에서는 마스터테이블 로드로 대체 권장)
 MARKET_MAP: Dict[str, str] = {
     # 예시: '145020': 'J', '347850': 'J', '257720': 'U', '178320': 'J', '348370': 'U'
 }
 
 # 데이터 없음 1차 감지 상태 저장(연속 DATA_EMPTY 확인용)
 EXCLUDE_STATE: Dict[str, Dict[str, bool]] = {}
@@ -269,50 +271,76 @@ logger.info(
     DIAGNOSTIC_ONLY,
     DIAGNOSTIC_FORCE_RUN,
     str(DIAGNOSTIC_DUMP_DIR),
     DIAG_ENABLED,
 )
 
 # 전략별 레짐 축소 우선순위
 def _parse_strategy_priority(raw: str) -> list[int]:
     priorities: list[int] = []
     for item in raw.split(","):
         item = item.strip()
         if not item:
             continue
         try:
             value = int(item)
         except ValueError:
             continue
         if 1 <= value <= 5 and value not in priorities:
             priorities.append(value)
     return priorities or [5, 4, 3, 2, 1]
 
 
 STRATEGY_REDUCTION_PRIORITY = _parse_strategy_priority(
     _cfg("STRATEGY_REDUCTION_PRIORITY")
 )
+
+
+def _parse_active_strategies(raw: str) -> set[int]:
+    strategies: set[int] = set()
+    for item in (raw or "").split(","):
+        item = item.strip()
+        if not item:
+            continue
+        try:
+            sid = int(item)
+        except ValueError:
+            continue
+        if sid >= 0:
+            strategies.add(sid)
+    if not strategies:
+        return {1}
+    return strategies
+
+
+ACTIVE_STRATEGIES = _parse_active_strategies(_cfg("ACTIVE_STRATEGIES"))
+UNMANAGED_STRATEGY_ID = 0
+ALLOW_ADOPT_UNMANAGED = (_cfg("ALLOW_ADOPT_UNMANAGED") or "false").lower() in (
+    "1",
+    "true",
+    "yes",
+)
 # 신고가 → 3일 눌림 → 반등 확인 후 매수 파라미터
 USE_PULLBACK_ENTRY = _cfg("USE_PULLBACK_ENTRY").lower() != "false"
 PULLBACK_LOOKBACK = int(_cfg("PULLBACK_LOOKBACK") or "60")
 PULLBACK_DAYS = int(_cfg("PULLBACK_DAYS") or "3")
 PULLBACK_REVERSAL_BUFFER_PCT = float(_cfg("PULLBACK_REVERSAL_BUFFER_PCT") or "0.2")
 PULLBACK_TOPN = int(_cfg("PULLBACK_TOPN") or "50")
 PULLBACK_UNIT_WEIGHT = float(_cfg("PULLBACK_UNIT_WEIGHT") or "0.03")
 PULLBACK_MAX_BUYS_PER_DAY = int(_cfg("PULLBACK_MAX_BUYS_PER_DAY") or "5")
 CHAMPION_MIN_TRADES = int(_cfg("CHAMPION_MIN_TRADES") or "5")
 CHAMPION_MIN_WINRATE = float(_cfg("CHAMPION_MIN_WINRATE") or "45.0")
 CHAMPION_MAX_MDD = float(_cfg("CHAMPION_MAX_MDD") or "30.0")
 CHAMPION_MIN_SHARPE = float(_cfg("CHAMPION_MIN_SHARPE") or "0.0")
 
 # 챔피언 등급 & GOOD/BAD 타점 판별 파라미터
 CHAMPION_A_RULES = {
     "min_trades": 30,
     "min_cumret_pct": 40.0,
     "max_mdd_pct": 25.0,
     "min_win_pct": 50.0,
     "min_sharpe": 1.2,
     "min_turnover": 3_000_000_000,  # 30억
 }
 
 GOOD_ENTRY_PULLBACK_RANGE = (5.0, 15.0)  # 신고가 대비 눌림폭(%): 최소~최대
 GOOD_ENTRY_MA20_RANGE = (1.0, 1.15)  # 현재가/20MA 허용 구간
diff --git a/trader/diagnostics_runner.py b/trader/diagnostics_runner.py
index 98b1dbcf9cddeb2201f7a652e403cde4821fc9a6..2287e95ce4d02ba65f37832d3510584179ffa835 100644
--- a/trader/diagnostics_runner.py
+++ b/trader/diagnostics_runner.py
@@ -1,41 +1,43 @@
 from __future__ import annotations
 
 import json
 import logging
 from datetime import datetime
 from pathlib import Path
 from typing import Any, Dict, Iterable, List, Optional, Tuple
 
 from rolling_k_auto_trade_api.best_k_meta_strategy import run_rebalance
 from trader import state_store as runtime_state_store
 from trader.config import (
+    ACTIVE_STRATEGIES,
     DIAG_ENABLED,
     DIAGNOSTIC_DUMP_DIR,
     DIAGNOSTIC_MAX_SYMBOLS,
     DIAGNOSTIC_TARGET_MARKETS,
     KST,
+    UNMANAGED_STRATEGY_ID,
 )
 from trader.core_utils import get_rebalance_anchor_date
 from trader.data_health import check_data_health
 from trader.kis_wrapper import KisAPI
 from trader.setup_eval import evaluate_setup
 from trader.time_utils import now_kst
 
 logger = logging.getLogger(__name__)
 
 
 def _normalize_code(sym: str | None) -> str:
     return str(sym or "").strip().lstrip("A").zfill(6)
 
 
 def _iso_now() -> str:
     return datetime.now(KST).isoformat()
 
 
 def _ensure_runtime_keys(runtime_state: Dict[str, Any]) -> None:
     runtime_state.setdefault("diagnostics", {})
     runtime_state.setdefault("memory", {})
     runtime_state["diagnostics"].setdefault("orphans", {})
     runtime_state["memory"].setdefault("data_health", {})
     runtime_state["memory"].setdefault("setup_eval", {})
     runtime_state["memory"].setdefault("exit_eval", {})
@@ -181,100 +183,121 @@ def _load_balance(kis: Optional[KisAPI]) -> Tuple[Dict[str, Any], List[Dict[str,
 
 
 def run_diagnostics(
     *,
     kis: Optional[KisAPI],
     runtime_state: Dict[str, Any],
     selected_by_market: Dict[str, Any] | None,
 ) -> Dict[str, Any]:
     runtime_state = runtime_state or runtime_state_store.load_state()
     _ensure_runtime_keys(runtime_state)
     ts = now_kst()
     ts_iso = ts.isoformat()
 
     if selected_by_market is None:
         try:
             rebalance_payload = run_rebalance(str(get_rebalance_anchor_date()), return_by_market=True)
             selected_by_market = rebalance_payload.get("selected_by_market") or {}
         except Exception as e:
             logger.exception("[DIAG][REBALANCE] failed: %s", e)
             selected_by_market = {}
 
     target_markets = [m for m in (DIAGNOSTIC_TARGET_MARKETS or "").split(",") if m.strip()]
     selected_by_market = _filter_markets(selected_by_market, target_markets)
     balance, holdings = _load_balance(kis)
     try:
-        runtime_state = runtime_state_store.reconcile_with_kis_balance(runtime_state, balance)
+        runtime_state = runtime_state_store.reconcile_with_kis_balance(
+            runtime_state,
+            balance,
+            active_strategies=ACTIVE_STRATEGIES,
+            unmanaged_strategy_id=UNMANAGED_STRATEGY_ID,
+        )
         runtime_state_store.save_state(runtime_state)
         logger.info("[DIAG][STATE] reconciled positions=%d", len(runtime_state.get("positions", {})))
     except Exception:
         logger.exception("[DIAG][STATE] reconcile failed during diagnostics")
     positions = runtime_state.get("positions") or {}
 
     targets = _collect_target_symbols(
         holdings=holdings,
         runtime_state=runtime_state,
         selected_by_market=selected_by_market,
     )
     logger.info("[DIAG][MD] symbols=%d as_of=%s", len(targets), ts_iso)
     runtime_state["diagnostics"]["last_run"].update({"ts": ts_iso, "targets": targets})
 
     orphan_n = 0
     unknown_n = 0
+    unmanaged_n = 0
+    managed_n = 0
     for row in holdings:
         qty = _safe_qty(row)
         if qty <= 0:
             continue
         code = _normalize_code(row.get("code") or row.get("pdno"))
         avg_value = _safe_avg(row)
         avg = avg_value if avg_value != 0.0 else None
         pos = positions.get(code) if isinstance(positions, dict) else None
         if not pos:
             orphan_n += 1
             _record_orphan_or_unknown(
                 runtime_state=runtime_state,
                 code=code,
                 qty=qty,
                 avg=avg,
                 kind="ORPHAN",
                 reason="MISSING_IN_STATE",
                 ts=ts_iso,
                 source="kis",
             )
             continue
         sid = pos.get("sid") or pos.get("strategy_id")
-        if sid is None or str(sid).strip() == "" or str(sid).upper() == "UNKNOWN":
+        sid_str = str(sid).strip()
+        if sid is None or sid_str == "" or sid_str == str(UNMANAGED_STRATEGY_ID):
+            unmanaged_n += 1
+            _record_orphan_or_unknown(
+                runtime_state=runtime_state,
+                code=code,
+                qty=qty,
+                avg=avg,
+                kind="UNMANAGED",
+                reason="STRATEGY_ID_UNMANAGED",
+                ts=ts_iso,
+            )
+        elif sid_str.upper() == "UNKNOWN":
             unknown_n += 1
             _record_orphan_or_unknown(
                 runtime_state=runtime_state,
                 code=code,
                 qty=qty,
                 avg=avg,
                 kind="UNKNOWN",
                 reason="STRATEGY_ID_UNKNOWN",
                 ts=ts_iso,
             )
+        else:
+            managed_n += 1
 
     data_health_results: Dict[str, Any] = {}
     setup_eval_results: Dict[str, Any] = {}
 
     for code in targets:
         health = check_data_health(code, kis)
         health["ts"] = health.get("ts") or _iso_now()
         reasons = health.get("reasons") or []
         ok = bool(health.get("ok"))
         if ok:
             if not reasons:
                 reasons = ["OK"]
         else:
             if not reasons:
                 reasons = []
             if health.get("daily_len") is not None and health.get("daily_len") < 21:
                 reasons.append("daily_len<21")
             if health.get("intraday_len") is not None and health.get("intraday_len") < 20:
                 reasons.append("intraday_len<20")
             if health.get("prev_close") is None:
                 reasons.append("prev_close=None")
             if health.get("vwap") is None:
                 reasons.append("vwap=None")
             if not reasons:
                 reasons = ["UNKNOWN_DATA_HEALTH_FAIL"]
@@ -300,112 +323,133 @@ def run_diagnostics(
         )
         setup["reasons"] = setup_reasons
         setup_eval_results[code] = setup
         runtime_state["memory"]["setup_eval"][code] = setup
         if setup_ok:
             logger.info(
                 "[SETUP-OK] %s | reasons=%s | daily=%s intra=%s",
                 code,
                 setup_reasons,
                 setup.get("daily", {}),
                 setup.get("intra", {}),
             )
         else:
             logger.info(
                 "[SETUP-BAD] %s | missing=%s reasons=%s | daily=%s intra=%s",
                 code,
                 setup.get("missing"),
                 setup_reasons,
                 setup.get("daily", {}),
                 setup.get("intra", {}),
             )
 
     exit_eval_results: Dict[str, Any] = {}
     for code, pos in (positions or {}).items():
         qty = int(pos.get("qty") or 0)
-        sid = pos.get("sid") or pos.get("strategy_id") or "UNKNOWN"
-        strategy_id = pos.get("strategy_id") or "UNKNOWN"
+        sid = pos.get("sid") or pos.get("strategy_id") or UNMANAGED_STRATEGY_ID
+        strategy_id = pos.get("strategy_id") or UNMANAGED_STRATEGY_ID
+        sid_str = str(sid).strip().upper()
+        strategy_id_str = str(strategy_id).strip().upper()
+        managed = bool(pos.get("managed")) and strategy_id_str not in {"", "UNKNOWN"} and strategy_id_str != str(UNMANAGED_STRATEGY_ID)
         reasons: List[str] = []
-        if sid in (None, "", "UNKNOWN"):
-            reasons.append("MISSING_SID")
-        if strategy_id in (None, "", "UNKNOWN"):
-            reasons.append("MISSING_STRATEGY_ID")
+        if not managed:
+            if strategy_id_str == "UNKNOWN":
+                unknown_n += 1
+                reasons.append("UNKNOWN_STRATEGY_ID")
+            else:
+                unmanaged_n += 1
+                reasons.append("UNMANAGED_HOLDING")
+            logger.info(
+                "[UNMANAGED-SKIP-EXIT] code=%s qty=%s strategy_id=%s reason=%s",
+                code,
+                qty,
+                strategy_id,
+                reasons[-1],
+            )
         if qty <= 0:
             reasons.append("QTY_ZERO")
-        if sid in (None, "", "UNKNOWN") or strategy_id in (None, "", "UNKNOWN"):
-            unknown_n += 1
-            _record_orphan_or_unknown(
-                runtime_state=runtime_state,
-                code=code,
-                qty=qty,
-                avg=float(pos.get("avg_price") or 0.0),
-                kind="UNKNOWN",
-                reason="EXIT_STRATEGY_ID_MISSING",
-                ts=ts_iso,
-                source="state",
-            )
+        if managed:
+            managed_n += 1
         if not reasons:
             exit_ok = True
             reasons = ["EMPTY_EXIT_REASON_GUARD"]
         else:
             exit_ok = False
         exit_eval_results[code] = {
             "ts": _iso_now(),
             "sid": sid or "UNKNOWN",
             "strategy_id": strategy_id,
             "qty": qty,
+            "managed": managed,
             "exit_ok": exit_ok,
             "reasons": reasons,
         }
         runtime_state["memory"]["exit_eval"][code] = exit_eval_results[code]
         logger.info(
             "[EXIT-CHECK] code=%s sid=%s strategy_id=%s qty=%s exit_ok=%s reasons=%s",
             code,
             sid,
             strategy_id,
             qty,
             exit_ok,
             reasons,
         )
 
     data_health_fail_n = sum(1 for v in data_health_results.values() if not v.get("ok"))
     setup_bad_n = sum(1 for v in setup_eval_results.values() if not v.get("setup_ok"))
 
+    managed_positions_count = 0
+    unmanaged_positions_count = 0
+    unknown_positions_count = 0
+    if isinstance(positions, dict):
+        for pos in positions.values():
+            sid_val = str((pos or {}).get("strategy_id")).strip().upper()
+            if sid_val == "UNKNOWN":
+                unknown_positions_count += 1
+                continue
+            if bool((pos or {}).get("managed")):
+                managed_positions_count += 1
+            else:
+                unmanaged_positions_count += 1
+
     diag_payload = {
         "as_of": ts_iso,
         "diag_enabled": bool(DIAG_ENABLED),
         "targets": targets,
         "orphans_n": orphan_n,
         "unknown_n": unknown_n,
         "data_health_fail_n": data_health_fail_n,
         "setup_bad_n": setup_bad_n,
         "data_health": data_health_results,
         "setup_eval": setup_eval_results,
         "exit_eval": exit_eval_results,
         "orphans": runtime_state["diagnostics"]["orphans"],
         "selected_by_market": selected_by_market or {},
         "balance": balance,
+        "managed_positions": managed_positions_count,
+        "unmanaged_positions": unmanaged_positions_count,
+        "unknown_positions": unknown_positions_count,
     }
 
     diag_path = DIAGNOSTIC_DUMP_DIR / "diag_latest.json"
     timestamped_path = DIAGNOSTIC_DUMP_DIR / f"diag_{ts.strftime('%Y%m%d_%H%M%S')}.json"
     try:
         _dump_json(diag_path, diag_payload)
         _dump_json(timestamped_path, diag_payload)
         logger.info(
             "[DIAG][DUMP] wrote=%s targets=%d orphans=%d unknown=%d",
             diag_path,
             len(targets),
             orphan_n,
             unknown_n,
         )
     except Exception as e:
         logger.exception("[DIAG][DUMP_FAIL] path=%s err=%s", diag_path, e)
 
     try:
         runtime_state_store.save_state(runtime_state)
     except Exception:
         logger.exception("[DIAG][STATE] failed to persist diagnostic annotations")
 
     return diag_payload
 
 
diff --git a/trader/kis_wrapper.py b/trader/kis_wrapper.py
index b1a520c758b68d81fe676ebc0df92455192bf70e..b52f0e9537175553f043e4e03298ce86a9da4559 100644
--- a/trader/kis_wrapper.py
+++ b/trader/kis_wrapper.py
@@ -1032,86 +1032,89 @@ class KisAPI:
             c = code.strip()
             codes = [c, f"A{c}"] if not c.startswith("A") else [c, c[1:]]
             for market_div in markets:
                 for code_fmt in codes:
                     params = {"fid_cond_mrkt_div_code": market_div, "fid_input_iscd": code_fmt}
                     try:
                         # [CHG] 안전요청 사용
                         resp = self._safe_request(
                             "GET", url, headers=headers, params=params, timeout=(3.0, 5.0)
                         )
                         data = resp.json()
                     except Exception:
                         continue
                     if resp.status_code == 200 and data.get("rt_cd") == "0" and data.get("output"):
                         try:
                             return float(data["output"].get("bidp1"))
                         except Exception:
                             return None
         return None
 
     def get_index_quote(self, index_code: str) -> Dict[str, Optional[float]]:
         """(간이) 지수 스냅샷 placeholder."""
         return {"price": None, "prev_close": None, "vwap": None}
 
     # ----- 잔고/포지션 -----
-    def _parse_cash_from_output2(self, out2: Any) -> int:
+    def _parse_cash_from_output2(self, out2: Any) -> tuple[int, dict]:
         """
         ✅ 예수금 파싱 규칙:
         1) ord_psbl_cash (주문가능현금)
         2) nrcvb_buy_amt (매수가능금액)
         3) dnca_tot_amt  (예수금 총액; 결제미수 포함 가능)
         """
 
         def _to_int(x) -> int:
             try:
                 s = safe_strip(x)
                 if s == "":
                     return 0
                 return int(float(s))
             except Exception:
                 return 0
 
         row = None
         if isinstance(out2, list) and out2:
             row = out2[0]
         elif isinstance(out2, dict):
             row = out2
         else:
-            return 0
-
-        cash = _to_int(row.get("ord_psbl_cash"))
-        if cash <= 0:
-            cash = _to_int(row.get("nrcvb_buy_amt"))
-        if cash <= 0:
-            cash = _to_int(row.get("dnca_tot_amt"))
-
-        if cash < 0:
-            logger.warning("[CASH_BALANCE] 음수 → 0 보정 (raw=%s)", cash)
-            cash = 0
+            return 0, {}
 
-        return cash
+        raw_fields = {
+            "ord_psbl_cash": row.get("ord_psbl_cash"),
+            "nrcvb_buy_amt": row.get("nrcvb_buy_amt"),
+            "dnca_tot_amt": row.get("dnca_tot_amt"),
+        }
+        selected_key = None
+        cash = 0
+        for key in ("ord_psbl_cash", "nrcvb_buy_amt", "dnca_tot_amt"):
+            if key in row:
+                selected_key = key
+                cash = _to_int(row.get(key))
+                break
+        clamp_applied = False
+        return cash, {"raw_fields": raw_fields, "selected_key": selected_key, "clamp_applied": clamp_applied}
 
     def _inquire_balance_page(self, fk: str, nk: str) -> dict:
         """잔고 1페이지 호출(예외는 상위에서 처리)."""
         url = f"{API_BASE_URL}/uapi/domestic-stock/v1/trading/inquire-balance"
         tr_list = _pick_tr(self.env, "BALANCE")
         if not tr_list:
             raise RuntimeError("BALANCE TR 미구성")
         tr = tr_list[0]
         headers = self._headers(tr)
         params = {
             "CANO": self.CANO,
             "ACNT_PRDT_CD": self.ACNT_PRDT_CD,
             "AFHR_FLPR_YN": "N",
             "UNPR_YN": "N",
             "UNPR_DVSN": "01",
             "FUND_STTL_ICLD_YN": "N",
             "FNCG_AMT_AUTO_RDPT_YN": "N",
             "PRCS_DVSN": "01",
             "OFL_YN": "N",
             "INQR_DVSN": "02",
             "CTX_AREA_FK100": fk,
             "CTX_AREA_NK100": nk,
         }
         logger.info(f"[잔고조회 요청파라미터] {params}")
         # [CHG] 안전요청 사용
@@ -1149,51 +1152,58 @@ class KisAPI:
                 else:
                     break
             empty_cnt = 0
             all_rows.extend(rows)
 
             # ✅ '처음 나온' output2만 요약으로 사용 (마지막 페이지 값으로 덮어쓰지 않음)
             out2 = j.get("output2")
             if out2 is not None and out2_last is None:
                 out2_last = out2
 
             fk = (j.get("ctx_area_fk100") or "").strip()
             nk = (j.get("ctx_area_nk100") or "").strip()
             if not fk and not nk:
                 break
 
         return {"output1": all_rows, "output2": out2_last, "ctx_area_fk100": fk, "ctx_area_nk100": nk}
 
     def get_cash_balance(self) -> int:
         """
         ✅ 예수금: output2.ord_psbl_cash 우선.
         실패/0원 시 최근 캐시(self._last_cash) 폴백.
         """
         try:
             j = self.inquire_balance_all()
             out2 = j.get("output2")
-            cash = self._parse_cash_from_output2(out2)
+            cash, meta = self._parse_cash_from_output2(out2)
+            logger.info(
+                "[CASH] raw=%s orderable=%s source_fields=%s clamp_applied=%s",
+                meta.get("raw_fields"),
+                cash,
+                meta.get("selected_key"),
+                meta.get("clamp_applied"),
+            )
             if cash > 0:
                 self._last_cash = cash
                 logger.info("[CASH_BALANCE_OK] ord_psbl_cash≈%s원", f"{cash:,}")
                 return cash
             # 0원이면 캐시 폴백
             if self._last_cash is not None and self._last_cash > 0:
                 logger.warning("[CASH_FALLBACK] live=0 → use last=%s", f"{self._last_cash:,}")
                 return self._last_cash
         except Exception as e:
             logger.error(f"[CASH_BALANCE_FAIL] {e}")
             if self._last_cash is not None and self._last_cash > 0:
                 logger.warning("[CASH_FALLBACK] netfail → use last=%s", f"{self._last_cash:,}")
                 return self._last_cash
         return 0
 
     def get_positions(self) -> List[Dict]:
         """보유 종목 전체(페이징 병합)."""
         try:
             j = self.inquire_balance_all()
             return j.get("output1") or []
         except Exception as e:
             logger.error("[GET_POSITIONS_FAIL] %s", e)
             return []
 
     def get_balance_map(self) -> Dict[str, int]:
diff --git a/trader/state_store.py b/trader/state_store.py
index ad6609bd6f5ba00f89e5b778d326a80a02ccffaa..e2fa7fc6d4d500c84cb218a69667cc25333d0aab 100644
--- a/trader/state_store.py
+++ b/trader/state_store.py
@@ -1,89 +1,116 @@
 from __future__ import annotations
 
 import json
 import logging
 import os
 import uuid
 from datetime import datetime
 from pathlib import Path
 from typing import Any, Dict
 
-from .config import KST, STATE_PATH
+from .config import ACTIVE_STRATEGIES, KST, STATE_PATH, UNMANAGED_STRATEGY_ID
 
 logger = logging.getLogger(__name__)
 
-SCHEMA_VERSION = 2
+SCHEMA_VERSION = 3
 RUNTIME_STATE_DIR = Path(".runtime")
 RUNTIME_STATE_PATH = RUNTIME_STATE_DIR / "state.json"
 _LOT_ID_PREFIX = "LOT"
 
 
 def _normalize_code(symbol: str | int | None) -> str:
     return str(symbol or "").zfill(6)
 
 
+def _normalize_strategy_id(value: Any) -> Any:
+    if value is None:
+        return None
+    try:
+        return int(value)
+    except Exception:
+        return value
+
+
+def _is_managed(strategy_id: Any, active_strategies: set[int] | None = None) -> bool:
+    try:
+        sid_int = int(strategy_id)
+    except Exception:
+        return False
+    return sid_int in (active_strategies or ACTIVE_STRATEGIES)
+
+
 def _default_runtime_state() -> Dict[str, Any]:
     return {
         "schema_version": SCHEMA_VERSION,
         "updated_at": None,
         "positions": {},
         "orders": {},
         "lots": [],
         "memory": {"last_price": {}, "last_seen": {}, "last_strategy_id": {}},
     }
 
 
 def load_state() -> Dict[str, Any]:
     if not RUNTIME_STATE_PATH.exists():
         return _default_runtime_state()
     try:
         with open(RUNTIME_STATE_PATH, "r", encoding="utf-8") as f:
             state = json.load(f)
         if not isinstance(state, dict):
             logger.warning("[RUNTIME_STATE] invalid state format: %s", type(state))
             return _default_runtime_state()
         state.setdefault("schema_version", SCHEMA_VERSION)
         state.setdefault("positions", {})
         state.setdefault("orders", {})
         memory = state.get("memory")
         if not isinstance(memory, dict):
             memory = {}
             state["memory"] = memory
         memory.setdefault("last_price", {})
         memory.setdefault("last_seen", {})
         memory.setdefault("last_strategy_id", {})
         state.setdefault("updated_at", None)
         lots = state.get("lots")
         if not isinstance(lots, list):
             lots = []
             state["lots"] = lots
         positions = state.get("positions")
         if isinstance(positions, dict):
             for sym, payload in list(positions.items()):
                 if not isinstance(payload, dict):
                     positions[sym] = {}
+                    payload = positions[sym]
+                code_norm = _normalize_code(sym)
+                payload.setdefault("code", code_norm)
+                sid = _normalize_strategy_id(payload.get("strategy_id"))
+                payload["strategy_id"] = sid if sid is not None else UNMANAGED_STRATEGY_ID
+                payload["managed"] = _is_managed(payload.get("strategy_id"))
+                payload.setdefault("opened_at", payload.get("opened_at") or None)
+                payload.setdefault("updated_at", payload.get("updated_at") or None)
+                payload.setdefault("meta", {})
+                payload["position_key"] = f"{code_norm}:{payload.get('strategy_id')}"
         return state
     except Exception:
         logger.exception("[RUNTIME_STATE] failed to load %s", RUNTIME_STATE_PATH)
         return _default_runtime_state()
 
 
 def save_state(state: Dict[str, Any]) -> None:
     try:
         RUNTIME_STATE_DIR.mkdir(parents=True, exist_ok=True)
         payload = dict(state)
         payload.setdefault("schema_version", SCHEMA_VERSION)
         payload.setdefault("positions", {})
         payload.setdefault("orders", {})
         payload.setdefault("lots", [])
         payload.setdefault("memory", {"last_price": {}, "last_seen": {}, "last_strategy_id": {}})
         payload["updated_at"] = datetime.now(KST).isoformat()
         tmp_path = RUNTIME_STATE_PATH.with_name(f"{RUNTIME_STATE_PATH.name}.tmp")
         with open(tmp_path, "w", encoding="utf-8") as f:
             json.dump(payload, f, ensure_ascii=False, indent=2)
             f.flush()
             os.fsync(f.fileno())
         os.replace(tmp_path, RUNTIME_STATE_PATH)
         try:
             size = RUNTIME_STATE_PATH.stat().st_size
             logger.info("[STATE][SAVE] path=%s bytes=%d", RUNTIME_STATE_PATH, size)
@@ -223,50 +250,58 @@ def _apply_sell_to_lots(
     remaining = _consume(sid_filter, remaining)
     if remaining > 0 and sid_filter is not None:
         remaining = _consume(None, remaining)
     if remaining > 0:
         logger.warning(
             "[RUNTIME_STATE][LOT_SELL_MISMATCH] code=%s sid=%s remaining_unmatched=%s",
             target_code,
             sid_filter,
             remaining,
         )
 
 def get_position(state: Dict[str, Any], symbol: str) -> Dict[str, Any] | None:
     positions = state.get("positions", {})
     if not isinstance(positions, dict):
         return None
     return positions.get(str(symbol).zfill(6))
 
 
 def upsert_position(state: Dict[str, Any], symbol: str) -> Dict[str, Any]:
     positions = state.setdefault("positions", {})
     key = str(symbol).zfill(6)
     pos = positions.get(key)
     if not isinstance(pos, dict):
         pos = {}
     positions[key] = pos
+    pos.setdefault("code", key)
+    sid = _normalize_strategy_id(pos.get("strategy_id"))
+    if sid is None:
+        pos["strategy_id"] = UNMANAGED_STRATEGY_ID
+    else:
+        pos["strategy_id"] = sid
+    pos["managed"] = _is_managed(pos.get("strategy_id"))
+    pos["position_key"] = f"{key}:{pos.get('strategy_id')}"
     return pos
 
 
 def update_position_fields(state: Dict[str, Any], symbol: str, fields: Dict[str, Any]) -> Dict[str, Any]:
     pos = upsert_position(state, symbol)
     for field, value in fields.items():
         pos[field] = value
     return pos
 
 
 def _order_bucket(state: Dict[str, Any], symbol: str, side: str) -> Dict[str, Any]:
     orders = state.setdefault("orders", {})
     symbol_key = str(symbol).zfill(6)
     symbol_bucket = orders.setdefault(symbol_key, {})
     return symbol_bucket.setdefault(side.upper(), {})
 
 
 def should_block_order(
     state: Dict[str, Any],
     symbol: str,
     side: str,
     now_ts: str,
     *,
     window_sec: int = 300,
     max_attempts: int = 2,
@@ -333,131 +368,153 @@ def mark_fill(
             record_lot_open(
                 state,
                 code=symbol,
                 sid=strategy_id,
                 strategy=str(strategy_id),
                 engine=str(pos.get("engine") or "unknown"),
                 qty=int(qty),
                 entry_price=float(price),
                 entry_ts=ts,
                 order_id=order_id,
             )
         else:
             _apply_sell_to_lots(
                 state,
                 code=symbol,
                 qty=int(qty),
                 strategy_id=strategy_id,
                 order_id=order_id,
                 price=float(price),
                 ts=ts,
             )
     except Exception:
         logger.exception("[RUNTIME_STATE] lot update failed for %s", symbol)
     cur_qty = int(pos.get("qty") or 0)
     cur_avg = float(pos.get("avg_price") or 0.0)
+    code_key = _normalize_code(symbol)
+    pos.setdefault("code", code_key)
+    pos["strategy_id"] = _normalize_strategy_id(strategy_id)
+    pos["managed"] = _is_managed(pos.get("strategy_id"))
+    pos["position_key"] = f"{code_key}:{pos.get('strategy_id')}"
+    pos.setdefault("opened_at", pos.get("opened_at") or ts)
     if side.upper() == "BUY":
         total_qty = cur_qty + int(qty)
         avg_price = (
             (cur_avg * cur_qty + float(price) * int(qty)) / total_qty
             if total_qty > 0
             else 0.0
         )
         pos.update({"qty": total_qty, "avg_price": avg_price, "last_buy_ts": ts})
     else:
         pos.update({"qty": max(0, cur_qty - int(qty)), "last_sell_ts": ts})
-    pos["strategy_id"] = strategy_id
     pos["last_order_id"] = order_id
     pos["last_action"] = side.upper()
     pos["last_action_ts"] = ts
     pos["last_order_status"] = status
+    pos["updated_at"] = ts
     update_position_fields(state, symbol, pos)
     try:
-        if side.upper() == "BUY":
-            save_state(state)
+        save_state(state)
     except Exception:
-        logger.exception("[RUNTIME_STATE] failed to persist after lot open for %s", symbol)
+        logger.exception("[RUNTIME_STATE] failed to persist after lot update for %s", symbol)
 
 
 def reconcile_with_kis_balance(
     state: Dict[str, Any],
     balance: Dict[str, Any],
     *,
     preferred_strategy: Dict[str, Any] | None = None,
+    active_strategies: set[int] | None = None,
+    unmanaged_strategy_id: int = 0,
 ) -> Dict[str, Any]:
     preferred_strategy = preferred_strategy or {}
+    active_strategies = active_strategies or set()
     positions = state.setdefault("positions", {})
     lots = _ensure_lots(state)
     state_lots_by_code: Dict[str, list[dict[str, Any]]] = {}
     for lot in lots:
         code_key = _normalize_code(lot.get("code") or lot.get("pdno"))
         if not code_key:
             continue
         bucket = state_lots_by_code.setdefault(code_key, [])
         bucket.append(lot)
 
     balance_positions = balance.get("positions") if isinstance(balance, dict) else None
     if not isinstance(balance_positions, list):
         logger.warning("[STATE][RECONCILE] balance.positions missing or invalid")
         return state
 
     now_iso = datetime.now(KST).isoformat()
     holdings = []
     for row in balance_positions:
         symbol = _normalize_code(row.get("code") or row.get("pdno"))
         qty = int(float(row.get("qty") or row.get("hldg_qty") or row.get("ord_psbl_qty") or 0))
         if not symbol or qty <= 0:
             continue
         holdings.append(
             {
                 "code": symbol,
                 "qty": qty,
                 "avg": float(row.get("avg_price") or row.get("pchs_avg_pric") or 0.0),
                 "cur": float(row.get("prpr") or 0.0) if row.get("prpr") not in (None, "") else None,
             }
         )
     logger.info("[STATE][RECONCILE] kis_holdings=%d", len(holdings))
 
     created_orphans = 0
     qty_adjusted = 0
     updated_codes = 0
 
     for holding in holdings:
         code = holding["code"]
         qty = holding["qty"]
         avg = holding["avg"] if holding["avg"] != 0.0 else None
         cur = holding["cur"]
         pos = upsert_position(state, code)
-        strategy_id = pos.get("strategy_id") or preferred_strategy.get(code) or "UNKNOWN"
+        pos_meta = pos.setdefault("meta", {})
+        raw_strategy_id = pos.get("strategy_id") or preferred_strategy.get(code)
+        strategy_id = raw_strategy_id if raw_strategy_id not in (None, "") else unmanaged_strategy_id
+        managed = _is_managed(strategy_id, active_strategies)
+        if not managed and raw_strategy_id not in (None, "", unmanaged_strategy_id):
+            strategy_id = unmanaged_strategy_id
         pos.update(
             {
                 "strategy_id": strategy_id,
+                "managed": managed,
                 "qty": qty,
                 "avg_price": float(holding["avg"] or 0.0),
                 "last_action": "RECONCILE",
+                "updated_at": now_iso,
+                "opened_at": pos.get("opened_at") or now_iso,
+                "position_key": f"{code}:{strategy_id}",
             }
         )
+        if not managed:
+            pos_meta.setdefault("created_by", "reconcile_unmanaged")
+            notes = pos_meta.setdefault("notes", [])
+            if isinstance(notes, list):
+                notes.append("UNMANAGED_HOLDING")
         state_lots = state_lots_by_code.get(code, [])
         state_sum = sum(int(l.get("remaining_qty") or l.get("qty") or 0) for l in state_lots if str(l.get("status") or "OPEN").upper() == "OPEN")
         if not state_lots:
             lot = {
                 "lot_id": f"ORPHAN-{code}-{now_iso.replace(':', '').replace('-', '')}",
                 "code": code,
                 "pdno": code,
                 "sid": "ORPHAN",
                 "strategy_id": "ORPHAN",
                 "strategy": "ORPHAN",
                 "engine": "reconcile_kis_balance",
                 "qty": qty,
                 "remaining_qty": qty,
                 "entry_price": avg if avg is not None else None,
                 "entry_ts": now_iso,
                 "status": "OPEN",
                 "source": "reconcile_kis_balance",
                 "created_at": now_iso,
                 "updated_at": now_iso,
                 "notes": ["MISSING_IN_STATE"],
             }
             lots.append(lot)
             created_orphans += 1
             updated_codes += 1
             logger.warning(
diff --git a/trader/trader.py b/trader/trader.py
index 6f749272b26196ad27b0b48e996e795c2d07f76b..9cb9441f123cb920c5ee993ef7ce789094069e5b 100644
--- a/trader/trader.py
+++ b/trader/trader.py
@@ -1,79 +1,95 @@
 # -*- coding: utf-8 -*-
 """Thin entrypoint orchestrating KOSPI core + KOSDAQ alpha engines."""
 from __future__ import annotations
 
 import logging
 import os
 
 from portfolio.portfolio_manager import PortfolioManager
 from trader.kis_wrapper import KisAPI
 from trader import state_store as runtime_state_store
 from trader.time_utils import is_trading_day, now_kst
 from trader.subject_flow import get_subject_flow_with_fallback  # noqa: F401 - exported for engines
-from trader.config import DIAG_ENABLED, DIAGNOSTIC_FORCE_RUN, DIAGNOSTIC_MODE, DIAGNOSTIC_ONLY
+from trader.config import (
+    ACTIVE_STRATEGIES,
+    ALLOW_ADOPT_UNMANAGED,
+    DIAG_ENABLED,
+    DIAGNOSTIC_FORCE_RUN,
+    DIAGNOSTIC_MODE,
+    DIAGNOSTIC_ONLY,
+)
 
 logger = logging.getLogger(__name__)
 
 
 def main() -> None:
     now = now_kst()
     diag_enabled = bool(DIAG_ENABLED or DIAGNOSTIC_FORCE_RUN)
+    disable_live_env = os.getenv("DISABLE_LIVE_TRADING", "").lower()
     logger.info(
         "[DIAG][TRADER] now=%s trading_day=%s diag_enabled=%s force_run=%s only=%s mode=%s",
         now.isoformat(),
         is_trading_day(now),
         DIAG_ENABLED,
         DIAGNOSTIC_FORCE_RUN,
         DIAGNOSTIC_ONLY,
         DIAGNOSTIC_MODE,
     )
+    logger.info(
+        "[TRADER][STARTUP] active_strategies=%s live_trading_enabled_env=%s allow_adopt_unmanaged=%s",
+        sorted(ACTIVE_STRATEGIES),
+        disable_live_env not in {"1", "true", "yes", "on"},
+        ALLOW_ADOPT_UNMANAGED,
+    )
     if diag_enabled:
         os.environ["DISABLE_LIVE_TRADING"] = "true"
         logger.info(
             "[DIAG][TRADER] forcing DISABLE_LIVE_TRADING=true (diag_enabled=%s)",
             diag_enabled,
         )
     trading_day = is_trading_day(now)
     if (not trading_day) and (not (DIAG_ENABLED and DIAGNOSTIC_FORCE_RUN)):
         logger.warning("[TRADER] 비거래일(%s) → 즉시 종료", now.date())
         return
     if (not trading_day) and diag_enabled:
         logger.warning(
             "[DIAG][TRADER] non-trading-day(%s) but running diagnostics (only=%s force_run=%s)",
             now.date(),
             DIAGNOSTIC_ONLY,
             DIAGNOSTIC_FORCE_RUN,
         )
     runtime_state = {}
     kis: KisAPI | None = None
     try:
         runtime_state = runtime_state_store.load_state()
         kis = KisAPI()
         balance = kis.get_balance()
         runtime_state = runtime_state_store.reconcile_with_kis_balance(
-            runtime_state, balance
+            runtime_state,
+            balance,
+            active_strategies=ACTIVE_STRATEGIES,
         )
         runtime_state_store.save_state(runtime_state)
         logger.info("[TRADER] runtime state reconciled")
     except Exception:
         logger.exception("[TRADER] runtime state reconcile failed")
         runtime_state = runtime_state or runtime_state_store.load_state()
 
     if DIAGNOSTIC_ONLY:
         from trader.diagnostics_runner import run_diagnostics
 
         run_diagnostics(kis=kis, runtime_state=runtime_state, selected_by_market=None)
         logger.info("[DIAG][TRADER] diagnostic_only complete")
         return
 
     diag_result = None
     if DIAGNOSTIC_MODE:
         try:
             from trader.diagnostics_runner import run_diagnostics
 
             diag_result = run_diagnostics(
                 kis=kis, runtime_state=runtime_state, selected_by_market=None
             )
         except Exception:
             logger.exception("[DIAG][TRADER] diagnostics run failed")
 
