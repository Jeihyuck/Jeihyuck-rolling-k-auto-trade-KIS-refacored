diff --git a/trader/botstate_sync.py b/trader/botstate_sync.py
index a19b9c552c36ee889bc508ebad2fa65e0e622a4a..442fc1e727fa4c08aa35260bf7f64f26978caeae 100644
--- a/trader/botstate_sync.py
+++ b/trader/botstate_sync.py
@@ -1,66 +1,94 @@
 from __future__ import annotations
 
 import json
 import os
 import subprocess
 import time
 import logging
 from datetime import datetime, timedelta
 from pathlib import Path
-from typing import Dict, Iterable
+from typing import Iterable
 from zoneinfo import ZoneInfo
 
 logger = logging.getLogger(__name__)
 
 KST = ZoneInfo("Asia/Seoul")
 
 DEFAULT_BOTSTATE_WORKTREE_DIR = "_botstate"
 BOTSTATE_WORKTREE_DIR_ENV = "BOTSTATE_WORKTREE_DIR"
 
 
 def resolve_botstate_worktree_dir() -> Path:
     return Path(os.getenv(BOTSTATE_WORKTREE_DIR_ENV, DEFAULT_BOTSTATE_WORKTREE_DIR)).resolve()
 
 
-def _run(cmd: list[str], cwd: Path | None = None) -> subprocess.CompletedProcess:
+def _run(cmd: list[str], cwd: Path | None = None, *, check: bool = True) -> subprocess.CompletedProcess:
     try:
-        return subprocess.run(cmd, cwd=cwd, check=True, text=True, capture_output=True)
+        return subprocess.run(cmd, cwd=cwd, check=check, text=True, capture_output=True)
     except subprocess.CalledProcessError as exc:
         logger.error(
             "[BOTSTATE][CMD-ERROR] cmd=%s cwd=%s returncode=%s stdout=%s stderr=%s",
             exc.cmd,
             cwd,
             exc.returncode,
             exc.stdout,
             exc.stderr,
         )
         raise
 
 
-def _git(worktree_dir: Path, *args: str) -> subprocess.CompletedProcess:
-    return _run(["git", "-C", str(worktree_dir), *args])
+def git_porcelain(worktree_dir: Path) -> str:
+    return _git(worktree_dir, "status", "--porcelain").stdout
+
+
+def stage_all(worktree_dir: Path) -> None:
+    _git(worktree_dir, "add", "-A")
+
+
+def commit_if_staged(worktree_dir: Path, message: str) -> bool:
+    diff_proc = _git(worktree_dir, "diff", "--cached", "--quiet", check=False)
+    if diff_proc.returncode == 0:
+        return False
+    _git(worktree_dir, "commit", "-m", message)
+    return True
+
+
+def ensure_clean_before_rebase(worktree_dir: Path, message_for_autosave: str) -> None:
+    status = git_porcelain(worktree_dir)
+    files = [line.strip() for line in status.splitlines() if line.strip()]
+    dirty = bool(files)
+    logger.info("[BOTSTATE][GIT] dirty=%s files=%s", dirty, files)
+    if not dirty:
+        return
+    stage_all(worktree_dir)
+    committed = commit_if_staged(worktree_dir, message_for_autosave)
+    logger.info("[BOTSTATE][GIT] committed=%s msg=%s", committed, message_for_autosave)
+
+
+def _git(worktree_dir: Path, *args: str, check: bool = True) -> subprocess.CompletedProcess:
+    return _run(["git", "-C", str(worktree_dir), *args], check=check)
 
 
 def _configure_safe_directories(base_dir: Path, worktree_dir: Path) -> None:
     base_dir_resolved = base_dir.resolve()
     worktree_dir_resolved = worktree_dir.resolve()
     for path in {base_dir_resolved, worktree_dir_resolved}:
         _run(["git", "config", "--global", "--add", "safe.directory", str(path)])
 
 
 def setup_worktree(base_dir: Path, worktree_dir: Path, target_branch: str = "bot-state") -> None:
     base_dir = base_dir.resolve()
     worktree_dir = worktree_dir.resolve()
     worktree_dir.mkdir(parents=True, exist_ok=True)
     _configure_safe_directories(base_dir, worktree_dir)
     try:
         _run(["git", "worktree", "add", "-B", target_branch, str(worktree_dir), target_branch], cwd=base_dir)
     except subprocess.CalledProcessError:
         _run(["git", "fetch", "origin", f"{target_branch}:{target_branch}"], cwd=base_dir)
         _run(["git", "worktree", "add", "-B", target_branch, str(worktree_dir), target_branch], cwd=base_dir)
     _git(worktree_dir, "pull", "--rebase")
 
 
 def _lock_path(worktree_dir: Path) -> Path:
     return worktree_dir / "bot_state" / "locks" / "trader.lock.json"
 
@@ -109,41 +137,91 @@ def release_lock(worktree_dir: Path, run_id: str) -> None:
 
 def persist_run_files(worktree_dir: Path, new_files: Iterable[Path], message: str) -> None:
     worktree_dir = worktree_dir.resolve()
     files = list(new_files)
     for path in files:
         try:
             if path.resolve().is_relative_to(worktree_dir.resolve()):
                 target = path.resolve()
             else:
                 if "bot_state" in path.parts:
                     idx = path.parts.index("bot_state")
                     rel = Path(*path.parts[idx:])
                 else:
                     rel = Path("bot_state") / Path(*path.parts[-4:])
                 target = (worktree_dir / rel).resolve()
                 target.parent.mkdir(parents=True, exist_ok=True)
                 target.write_bytes(path.read_bytes())
             rel_target = target.relative_to(worktree_dir)
             _git(worktree_dir, "add", str(rel_target))
         except Exception:
             continue
     push_retry(worktree_dir, message=message)
     logger.info("[BOTSTATE][PERSIST] files=%s message=%s", len(files), message)
 
 
+def _pull_with_autostash(worktree_dir: Path, branch: str) -> bool:
+    try:
+        _git(worktree_dir, "pull", "--rebase", "--autostash", "origin", branch)
+        return True
+    except subprocess.CalledProcessError as exc:
+        stdout = exc.stdout or ""
+        stderr = exc.stderr or ""
+        if "--autostash" in stderr or "unknown option" in stderr or "unknown option" in stdout:
+            logger.warning("[BOTSTATE][GIT] --autostash unsupported fallback -> manual stash")
+            _git(worktree_dir, "stash", "push", "-u", "-m", "autostash botstate")
+            try:
+                _git(worktree_dir, "pull", "--rebase", "origin", branch)
+                return True
+            finally:
+                try:
+                    _git(worktree_dir, "stash", "pop")
+                except subprocess.CalledProcessError:
+                    logger.warning("[BOTSTATE][GIT] stash pop failed after manual autostash")
+                    raise
+        raise
+
+
 def push_retry(worktree_dir: Path, message: str, retries: int = 3) -> None:
     worktree_dir = worktree_dir.resolve()
+    branch = _git(worktree_dir, "rev-parse", "--abbrev-ref", "HEAD").stdout.strip()
     for attempt in range(1, retries + 1):
+        pull_ok = False
+        push_ok = False
+        retry_reason = ""
         try:
-            _git(worktree_dir, "commit", "-m", message)
-        except subprocess.CalledProcessError:
-            pass
-        try:
-            _git(worktree_dir, "pull", "--rebase")
-            _git(worktree_dir, "push")
-            logger.info("[BOTSTATE][PUSH] message=%s attempt=%s", message, attempt)
+            _git(worktree_dir, "fetch", "origin", branch)
+            committed = commit_if_staged(worktree_dir, message)
+            logger.info("[BOTSTATE][GIT] committed=%s msg=%s", committed, message)
+            ensure_clean_before_rebase(worktree_dir, message_for_autosave=f"autosave before {message}")
+            rev_list = _git(worktree_dir, "rev-list", "--left-right", "--count", f"origin/{branch}...HEAD").stdout.strip()
+            try:
+                behind, ahead = (int(x) for x in rev_list.split())
+            except Exception:
+                behind, ahead = 0, 0
+            logger.info("[BOTSTATE][GIT] behind=%s ahead=%s", behind, ahead)
+
+            if behind == 0 and ahead > 0:
+                _git(worktree_dir, "push")
+                push_ok = True
+            elif behind > 0:
+                pull_ok = _pull_with_autostash(worktree_dir, branch)
+                _git(worktree_dir, "push")
+                push_ok = True
+            else:
+                _git(worktree_dir, "push")
+                push_ok = True
+
+            logger.info("[BOTSTATE][GIT] push_ok=%s pull_ok=%s attempt=%s", push_ok, pull_ok, attempt)
             return
-        except subprocess.CalledProcessError as e:
+        except subprocess.CalledProcessError as exc:
+            retry_reason = (exc.stderr or "").strip() or (exc.stdout or "").strip() or str(exc)
+            logger.warning("[BOTSTATE][GIT] push_ok=%s pull_ok=%s retry_reason=%s attempt=%s", push_ok, pull_ok, retry_reason, attempt)
+            if "non-fast-forward" in retry_reason or "fetch first" in retry_reason.lower():
+                ensure_clean_before_rebase(worktree_dir, message_for_autosave=f"autosave before {message}")
+                try:
+                    pull_ok = _pull_with_autostash(worktree_dir, branch)
+                except subprocess.CalledProcessError as pull_exc:
+                    retry_reason = (pull_exc.stderr or "").strip() or (pull_exc.stdout or "").strip() or str(pull_exc)
             if attempt == retries:
                 raise
             time.sleep(2 * attempt)
diff --git a/trader/pb1_runner.py b/trader/pb1_runner.py
index 8d6acc3f2d2f3a2ae868191df6bd7d2ee369e18b..ee5183dcb00329d3ea267557caf6c57633e5a0ca 100644
--- a/trader/pb1_runner.py
+++ b/trader/pb1_runner.py
@@ -145,114 +145,117 @@ def main() -> None:
             return True
         max_wait_min = int(os.getenv("MAX_WAIT_BEFORE_MORNING_MIN", "120") or "120")
         if delta > timedelta(minutes=max_wait_min):
             logger.info("[PB1][WAIT-SKIP] delta_min=%.1f max_wait_min=%s -> exit early", delta.total_seconds() / 60, max_wait_min)
             return False
         logger.info("[PB1][WAIT] waiting until morning window start delta_sec=%.0f", delta.total_seconds())
         time.sleep(delta.total_seconds())
         return True
 
     if not _sleep_until_morning_window():
         return
     now = now_kst()
 
     os.environ.setdefault("MORNING_WINDOW_START", MORNING_WINDOW_START)
     os.environ.setdefault("MORNING_WINDOW_END", MORNING_WINDOW_END)
     os.environ.setdefault("MORNING_EXIT_START", MORNING_EXIT_START)
     os.environ.setdefault("MORNING_EXIT_END", MORNING_EXIT_END)
     os.environ.setdefault("AFTERNOON_WINDOW_START", AFTERNOON_WINDOW_START)
     os.environ.setdefault("AFTERNOON_WINDOW_END", AFTERNOON_WINDOW_END)
     os.environ.setdefault("CLOSE_AUCTION_START", CLOSE_AUCTION_START)
     os.environ.setdefault("CLOSE_AUCTION_END", CLOSE_AUCTION_END)
 
     worktree_dir = resolve_botstate_worktree_dir()
     setup_worktree(Path.cwd(), worktree_dir, target_branch=args.target_branch)
 
+    owner = os.getenv("GITHUB_ACTOR", "local")
+    run_id = os.getenv("GITHUB_RUN_ID", "local")
+    lock_acquired = acquire_lock(worktree_dir, owner=owner, run_id=run_id, ttl_sec=BOTSTATE_LOCK_TTL_SEC)
+    if not lock_acquired:
+        logger.warning("[BOTSTATE][LOCKED] owner=%s run_id=%s", owner, run_id)
+        return
+
     os.environ["STATE_PATH"] = str(worktree_dir / "trader" / "state" / "state.json")
     from trader import state_store as runtime_state_store
     state_dir = Path(os.environ["STATE_PATH"]).parent
     state_dir.mkdir(parents=True, exist_ok=True)
     state_target_path = Path(os.environ["STATE_PATH"])
 
     runtime_state = {}
     kis: KisAPI | None = None
     try:
         runtime_state = runtime_state_store.load_state()
         kis = KisAPI()
         balance = kis.get_balance()
         runtime_state = runtime_state_store.reconcile_with_kis_balance(runtime_state, balance, active_strategies={1})
         runtime_state_store.save_state(runtime_state)
     except Exception:
         logger.exception("[PB1] runtime state reconcile failed")
         runtime_state = runtime_state or runtime_state_store.load_state()
         dry_run_reasons.append("kis_init_failed")
         dry_run_reason = ",".join(dry_run_reasons)
         dry_run = True
         _apply_env_flags(dry_run)
 
     if DIAGNOSTIC_ONLY:
         logger.info("[PB1][DIAG] diagnostic_only mode -> exit")
+        release_lock(worktree_dir, run_id=run_id)
         return
 
     window = decide_window(now=now, override=args.window)
     if window is None and diag_enabled:
         window_name_for_log = "diagnostic"
         phase_for_log = "verify"
     else:
         phase_for_log = window.phase if window and hasattr(window, "phase") else "none"
         window_name_for_log = window.name if window else "none"
     logger.info(
         "[PB1][RUN-START] event=%s now_kst=%s trading_day=%s window=%s phase=%s DRY_RUN=%s DISABLE_LIVE_TRADING=%s LIVE_TRADING_ENABLED=%s STRATEGY_MODE=%s PB1_ENTRY_ENABLED=%s reasons=%s",
         event_name_lower or "unknown",
         now.isoformat(),
         trading_day,
         window_name_for_log,
         phase_for_log,
         dry_run,
         os.getenv("DISABLE_LIVE_TRADING"),
         os.getenv("LIVE_TRADING_ENABLED"),
         os.getenv("STRATEGY_MODE"),
         os.getenv("PB1_ENTRY_ENABLED"),
         dry_run_reasons or ["live"],
     )
     if window is None and not diag_enabled:
         logger.info("[PB1][WINDOW] outside active windows override=%s now=%s", args.window, now)
+        release_lock(worktree_dir, run_id=run_id)
         return
     if window is None and diag_enabled:
         window = window  # keep None, but allow diagnostic flow below
 
     if non_trading_day:
         logger.info("[PB1][SKIP] non-trading-day(%s) â†’ diagnostics/dry-run reason=%s", now.date(), dry_run_reason)
         if diag_enabled:
             logger.warning("[PB1][DIAG] non-trading-day(%s) but running diagnostics", now.date())
 
-    owner = os.getenv("GITHUB_ACTOR", "local")
-    run_id = os.getenv("GITHUB_RUN_ID", "local")
-    if not acquire_lock(worktree_dir, owner=owner, run_id=run_id, ttl_sec=BOTSTATE_LOCK_TTL_SEC):
-        logger.warning("[BOTSTATE][LOCKED] owner=%s run_id=%s", owner, run_id)
-        return
-
     touched: list[Path] = []
     try:
         engine = PB1Engine(
             kis=kis,
             worktree_dir=worktree_dir,
             window=window,
             phase_override=args.phase,
             dry_run=dry_run,
             env="paper" if dry_run else kis.env if kis else "paper",
             run_id=run_id,
         )
         touched = engine.run()
         if state_target_path.exists():
             touched.append(state_target_path)
         logger.info("[PB1] run complete touched=%s", touched)
         persist_run_files(
             worktree_dir,
             touched,
             message=f"pb1 ledger run_id={run_id} window={window.name} phase={engine.phase}",
         )
     finally:
         release_lock(worktree_dir, run_id=run_id)
 
 
 if __name__ == "__main__":
