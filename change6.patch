diff --git a/.github/workflows/trade-monitor.yml b/.github/workflows/trade-monitor.yml
index 6bf54fb1000399a15b71fc9ba5f2f8a3498f4270..94810b40a1ad862ed60105851c2a7a85d0d71fff 100644
--- a/.github/workflows/trade-monitor.yml
+++ b/.github/workflows/trade-monitor.yml
@@ -170,93 +170,98 @@ jobs:
         env:
           PYTHONPATH: ${{ github.workspace }}
         run: |
           python - << 'PY'
           import trader
           from trader import trader as t
           print("trader package path:", trader.__file__)
           print("trader.trader module path:", t.__file__)
           print("=== HEAD OF trader.trader ===")
           try:
               with open(t.__file__, 'r', encoding='utf-8') as f:
                   for i in range(1, 80):
                       line = f.readline()
                       if not line:
                           break
                       print(f"{i:03}: {line.rstrip()}")
           except Exception as e:
               print("ERROR while reading trader.trader:", e)
           PY
 
       - name: ë¦¬ë°¸ëŸ°ì‹± API ì„œë²„ ì‹¤í–‰ (FastAPI, ë°±ê·¸ë¼ìš´ë“œ, ë¡œê·¸íŒŒì¼)
         run: |
           nohup uvicorn rolling_k_auto_trade_api.main:app --host 0.0.0.0 --port 8000 > fastapi.log 2>&1 &
           sleep 30  # ì„œë²„ ê¸°ë™ ëŒ€ê¸°
 
+      - name: Compile modules
+        run: |
+          python -m compileall trader rolling_k_auto_trade_api
       - name: trader ìžë™ë§¤ë§¤ ë¡œì§ ì‹¤í–‰
         env:
           PYTHONPATH: ${{ github.workspace }}
         run: |
           python -m trader.trader
 
       - name: CEO ë¦¬í¬íŠ¸ ìžë™ ìƒì„±
         if: always()
         env:
           PYTHONPATH: ${{ github.workspace }}
         run: |
           python -m trader.report_ceo || true
 
       - name: Verify CEO report exists
         if: always()
         run: |
           ls -al trader/logs || true
 
-      - name: CEO ë¦¬í¬íŠ¸ artifact ì—…ë¡œë“œ
+      - name: Push state (plain)
+        if: github.event_name != 'pull_request'
+        run: |
+          test -f scripts/state_push_plain.sh && bash scripts/state_push_plain.sh || true
+
+      - name: Save state snapshot as artifact (audit only)
         if: always()
         uses: actions/upload-artifact@v4
         with:
-          name: ceo-report
-          path: trader/logs/*.md
-          if-no-files-found: error
+          name: trader-state-${{ github.run_id }}
+          path: |
+            trader/state/state.json
+            bot_state/state.json
+            trader/logs/CEO_Report_*.md
+            trader/logs/ledger.jsonl
           retention-days: 30
 
       - name: Rebalance JSON artifact ì—…ë¡œë“œ
         if: always()
         uses: actions/upload-artifact@v4
         with:
           name: rebalance-results
           path: rebalance_results/*.json
           if-no-files-found: warn
           retention-days: 60
 
       - name: Trades ë¡œê·¸ ì—…ë¡œë“œ
         if: always()
         uses: actions/upload-artifact@v4
         with:
           name: trade-logs
           path: trader/logs/*.json
           if-no-files-found: ignore
           retention-days: 14
 
       - name: FastAPI ë¡œê·¸ ì¶œë ¥ (cat)
         if: always()
         run: |
           echo "::group::FastAPI Server Log"
           cat fastapi.log || true
           echo "::endgroup::"
 
       - name: FastAPI ë¡œê·¸ ì—…ë¡œë“œ (artifact)
         if: always()
         uses: actions/upload-artifact@v4
         with:
           name: fastapi-log
           path: fastapi.log
           if-no-files-found: ignore
           retention-days: 14
 
-      - name: Push state (plain)
-        if: success() && github.event_name != 'pull_request'
-        run: |
-          bash scripts/state_push_plain.sh
-
-            
-          
+      
diff --git a/trader/config.py b/trader/config.py
index e7e0d81e9202f92a546b8364e1a3c07786e4598e..f1902d337e6cc3bdc7e3b88eb95f07653f76c3ea 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -81,51 +81,54 @@ CONFIG = {
     "MOM_TH_PCT": "0.5",    # fast/slow ê´´ë¦¬ ìž„ê³„ê°’(%) â€“ 0.5% ì´ìƒì´ë©´ ê°•ì„¸ë¡œ ë³¸ë‹¤
     # Subject flow gate ê¸°ë³¸ê°’
     "MIN_SMART_MONEY_RATIO_KOSPI": "0.02",
     "MIN_SMART_MONEY_RATIO_KOSDAQ": "0.03",
     "SUBJECT_FLOW_TIMEOUT_SEC": "1.2",
     "SUBJECT_FLOW_RETRY": "1",
     "SUBJECT_FLOW_CACHE_TTL_SEC": "60",
     "SUBJECT_FLOW_FAIL_POLICY": "CACHE",
     "SUBJECT_FLOW_EMPTY_POLICY": "TREAT_AS_FAIL",
     "SUBJECT_FLOW_DEGRADED_TURNOVER_MULT": "1.5",
     "SUBJECT_FLOW_DEGRADED_OB_ADD": "10",
     "SUBJECT_FLOW_MAX_CALLS_PER_RUN": "200",
 }
 
 
 def _cfg(key: str) -> str:
     """í™˜ê²½ë³€ìˆ˜ > CONFIG ê¸°ë³¸ê°’"""
     return os.getenv(key, CONFIG.get(key, ""))
 
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 LOG_DIR = Path(__file__).parent / "logs"
 LOG_DIR.mkdir(exist_ok=True)
-STATE_FILE = Path(__file__).parent / "trade_state.json"
+STATE_FILE = Path(__file__).parent / "trade_state.json"  # legacy; position state uses STATE_PATH
+STATE_DIR = Path(__file__).parent / "state"
+STATE_PATH = STATE_DIR / "state.json"
+STATE_DIR.mkdir(parents=True, exist_ok=True)
 
 # ì¢…ëª©ë³„ ì‹œìž¥ì½”ë“œ ê³ ì • ë§µ (ì‹¤ì „ì—ì„œëŠ” ë§ˆìŠ¤í„°í…Œì´ë¸” ë¡œë“œë¡œ ëŒ€ì²´ ê¶Œìž¥)
 MARKET_MAP: Dict[str, str] = {
     # ì˜ˆì‹œ: '145020': 'J', '347850': 'J', '257720': 'U', '178320': 'J', '348370': 'U'
 }
 
 # ë°ì´í„° ì—†ìŒ 1ì°¨ ê°ì§€ ìƒíƒœ ì €ìž¥(ì—°ì† DATA_EMPTY í™•ì¸ìš©)
 EXCLUDE_STATE: Dict[str, Dict[str, bool]] = {}
 
 KST = ZoneInfo("Asia/Seoul")
 
 SELL_FORCE_TIME_STR = _cfg("SELL_FORCE_TIME").strip()
 SELL_ALL_BALANCES_AT_CUTOFF = _cfg("SELL_ALL_BALANCES_AT_CUTOFF").lower() == "true"
 RATE_SLEEP_SEC = float(_cfg("API_RATE_SLEEP_SEC"))
 FORCE_SELL_PASSES_CUTOFF = int(_cfg("FORCE_SELL_PASSES_CUTOFF"))
 FORCE_SELL_PASSES_CLOSE = int(_cfg("FORCE_SELL_PASSES_CLOSE"))
 FORCE_SELL_BLOCKED_LOTS = _cfg("FORCE_SELL_BLOCKED_LOTS").lower() in ("1", "true", "yes")
 PARTIAL1 = float(_cfg("PARTIAL1"))
 PARTIAL2 = float(_cfg("PARTIAL2"))
 TRAIL_PCT = float(_cfg("TRAIL_PCT"))
 FAST_STOP = float(_cfg("FAST_STOP"))
 ATR_STOP = float(_cfg("ATR_STOP"))
 TIME_STOP_HHMM = _cfg("TIME_STOP_HHMM")
 DEFAULT_PROFIT_PCT = float(_cfg("DEFAULT_PROFIT_PCT"))
 DEFAULT_LOSS_PCT = float(_cfg("DEFAULT_LOSS_PCT"))
diff --git a/trader/execution.py b/trader/execution.py
index 6b21039f911c22cff22043d830d850b2548806d1..f2b8ee0ad24221b98ef794f21c9671d80fdf87d6 100644
--- a/trader/execution.py
+++ b/trader/execution.py
@@ -1,79 +1,239 @@
 """í¬ì§€ì…˜ ì´ˆê¸°í™”, ì²´ê²°, ë ˆì§ ê´€ë ¨ ê¸°ëŠ¥."""
 from __future__ import annotations
 
 import logging
 
 import csv
 import json
 import os
 import time
 from datetime import datetime, time as dtime, timedelta
 from pathlib import Path
 from typing import Any, Dict, List, Optional, Tuple
 
 import requests
 
 from .core_constants import *  # noqa: F401,F403
+from .config import KST, STATE_PATH
 from .core_utils import (
     _get_daily_candles_cached,
     _log_realized_pnl,
     _round_to_tick,
     _to_float,
     _to_int,
     _with_retry,
     log_trade,
 )
 from .kis_wrapper import KisAPI, NetTemporaryError
 from .fills import append_fill
 from .signals import (
     _get_atr,
     _notional_to_qty,
     _safe_get_price,
     _weight_to_qty,
     get_20d_return_pct,
     is_strong_momentum,
     _detect_pullback_reversal,
 )
 from .metrics import vwap_guard
 
 __all__ = [
     "fetch_rebalancing_targets",
     "_init_position_state",
     "_init_position_state_from_balance",
     "_maybe_scale_in_dips",
     "_sell_once",
     "ensure_fill_has_name",
     "compute_entry_target",
     "place_buy_with_fallback",
     "_get_kosdaq_snapshot",
     "_update_market_regime",
     "log_champion_and_regime",
     "_adaptive_exit",
     "REGIME_STATE",
+    "record_entry_state",
+    "update_position_meta",
+    "update_position_flags",
 ]
 
+
+def _normalize_entry_meta(
+    *,
+    code: str,
+    strategy_id: Any,
+    engine: str,
+    entry_reason: str,
+    order_type: str | None,
+    best_k: Any,
+    tgt_px: Any,
+    gap_pct_at_entry: Any,
+    entry_time: str | None = None,
+) -> Dict[str, Any]:
+    return {
+        "time": entry_time or datetime.now(KST).isoformat(),
+        "strategy_id": strategy_id,
+        "engine": engine,
+        "entry_reason": entry_reason,
+        "order_type": order_type,
+        "best_k": best_k,
+        "tgt_px": tgt_px,
+        "gap_pct_at_entry": gap_pct_at_entry,
+    }
+
+
+def _normalize_meta(payload: Dict[str, Any] | None) -> Dict[str, Any]:
+    payload = payload or {}
+    return {
+        "pullback_peak_price": payload.get("pullback_peak_price"),
+        "pullback_reversal_price": payload.get("pullback_reversal_price"),
+        "pullback_reason": payload.get("pullback_reason"),
+    }
+
+
+def _normalize_flags(payload: Dict[str, Any] | None) -> Dict[str, Any]:
+    payload = payload or {}
+    return {
+        "bear_s1_done": bool(payload.get("bear_s1_done", False)),
+        "bear_s2_done": bool(payload.get("bear_s2_done", False)),
+    }
+
+
+def record_entry_state(
+    *,
+    state: Dict[str, Any],
+    code: str,
+    qty: int,
+    avg_price: float,
+    strategy_id: Any,
+    engine: str,
+    entry_reason: str,
+    order_type: str | None,
+    best_k: Any,
+    tgt_px: Any,
+    gap_pct_at_entry: Any,
+    meta: Dict[str, Any] | None = None,
+    flags: Dict[str, Any] | None = None,
+    entry_time: str | None = None,
+) -> Dict[str, Any]:
+    code_key = str(code).zfill(6)
+    sid_key = str(strategy_id)
+    pos = state.setdefault("positions", {}).setdefault(
+        code_key,
+        {
+            "entries": {},
+            "flags": {"bear_s1_done": False, "bear_s2_done": False},
+            "broker_qty": None,
+            "broker_avg_price": None,
+            "miss_count": 0,
+        },
+    )
+    entries = pos.setdefault("entries", {})
+    entries[sid_key] = {
+        "qty": int(qty),
+        "avg_price": float(avg_price),
+        "entry": _normalize_entry_meta(
+            code=str(code),
+            strategy_id=strategy_id,
+            engine=engine,
+            entry_reason=entry_reason,
+            order_type=order_type,
+            best_k=best_k,
+            tgt_px=tgt_px,
+            gap_pct_at_entry=gap_pct_at_entry,
+            entry_time=entry_time,
+        ),
+        "meta": _normalize_meta(meta),
+    }
+    if flags:
+        update_position_flags(state, code, flags)
+    logger.info(
+        "[ENTRY] code=%s strategy=%s engine=%s best_k=%s tgt_px=%s saved_state=OK",
+        code_key,
+        strategy_id,
+        engine,
+        best_k,
+        tgt_px,
+    )
+    return state
+
+
+def update_position_meta(
+    state: Dict[str, Any],
+    code: str,
+    strategy_id: Any,
+    meta_updates: Dict[str, Any] | None = None,
+) -> Dict[str, Any]:
+    code_key = str(code).zfill(6)
+    sid_key = str(strategy_id)
+    pos = state.get("positions", {}).get(code_key)
+    if not isinstance(pos, dict):
+        return state
+    entries = pos.get("entries", {})
+    entry = entries.get(sid_key)
+    if not isinstance(entry, dict):
+        return state
+    meta = entry.setdefault(
+        "meta",
+        {
+            "pullback_peak_price": None,
+            "pullback_reversal_price": None,
+            "pullback_reason": None,
+        },
+    )
+    if meta_updates:
+        for key in ("pullback_peak_price", "pullback_reversal_price", "pullback_reason"):
+            if key in meta_updates:
+                meta[key] = meta_updates.get(key)
+    return state
+
+
+def update_position_flags(
+    state: Dict[str, Any],
+    code: str,
+    flag_updates: Dict[str, Any],
+) -> Dict[str, Any]:
+    code_key = str(code).zfill(6)
+    pos = state.get("positions", {}).get(code_key)
+    if not isinstance(pos, dict):
+        return state
+    flags = pos.setdefault(
+        "flags",
+        {"bear_s1_done": False, "bear_s2_done": False},
+    )
+    before_flags = dict(flags)
+    for key in ("bear_s1_done", "bear_s2_done"):
+        if key in flag_updates:
+            flags[key] = bool(flag_updates.get(key))
+    logger.info(
+        "[FLAGS] code=%s flags_before=%s flags_after=%s",
+        code_key,
+        before_flags,
+        flags,
+    )
+    return state
+
 def fetch_rebalancing_targets(date: str) -> list[dict[str, Any]]:
     REBALANCE_API_URL = f"http://localhost:8000/rebalance/run/{date}?force_order=true"
     response = requests.post(REBALANCE_API_URL)
     logger.info(f"[ðŸ›°ï¸ ë¦¬ë°¸ëŸ°ì‹± API ì „ì²´ ì‘ë‹µ]: {response.text}")
     if response.status_code == 200:
         data = response.json()
         selected = data.get("selected") or data.get("selected_stocks") or []
         logger.info(f"[ðŸŽ¯ ë¦¬ë°¸ëŸ°ì‹± ì¢…ëª©]: {selected}")
         try:
             champion = selected[0] if selected else None
             log_champion_and_regime(logger, champion, REGIME_STATE, context="rebalance_api")
         except Exception as e:
             logger.exception(f"[VWAP_CHAMPION_LOG_ERROR] {e}")
         return selected
     raise Exception(f"ë¦¬ë°¸ëŸ°ì‹± API í˜¸ì¶œ ì‹¤íŒ¨: {response.text}")
 
 def _init_position_state(kis: KisAPI, holding: Dict[str, Any], code: str, entry_price: float, qty: int, k_value: Any, target_price: Optional[float]) -> None:
     try:
         _ = kis.is_market_open()
     except Exception:
         pass
     atr = _get_atr(kis, code)
     rng_eff = (atr * 1.5) if (atr and atr > 0) else max(1.0, entry_price * 0.01)
     t1 = entry_price + 0.5 * rng_eff
     t2 = entry_price + 1.0 * rng_eff
@@ -124,50 +284,51 @@ def _init_position_state_from_balance(kis: KisAPI, holding: Dict[str, Any], code
         'sold_p2': False,
         'trail_pct': TRAIL_PCT,
         'atr': float(atr) if atr else None,
         'stop_abs': float(avg_price - ATR_STOP * atr) if atr else float(avg_price * (1 - FAST_STOP)),
         'k_value': None,
         'target_price_src': None,
         'bear_s1_done': False,
         'bear_s2_done': False,
         # ê¸°ì¡´ ë³´ìœ ë¶„ì€ ì¶”ê°€ ì§„ìž…(stage 3 ì™„ë£Œ ìƒíƒœ)ìœ¼ë¡œ ê°„ì£¼
         'entry_stage': 3,
         'max_price_after_entry': float(avg_price),
         'planned_total_qty': int(qty),
         'stage1_qty': int(qty),
         'stage2_qty': 0,
         'stage3_qty': 0,
     }
 
 
 def _maybe_scale_in_dips(
     kis: KisAPI,
     holding: Dict[str, Any],
     code: str,
     target: Dict[str, Any],
     now_str: str,
     regime_mode: str,
+    position_state: Dict[str, Any] | None = None,
 ) -> None:
     """
     ì‹ ê³ ê°€ â†’ 3ì¼ ì—°ì† í•˜ë½ â†’ ë°˜ë“± í™•ì¸ ì‹œ ë‹¨ê³„ì  ì¶”ê°€ ë§¤ìˆ˜ ë¡œì§.
     - entry_stage: 1 â†’ 2ì°¨ ì§„ìž… í›„ë³´(ë°˜ë“± í™•ì¸ì„  ëŒíŒŒ), 2 â†’ 3ì°¨ ì§„ìž… í›„ë³´(ì‹ ê³ ê°€ íšŒë³µ)
     - bull / neutral ëª¨ë“œì—ì„œë§Œ ë™ìž‘, bear ëª¨ë“œì—ì„œëŠ” ì¶”ê°€ ì§„ìž… ê¸ˆì§€
     """
     pos = holding.get(code)
     if not pos:
         return
 
     # ì•½ì„¸ ë ˆì§ì—ì„œëŠ” ì¶”ê°€ ì§„ìž… ê¸ˆì§€
     if regime_mode not in ("bull", "neutral"):
         return
 
     entry_stage = int(pos.get("entry_stage") or 1)
     if entry_stage >= 3:
         return
 
     # í˜„ìž¬ê°€ ì¡°íšŒ
     try:
         cur_price = _safe_get_price(kis, code)
     except Exception:
         cur_price = None
     if cur_price is None or cur_price <= 0:
         return
@@ -223,50 +384,61 @@ def _maybe_scale_in_dips(
     # ì‹ ê³ ê°€ â†’ 3ì¼ ëˆŒë¦¼ â†’ ë°˜ë“± ì—¬ë¶€ í™•ì¸
     pullback = _detect_pullback_reversal(
         kis=kis,
         code=code,
         current_price=float(cur_price),
     )
     if USE_PULLBACK_ENTRY and not pullback.get("setup"):
         logger.info(
             f"[PULLBACK-SKIP] {code}: ì‹ ê³ ê°€ ëˆŒë¦¼ íŒ¨í„´ ë¯¸ì¶©ì¡± â†’ reason={pullback.get('reason')}"
         )
         return
 
     if USE_PULLBACK_ENTRY and not pullback.get("reversing"):
         rev_px = pullback.get("reversal_price")
         logger.info(
             f"[PULLBACK-WAIT] {code}: í˜„ìž¬ê°€({cur_price}) < ë°˜ë“±í™•ì¸ì„ ({rev_px}) â†’ ëŒ€ê¸°"
         )
         return
 
     reversal_price = pullback.get("reversal_price") or float(cur_price)
     peak_price = pullback.get("peak_price") or reversal_price
 
     # ì°¸ê³ ìš© ìƒíƒœ ì—…ë°ì´íŠ¸
     pos["pullback_peak_price"] = float(peak_price)
     pos["pullback_reversal_price"] = float(reversal_price)
+    if position_state is not None:
+        update_position_meta(
+            position_state,
+            code,
+            pos.get("strategy_id") or 1,
+            {
+                "pullback_peak_price": float(peak_price),
+                "pullback_reversal_price": float(reversal_price),
+                "pullback_reason": pullback.get("reason"),
+            },
+        )
 
     add_qty = 0
     next_stage = entry_stage
 
     if entry_stage == 1:
         # 2ì°¨ ì§„ìž…: 3ì¼ ëˆŒë¦¼ í›„ ë°˜ë“± í™•ì¸ì„  ëŒíŒŒ â†’ s1+s2ê¹Œì§€ í™•ëŒ€
         if cur_price >= reversal_price and current_qty < (s1 + s2):
             add_qty = max(0, (s1 + s2) - current_qty)
             next_stage = 2
     elif entry_stage == 2:
         # 3ì°¨ ì§„ìž…: ì‹ ê³ ê°€ íšŒë³µ(peak_price ëŒíŒŒ) ì‹œ ì „ì²´ planned_total_qtyê¹Œì§€ í™•ëŒ€
         if cur_price >= peak_price and current_qty < planned_total_qty:
             add_qty = max(0, planned_total_qty - current_qty)
             next_stage = 3
     else:
         return
 
     if add_qty <= 0:
         return
 
     logger.info(
         f"[SCALE-IN] {code} stage={entry_stage}->{next_stage} "
         f"reversal_line={reversal_price:.2f} peak={peak_price:.2f} cur={cur_price} add_qty={add_qty}"
     )
 
@@ -1016,27 +1188,25 @@ def _adaptive_exit(
 
         # ì‹¤í˜„ì†ìµ ë¡œê·¸
         try:
             log_trade(
                 {
                     "datetime": now.strftime("%Y-%m-%d %H:%M:%S"),
                     "code": code,
                     "name": pos.get("name"),
                     "side": "SELL",
                     "qty": int(sold_qty),
                     "price": float(exec_px) if exec_px is not None else float(cur),
                     "amount": int(sold_qty) * int(exec_px or cur),
                     "reason": reason,
                     "regime_mode": regime_mode,
                 }
             )
         except Exception as e:
             logger.warning(f"[EXIT-LOG-FAIL] {code}: {e}")
 
     except Exception as e:
         logger.error(f"[SELL-FAIL] {code} qty={sell_size} err={e}")
         # ë§¤ë„ ì‹¤íŒ¨ ì‹œì—ëŠ” ìƒíƒœ ì›ë³µí•˜ì§€ ì•Šê³ , ë‹¤ìŒ ë£¨í”„ì—ì„œ ë‹¤ì‹œ íŒë‹¨
         return None, None, None, None
 
     return reason, exec_px, result, sold_qty
-
-
diff --git a/trader/exit_allocation.py b/trader/exit_allocation.py
new file mode 100644
index 0000000000000000000000000000000000000000..ed91cf578f3652e75b1d659ae0970af8d0db59a7
--- /dev/null
+++ b/trader/exit_allocation.py
@@ -0,0 +1,138 @@
+from __future__ import annotations
+
+from typing import Any, Dict, List, Optional
+
+from trader.ledger import apply_sell_fill_fifo, dominant_strategy_for
+
+def _strategy_qty_map(lot_state: Dict[str, Any], code: str) -> Dict[str, int]:
+    lots = lot_state.get("lots", [])
+    code_key = str(code).zfill(6)
+    totals: Dict[str, int] = {}
+    if not isinstance(lots, list):
+        return totals
+    for lot in lots:
+        if str(lot.get("pdno") or "").zfill(6) != code_key:
+            continue
+        remaining = int(lot.get("remaining_qty") or 0)
+        if remaining <= 0:
+            continue
+        sid = lot.get("strategy_id")
+        if sid is None:
+            continue
+        sid_key = str(sid)
+        totals[sid_key] = totals.get(sid_key, 0) + remaining
+    return totals
+
+
+def allocate_sell_qty(
+    lot_state: Dict[str, Any],
+    code: str,
+    requested_qty: int,
+    *,
+    scope: str,
+    trigger_strategy_id: Optional[Any] = None,
+) -> List[Dict[str, Any]]:
+    code = str(code).zfill(6)
+    requested_qty = int(requested_qty)
+    if requested_qty <= 0:
+        return []
+
+    if scope == "strategy":
+        if trigger_strategy_id is None:
+            return []
+        totals = _strategy_qty_map(lot_state, code)
+        trigger_key = str(trigger_strategy_id)
+        qty = min(requested_qty, int(totals.get(trigger_key, 0)))
+        return (
+            [{"strategy_id": trigger_key, "qty": int(qty)}]
+            if qty > 0
+            else []
+        )
+
+    totals = _strategy_qty_map(lot_state, code)
+    if not totals:
+        return []
+
+    if scope == "dominant":
+        dominant = dominant_strategy_for(lot_state, code)
+        if dominant is None:
+            return []
+        dominant_key = str(dominant)
+        qty = min(requested_qty, totals.get(dominant_key, 0))
+        return [{"strategy_id": dominant_key, "qty": int(qty)}] if qty > 0 else []
+
+    if scope != "proportional":
+        return []
+
+    total_qty = sum(totals.values())
+    if total_qty <= 0:
+        return []
+    requested_qty = min(requested_qty, total_qty)
+    allocations: List[Dict[str, Any]] = []
+    remaining = requested_qty
+    strategy_ids = sorted(totals.keys())
+    for sid in strategy_ids[:-1]:
+        ratio_qty = int(requested_qty * (totals[sid] / total_qty))
+        qty = min(ratio_qty, totals[sid], remaining)
+        if qty > 0:
+            allocations.append({"strategy_id": sid, "qty": int(qty)})
+            remaining -= qty
+    if remaining > 0:
+        last_sid = strategy_ids[-1]
+        qty = min(remaining, totals[last_sid])
+        if qty > 0:
+            allocations.append({"strategy_id": last_sid, "qty": int(qty)})
+    return allocations
+
+
+def apply_sell_allocation(
+    lot_state: Dict[str, Any],
+    code: str,
+    allocations: List[Dict[str, Any]],
+    sell_ts: str,
+    *,
+    allow_blocked: bool = False,
+) -> int:
+    sold_total = 0
+    for alloc in allocations:
+        qty = int(alloc.get("qty") or 0)
+        sid = alloc.get("strategy_id", None)
+        if qty <= 0:
+            continue
+        apply_sell_fill_fifo(
+            lot_state,
+            pdno=str(code).zfill(6),
+            qty_filled=qty,
+            sell_ts=sell_ts,
+            strategy_id=sid,
+            allow_blocked=allow_blocked,
+        )
+        sold_total += qty
+    return sold_total
+
+
+def run_allocation_self_checks() -> None:
+    lot_state = {
+        "lots": [
+            {"pdno": "000001", "strategy_id": 1, "remaining_qty": 7},
+            {"pdno": "000001", "strategy_id": 5, "remaining_qty": 3},
+            {"pdno": "000001", "strategy_id": "ORPHAN", "remaining_qty": 5},
+        ]
+    }
+    allocations = allocate_sell_qty(
+        lot_state, "000001", 10, scope="proportional", trigger_strategy_id=None
+    )
+    assert sum(a["qty"] for a in allocations) == 10
+    allocations = allocate_sell_qty(
+        lot_state, "000001", 5, scope="strategy", trigger_strategy_id=1
+    )
+    assert allocations and all(a["strategy_id"] == "1" for a in allocations)
+    allocations = allocate_sell_qty(
+        lot_state, "000001", 10, scope="proportional", trigger_strategy_id=None
+    )
+    allocated_strategies = {a["strategy_id"] for a in allocations}
+    assert "ORPHAN" in allocated_strategies
+
+
+if __name__ == "__main__":
+    run_allocation_self_checks()
diff --git a/trader/legacy_kosdaq_runner.py b/trader/legacy_kosdaq_runner.py
index 6cfd01a59e3e9870e60c3c5f0d31bc870c43bc39..de3a1d23b3335168a0c5b396c7be8a671a0357a4 100644
--- a/trader/legacy_kosdaq_runner.py
+++ b/trader/legacy_kosdaq_runner.py
@@ -1,97 +1,108 @@
 # -*- coding: utf-8 -*-
 """ê±°ëž˜ ë©”ì¸ ë£¨í”„.
 
 ê¸°ì¡´ trader.pyì˜ ì„¤ì •/ìœ í‹¸ì„ ë¶„ë¦¬í•˜ê³ , ë©”ì¸ ì§„ìž…ì ë§Œ ë‚¨ê²¨ ì „ëžµ ì¶”ê°€ê°€
 ì‰¬ìš´ êµ¬ì¡°ë¡œ ë³€ê²½í–ˆë‹¤.
 """
 from __future__ import annotations
 
 import json
 import re
 import time
 from datetime import date, datetime, time as dtime, timedelta
 from typing import Any, Dict, List, Tuple, TYPE_CHECKING
 
 
 try:
     from .config import (
         DAILY_CAPITAL,
+        FAST_STOP,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         FORCE_SELL_BLOCKED_LOTS,
         ALLOW_WHEN_CLOSED,
         ALLOW_PYRAMID,
         BASE_QTY_MODE,
         KST,
         LOG_DIR,
         RATE_SLEEP_SEC,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
+        STATE_PATH,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         _cfg,
         logger,
     )
 except ImportError:
     # ALLOW_WHEN_CLOSEDê°€ ëˆ„ë½ë¼ë„ ëŸ¬ë„ˆê°€ ì¦‰ì‹œ ì¤‘ë‹¨ë˜ì§€ ì•Šë„ë¡ ì•ˆì „í•œ ê¸°ë³¸ê°’ì„ ì œê³µí•œë‹¤.
     from .config import (
         DAILY_CAPITAL,
+        FAST_STOP,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         FORCE_SELL_BLOCKED_LOTS,
         KST,
         LOG_DIR,
         BASE_QTY_MODE,
         RATE_SLEEP_SEC,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
+        STATE_PATH,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         _cfg,
         logger,
     )
 
     ALLOW_WHEN_CLOSED = False
     logger.warning("[CONFIG] ALLOW_WHEN_CLOSED missing; defaulting to False")
     ALLOW_PYRAMID = False
     logger.warning("[CONFIG] ALLOW_PYRAMID missing; defaulting to False")
 from . import signals
 from trader.time_utils import MARKET_CLOSE, MARKET_OPEN, is_trading_day
 from trader.subject_flow import get_subject_flow_with_fallback, reset_flow_call_count
+from trader.execution import record_entry_state
+from trader.exit_allocation import allocate_sell_qty, apply_sell_allocation
 from trader.ledger import (
     apply_sell_fill_fifo,
     dominant_strategy_for,
     record_buy_fill,
     remaining_qty_for_strategy,
     reconcile_with_broker_holdings,
 )
-from trader.state_store import load_state as load_lot_state, save_state as save_lot_state
+from trader.lot_state_store import load_lot_state, save_lot_state
+from trader.position_state_store import (
+    load_position_state,
+    reconcile_with_broker,
+    save_position_state,
+)
 from .core import *  # noqa: F401,F403 - ì „ëžµ ìœ í‹¸ ì „ì²´ ë…¸ì¶œë¡œ í™•ìž¥ì„± í™•ë³´
 
 if TYPE_CHECKING:
     # core ìª½ì— êµ¬í˜„ë¼ ìžˆëŠ” í—¬í¼ë“¤ì„ íƒ€ìž…ì²´ì»¤ì—ê²Œë§Œ ëª…ì‹œì ìœ¼ë¡œ ì•Œë ¤ì¤€ë‹¤.
     from .core import (
         _this_iso_week_key,
         _get_effective_ord_cash,
         _to_float,
         _to_int,
         _weight_to_qty,
         _classify_champion_grade,
         _update_market_regime,
         _notional_to_qty,
         _fetch_balances,
         _init_position_state_from_balance,
         _sell_once,
         _adaptive_exit,
         _compute_daily_entry_context,
         _compute_intraday_entry_context,
         _safe_get_price,
         _round_to_tick,
         _init_position_state,
         _detect_pullback_reversal,
         _has_bullish_trend_structure,
     )
@@ -107,53 +118,55 @@ def main(
     )
     kis = KisAPI()
 
     rebalance_date = get_rebalance_anchor_date()
     logger.info(
         f"[â„¹ï¸ ë¦¬ë°¸ëŸ°ì‹± ê¸°ì¤€ì¼(KST)]: {rebalance_date} (anchor={REBALANCE_ANCHOR}, ref={WEEKLY_ANCHOR_REF})"
     )
     logger.info(
         f"[â±ï¸ ì»¤íŠ¸ì˜¤í”„(KST)] SELL_FORCE_TIME={SELL_FORCE_TIME.strftime('%H:%M')} / ì „ì²´ìž”ê³ ë§¤ë„={SELL_ALL_BALANCES_AT_CUTOFF} / "
         f"íŒ¨ìŠ¤(ì»¤íŠ¸ì˜¤í”„/ë§ˆê°)={FORCE_SELL_PASSES_CUTOFF}/{FORCE_SELL_PASSES_CLOSE}"
     )
     logger.info(
         f"[ðŸ’° CAPITAL] {effective_capital:,}ì› (configured DAILY_CAPITAL={DAILY_CAPITAL:,})"
     )
     logger.info(f"[ðŸ›¡ï¸ SLIPPAGE_ENTER_GUARD_PCT] {SLIPPAGE_ENTER_GUARD_PCT:.2f}%")
 
     # ìƒíƒœ ë³µêµ¬
     state_loaded_at = datetime.now(KST)
     state_loaded_date = state_loaded_at.strftime("%Y-%m-%d")
     state_loaded_str = state_loaded_at.strftime("%Y-%m-%d %H:%M:%S")
     state_loaded_midnight = f"{state_loaded_date} 00:00:00"
 
     holding, traded = load_state()
     lot_state_path = "bot_state/state.json"
     lot_state = load_lot_state(lot_state_path)
+    position_state_path = str(STATE_PATH)
+    position_state = load_position_state(position_state_path)
+    position_state_dirty = False
     triggered_today: set[str] = set()
     s1_done_today: set[str] = set()
-    last_price_map: dict[str, float] = {}
     last_today_prefix: str | None = None
 
     if isinstance(traded, (set, list, tuple)):
         logger.warning(
             f"[STATE-MIGRATE] traded íƒ€ìž… {type(traded)} â†’ dictë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜(ì¤‘ë³µ ì§„ìž… ê°€ë“œ ìœ ì§€)"
         )
         traded = {
             code: {"buy_time": state_loaded_midnight, "qty": 0, "price": 0.0}
             for code in traded
         }
     elif not isinstance(traded, dict):
         logger.warning(
             f"[STATE-FORMAT] traded íƒ€ìž… {type(traded)} ì§€ì› ì•ˆ í•¨ â†’ ë¹ˆ dictë¡œ ìž¬ì„¤ì •"
         )
         traded = {}
 
     def _traded_codes(traded_state: Any) -> List[str]:
         if isinstance(traded_state, dict):
             return list(traded_state.keys())
         return []
 
     def _traded_today(traded_state: Any, today_prefix: str) -> set:
         if not isinstance(traded_state, dict):
             return set()
 
@@ -173,57 +186,164 @@ def main(
         try:
             traded_state[code] = payload
         except Exception:
             logger.warning(
                 f"[TRADED-STATE] tradedì— ì½”ë“œ ì¶”ê°€ ì‹¤íŒ¨: type={type(traded_state)}"
             )
 
     def _lot_state_signature(state: dict) -> tuple:
         lots = state.get("lots")
         if not isinstance(lots, list):
             return tuple()
         return tuple(
             (
                 str(lot.get("lot_id")),
                 str(lot.get("pdno")),
                 int(lot.get("remaining_qty") or 0),
             )
             for lot in lots
         )
 
     def _maybe_save_lot_state(before_signature: tuple) -> None:
         after_signature = _lot_state_signature(lot_state)
         if after_signature != before_signature:
             save_lot_state(lot_state_path, lot_state)
 
+    def _ensure_position_entry(
+        code: str, strategy_id: int | str
+    ) -> Dict[str, Any]:
+        code_key = str(code).zfill(6)
+        sid_key = str(strategy_id)
+        pos = position_state.setdefault("positions", {}).setdefault(
+            code_key,
+            {
+                "entries": {},
+                "flags": {"bear_s1_done": False, "bear_s2_done": False},
+                "broker_qty": None,
+                "broker_avg_price": None,
+                "miss_count": 0,
+            },
+        )
+        entries = pos.setdefault("entries", {})
+        entry = entries.get(sid_key)
+        if isinstance(entry, dict):
+            return entry
+        now_ts = datetime.now(KST).isoformat()
+        entry = {
+            "qty": int((holding.get(code) or {}).get("qty") or 0),
+            "avg_price": float((holding.get(code) or {}).get("buy_price") or 0.0),
+            "entry": {
+                "time": now_ts,
+                "strategy_id": sid_key,
+                "engine": "unknown",
+                "entry_reason": "RECONCILE",
+                "order_type": "unknown",
+                "best_k": None,
+                "tgt_px": None,
+                "gap_pct_at_entry": None,
+            },
+            "meta": {
+                "pullback_peak_price": None,
+                "pullback_reversal_price": None,
+                "pullback_reason": None,
+            },
+        }
+        entries[sid_key] = entry
+        return entry
+
+    def _set_position_flags(code: str, **flags: bool) -> None:
+        nonlocal position_state_dirty
+        pos = position_state.setdefault("positions", {}).setdefault(
+            str(code).zfill(6),
+            {
+                "entries": {},
+                "flags": {"bear_s1_done": False, "bear_s2_done": False},
+                "broker_qty": None,
+                "broker_avg_price": None,
+                "miss_count": 0,
+            },
+        )
+        flags_before = dict(pos.get("flags") or {})
+        entry_flags = pos.setdefault(
+            "flags",
+            {"bear_s1_done": False, "bear_s2_done": False},
+        )
+        for key, value in flags.items():
+            entry_flags[key] = bool(value)
+            if code in holding:
+                holding[code][key] = bool(value)
+        logger.info(
+            "[FLAGS] code=%s flags_before=%s flags_after=%s",
+            str(code).zfill(6),
+            flags_before,
+            entry_flags,
+        )
+        position_state_dirty = True
+
+    def _update_last_price_memory(code: str, current_price: float, now_ts: str) -> None:
+        nonlocal position_state_dirty
+        memory = position_state.setdefault("memory", {})
+        memory.setdefault("last_price", {})[str(code).zfill(6)] = float(current_price)
+        memory.setdefault("last_seen", {})[str(code).zfill(6)] = now_ts
+        position_state_dirty = True
+
+    def _pullback_stop_hit(
+        code: str, current_price: float, strategy_id: int | str = 5
+    ) -> bool:
+        pos = position_state.get("positions", {}).get(str(code).zfill(6))
+        if not isinstance(pos, dict):
+            return False
+        entries = pos.get("entries", {})
+        entry = entries.get(str(strategy_id))
+        if not isinstance(entry, dict):
+            return False
+        meta = entry.get("meta", {}) or {}
+        reversal_price = meta.get("pullback_reversal_price")
+        if reversal_price is None:
+            return False
+        try:
+            return float(current_price) < float(reversal_price) * (1 - FAST_STOP)
+        except Exception:
+            return False
+
     def _remaining_qty_for(pdno: str) -> int:
         return sum(
             int(lot.get("remaining_qty") or 0)
             for lot in lot_state.get("lots", [])
             if str(lot.get("pdno")).zfill(6) == str(pdno).zfill(6)
         )
 
+    def _ledger_total_available_qty(code: str) -> int:
+        return sum(
+            int(lot.get("remaining_qty") or 0)
+            for lot in lot_state.get("lots", [])
+            if str(lot.get("pdno")).zfill(6) == str(code).zfill(6)
+        )
+
+    def _cap_sell_qty(code: str, requested_qty: int) -> int:
+        return min(int(requested_qty), int(_ledger_total_available_qty(code)))
+
     def _normalize_strategy_id(value: Any) -> int:
         try:
             strategy_num = int(value)
         except Exception:
             return 1
         if 1 <= strategy_num <= 5:
             return strategy_num
         return 1
 
     def _derive_strategy_id(payload: Dict[str, Any]) -> int:
         raw = (
             payload.get("strategy_id")
             or payload.get("strategyId")
             or payload.get("strategy_no")
             or payload.get("strategyNo")
         )
         if raw is not None and str(raw).isdigit():
             strategy_id = _normalize_strategy_id(raw)
             if strategy_id != int(raw):
                 logger.info(
                     "[STRATEGY_ID_NORMALIZE] raw=%s -> %s (clamped)",
                     raw,
                     strategy_id,
                 )
             return strategy_id
@@ -296,72 +416,113 @@ def main(
         if requested_qty <= 0:
             return 0
         try:
             time.sleep(delay_sec)
             try:
                 balances = _fetch_balances(kis, ttl_sec=0)
             except TypeError:
                 balances = _fetch_balances(kis)
         except Exception:
             return int(requested_qty)
         for row in balances:
             if str(row.get("code")).zfill(6) != str(code).zfill(6):
                 continue
             new_qty = int(row.get("qty") or 0)
             sold = max(0, int(prev_qty) - int(new_qty))
             if sold <= 0:
                 return 0
             return min(int(requested_qty), int(sold))
         return int(requested_qty)
 
     def _apply_sell_to_ledger_with_balance(
         code: str,
         requested_qty: int,
         sell_ts: str,
         result: Any,
-        strategy_id: int | None = None,
+        scope: str = "proportional",
+        trigger_strategy_id: int | None = None,
         prev_qty_before: int | None = None,
         allow_blocked: bool = False,
     ) -> None:
         if not _is_order_success(result):
             return
         prev_qty = int(prev_qty_before if prev_qty_before is not None else (holding.get(code) or {}).get("qty") or requested_qty)
-        if strategy_id is not None:
-            available_qty = remaining_qty_for_strategy(lot_state, code, strategy_id)
-            requested_qty = min(int(requested_qty), int(available_qty))
-            if requested_qty <= 0:
-                return
         sold_qty = _estimate_sold_qty(code, requested_qty, prev_qty)
         if sold_qty <= 0:
             return
+        if scope == "strategy" and trigger_strategy_id is None:
+            scope = "proportional"
         before_lot_signature = _lot_state_signature(lot_state)
-        _apply_sell_to_ledger(
+        allocations = allocate_sell_qty(
+            lot_state,
             code,
             int(sold_qty),
+            scope=scope,
+            trigger_strategy_id=trigger_strategy_id,
+        )
+        if not allocations:
+            if sold_qty > 0:
+                now_ts = datetime.now(KST).isoformat()
+                lot_state.setdefault("lots", []).append(
+                    {
+                        "lot_id": f"{str(code).zfill(6)}-ORPHAN-{now_ts}",
+                        "pdno": str(code).zfill(6),
+                        "strategy_id": "ORPHAN",
+                        "engine": "orphan",
+                        "entry_ts": now_ts,
+                        "entry_price": 0.0,
+                        "qty": int(sold_qty),
+                        "remaining_qty": int(sold_qty),
+                        "meta": {"reconciled": True},
+                    }
+                )
+                apply_sell_fill_fifo(
+                    lot_state,
+                    pdno=str(code).zfill(6),
+                    qty_filled=int(sold_qty),
+                    sell_ts=sell_ts,
+                    strategy_id="ORPHAN",
+                    allow_blocked=allow_blocked,
+                )
+                _maybe_save_lot_state(before_lot_signature)
+            return
+        broker_qty_after = max(0, int(prev_qty) - int(sold_qty))
+        logger.info(
+            "[SELL-ALLOC] code=%s requested_qty=%s scope=%s allocations=%s sold_qty=%s broker_qty_before=%s broker_qty_after=%s",
+            str(code).zfill(6),
+            int(requested_qty),
+            scope,
+            allocations,
+            int(sold_qty),
+            int(prev_qty),
+            int(broker_qty_after),
+        )
+        apply_sell_allocation(
+            lot_state,
+            code,
+            allocations,
             sell_ts,
-            result,
-            strategy_id=strategy_id,
             allow_blocked=allow_blocked,
         )
         _maybe_save_lot_state(before_lot_signature)
 
     def _apply_sell_to_ledger(
         pdno: str,
         qty: int,
         sell_ts: str,
         result: Any,
         strategy_id: int | None = None,
         allow_blocked: bool = False,
     ) -> None:
         if not _is_order_success(result):
             return
         before = _remaining_qty_for(pdno)
         apply_sell_fill_fifo(
             lot_state,
             pdno=pdno,
             qty_filled=qty,
             sell_ts=sell_ts,
             strategy_id=strategy_id,
             allow_blocked=allow_blocked,
         )
         after = _remaining_qty_for(pdno)
         logger.info(
@@ -1148,63 +1309,87 @@ def main(
             else:
                 closed_checks = 0
 
             if kis.should_cooldown(now_dt_kst):
                 logger.warning("[COOLDOWN] 2ì´ˆê°„ ëŒ€ê¸° (API ì œí•œ ë³´í˜¸)")
                 time.sleep(2)
 
             # ìž”ê³  ê°€ì ¸ì˜¤ê¸°
             prev_holding = holding if isinstance(holding, dict) else {}
             balances = _fetch_balances(kis)
             holding = {}
             for bal in balances:
                 code = bal.get("code")
                 qty = int(bal.get("qty", 0))
                 if qty <= 0:
                     continue
                 price = float(bal.get("avg_price", 0.0))
                 holding[code] = {
                     "qty": qty,
                     "buy_price": price,
                     "bear_s1_done": False,
                     "bear_s2_done": False,
                 }
                 _init_position_state_from_balance(kis, holding, code, price, qty)
 
-            for code in holding.keys():
+            before_lot_signature = _lot_state_signature(lot_state)
+            reconcile_with_broker_holdings(lot_state, balances)
+            _maybe_save_lot_state(before_lot_signature)
+
+            for code, info in holding.items():
                 sid = dominant_strategy_for(lot_state, code)
                 if sid is not None:
                     holding[code]["strategy_id"] = sid
                     logger.info(
                         "[HOLDING_STRATEGY_RESTORE] code=%s sid=%s source=ledger",
                         code,
                         sid,
                     )
 
-            before_lot_signature = _lot_state_signature(lot_state)
-            reconcile_with_broker_holdings(lot_state, balances)
-            _maybe_save_lot_state(before_lot_signature)
+            position_state = reconcile_with_broker(position_state, balances)
+            position_state_dirty = True
+
+            for code, info in holding.items():
+                pos_state = position_state.get("positions", {}).get(str(code).zfill(6))
+                if not isinstance(pos_state, dict):
+                    continue
+                entries = pos_state.get("entries", {})
+                if not entries:
+                    sid = info.get("strategy_id") or "ORPHAN"
+                    _ensure_position_entry(code, sid)
+                    position_state_dirty = True
+                    entries = pos_state.get("entries", {})
+                entry = entries.get(str(info.get("strategy_id"))) if entries else None
+                if not isinstance(entry, dict):
+                    continue
+                meta = entry.get("meta", {})
+                flags = pos_state.get("flags", {})
+                info["engine"] = entry.get("entry", {}).get("engine") or info.get("engine")
+                info["bear_s1_done"] = bool(flags.get("bear_s1_done", False))
+                info["bear_s2_done"] = bool(flags.get("bear_s2_done", False))
+                info["pullback_peak_price"] = meta.get("pullback_peak_price")
+                info["pullback_reversal_price"] = meta.get("pullback_reversal_price")
 
             # ìž”ê³  ê¸°ì¤€ìœ¼ë¡œ ë³´ìœ ì¢…ëª© ë§¤ë„ ê°€ëŠ¥ ìˆ˜ëŸ‰ ë§µ ìƒì„±
             ord_psbl_map = {
                 bal.get("code"): int(bal.get("sell_psbl_qty", 0)) for bal in balances
             }
 
             if isinstance(traded, dict):
                 for code, payload in list(traded.items()):
                     if (payload or {}).get("status") == "pending" and code in holding:
                         traded[code]["status"] = "filled"
 
             traded_today = _traded_today(traded, today_prefix)
             for bal in balances:
                 code = bal.get("code")
                 raw = bal.get("raw") or {}
                 raw_l = {str(k).lower(): v for k, v in raw.items()}
                 thdt_buy_qty = _to_int(
                     raw_l.get("thdt_buyqty")
                     or raw_l.get("thdt_buy_qty")
                     or raw_l.get("thdt_buy_q")
                 )
                 if thdt_buy_qty > 0:
                     traded_today.add(code)
 
             if not ALLOW_PYRAMID:
@@ -1236,213 +1421,235 @@ def main(
                         if now_dt_kst - buy_dt <= timedelta(
                             minutes=recent_keep_minutes
                         ):
                             holding[code] = info
                             ord_psbl_map.setdefault(code, int(info.get("qty", 0)))
                             logger.info(
                                 f"[HOLDING-MERGE] {code} ìµœê·¼ ë§¤ìˆ˜({buy_time_str}) ë°˜ì˜ â†’ ìž”ê³  ë¯¸ë°˜ì˜ ë³´í˜¸"
                             )
                     except Exception as e:
                         logger.warning(f"[HOLDING-MERGE-FAIL] {code}: {e}")
 
             logger.info(
                 f"[STATUS] holdings={holding} traded_today={sorted(traded_today)} ord_psbl={ord_psbl_map}"
             )
 
             # ì»¤íŠ¸ì˜¤í”„ íƒ€ìž„ ë„ë‹¬ ì‹œ ê°•ì œë§¤ë„ ë£¨í‹´
             if now_dt_kst.time() >= SELL_FORCE_TIME and SELL_ALL_BALANCES_AT_CUTOFF:
                 logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ë„ë‹¬: ì „ëŸ‰ë§¤ë„ ë£¨í‹´ ì‹¤í–‰]")
                 pass_count = FORCE_SELL_PASSES_CUTOFF
                 if now_dt_kst.time() >= dtime(hour=15, minute=0):
                     pass_count = FORCE_SELL_PASSES_CLOSE
                 for code, qty in ord_psbl_map.items():
                     if qty <= 0:
                         continue
                     prev_qty_before = int((holding.get(code) or {}).get("qty") or 0)
+                    qty = _cap_sell_qty(code, qty)
+                    if qty <= 0:
+                        continue
                     exec_px, result = _sell_once(kis, code, qty, prefer_market=True)
                     log_trade(
                         {
                             "datetime": now_str,
                             "code": code,
                             "name": None,
                             "qty": int(qty),
                             "K": None,
                             "target_price": None,
                             "strategy": "ê°•ì œë§¤ë„",
                             "side": "SELL",
                             "price": exec_px,
                             "amount": int((exec_px or 0)) * int(qty),
                             "result": result,
                             "reason": "ì»¤íŠ¸ì˜¤í”„ ê°•ì œë§¤ë„",
                         }
                     )
                     _apply_sell_to_ledger_with_balance(
                         code,
                         int(qty),
                         now_dt_kst.isoformat(),
                         result,
-                        strategy_id=None,
+                        scope="proportional",
+                        trigger_strategy_id=None,
                         prev_qty_before=prev_qty_before,
                         allow_blocked=FORCE_SELL_BLOCKED_LOTS,
                     )
                     time.sleep(RATE_SLEEP_SEC)
                 for _ in range(pass_count - 1):
                     logger.info(
                         f"[ì»¤íŠ¸ì˜¤í”„ ì¶”ê°€íŒ¨ìŠ¤] {pass_count}íšŒ ì¤‘ ë‚¨ì€ íŒ¨ìŠ¤ ì‹¤í–‰ (ìž”ê³ ë³€ë™ ê°ì§€ìš©)"
                     )
                     time.sleep(loop_sleep_sec)
                     continue
                 logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ì¢…ë£Œ] ë£¨í”„ ì¢…ë£Œ")
                 break
 
             # === (1) ìž”ì—¬ ë¬¼ëŸ‰ ëŒ€ìƒ ìŠ¤íƒ‘/ë¦¬ë°¸ëŸ°ìŠ¤ ê´€ë¦¬ ===
             for code in list(holding.keys()):
+                pos_state = position_state.get("positions", {}).get(str(code).zfill(6))
+                if isinstance(pos_state, dict):
+                    entries = pos_state.get("entries", {})
+                    entry_ids = ",".join(sorted(entries.keys())) if entries else "ORPHAN"
+                    entry_sample = None
+                    if entries:
+                        entry_sample = next(iter(entries.values()))
+                    entry_meta = entry_sample.get("entry", {}) if isinstance(entry_sample, dict) else {}
+                    flags = pos_state.get("flags", {}) if isinstance(pos_state, dict) else {}
+                    logger.info(
+                        "[EXIT-CHECK] code=%s strategy=%s engine=%s flags=bear_s1_done=%s bear_s2_done=%s source=state.json",
+                        str(code).zfill(6),
+                        entry_ids,
+                        entry_meta.get("engine"),
+                        flags.get("bear_s1_done", False),
+                        flags.get("bear_s2_done", False),
+                    )
+                else:
+                    logger.info(
+                        "[EXIT-CHECK] code=%s strategy=ORPHAN engine=unknown flags=bear_s1_done=False bear_s2_done=False source=ORPHAN_POSITION",
+                        str(code).zfill(6),
+                    )
                 # ì‹ ê·œ ì§„ìž… ê¸ˆì§€ ëª¨ë“œ
                 if code not in code_to_target:
                     continue
 
                 # --- 1a) ê°•ì œ ë ˆì§ë³„ ì¶•ì†Œ ë¡œì§ ---
                 sellable_qty = ord_psbl_map.get(code, 0)
                 if sellable_qty <= 0:
                     continue
 
                 regime_key = regime.get("key")
                 mode = regime.get("mode")
                 if regime_key and regime_key[0] == "bear":
                     if regime["bear_stage"] >= 1:
                         sellable_qty = ord_psbl_map.get(code, 0)
                         guard = _s1_guard_target(
                             now_dt_kst.date(), code, holding[code].get("qty", 0)
                         )
                         base_qty = int(guard.get("base_qty") or 0)
                         if base_qty <= 0:
                             regime_s1_summary["skipped"] += 1
                             _log_s1_action(
                                 code,
                                 "SKIP",
                                 base_qty,
                                 0,
                                 int(guard.get("sold", 0)),
                                 0,
                                 0,
                                 "base_qty_zero",
                             )
                         else:
                             target_qty = max(1, int(base_qty * REG_PARTIAL_S1))
                             sold_today = int(guard.get("sold", 0))
                             remaining = max(0, target_qty - sold_today)
 
                             if remaining <= 0 or sellable_qty <= 0:
                                 if remaining <= 0:
-                                    holding[code]["bear_s1_done"] = True
+                                    _set_position_flags(code, bear_s1_done=True)
                                     s1_done_today.add(code)
                                 regime_s1_summary["skipped"] += 1
                                 _log_s1_action(
                                     code,
                                     "SKIP",
                                     base_qty,
                                     target_qty,
                                     sold_today,
                                     remaining,
                                     0,
                                     (
                                         "target_met"
                                         if remaining <= 0
                                         else "no_sellable_qty"
                                     ),
                                 )
                             else:
-                                sid = _resolve_sell_sid(code)
                                 sell_qty = min(remaining, sellable_qty)
-                                if sid is not None:
-                                    sell_qty = min(
-                                        sell_qty,
-                                        remaining_qty_for_strategy(lot_state, code, sid),
-                                    )
+                                sell_qty = _cap_sell_qty(code, sell_qty)
                                 if sell_qty <= 0:
                                     regime_s1_summary["skipped"] += 1
                                     _log_s1_action(
                                         code,
                                         "SKIP",
                                         base_qty,
                                         target_qty,
                                         sold_today,
                                         remaining,
                                         0,
                                         "strategy_qty_zero",
                                     )
                                     continue
                                 regime_s1_summary["total_qty"] += int(sell_qty)
                                 try:
                                     prev_qty_before = int(
                                         (holding.get(code) or {}).get("qty") or 0
                                     )
                                     exec_px, result = _sell_once(
                                         kis, code, sell_qty, prefer_market=True
                                     )
                                     status, skip_reason = _sell_result_status(result)
                                 except Exception as e:
                                     exec_px, result = None, None
                                     status, skip_reason = "ERROR", str(e)
 
                                 reason_msg = skip_reason or "ì‹œìž¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ"
 
                                 if status == "SENT":
                                     guard["sold"] = sold_today + int(sell_qty)
                                     holding[code]["qty"] = max(
                                         0, holding[code]["qty"] - int(sell_qty)
                                     )
                                     if guard["sold"] >= target_qty:
-                                        holding[code]["bear_s1_done"] = True
+                                        _set_position_flags(code, bear_s1_done=True)
                                         s1_done_today.add(code)
                                     _persist_guard_state(now_dt_kst.date())
                                     regime_s1_summary["sent_qty"] += int(sell_qty)
                                     regime_s1_summary["sent_orders"] += 1
                                     trade_payload = {
                                         "datetime": now_str,
                                         "code": code,
                                         "name": None,
                                         "qty": int(sell_qty),
                                         "K": holding[code].get("k_value"),
                                         "target_price": holding[code].get(
                                             "target_price_src"
                                         ),
                                         "strategy": "ë ˆì§ì¶•ì†Œ",  # ì‹ ê·œ ì „ëžµ êµ¬ë¶„ì„ ìœ„í•´ strategy í•„ë“œ í™œìš©
                                         "side": "SELL",
                                         "price": exec_px,
                                         "amount": int((exec_px or 0)) * int(sell_qty),
                                         "reason": reason_msg,
                                     }
                                     if result is not None:
                                         trade_payload["result"] = result
                                     log_trade(trade_payload)
                                     _apply_sell_to_ledger_with_balance(
                                         code,
                                         int(sell_qty),
                                         now_dt_kst.isoformat(),
                                         result,
-                                        strategy_id=sid,
+                                        scope="strategy",
+                                        trigger_strategy_id=_resolve_sell_sid(code),
                                         prev_qty_before=prev_qty_before,
                                     )
                                     save_state(holding, traded)
                                     time.sleep(RATE_SLEEP_SEC)
                                 elif status == "SKIP":
                                     regime_s1_summary["skipped"] += 1
                                 else:
                                     regime_s1_summary["skipped"] += 1
 
                                 _log_s1_action(
                                     code,
                                     status,
                                     base_qty,
                                     target_qty,
                                     sold_today,
                                     remaining,
                                     sell_qty,
                                     reason_msg,
                                 )
 
                     if regime["bear_stage"] >= 2 and not holding[code].get(
                         "bear_s2_done"
                     ):
                         if not holding[code].get("bear_s1_done"):
                             _log_s2_action(
@@ -1461,260 +1668,303 @@ def main(
                                 f"[REGIME_S2][SEQ] {code}: ë™ì¼ ì¼ìž S1 ì™„ë£Œ ì§í›„ S2 ì§„ìž…"
                             )
                         sellable_qty = ord_psbl_map.get(code, 0)
                         guard = _s2_guard_target(
                             now_dt_kst.date(), code, holding[code].get("qty", 0)
                         )
                         base_qty = int(guard.get("base_qty") or 0)
                         if base_qty <= 0:
                             _log_s2_action(
                                 code,
                                 "SKIP",
                                 base_qty,
                                 0,
                                 int(guard.get("sold", 0)),
                                 0,
                                 0,
                                 "base_qty_zero",
                             )
                         else:
                             target_qty = max(1, int(base_qty * REG_PARTIAL_S2))
                             sold_today = int(guard.get("sold", 0))
                             remaining = max(0, target_qty - sold_today)
 
                             if remaining <= 0 or sellable_qty <= 0:
                                 if remaining <= 0:
-                                    holding[code]["bear_s2_done"] = True
+                                    _set_position_flags(code, bear_s2_done=True)
                                 _log_s2_action(
                                     code,
                                     "SKIP",
                                     base_qty,
                                     target_qty,
                                     sold_today,
                                     remaining,
                                     0,
                                     (
                                         "target_met"
                                         if remaining <= 0
                                         else "no_sellable_qty"
                                     ),
                                 )
                             else:
-                                sid = _resolve_sell_sid(code)
                                 sell_qty = min(remaining, sellable_qty)
-                                if sid is not None:
-                                    sell_qty = min(
-                                        sell_qty,
-                                        remaining_qty_for_strategy(lot_state, code, sid),
-                                    )
+                                sell_qty = _cap_sell_qty(code, sell_qty)
                                 if sell_qty <= 0:
                                     _log_s2_action(
                                         code,
                                         "SKIP",
                                         base_qty,
                                         target_qty,
                                         sold_today,
                                         remaining,
                                         0,
                                         "strategy_qty_zero",
                                     )
                                     continue
                                 try:
                                     prev_qty_before = int(
                                         (holding.get(code) or {}).get("qty") or 0
                                     )
                                     exec_px, result = _sell_once(
                                         kis, code, sell_qty, prefer_market=True
                                     )
                                     status, skip_reason = _sell_result_status(result)
                                 except Exception as e:
                                     exec_px, result = None, None
                                     status, skip_reason = "ERROR", str(e)
 
                                 reason_msg = skip_reason or "ì‹œìž¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ"
 
                                 if status == "SENT":
                                     guard["sold"] = sold_today + int(sell_qty)
                                     holding[code]["qty"] = max(
                                         0, holding[code]["qty"] - int(sell_qty)
                                     )
                                     if guard["sold"] >= target_qty:
-                                        holding[code]["bear_s2_done"] = True
+                                        _set_position_flags(code, bear_s2_done=True)
                                     _persist_guard_state(now_dt_kst.date())
                                     log_trade(
                                         {
                                             "datetime": now_str,
                                             "code": code,
                                             "name": None,
                                             "qty": int(sell_qty),
                                             "K": holding[code].get("k_value"),
                                             "target_price": holding[code].get(
                                                 "target_price_src"
                                             ),
                                             "strategy": "ë ˆì§ì¶•ì†Œ",
                                             "side": "SELL",
                                             "price": exec_px,
                                             "amount": int((exec_px or 0))
                                             * int(sell_qty),
                                             "result": result,
                                             "reason": reason_msg,
                                         }
                                     )
                                     _apply_sell_to_ledger_with_balance(
                                         code,
                                         int(sell_qty),
                                         now_dt_kst.isoformat(),
                                         result,
-                                        strategy_id=sid,
+                                        scope="strategy",
+                                        trigger_strategy_id=_resolve_sell_sid(code),
                                         prev_qty_before=prev_qty_before,
                                     )
                                     save_state(holding, traded)
                                     time.sleep(RATE_SLEEP_SEC)
                                 elif status == "SKIP":
                                     pass
                                 _log_s2_action(
                                     code,
                                     status,
                                     base_qty,
                                     target_qty,
                                     sold_today,
                                     remaining,
                                     sell_qty,
                                     reason_msg,
                                 )
 
                 # --- 1b) TP/SL/íŠ¸ë ˆì¼ë§, VWAP ê°€ë“œ ---
                 try:
                     exit_reason, exec_px, exit_result, sold_qty = _adaptive_exit(
                         kis,
                         code,
                         holding[code],
                         regime_mode=mode or "neutral",
                     )
                 except Exception as e:
                     logger.error(f"[_adaptive_exit ì‹¤íŒ¨] {code}: {e}")
                     exit_reason = exec_px = exit_result = sold_qty = None
 
                 if sold_qty:
-                    sid = _resolve_sell_sid(code)
-                    if sid is not None:
-                        sold_qty = min(
-                            int(sold_qty),
-                            remaining_qty_for_strategy(lot_state, code, sid),
-                        )
                     if sold_qty <= 0:
                         continue
                     prev_qty_before = int((holding.get(code) or {}).get("qty") or 0)
+                    sold_qty = _cap_sell_qty(code, sold_qty)
+                    if sold_qty <= 0:
+                        continue
                     _apply_sell_to_ledger_with_balance(
                         code,
                         int(sold_qty),
                         now_dt_kst.isoformat(),
                         exit_result,
-                        strategy_id=sid,
+                        scope="strategy",
+                        trigger_strategy_id=_resolve_sell_sid(code),
                         prev_qty_before=prev_qty_before,
                     )
                     save_state(holding, traded)
                     time.sleep(RATE_SLEEP_SEC)
+                else:
+                    try:
+                        current_price = _safe_get_price(kis, code)
+                    except Exception:
+                        current_price = None
+                    if current_price and _pullback_stop_hit(code, current_price):
+                        sellable_qty = ord_psbl_map.get(code, 0)
+                        pb_avail = remaining_qty_for_strategy(lot_state, code, 5)
+                        sell_qty = min(int(sellable_qty), int(pb_avail))
+                        if sell_qty > 0:
+                            prev_qty_before = int(
+                                (holding.get(code) or {}).get("qty") or 0
+                            )
+                            exec_px, result = _sell_once(
+                                kis, code, sell_qty, prefer_market=True
+                            )
+                            log_trade(
+                                {
+                                    "datetime": now_str,
+                                    "code": code,
+                                    "name": None,
+                                    "qty": int(sell_qty),
+                                    "K": holding[code].get("k_value"),
+                                    "target_price": holding[code].get("target_price_src"),
+                                    "strategy": "ëˆŒë¦¼ëª© ì†ì ˆ",
+                                    "side": "SELL",
+                                    "price": exec_px,
+                                    "amount": int((exec_px or 0)) * int(sell_qty),
+                                    "result": result,
+                                    "reason": "pullback_reversal_break",
+                                }
+                            )
+                            _apply_sell_to_ledger_with_balance(
+                                code,
+                                int(sell_qty),
+                                now_dt_kst.isoformat(),
+                                result,
+                                scope="strategy",
+                                trigger_strategy_id=5,
+                                prev_qty_before=prev_qty_before,
+                            )
+                            save_state(holding, traded)
+                            time.sleep(RATE_SLEEP_SEC)
+                            logger.info(
+                                "[PULLBACK-STOP] code=%s current=%s reason=reversal_break",
+                                code,
+                                current_price,
+                            )
 
             # === (2) ì‹ ê·œ ì§„ìž… ë¡œì§ (ì±”í”¼ì–¸) ===
             for code, info in code_to_target.items():
                 if not can_buy:
                     continue
 
                 if code in traded_today:
                     continue
 
                 if code in holding and not ALLOW_PYRAMID:
                     continue
 
                 if code in triggered_today:
                     logger.info(f"[TRIGGER-SKIP] {code}: ê¸ˆì¼ ì´ë¯¸ íŠ¸ë¦¬ê±° ë°œìƒ")
                     continue
 
                 target_qty = int(info.get("qty", 0))
                 if target_qty <= 0:
                     logger.info(f"[REBALANCE] {code}: target_qty=0 â†’ ìŠ¤í‚µ")
                     continue
 
                 target_price = info.get("target_price")
                 k_value = info.get("best_k")
                 strategy = info.get("strategy")
                 weight = _to_float(info.get("weight") or 0.0)
 
                 planned_notional = int(
                     _to_float(info.get("target_notional") or 0.0) or 0
                 )
                 logger.info(
                     f"[TARGET] {code} qty={target_qty} tgt_px={target_price} notional={planned_notional} K={k_value}"
                 )
 
                 # [ì¤‘ë³µ ì§„ìž… ë°©ì§€] ì´ë¯¸ ì£¼ë¬¸ëœ ì¢…ëª©ì¸ì§€ í™•ì¸
                 if code in traded_today:
                     logger.info(f"[SKIP] {code}: ì´ë¯¸ ê¸ˆì¼ ê±°ëž˜ë¨")
                     continue
 
-                strategy_id = info.get("strategy_id")
+                strategy_id = info.get("strategy_id") or _derive_strategy_id(info)
                 if strategy_id is not None and remaining_qty_for_strategy(
                     lot_state, code, strategy_id
                 ) > 0:
                     logger.info(
                         "[ENTRY-SKIP] already owned in ledger: code=%s sid=%s",
                         code,
                         strategy_id,
                     )
                     continue
 
                 if _pending_block(traded, code, now_dt_kst, block_sec=45):
                     logger.info(
                         f"[SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘ â†’ ìž¬ì£¼ë¬¸ ë°©ì§€"
                     )
                     continue
 
-                prev_price = last_price_map.get(code)
+                prev_price = (
+                    position_state.get("memory", {})
+                    .get("last_price", {})
+                    .get(str(code).zfill(6))
+                )
                 if prev_price is None:
                     try:
                         cached = signals._LAST_PRICE_CACHE.get(code) or {}
                         ts = cached.get("ts")
                         if ts and (time.time() - float(ts) <= 120):
                             prev_price = cached.get("px")
                     except Exception:
                         prev_price = None
 
                 price_res = _safe_get_price(kis, code, with_source=True)
                 if isinstance(price_res, tuple):
                     current_price, price_source = price_res
                 else:
                     current_price, price_source = price_res, None
 
                 if not current_price or current_price <= 0:
                     logger.warning(f"[PRICE_FAIL] {code}: í˜„ìž¬ê°€ ì¡°íšŒ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ")
                     continue
 
-                try:
-                    last_price_map[code] = float(current_price)
-                except Exception:
-                    pass
+                _update_last_price_memory(code, float(current_price), now_dt_kst.isoformat())
 
                 # === GOOD/BAD íƒ€ì  í‰ê°€ ===
                 daily_ctx = _compute_daily_entry_context(
                     kis, code, current_price, price_source
                 )
                 intra_ctx = _compute_intraday_entry_context(
                     kis, code, fast=MOM_FAST, slow=MOM_SLOW
                 )
 
                 momentum_confirmed = bool(
                     daily_ctx.get("strong_trend")
                     or intra_ctx.get("vwap_reclaim")
                     or intra_ctx.get("range_break")
                 )
 
                 if mode == "neutral" and not (
                     info.get("champion_grade") in ("A", "B") or momentum_confirmed
                 ):
                     logger.info(
                         f"[ENTRY-SKIP] {code}: neutral ë ˆì§ì—ì„œ ë¹„ì±”í”¼ì–¸/ëª¨ë©˜í…€ ë¯¸í™•ì¸ â†’ ì‹ ê·œ ì§„ìž… ë³´ë¥˜"
                     )
                     continue
 
                 setup_state = signals.evaluate_setup_gate(
                     daily_ctx, intra_ctx, regime_state=regime_state
@@ -1868,78 +2118,100 @@ def main(
                         f"[BUY-PENDING] {code}: ìž”ê³ ì— ë°˜ì˜ë˜ì§€ ì•Šì•„ ìƒíƒœ ê¸°ë¡ ë³´ë¥˜(result={result})"
                     )
                     continue
                 traded[code]["status"] = "filled"
                 _record_trade(
                     traded,
                     code,
                     {
                         "buy_time": now_str,
                         "qty": int(qty),
                         "price": float(exec_price),
                         "status": "filled",
                         "pending_since": None,
                     },
                 )
 
                 _init_position_state(
                     kis,
                     holding,
                     code,
                     float(exec_price),
                     int(qty),
                     k_value,
                     target_price,
                 )
+                position_state = record_entry_state(
+                    state=position_state,
+                    code=code,
+                    qty=int(qty),
+                    avg_price=float(exec_price),
+                    strategy_id=strategy_id,
+                    engine=trigger_label,
+                    entry_reason="SETUP-OK + TRIGGER-YES",
+                    order_type="marketable_limit",
+                    best_k=k_value,
+                    tgt_px=target_price,
+                    gap_pct_at_entry=trigger_state.get("gap_pct"),
+                    flags={
+                        "bear_s1_done": holding[code].get("bear_s1_done", False),
+                        "bear_s2_done": holding[code].get("bear_s2_done", False),
+                    },
+                    entry_time=now_dt_kst.isoformat(),
+                )
+                position_state_dirty = True
 
                 lot_id = _build_lot_id(
                     result,
                     now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
                     code,
                 )
                 before_lot_signature = _lot_state_signature(lot_state)
                 record_buy_fill(
                     lot_state,
                     lot_id=lot_id,
                     pdno=code,
-                    strategy_id=info.get("strategy_id") or _derive_strategy_id(info),
+                    strategy_id=strategy_id,
                     engine="legacy_kosdaq_runner",
                     entry_ts=now_dt_kst.isoformat(),
                     entry_price=float(exec_price),
                     qty=int(qty),
                     meta={
                         "strategy_name": strategy,
+                        "entry_reason": "SETUP-OK + TRIGGER-YES",
                         "k": k_value,
                         "target_price": target_price,
+                        "best_k": k_value,
+                        "tgt_px": target_price,
                         "engine": "legacy_kosdaq_runner",
                         "rebalance_date": str(rebalance_date),
                     },
                 )
                 logger.info(
                     "[LEDGER][BUY] code=%s sid=%s lot_id=%s qty=%s",
                     code,
-                    info.get("strategy_id") or _derive_strategy_id(info),
+                    strategy_id,
                     lot_id,
                     qty,
                 )
                 _maybe_save_lot_state(before_lot_signature)
 
                 log_trade(
                     {
                         **trade_ctx,
                         "price": float(exec_price),
                         "amount": int(float(exec_price) * int(qty)),
                         "result": result,
                     }
                 )
                 effective_cash = _get_effective_ord_cash(
                     kis, soft_cap=effective_capital
                 )
                 if effective_cash <= 0:
                     can_buy = False
                 save_state(holding, traded)
                 time.sleep(RATE_SLEEP_SEC)
 
             # ====== ëˆŒë¦¼ëª© ì „ìš© ë§¤ìˆ˜ (ì±”í”¼ì–¸ê³¼ ë…ë¦½ì ìœ¼ë¡œ Top-N ì‹œì´ ë¦¬ìŠ¤íŠ¸ ìŠ¤ìº”) ======
             if USE_PULLBACK_ENTRY and is_open:
                 if not can_buy:
                     logger.info("[PULLBACK-SKIP] can_buy=False â†’ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ")
@@ -2091,69 +2363,106 @@ def main(
                             traded,
                             code,
                             {
                                 "buy_time": now_str,
                                 "qty": int(qty),
                                 "price": float(exec_price),
                                 "status": "filled",
                                 "pending_since": None,
                             },
                         )
                         pullback_buys_today += 1
 
                         try:
                             _init_position_state(
                                 kis,
                                 holding,
                                 code,
                                 float(exec_price),
                                 int(qty),
                                 None,
                                 trigger_price,
                             )
                         except Exception as e:
                             logger.warning(f"[PULLBACK-INIT-FAIL] {code}: {e}")
 
+                        pullback_meta = {}
+                        if isinstance(resp, dict):
+                            pullback_meta = {
+                                "pullback_peak_price": resp.get("peak_price"),
+                                "pullback_reversal_price": resp.get("reversal_price"),
+                                "pullback_reason": resp.get("reason"),
+                            }
+                        position_state = record_entry_state(
+                            state=position_state,
+                            code=code,
+                            qty=int(qty),
+                            avg_price=float(exec_price),
+                            strategy_id=5,
+                            engine="pullback",
+                            entry_reason="PULLBACK-SETUP + REVERSAL",
+                            order_type="marketable_limit",
+                            best_k=None,
+                            tgt_px=trigger_price,
+                            gap_pct_at_entry=None,
+                            meta=pullback_meta,
+                            flags={
+                                "bear_s1_done": holding[code].get("bear_s1_done", False),
+                                "bear_s2_done": holding[code].get("bear_s2_done", False),
+                            },
+                            entry_time=now_dt_kst.isoformat(),
+                        )
+                        position_state_dirty = True
+
                         lot_id = _build_lot_id(
                             result,
                             now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
                             code,
                         )
                         before_lot_signature = _lot_state_signature(lot_state)
                         record_buy_fill(
                             lot_state,
                             lot_id=lot_id,
                             pdno=code,
                             strategy_id=5,
                             engine="legacy_kosdaq_runner",
                             entry_ts=now_dt_kst.isoformat(),
                             entry_price=float(exec_price),
                             qty=int(qty),
                             meta={
                                 "strategy_name": f"ì½”ìŠ¤ë‹¥ Top{PULLBACK_TOPN} ëˆŒë¦¼ëª©",
+                                "entry_reason": "PULLBACK-SETUP + REVERSAL",
                                 "k": None,
                                 "target_price": trigger_price,
+                                "best_k": None,
+                                "tgt_px": trigger_price,
+                                "pullback_peak_price": resp.get("peak_price")
+                                if isinstance(resp, dict)
+                                else None,
+                                "pullback_reversal_price": resp.get("reversal_price")
+                                if isinstance(resp, dict)
+                                else None,
                                 "engine": "legacy_kosdaq_runner",
                                 "rebalance_date": str(rebalance_date),
                             },
                         )
                         logger.info(
                             "[LEDGER][BUY] code=%s sid=%s lot_id=%s qty=%s",
                             code,
                             5,
                             lot_id,
                             qty,
                         )
                         _maybe_save_lot_state(before_lot_signature)
 
                         logger.info(
                             f"[âœ… ëˆŒë¦¼ëª© ë§¤ìˆ˜] {code}, qty={qty}, price={exec_price}, trigger={trigger_price}, result={result}"
                         )
 
                         log_trade(
                             {
                                 "datetime": now_str,
                                 "code": code,
                                 "name": info.get("name"),
                                 "qty": int(qty),
                                 "K": None,
                                 "target_price": trigger_price,
@@ -2187,148 +2496,142 @@ def main(
                                 guard = _s1_guard_nontarget(
                                     now_dt_kst.date(),
                                     code,
                                     holding[code].get("qty", 0),
                                 )
                                 base_qty = int(guard.get("base_qty") or 0)
                                 if base_qty <= 0:
                                     regime_s1_summary["skipped"] += 1
                                     _log_s1_action(
                                         code,
                                         "SKIP",
                                         base_qty,
                                         0,
                                         int(guard.get("sold", 0)),
                                         0,
                                         0,
                                         "base_qty_zero",
                                     )
                                 else:
                                     target_qty = max(1, int(base_qty * REG_PARTIAL_S1))
                                     sold_today = int(guard.get("sold", 0))
                                     remaining = max(0, target_qty - sold_today)
 
                                     if remaining <= 0 or sellable_here <= 0:
                                         if remaining <= 0:
-                                            holding[code]["bear_s1_done"] = True
+                                            _set_position_flags(code, bear_s1_done=True)
                                             s1_done_today.add(code)
                                         regime_s1_summary["skipped"] += 1
                                         _log_s1_action(
                                             code,
                                             "SKIP",
                                             base_qty,
                                             target_qty,
                                             sold_today,
                                             remaining,
                                             0,
                                             (
                                                 "target_met"
                                                 if remaining <= 0
                                                 else "no_sellable_qty"
                                             ),
                                         )
                                     else:
-                                        sid = _resolve_sell_sid(code)
                                         sell_qty = min(remaining, sellable_here)
-                                        if sid is not None:
-                                            sell_qty = min(
-                                                sell_qty,
-                                                remaining_qty_for_strategy(
-                                                    lot_state, code, sid
-                                                ),
-                                            )
+                                        sell_qty = _cap_sell_qty(code, sell_qty)
                                         if sell_qty <= 0:
                                             regime_s1_summary["skipped"] += 1
                                             _log_s1_action(
                                                 code,
                                                 "SKIP",
                                                 base_qty,
                                                 target_qty,
                                                 sold_today,
                                                 remaining,
                                                 0,
                                                 "strategy_qty_zero",
                                             )
                                             continue
                                         regime_s1_summary["total_qty"] += int(sell_qty)
                                         try:
                                             prev_qty_before = int(
                                                 (holding.get(code) or {}).get("qty")
                                                 or 0
                                             )
                                             exec_px, result = _sell_once(
                                                 kis, code, sell_qty, prefer_market=True
                                             )
                                             status, skip_reason = _sell_result_status(
                                                 result
                                             )
                                         except Exception as e:
                                             exec_px, result = None, None
                                             status, skip_reason = "ERROR", str(e)
 
                                         reason_msg = (
                                             skip_reason or "ì‹œìž¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)"
                                         )
 
                                         if status == "SENT":
                                             guard["sold"] = sold_today + int(sell_qty)
                                             holding[code]["qty"] = max(
                                                 0, holding[code]["qty"] - int(sell_qty)
                                             )
                                             if guard["sold"] >= target_qty:
-                                                holding[code]["bear_s1_done"] = True
+                                                _set_position_flags(code, bear_s1_done=True)
                                                 s1_done_today.add(code)
                                             _persist_guard_state(now_dt_kst.date())
                                             regime_s1_summary["sent_qty"] += int(
                                                 sell_qty
                                             )
                                             regime_s1_summary["sent_orders"] += 1
                                             trade_payload = {
                                                 "datetime": now_str,
                                                 "code": code,
                                                 "name": None,
                                                 "qty": int(sell_qty),
                                                 "K": holding[code].get("k_value"),
                                                 "target_price": holding[code].get(
                                                     "target_price_src"
                                                 ),
                                                 "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
                                                 "side": "SELL",
                                                 "price": exec_px,
                                                 "amount": int((exec_px or 0))
                                                 * int(sell_qty),
                                                 "reason": reason_msg,
                                             }
                                             if result is not None:
                                                 trade_payload["result"] = result
                                             log_trade(trade_payload)
                                             _apply_sell_to_ledger_with_balance(
                                                 code,
                                                 int(sell_qty),
                                                 now_dt_kst.isoformat(),
                                                 result,
-                                                strategy_id=sid,
+                                                scope="strategy",
+                                                trigger_strategy_id=_resolve_sell_sid(code),
                                                 prev_qty_before=prev_qty_before,
                                             )
                                             save_state(holding, traded)
                                             time.sleep(RATE_SLEEP_SEC)
                                         elif status == "SKIP":
                                             regime_s1_summary["skipped"] += 1
                                         else:
                                             regime_s1_summary["skipped"] += 1
 
                                         _log_s1_action(
                                             code,
                                             status,
                                             base_qty,
                                             target_qty,
                                             sold_today,
                                             remaining,
                                             sell_qty,
                                             reason_msg,
                                         )
 
                             if regime["bear_stage"] >= 2 and not holding[code].get(
                                 "bear_s2_done"
                             ):
                                 if not holding[code].get("bear_s1_done"):
                                     _log_s2_action(
@@ -2349,139 +2652,133 @@ def main(
                                 sellable_here = ord_psbl_map.get(code, 0)
                                 guard = _s2_guard_nontarget(
                                     now_dt_kst.date(),
                                     code,
                                     holding[code].get("qty", 0),
                                 )
                                 base_qty = int(guard.get("base_qty") or 0)
                                 if base_qty <= 0:
                                     _log_s2_action(
                                         code,
                                         "SKIP",
                                         base_qty,
                                         0,
                                         int(guard.get("sold", 0)),
                                         0,
                                         0,
                                         "base_qty_zero",
                                     )
                                 else:
                                     target_qty = max(1, int(base_qty * REG_PARTIAL_S2))
                                     sold_today = int(guard.get("sold", 0))
                                     remaining = max(0, target_qty - sold_today)
 
                                     if remaining <= 0 or sellable_here <= 0:
                                         if remaining <= 0:
-                                            holding[code]["bear_s2_done"] = True
+                                            _set_position_flags(code, bear_s2_done=True)
                                         _log_s2_action(
                                             code,
                                             "SKIP",
                                             base_qty,
                                             target_qty,
                                             sold_today,
                                             remaining,
                                             0,
                                             (
                                                 "target_met"
                                                 if remaining <= 0
                                                 else "no_sellable_qty"
                                             ),
                                         )
                                     else:
-                                        sid = _resolve_sell_sid(code)
                                         sell_qty = min(remaining, sellable_here)
-                                        if sid is not None:
-                                            sell_qty = min(
-                                                sell_qty,
-                                                remaining_qty_for_strategy(
-                                                    lot_state, code, sid
-                                                ),
-                                            )
+                                        sell_qty = _cap_sell_qty(code, sell_qty)
                                         if sell_qty <= 0:
                                             _log_s2_action(
                                                 code,
                                                 "SKIP",
                                                 base_qty,
                                                 target_qty,
                                                 sold_today,
                                                 remaining,
                                                 0,
                                                 "strategy_qty_zero",
                                             )
                                             continue
                                         try:
                                             prev_qty_before = int(
                                                 (holding.get(code) or {}).get("qty")
                                                 or 0
                                             )
                                             exec_px, result = _sell_once(
                                                 kis, code, sell_qty, prefer_market=True
                                             )
                                             status, skip_reason = _sell_result_status(
                                                 result
                                             )
                                         except Exception as e:
                                             exec_px, result = None, None
                                             status, skip_reason = "ERROR", str(e)
 
                                         reason_msg = (
                                             skip_reason or "ì‹œìž¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)"
                                         )
 
                                         if status == "SENT":
                                             guard["sold"] = sold_today + int(sell_qty)
                                             holding[code]["qty"] = max(
                                                 0, holding[code]["qty"] - int(sell_qty)
                                             )
                                             if guard["sold"] >= target_qty:
-                                                holding[code]["bear_s2_done"] = True
+                                                _set_position_flags(code, bear_s2_done=True)
                                             _persist_guard_state(now_dt_kst.date())
                                             log_trade(
                                                 {
                                                     "datetime": now_str,
                                                     "code": code,
                                                     "name": None,
                                                     "qty": int(sell_qty),
                                                     "K": holding[code].get("k_value"),
                                                     "target_price": holding[code].get(
                                                         "target_price_src"
                                                     ),
                                                     "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
                                                     "side": "SELL",
                                                     "price": exec_px,
                                                     "amount": int((exec_px or 0))
                                                     * int(sell_qty),
                                                     "result": result,
                                                     "reason": reason_msg,
                                                 }
                                             )
                                             _apply_sell_to_ledger_with_balance(
                                                 code,
                                                 int(sell_qty),
                                                 now_dt_kst.isoformat(),
                                                 result,
-                                                strategy_id=sid,
+                                                scope="strategy",
+                                                trigger_strategy_id=_resolve_sell_sid(code),
                                                 prev_qty_before=prev_qty_before,
                                             )
                                             save_state(holding, traded)
                                             time.sleep(RATE_SLEEP_SEC)
                                         elif status == "SKIP":
                                             pass
 
                                         _log_s2_action(
                                             code,
                                             status,
                                             base_qty,
                                             target_qty,
                                             sold_today,
                                             remaining,
                                             sell_qty,
                                             reason_msg,
                                         )
 
                     try:
                         momentum_intact, trend_ctx = _has_bullish_trend_structure(
                             kis, code
                         )
                     except NetTemporaryError:
                         logger.warning(
                             f"[20D_TREND_TEMP_SKIP] {code}: ë„¤íŠ¸ì›Œí¬ ì¼ì‹œ ì‹¤íŒ¨ â†’ ì´ë²ˆ ë£¨í”„ ìŠ¤í‚µ"
@@ -2501,48 +2798,54 @@ def main(
                     if momentum_intact:
                         logger.info(
                             (
                                 f"[ëª¨ë©˜í…€ ë³´ìœ ] {code}: 5/10/20 ì •ë°°ì—´ & 20ì¼ì„  ìƒìŠ¹ & ì¢…ê°€>20ì¼ì„  ìœ ì§€ "
                                 f"(close={trend_ctx.get('last_close'):.2f}, ma5={trend_ctx.get('ma5'):.2f}, "
                                 f"ma10={trend_ctx.get('ma10'):.2f}, ma20={trend_ctx.get('ma20'):.2f}â†’{trend_ctx.get('ma20_prev'):.2f})"
                             )
                         )
                         continue
 
             if regime_s1_summary.get("by_stock"):
                 logger.info(
                     f"[REGIME_S1][SUMMARY] sent_qty={regime_s1_summary['sent_qty']} "
                     f"sent_orders={regime_s1_summary['sent_orders']} "
                     f"skipped={regime_s1_summary['skipped']} total_qty={regime_s1_summary['total_qty']} "
                     f"by_stock={regime_s1_summary['by_stock']}"
                 )
 
             # --- ìž¥ì¤‘ ì»¤íŠ¸ì˜¤í”„(KST): 14:40 ë„ë‹¬ ì‹œ "ì „ëŸ‰ë§¤ë„ ì—†ì´" ë¦¬í¬íŠ¸ ìƒì„± í›„ ì •ìƒ ì¢…ë£Œ ---
             if is_open and now_dt_kst.time() >= SELL_FORCE_TIME:
                 logger.info(
                     f"[â° ì»¤íŠ¸ì˜¤í”„] {SELL_FORCE_TIME.strftime('%H:%M')} ë„ë‹¬: ì „ëŸ‰ ë§¤ë„ ì—†ì´ ë¦¬í¬íŠ¸ ìƒì„± í›„ ì¢…ë£Œ"
                 )
 
                 save_state(holding, traded)
+                if position_state_dirty:
+                    save_position_state(position_state_path, position_state)
+                    position_state_dirty = False
 
                 try:
                     _report = ceo_report(datetime.now(KST), period="daily")
                     logger.info(
                         f"[ðŸ“„ CEO Report ìƒì„± ì™„ë£Œ] title={_report.get('title')}"
                     )
                 except Exception as e:
                     logger.error(f"[CEO Report ìƒì„± ì‹¤íŒ¨] {e}")
 
                 logger.info("[âœ… ì»¤íŠ¸ì˜¤í”„ ì™„ë£Œ: ë£¨í”„ ì •ìƒ ì¢…ë£Œ]")
                 break
 
             save_state(holding, traded)
+            if position_state_dirty:
+                save_position_state(position_state_path, position_state)
+                position_state_dirty = False
             time.sleep(loop_sleep_sec)
 
     except KeyboardInterrupt:
         logger.info("[ðŸ›‘ ìˆ˜ë™ ì¢…ë£Œ]")
     except Exception as e:
         logger.exception(f"[FATAL] ë©”ì¸ ë£¨í”„ ì˜ˆì™¸ ë°œìƒ: {e}")
 
 
 if __name__ == "__main__":
     main()
diff --git a/trader/lot_state_store.py b/trader/lot_state_store.py
new file mode 100644
index 0000000000000000000000000000000000000000..c9abbef01fcad350102e566107b42f8206ac791b
--- /dev/null
+++ b/trader/lot_state_store.py
@@ -0,0 +1,40 @@
+from __future__ import annotations
+
+import json
+import logging
+import os
+from pathlib import Path
+from typing import Any, Dict
+
+logger = logging.getLogger(__name__)
+
+
+def load_lot_state(path_json: str) -> Dict[str, Any]:
+    path = Path(path_json)
+    if not path.exists():
+        return {"lots": []}
+    try:
+        with open(path, "r", encoding="utf-8") as f:
+            state = json.load(f)
+        if not isinstance(state, dict):
+            logger.warning("[LOT_STATE] invalid format: %s", type(state))
+            return {"lots": []}
+        state.setdefault("lots", [])
+        return state
+    except Exception:
+        logger.exception("[LOT_STATE] failed to load %s", path_json)
+        return {"lots": []}
+
+
+def save_lot_state(path_json: str, state: Dict[str, Any]) -> None:
+    path = Path(path_json)
+    try:
+        path.parent.mkdir(parents=True, exist_ok=True)
+        payload = dict(state)
+        payload.setdefault("lots", [])
+        tmp_path = path.with_name(f"{path.name}.tmp")
+        with open(tmp_path, "w", encoding="utf-8") as f:
+            json.dump(payload, f, ensure_ascii=False, indent=2)
+        os.replace(tmp_path, path)
+    except Exception:
+        logger.exception("[LOT_STATE] failed to save %s", path_json)
diff --git a/trader/position_state_store.py b/trader/position_state_store.py
new file mode 100644
index 0000000000000000000000000000000000000000..8e9cfadc3950999188662920c4fd44671ecc9aff
--- /dev/null
+++ b/trader/position_state_store.py
@@ -0,0 +1,204 @@
+from __future__ import annotations
+
+import json
+import logging
+import os
+from datetime import datetime
+from pathlib import Path
+from typing import Any, Dict, Iterable
+
+from .config import KST
+
+logger = logging.getLogger(__name__)
+
+SCHEMA_VERSION = 1
+
+
+def _empty_state() -> Dict[str, Any]:
+    return {
+        "schema_version": SCHEMA_VERSION,
+        "updated_at": None,
+        "positions": {},
+        "memory": {"last_price": {}, "last_seen": {}},
+    }
+
+
+def _coerce_state(state: Dict[str, Any]) -> Dict[str, Any]:
+    if not isinstance(state, dict):
+        return _empty_state()
+    state.setdefault("schema_version", SCHEMA_VERSION)
+    state.setdefault("updated_at", None)
+    positions = state.get("positions")
+    if not isinstance(positions, dict):
+        positions = {}
+        state["positions"] = positions
+    memory = state.get("memory")
+    if not isinstance(memory, dict):
+        memory = {}
+        state["memory"] = memory
+    memory.setdefault("last_price", {})
+    memory.setdefault("last_seen", {})
+    for code, payload in positions.items():
+        if not isinstance(payload, dict):
+            positions[code] = {
+                "entries": {},
+                "broker_qty": None,
+                "broker_avg_price": None,
+                "miss_count": 0,
+            }
+            continue
+        payload.setdefault("entries", {})
+        payload.setdefault("flags", {"bear_s1_done": False, "bear_s2_done": False})
+        payload.setdefault("broker_qty", None)
+        payload.setdefault("broker_avg_price", None)
+        payload.setdefault("miss_count", 0)
+    return state
+
+
+def _backup_corrupt(path: Path) -> None:
+    timestamp = datetime.now(KST).strftime("%Y%m%d%H%M%S")
+    backup = path.with_name(f"{path.name}.broken-{timestamp}")
+    try:
+        os.replace(path, backup)
+    except Exception:
+        logger.exception("[STATE] failed to backup corrupt file: %s", path)
+
+
+def load_position_state(path: str) -> Dict[str, Any]:
+    path_obj = Path(path)
+    if not path_obj.exists():
+        logger.info("[STATE] no file, start fresh path=%s", path_obj)
+        return _empty_state()
+    try:
+        with open(path_obj, "r", encoding="utf-8") as f:
+            payload = json.load(f)
+        state = _coerce_state(payload)
+        logger.info(
+            "[STATE] loaded path=%s positions=%s updated_at=%s",
+            path_obj,
+            len(state.get("positions", {})),
+            state.get("updated_at"),
+        )
+        return state
+    except json.JSONDecodeError:
+        logger.warning("[STATE] corrupted json, backing up: %s", path_obj)
+        _backup_corrupt(path_obj)
+        return _empty_state()
+    except Exception:
+        logger.exception("[STATE] failed to load %s", path_obj)
+        return _empty_state()
+
+
+def save_position_state(path: str, state: Dict[str, Any]) -> None:
+    path_obj = Path(path)
+    try:
+        path_obj.parent.mkdir(parents=True, exist_ok=True)
+        payload = _coerce_state(dict(state))
+        payload["updated_at"] = datetime.now(KST).isoformat()
+        tmp_path = path_obj.with_name(f"{path_obj.name}.tmp")
+        with open(tmp_path, "w", encoding="utf-8") as f:
+            json.dump(payload, f, ensure_ascii=False, indent=2)
+        os.replace(tmp_path, path_obj)
+    except Exception:
+        logger.exception("[STATE] failed to save %s", path_obj)
+
+
+def _normalize_code(value: Any) -> str:
+    text = str(value or "").strip()
+    return text.zfill(6) if text else ""
+
+
+def _orphan_entry(code: str, qty: int, avg_price: float | None) -> Dict[str, Any]:
+    now_ts = datetime.now(KST).isoformat()
+    return {
+        "qty": int(qty),
+        "avg_price": float(avg_price or 0.0),
+        "entry": {
+            "time": now_ts,
+            "strategy_id": "ORPHAN",
+            "engine": "unknown",
+            "entry_reason": "RECONCILE",
+            "order_type": "unknown",
+            "best_k": None,
+            "tgt_px": None,
+            "gap_pct_at_entry": None,
+        },
+        "meta": {
+            "pullback_peak_price": None,
+            "pullback_reversal_price": None,
+            "pullback_reason": None,
+        },
+    }
+
+
+def reconcile_with_broker(
+    state: Dict[str, Any], broker_positions: Iterable[Dict[str, Any]]
+) -> Dict[str, Any]:
+    state = _coerce_state(state)
+    positions = state["positions"]
+    memory = state["memory"]
+
+    broker_map: Dict[str, Dict[str, Any]] = {}
+    for row in broker_positions:
+        code = _normalize_code(row.get("code") or row.get("pdno") or "")
+        if not code:
+            continue
+        qty = int(row.get("qty") or 0)
+        if qty <= 0:
+            continue
+        broker_map[code] = {
+            "qty": qty,
+            "avg_price": row.get("avg_price"),
+        }
+
+    for code, payload in broker_map.items():
+        qty = int(payload.get("qty") or 0)
+        avg_price = payload.get("avg_price")
+        if code not in positions:
+            positions[code] = {
+                "entries": {},
+                "flags": {"bear_s1_done": False, "bear_s2_done": False},
+                "broker_qty": int(qty),
+                "broker_avg_price": float(avg_price or 0.0),
+                "miss_count": 0,
+            }
+            continue
+        pos = positions[code]
+        pos["broker_qty"] = int(qty)
+        pos["broker_avg_price"] = (
+            float(avg_price) if avg_price is not None else pos.get("broker_avg_price")
+        )
+        pos["miss_count"] = 0
+
+    for code in list(positions.keys()):
+        if code in broker_map:
+            continue
+        pos = positions.get(code) or {}
+        miss_count = int(pos.get("miss_count") or 0) + 1
+        pos["miss_count"] = miss_count
+        positions[code] = pos
+        if miss_count >= 3:
+            positions.pop(code, None)
+            memory.get("last_price", {}).pop(code, None)
+            memory.get("last_seen", {}).pop(code, None)
+
+    return state
+
+
+def run_reconcile_self_checks() -> None:
+    state = _empty_state()
+    state["positions"]["000001"] = {
+        "entries": {},
+        "flags": {"bear_s1_done": True, "bear_s2_done": False},
+        "broker_qty": 5,
+        "broker_avg_price": 100.0,
+        "miss_count": 2,
+    }
+    state = reconcile_with_broker(state, [])
+    assert state["positions"]["000001"]["miss_count"] == 3
+    state = reconcile_with_broker(state, [])
+    assert "000001" not in state["positions"]
+
+
+if __name__ == "__main__":
+    run_reconcile_self_checks()
diff --git a/trader/state_store.py b/trader/state_store.py
index 0cc2cbccf033ecd4c9c8c9a56118ee80b38190bb..253a2a8f2cbce79a377afb8cb227ece079ddd43f 100644
--- a/trader/state_store.py
+++ b/trader/state_store.py
@@ -1,48 +1,53 @@
 from __future__ import annotations
 
 import json
 import logging
+import os
 from datetime import datetime
 from pathlib import Path
 from typing import Any, Dict
 
 from .config import KST
 
 logger = logging.getLogger(__name__)
 
+SCHEMA_VERSION = 1
+
 
 def _default_state() -> Dict[str, Any]:
-    return {"version": 1, "lots": [], "updated_at": None}
+    return {"version": SCHEMA_VERSION, "lots": [], "updated_at": None}
 
 
 def load_state(path_json: str) -> Dict[str, Any]:
     path = Path(path_json)
-    if path.exists():
-        try:
-            with open(path, "r", encoding="utf-8") as f:
-                state = json.load(f)
-            if not isinstance(state, dict):
-                logger.warning("[STATE_STORE] invalid state format: %s", type(state))
-                return _default_state()
-            state.setdefault("version", 1)
-            state.setdefault("lots", [])
-            state.setdefault("updated_at", None)
-            return state
-        except Exception:
-            logger.exception("[STATE_STORE] failed to load %s", path_json)
+    if not path.exists():
+        return _default_state()
+    try:
+        with open(path, "r", encoding="utf-8") as f:
+            state = json.load(f)
+        if not isinstance(state, dict):
+            logger.warning("[STATE_STORE] invalid state format: %s", type(state))
             return _default_state()
-    return _default_state()
+        state.setdefault("version", SCHEMA_VERSION)
+        state.setdefault("lots", [])
+        state.setdefault("updated_at", None)
+        return state
+    except Exception:
+        logger.exception("[STATE_STORE] failed to load %s", path_json)
+        return _default_state()
 
 
 def save_state(path_json: str, state: Dict[str, Any]) -> None:
     path = Path(path_json)
     try:
         path.parent.mkdir(parents=True, exist_ok=True)
         payload = dict(state)
-        payload.setdefault("version", 1)
+        payload.setdefault("version", SCHEMA_VERSION)
         payload.setdefault("lots", [])
         payload["updated_at"] = datetime.now(KST).isoformat()
-        with open(path, "w", encoding="utf-8") as f:
+        tmp_path = path.with_name(f"{path.name}.tmp")
+        with open(tmp_path, "w", encoding="utf-8") as f:
             json.dump(payload, f, ensure_ascii=False, indent=2)
+        os.replace(tmp_path, path)
     except Exception:
         logger.exception("[STATE_STORE] failed to save %s", path_json)
