diff --git a/.github/workflows/trade-monitor.yml b/.github/workflows/trade-monitor.yml
index 32e532ad8ddfd9176d52936d183280cdb07c6f57..42646c70c60249f42147af9c5cee00d3faf8f438 100644
--- a/.github/workflows/trade-monitor.yml
+++ b/.github/workflows/trade-monitor.yml
@@ -70,50 +70,55 @@ jobs:
       W_MIN_ONE: "0.03"
 
       REBALANCE_ANCHOR: "weekly"
       FORCE_WEEKLY_REBALANCE: "0"
       MOMENTUM_OVERRIDES_FORCE_SELL: "true"
 
       # 레짐/지수
       KOSDAQ_INDEX_CODE: "KOSDAQ"
       KOSDAQ_ETF_FALLBACK: "229200"
 
       REG_BULL_MIN_UP_PCT: "0.5"
       REG_BULL_MIN_MINUTES: "10"
       REG_BEAR_VWAP_MINUTES: "10"
       REG_BEAR_DROP_FROM_HIGH: "0.7"
       REG_BEAR_STAGE1_MINUTES: "20"
       REG_BEAR_STAGE2_ADD_DROP: "0.5"
 
       REG_PARTIAL_S1: "0.30"
       REG_PARTIAL_S2: "0.30"
 
       TRAIL_PCT_BULL: "0.025"
       TRAIL_PCT_BEAR: "0.012"
       TP_PROFIT_PCT_BULL: "3.5"
 
       MARKET_DATA_WHEN_CLOSED: "false"
+      DIAGNOSTIC_ONLY: "true"
+      DIAGNOSTIC_FORCE_RUN: "true"
+      DISABLE_KOSDAQ_LOOP: "true"
+      DISABLE_KOSPI_ENGINE: "true"
+      DISABLE_LIVE_TRADING: "true"
 
       # 배분/속도
       DAILY_CAPITAL: "250000000"
       API_RATE_SLEEP_SEC: "0.3"
 
       # === VWAP 분봉 TR (선택: 코드에 기본값 이미 있으므로 생략해도 동작) ===
       # 한국투자증권 엑셀 기준 주식당일분봉조회 TR_ID (FHKST03010200)
       KIS_TR_ID_INTRADAY_CHART: "FHKST03010200"
       KIS_TR_ID_INTRADAY_CHART_REAL: "FHKST03010200"
 
       # === FastAPI 리밸런싱 서버(선정 필터) ===
       MIN_TRADES: "5"
       MAX_MDD_PCT: "30"
       MIN_WINRATE: "50"
       MIN_CUMRET: "2"
       TOP_K_LIMIT: "20"
       TOTAL_CAPITAL: "10000000"
       MIN_QTY_PER_TICKET: "1"
       K_MIN: "0.1"
       K_MAX: "0.9"
       K_STEP: "0.1"
       ALLOW_AFTER_HOURS: "0"
       REBALANCE_OUT_DIR: "rebalance_results"
 
     steps:
@@ -260,26 +265,26 @@ jobs:
       - name: Trades 로그 업로드
         if: always()
         uses: actions/upload-artifact@v4
         with:
           name: trade-logs
           path: trader/logs/*.json
           if-no-files-found: ignore
           retention-days: 14
 
       - name: FastAPI 로그 출력 (cat)
         if: always()
         run: |
           echo "::group::FastAPI Server Log"
           cat fastapi.log || true
           echo "::endgroup::"
 
       - name: FastAPI 로그 업로드 (artifact)
         if: always()
         uses: actions/upload-artifact@v4
         with:
           name: fastapi-log
           path: fastapi.log
           if-no-files-found: ignore
           retention-days: 14
 
-      
\ No newline at end of file
+      
diff --git a/README.md b/README.md
index d58aac991ce259d1183b79051b9769c3d5e8a9cf..4a112f0488c859b732bc00a0101d4519d328ab29 100644
--- a/README.md
+++ b/README.md
@@ -16,38 +16,44 @@ trader/
   trader.py (entrypoint)
   state_manager.py
   legacy_kosdaq_runner.py (previous KOSDAQ loop kept intact)
 ```
 
 ## Engine responsibilities
 - **KOSPI core engine**: KOSPI market-cap Top-N universe, equal-weight targets, periodic rebalance with market orders and KIS quotes.
 - **KOSDAQ alpha engine**: delegates to the legacy rolling-K/VWAP/pullback loop unchanged, using its original state file for backward compatibility.
 - **Capital split**: `PortfolioManager` divides `DAILY_CAPITAL` (or supplied total) into KOSPI and KOSDAQ ratios (default 60/40) and runs each engine independently.
 - **Performance**: portfolio-level PnL snapshots combine KIS cash/positions with engine allocation ratios for unified reporting without coupling the two engines.
   - Engine-level PnL is an attribution estimate based on capital split ratios because positions are pooled at the account level.
 
 ## How to run
 ```
 python -m trader.trader
 ```
 This initializes the portfolio manager, runs KOSPI rebalance if due, then executes the existing KOSDAQ intraday loop without interrupting either engine on errors. The KOSDAQ loop is blocking, so the entrypoint runs a single orchestrated cycle via `run_once()` rather than a repeating scheduler.
 
 Workflow는 bot-state 브랜치에 bot_state/state.json을 커밋하여 런 간 상태를 유지합니다.
 
 ## Diagnostic mode (no-order safety)
 Run a diagnostics-only pass (no KIS orders) even on non-trading days:
 ```
 DIAGNOSTIC_MODE=true DIAGNOSTIC_ONLY=true python -m trader.trader
 ```
-Expected log markers for grep:
-- `[DIAG][START]`, `[DIAG][RECONCILE]`, `[DIAG][DATA-HEALTH]`, `[DIAG][SETUP]`, `[DIAG][EXIT-PROBE]`, `[DIAG][END]`
+Key log markers for grep:
+- `[DIAG][TRADER] forcing DISABLE_LIVE_TRADING=true ...`
+- `[DIAG][STATE] reconciled positions=...`
+- `[DIAG][REBALANCE] kospi=... kosdaq=...`
+- `[DATA-HEALTH] code=... reasons=[...]`
+- `[SETUP-BAD] ... reasons=['...']` (never empty on failures)
+- `[ORPHAN]` / `[UNKNOWN]` aggregates
+- `[DIAG][DUMP] path=...`
 
 ## Strategy intent mode (single-account multi-strategy)
 - A new `StrategyManager` runs before engine loops and emits **order intents only** into `trader/state/strategy_intents.jsonl` with a cursor in `trader/state/strategy_intents_state.json`.
 - All five strategies (`breakout`~`volatility`) are present but **disabled by default**: `ENABLED_STRATEGIES=""` means no strategies run, and missing weights are treated as zero even when listed.
 - Enable a subset for testing, e.g. `ENABLED_STRATEGIES="momentum"` with optional weights `STRATEGY_WEIGHTS="momentum=0.10"`. Keep `STRATEGY_MODE=INTENT_ONLY` and `STRATEGY_DRY_RUN=true` (defaults) to avoid any KIS orders.
 - PortfolioManager order: strategies → KOSPI → KOSDAQ. During isolated testing use `DISABLE_KOSPI_ENGINE=true` or `DISABLE_KOSDAQ_LOOP=true` to skip respective engines.
 - State sync scripts in `scripts/state_pull_plain.sh` and `scripts/state_push_plain.sh` now copy the intent log/cursor alongside `trader/state/state.json` into the `bot-state` branch.
 
 ## CI and live-trading safeguards
 - CI (pull_request) runs set `DISABLE_LIVE_TRADING=true` so all KIS API calls are blocked and only static checks execute.
 - The live trading workflow is restricted to the `main` branch and triggers only via schedule or manual dispatch with the branch guard enabled.
diff --git a/portfolio/portfolio_manager.py b/portfolio/portfolio_manager.py
index 9193efeacf05c9c8dbd5f8b581282ebcef0a2a95..c453ceea72da1898c85b088a31656ac3aae9c61c 100644
--- a/portfolio/portfolio_manager.py
+++ b/portfolio/portfolio_manager.py
@@ -1,141 +1,107 @@
 from __future__ import annotations
 
 import logging
 import os
 from typing import Any, Dict
 
 from rolling_k_auto_trade_api.best_k_meta_strategy import run_rebalance
 from strategy.manager import StrategyManager
 from strategy.market_data import build_market_data
 import trader.intent_store as intent_store
 from trader.config import (
     DAILY_CAPITAL,
-    DIAGNOSTIC_MAX_SYMBOLS,
-    DIAGNOSTIC_MODE,
+    DIAG_ENABLED,
     DIAGNOSTIC_ONLY,
     DISABLE_KOSDAQ_LOOP,
     DISABLE_KOSPI_ENGINE,
     STRATEGY_INTENTS_PATH,
 )
-from trader.diagnostics import run_diagnostics
+from trader.diagnostics_runner import run_diagnostics_once
 from trader.intent_executor import IntentExecutor
-from trader.kis_wrapper import KisAPI
 import trader.state_store as state_store
 from trader.core_utils import get_rebalance_anchor_date
 from trader.subject_flow import reset_flow_call_count
 from .kospi_core_engine import KospiCoreEngine
 from .kosdaq_alpha_engine import KosdaqAlphaEngine
 from .performance import PerformanceTracker
 
 logger = logging.getLogger(__name__)
 
 
 class PortfolioManager:
     def __init__(
         self,
         total_capital: float | None = None,
         kospi_ratio: float = 0.6,
         kosdaq_ratio: float = 0.4,
     ) -> None:
         self.total_capital = float(total_capital or DAILY_CAPITAL)
         if kospi_ratio + kosdaq_ratio == 0:
             kospi_ratio, kosdaq_ratio = 0.6, 0.4
         norm = kospi_ratio + kosdaq_ratio
         self.kospi_ratio = kospi_ratio / norm
         self.kosdaq_ratio = kosdaq_ratio / norm
         self.kospi_engine = KospiCoreEngine(capital=self.total_capital * self.kospi_ratio)
         self.kosdaq_engine = KosdaqAlphaEngine(capital=self.total_capital * self.kosdaq_ratio)
         self.performance = PerformanceTracker()
         self.strategy_manager = StrategyManager(total_capital=self.total_capital)
         self.intent_executor = IntentExecutor()
         logger.info(
             "[PORTFOLIO] capital=%s kospi=%.0f%% kosdaq=%.0f%%",
             int(self.total_capital),
             self.kospi_ratio * 100,
             self.kosdaq_ratio * 100,
         )
 
     def run_once(self) -> Dict[str, Any]:
         reset_flow_call_count()
         selected_by_market: Dict[str, Any] = {}
         diag_result: Dict[str, Any] | None = None
-        holdings: list[dict[str, Any]] = []
-        kis_client: KisAPI | None = None
         try:
             rebalance_date = str(get_rebalance_anchor_date())
             rebalance_payload = run_rebalance(rebalance_date, return_by_market=True)
             selected_by_market = rebalance_payload.get("selected_by_market") or {}
             logger.info(
                 "[PORTFOLIO][REBALANCE] date=%s kospi=%d kosdaq=%d",
                 rebalance_date,
                 len(selected_by_market.get("KOSPI", [])),
                 len(selected_by_market.get("KOSDAQ", [])),
             )
         except Exception as e:
             logger.exception("[PORTFOLIO] rebalance fetch failed: %s", e)
 
         runtime_state = state_store.load_state()
-        try:
-            kis_client = KisAPI()
-            holdings = kis_client.get_positions()
-        except Exception as e:
-            logger.exception("[PORTFOLIO] failed to init KIS client for diagnostics: %s", e)
-            kis_client = None
-            holdings = []
-
-        symbols: list[str] = []
-        for rows in (selected_by_market or {}).values():
-            for row in rows or []:
-                code = str(row.get("code") or row.get("stock_code") or "").strip().lstrip("A").zfill(6)
-                if code and code != "000000":
-                    symbols.append(code)
-        for row in holdings or []:
-            code = str(row.get("pdno") or row.get("code") or "").strip().lstrip("A").zfill(6)
-            if code and code != "000000":
-                symbols.append(code)
-        if symbols:
-            symbols = sorted({c for c in symbols if c})[:DIAGNOSTIC_MAX_SYMBOLS]
-
         logger.info(
             "[DIAG][PM] diagnostic_mode=%s diagnostic_only=%s",
-            DIAGNOSTIC_MODE,
+            DIAG_ENABLED,
             DIAGNOSTIC_ONLY,
         )
-        if DIAGNOSTIC_MODE:
+        if DIAG_ENABLED:
             os.environ["DISABLE_LIVE_TRADING"] = "true"
-            logger.info("[DIAG][PM] forcing DISABLE_LIVE_TRADING=true")
-            diag_result = run_diagnostics(
-                selected_by_market=selected_by_market,
-                kis_client=kis_client,
-                pos_state=runtime_state,
-                symbols=symbols,
-            )
-            try:
-                state_store.save_state(runtime_state)
-            except Exception as e:
-                logger.exception("[DIAG][PM] failed to save diagnostic state: %s", e)
+            logger.info("[DIAG][PM] forcing DISABLE_LIVE_TRADING=true diag_enabled=%s", DIAG_ENABLED)
+            diag_result = run_diagnostics_once()
             if DIAGNOSTIC_ONLY:
                 return {
                     "diagnostics": diag_result,
                     "kospi": {"status": "skipped"},
                     "kosdaq": {"status": "skipped"},
                 }
 
         try:
             market_data = build_market_data(selected_by_market)
             strategy_result = self.strategy_manager.run_once(
                 market_data=market_data, portfolio_state=runtime_state
             )
             intents = strategy_result.get("intents") or []
         except Exception as e:
             logger.exception("[PORTFOLIO] strategy manager failure: %s", e)
             strategy_result = {"status": "error", "message": str(e), "enabled": [], "intents": []}
             intents = []
 
         try:
             STRATEGY_INTENTS_PATH.parent.mkdir(parents=True, exist_ok=True)
             STRATEGY_INTENTS_PATH.touch(exist_ok=True)
             intent_store.append_intents(intents, STRATEGY_INTENTS_PATH)
             executor_result = self.intent_executor.run_once()
         except Exception as e:
             logger.exception("[PORTFOLIO] intent executor failure: %s", e)
diff --git a/trader/config.py b/trader/config.py
index dea1da4a10a339028f5310ab922a6063dd10b1dd..0dff7c2d2855bde42aabb758650ec0fbc55d72c6 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -72,53 +72,54 @@ CONFIG = {
     "CHAMPION_MAX_MDD": "30.0",            # 최대 허용 MDD(%)
     "CHAMPION_MIN_SHARPE": "0.0",          # 최소 샤프 비율
     "NEUTRAL_ENTRY_SCALE": "0.6",          # 중립 레짐 신규/재진입 스케일링 비율
     # 기타
     "MARKET_DATA_WHEN_CLOSED": "false",
     "FORCE_WEEKLY_REBALANCE": "0",
     # NEW: 1분봉 VWAP 모멘텀 파라미터
     "MOM_FAST": "5",        # 1분봉 fast MA 길이
     "MOM_SLOW": "20",       # 1분봉 slow MA 길이
     "MOM_TH_PCT": "0.5",    # fast/slow 괴리 임계값(%) – 0.5% 이상이면 강세로 본다
     # Subject flow gate 기본값
     "MIN_SMART_MONEY_RATIO_KOSPI": "0.02",
     "MIN_SMART_MONEY_RATIO_KOSDAQ": "0.03",
     "SUBJECT_FLOW_TIMEOUT_SEC": "1.2",
     "SUBJECT_FLOW_RETRY": "1",
     "SUBJECT_FLOW_CACHE_TTL_SEC": "60",
     "SUBJECT_FLOW_FAIL_POLICY": "CACHE",
     "SUBJECT_FLOW_EMPTY_POLICY": "TREAT_AS_FAIL",
     "SUBJECT_FLOW_DEGRADED_TURNOVER_MULT": "1.5",
     "SUBJECT_FLOW_DEGRADED_OB_ADD": "10",
     "SUBJECT_FLOW_MAX_CALLS_PER_RUN": "200",
     "EMERGENCY_GLOBAL_SELL": "false",
     "STRATEGY_REDUCTION_PRIORITY": "5,4,3,2,1",
     # Diagnostics
     "DIAGNOSTIC_MODE": "false",
-    "DIAGNOSTIC_ONLY": "true",
-    "DIAGNOSTIC_FORCE_RUN": "true",
+    "DIAGNOSTIC_ONLY": "false",
+    "DIAGNOSTIC_FORCE_RUN": "false",
     "DIAGNOSTIC_DUMP_PATH": "trader/state/diagnostics",
+    "DIAGNOSTIC_TARGET_MARKETS": "",
     "DIAGNOSTIC_MAX_SYMBOLS": "200",
     # === Strategy intent/exec defaults ===
     "ENABLED_STRATEGIES": "",
     "STRATEGY_MODE": "INTENT_ONLY",  # INTENT_ONLY | LIVE
     "STRATEGY_DRY_RUN": "true",
     "STRATEGY_INTENTS_PATH": "trader/state/strategy_intents.jsonl",
     "STRATEGY_INTENTS_STATE_PATH": "trader/state/strategy_intents_state.json",
     "STRATEGY_MAX_OPEN_INTENTS": "20",
     "STRATEGY_MAX_POSITION_PCT": "0.10",
     "STRATEGY_ALLOW_SELL_ONLY": "false",
     "STRATEGY_WEIGHTS": "",
     "DISABLE_KOSDAQ_LOOP": "false",
     "DISABLE_KOSPI_ENGINE": "false",
 }
 
 
 def _cfg(key: str) -> str:
     """환경변수 > CONFIG 기본값"""
     return os.getenv(key, CONFIG.get(key, ""))
 
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 LOG_DIR = Path(__file__).parent / "logs"
@@ -227,53 +228,57 @@ if ENABLED_STRATEGIES_SET:
     }
 else:
     STRATEGY_WEIGHTS = {name: 0.0 for name in RAW_STRATEGY_WEIGHTS.keys()}
 
 STRATEGY_MODE = (_cfg("STRATEGY_MODE") or "INTENT_ONLY").upper()
 STRATEGY_DRY_RUN = (_cfg("STRATEGY_DRY_RUN") or "true").lower() in ("1", "true", "yes")
 STRATEGY_INTENTS_PATH = Path(_cfg("STRATEGY_INTENTS_PATH") or CONFIG["STRATEGY_INTENTS_PATH"])
 STRATEGY_INTENTS_STATE_PATH = Path(
     _cfg("STRATEGY_INTENTS_STATE_PATH") or CONFIG["STRATEGY_INTENTS_STATE_PATH"]
 )
 STRATEGY_MAX_OPEN_INTENTS = int(_cfg("STRATEGY_MAX_OPEN_INTENTS") or "20")
 STRATEGY_MAX_POSITION_PCT = float(_cfg("STRATEGY_MAX_POSITION_PCT") or "0.10")
 STRATEGY_ALLOW_SELL_ONLY = (_cfg("STRATEGY_ALLOW_SELL_ONLY") or "false").lower() in (
     "1",
     "true",
     "yes",
 )
 
 DIAGNOSTIC_MODE = (_cfg("DIAGNOSTIC_MODE") or "false").lower() in ("1", "true", "yes")
 DIAGNOSTIC_ONLY = (_cfg("DIAGNOSTIC_ONLY") or "false").lower() in ("1", "true", "yes")
 DIAGNOSTIC_FORCE_RUN = (_cfg("DIAGNOSTIC_FORCE_RUN") or "false").lower() in (
     "1",
     "true",
     "yes",
 )
-DIAGNOSTIC_DUMP_DIR = Path(_cfg("DIAGNOSTIC_DUMP_PATH") or CONFIG["DIAGNOSTIC_DUMP_PATH"])
+DIAGNOSTIC_DUMP_DIR = Path(
+    _cfg("DIAGNOSTIC_DUMP_DIR") or _cfg("DIAGNOSTIC_DUMP_PATH") or CONFIG["DIAGNOSTIC_DUMP_PATH"]
+)
 DIAGNOSTIC_DUMP_DIR.mkdir(parents=True, exist_ok=True)
 DIAGNOSTIC_MAX_SYMBOLS = int(_cfg("DIAGNOSTIC_MAX_SYMBOLS") or CONFIG["DIAGNOSTIC_MAX_SYMBOLS"])
+DIAGNOSTIC_TARGET_MARKETS = (_cfg("DIAGNOSTIC_TARGET_MARKETS") or "").strip()
+DIAG_ENABLED = DIAGNOSTIC_MODE or DIAGNOSTIC_ONLY
 
 if DIAGNOSTIC_MODE:
     STRATEGY_MODE = "INTENT_ONLY"
     STRATEGY_DRY_RUN = True
     STRATEGY_ALLOW_SELL_ONLY = True
 
 logger.info(
     "[DIAG][CONFIG] mode=%s only=%s force_run=%s dump_dir=%s",
     DIAGNOSTIC_MODE,
     DIAGNOSTIC_ONLY,
     DIAGNOSTIC_FORCE_RUN,
     str(DIAGNOSTIC_DUMP_DIR),
 )
 
 # 전략별 레짐 축소 우선순위
 def _parse_strategy_priority(raw: str) -> list[int]:
     priorities: list[int] = []
     for item in raw.split(","):
         item = item.strip()
         if not item:
             continue
         try:
             value = int(item)
         except ValueError:
             continue
diff --git a/trader/data_health.py b/trader/data_health.py
new file mode 100644
index 0000000000000000000000000000000000000000..d9497b4b74b48ac820caf97fb1d89f0826f7d944
--- /dev/null
+++ b/trader/data_health.py
@@ -0,0 +1,91 @@
+from __future__ import annotations
+
+import logging
+from typing import Any, Dict, Optional
+
+from trader.kis_wrapper import KisAPI
+
+logger = logging.getLogger(__name__)
+
+
+def _short_error(err: Exception) -> str:
+    text = str(err)
+    if len(text) > 40:
+        return text[:37] + "..."
+    return text or err.__class__.__name__
+
+
+def check_data_health(code: str, kis: Optional[KisAPI]) -> Dict[str, Any]:
+    reasons: list[str] = []
+    daily_n = 0
+    intraday_n = 0
+    prev_close = None
+    vwap = None
+    last_price = None
+
+    if kis is None:
+        return {
+            "ok": False,
+            "daily_n": daily_n,
+            "intraday_n": intraday_n,
+            "prev_close": prev_close,
+            "vwap": vwap,
+            "last_price": last_price,
+            "reasons": ["API_ERROR:NO_CLIENT"],
+        }
+
+    try:
+        daily = kis.safe_get_daily_candles(code)
+        daily_n = len(daily)
+        if daily_n < 21:
+            reasons.append("DAILY_LT_21")
+    except Exception as e:
+        reasons.append(f"API_ERROR:{_short_error(e)}")
+
+    try:
+        prev_close = kis.safe_get_prev_close(code)
+        if prev_close is None:
+            reasons.append("PREV_CLOSE_NONE")
+    except Exception as e:
+        reasons.append(f"API_ERROR:{_short_error(e)}")
+
+    bars: list[dict[str, Any]] | None = None
+    try:
+        bars = kis.safe_get_intraday_bars(code)
+        intraday_n = len(bars)
+        if intraday_n <= 0:
+            reasons.append("INTRADAY_EMPTY")
+    except Exception as e:
+        reasons.append(f"API_ERROR:{_short_error(e)}")
+
+    try:
+        vwap = kis.safe_compute_vwap(bars or [])
+        if vwap is None:
+            reasons.append("VWAP_NONE")
+    except Exception as e:
+        reasons.append(f"API_ERROR:{_short_error(e)}")
+
+    try:
+        last_price = kis.get_last_price(code)
+    except Exception as e:
+        reasons.append(f"API_ERROR:{_short_error(e)}")
+    if last_price is None:
+        reasons.append("LAST_PRICE_NONE")
+
+    ok = (
+        daily_n >= 21
+        and prev_close is not None
+        and last_price is not None
+        and vwap is not None
+        and not any(str(r or "").startswith("API_ERROR:") for r in reasons)
+    )
+
+    return {
+        "ok": ok,
+        "daily_n": int(daily_n),
+        "intraday_n": int(intraday_n),
+        "prev_close": prev_close,
+        "vwap": vwap,
+        "last_price": last_price,
+        "reasons": reasons,
+    }
diff --git a/trader/diagnostics_runner.py b/trader/diagnostics_runner.py
new file mode 100644
index 0000000000000000000000000000000000000000..9af0ef0cea6684428fc7182865d7f638ff4f5509
--- /dev/null
+++ b/trader/diagnostics_runner.py
@@ -0,0 +1,217 @@
+from __future__ import annotations
+
+import json
+import logging
+from datetime import datetime
+from pathlib import Path
+from typing import Any, Dict, Iterable
+
+from rolling_k_auto_trade_api.best_k_meta_strategy import run_rebalance
+from strategy.market_data import build_market_data
+from trader import state_store as runtime_state_store
+from trader.config import (
+    DIAG_ENABLED,
+    DIAGNOSTIC_DUMP_DIR,
+    DIAGNOSTIC_MAX_SYMBOLS,
+    DIAGNOSTIC_TARGET_MARKETS,
+)
+from trader.core_utils import get_rebalance_anchor_date
+from trader.data_health import check_data_health
+from trader.kis_wrapper import KisAPI
+from trader.setup_eval import evaluate_setup
+from trader.time_utils import is_trading_day, now_kst
+
+logger = logging.getLogger(__name__)
+
+
+def _normalize_code(sym: str | None) -> str:
+    return str(sym or "").strip().lstrip("A").zfill(6)
+
+
+def _filter_markets(
+    selected_by_market: Dict[str, Any] | None, allowed_markets: Iterable[str] | None
+) -> Dict[str, Any]:
+    if not allowed_markets:
+        return selected_by_market or {}
+    markets = {m.strip().upper() for m in allowed_markets if m and m.strip()}
+    if not markets:
+        return selected_by_market or {}
+    return {k: v for k, v in (selected_by_market or {}).items() if k.upper() in markets}
+
+
+def _collect_target_symbols(
+    selected_by_market: Dict[str, Any] | None, runtime_state: Dict[str, Any]
+) -> list[str]:
+    symbols: set[str] = set()
+    for rows in (selected_by_market or {}).values():
+        for row in rows or []:
+            code = _normalize_code(row.get("code") or row.get("stock_code") or row.get("pdno"))
+            if code and code != "000000":
+                symbols.add(code)
+    positions = runtime_state.get("positions") or {}
+    if isinstance(positions, dict):
+        symbols.update(positions.keys())
+    lots = runtime_state.get("lots") or []
+    if isinstance(lots, list):
+        for lot in lots:
+            code = _normalize_code(lot.get("code") or lot.get("pdno"))
+            if code and code != "000000":
+                symbols.add(code)
+    symbols_list = sorted(symbols)
+    if DIAGNOSTIC_MAX_SYMBOLS and len(symbols_list) > DIAGNOSTIC_MAX_SYMBOLS:
+        return symbols_list[:DIAGNOSTIC_MAX_SYMBOLS]
+    return symbols_list
+
+
+def _dump_payload(path: Path, payload: Dict[str, Any]) -> None:
+    path.parent.mkdir(parents=True, exist_ok=True)
+    with open(path, "w", encoding="utf-8") as f:
+        json.dump(payload, f, ensure_ascii=False, indent=2)
+    size = path.stat().st_size
+    logger.info("[DIAG][DUMP] path=%s bytes=%d", path, size)
+
+
+def run_diagnostics_once() -> Dict[str, Any]:
+    now = now_kst()
+    trading_day = is_trading_day(now)
+    runtime_state = runtime_state_store.load_state()
+
+    kis: KisAPI | None = None
+    try:
+        kis = KisAPI()
+    except Exception as e:
+        logger.exception("[DIAG][INIT] failed to init KisAPI: %s", e)
+
+    try:
+        balance = kis.get_balance() if kis else {}
+        runtime_state = runtime_state_store.reconcile_with_kis_balance(runtime_state, balance)
+        runtime_state_store.save_state(runtime_state)
+        logger.info("[DIAG][STATE] reconciled positions=%d", len(runtime_state.get("positions", {})))
+    except Exception as e:
+        logger.exception("[DIAG][STATE] reconcile failed: %s", e)
+
+    try:
+        rebalance_payload = run_rebalance(str(get_rebalance_anchor_date()), return_by_market=True)
+        selected_by_market = rebalance_payload.get("selected_by_market") or {}
+    except Exception as e:
+        logger.exception("[DIAG][REBALANCE] failed: %s", e)
+        selected_by_market = {}
+
+    target_markets = [m for m in (DIAGNOSTIC_TARGET_MARKETS or "").split(",") if m.strip()]
+    selected_by_market = _filter_markets(selected_by_market, target_markets)
+    logger.info(
+        "[DIAG][REBALANCE] kospi=%d kosdaq=%d",
+        len(selected_by_market.get("KOSPI", []) or []),
+        len(selected_by_market.get("KOSDAQ", []) or []),
+    )
+
+    market_data = build_market_data(selected_by_market, kis_client=kis)
+    logger.info(
+        "[DIAG][MD] symbols=%d as_of=%s",
+        len(market_data.get("prices", {})),
+        market_data.get("as_of"),
+    )
+
+    symbols = _collect_target_symbols(selected_by_market, runtime_state)
+    data_health: Dict[str, Any] = {}
+    setup_result: Dict[str, Any] = {}
+    for code in symbols:
+        health = check_data_health(code, kis)
+        data_health[code] = health
+        logger.info(
+            "[DATA-HEALTH] code=%s ok=%s daily_n=%s prev_close=%s intraday_n=%s vwap=%s reasons=%s",
+            code,
+            health.get("ok"),
+            health.get("daily_n"),
+            health.get("prev_close"),
+            health.get("intraday_n"),
+            health.get("vwap"),
+            health.get("reasons"),
+        )
+        setup = evaluate_setup(code, kis, health, runtime_state)
+        setup_result[code] = setup
+        if setup.get("setup_ok"):
+            logger.info("[SETUP-OK] code=%s reasons=%s", code, setup.get("reasons"))
+        else:
+            logger.info(
+                "[SETUP-BAD] %s | missing=%s reasons=%s | daily=%s intra=%s",
+                code,
+                setup.get("missing"),
+                setup.get("reasons"),
+                setup.get("daily", {}),
+                setup.get("intra", {}),
+            )
+        try:
+            pos = runtime_state_store.upsert_position(runtime_state, code)
+            pos["data_health"] = health
+            pos["setup"] = setup
+        except Exception:
+            logger.exception("[DIAG][STATE] failed to attach diagnostics for %s", code)
+
+    exit_checks: list[Dict[str, Any]] = []
+    for lot in runtime_state.get("lots") or []:
+        if str(lot.get("status") or "OPEN").upper() != "OPEN":
+            continue
+        lot_code = _normalize_code(lot.get("code") or lot.get("pdno"))
+        record = {
+            "lot_id": lot.get("lot_id"),
+            "code": lot_code,
+            "sid": lot.get("sid") or lot.get("strategy_id"),
+            "strategy": lot.get("strategy") or "unknown",
+            "qty": int(lot.get("remaining_qty") or lot.get("qty") or 0),
+            "decision": "SKIP_DIAG",
+            "reasons": [],
+        }
+        exit_checks.append(record)
+        logger.info(
+            "[EXIT-CHECK] lot_id=%s code=%s sid=%s strategy=%s qty=%s decision=%s reasons=%s",
+            record["lot_id"],
+            lot_code,
+            record["sid"],
+            record["strategy"],
+            record["qty"],
+            record["decision"],
+            record["reasons"],
+        )
+
+    orphan_symbols: list[str] = []
+    unknown_symbols: list[str] = []
+    for code, pos in (runtime_state.get("positions") or {}).items():
+        qty = int(pos.get("qty") or 0)
+        if qty <= 0:
+            continue
+        strategy_id = pos.get("strategy_id")
+        if strategy_id is None or strategy_id == "":
+            orphan_symbols.append(code)
+        elif str(strategy_id).upper() == "UNKNOWN":
+            unknown_symbols.append(code)
+    if orphan_symbols:
+        logger.warning("[ORPHAN] n=%d symbols=%s", len(orphan_symbols), orphan_symbols[:20])
+    if unknown_symbols:
+        logger.warning("[UNKNOWN] n=%d symbols=%s", len(unknown_symbols), unknown_symbols[:20])
+
+    payload = {
+        "ts": now.isoformat(),
+        "diag_enabled": bool(DIAG_ENABLED),
+        "trading_day": trading_day,
+        "selected_by_market": selected_by_market,
+        "data_health": data_health,
+        "setup": setup_result,
+        "orphans": orphan_symbols,
+        "unknowns": unknown_symbols,
+        "exit_checks": exit_checks,
+        "positions": runtime_state.get("positions", {}),
+    }
+
+    try:
+        runtime_state_store.save_state(runtime_state)
+    except Exception:
+        logger.exception("[DIAG][STATE] failed to persist diagnostic annotations")
+
+    dump_path = DIAGNOSTIC_DUMP_DIR / f"diag_{now.strftime('%Y%m%d_%H%M%S')}.json"
+    try:
+        _dump_payload(dump_path, payload)
+    except Exception as e:
+        logger.warning("[DIAG][DUMP_FAIL] path=%s err=%s", dump_path, e)
+
+    return payload
diff --git a/trader/setup_eval.py b/trader/setup_eval.py
new file mode 100644
index 0000000000000000000000000000000000000000..c97be3a645707b6937c82ebf39d67af86eb1d71f
--- /dev/null
+++ b/trader/setup_eval.py
@@ -0,0 +1,41 @@
+from __future__ import annotations
+
+from typing import Any, Dict, List, Optional
+
+from trader.kis_wrapper import KisAPI
+
+
+def evaluate_setup(code: str, kis: Optional[KisAPI], health: Dict[str, Any], state: Dict[str, Any]) -> Dict[str, Any]:
+    health = health or {}
+    reasons: List[str] = []
+    missing: List[str] = []
+    setup_ok = True
+
+    if not health.get("ok", False):
+        setup_ok = False
+        health_reasons = health.get("reasons") or []
+        joined = ",".join(str(r) for r in health_reasons)
+        reasons.append(f"DATA_HEALTH_BAD:{joined}" if joined else "DATA_HEALTH_BAD")
+
+    positions = (state or {}).get("positions") if isinstance(state, dict) else {}
+    pos = (positions or {}).get(str(code).zfill(6), {})
+    daily_ctx: Dict[str, Any] = {}
+    intra_ctx: Dict[str, Any] = {}
+
+    if isinstance(pos, dict):
+        daily_ctx = pos.get("data_health") or {}
+        intra_ctx = pos.get("setup") or {}
+
+    if setup_ok is False and not reasons:
+        reasons.append("UNKNOWN_SETUP_FAIL")
+    if setup_ok is False and not missing:
+        missing.append("UNKNOWN_MISSING")
+
+    payload = {
+        "setup_ok": setup_ok,
+        "missing": missing,
+        "reasons": reasons if setup_ok is False or reasons else [],
+        "daily": daily_ctx,
+        "intra": intra_ctx,
+    }
+    return payload
diff --git a/trader/state_store.py b/trader/state_store.py
index 11a17297df234747a4969fae64de9fc651f3ecfe..413ca3083193e9ab5be0794d5c6840c926f87be0 100644
--- a/trader/state_store.py
+++ b/trader/state_store.py
@@ -1,108 +1,241 @@
 from __future__ import annotations
 
 import json
 import logging
 import os
+import uuid
 from datetime import datetime
 from pathlib import Path
 from typing import Any, Dict
 
 from .config import KST
 
 logger = logging.getLogger(__name__)
 
 SCHEMA_VERSION = 2
 RUNTIME_STATE_DIR = Path(".runtime")
 RUNTIME_STATE_PATH = RUNTIME_STATE_DIR / "state.json"
+_LOT_ID_PREFIX = "LOT"
+
+
+def _normalize_code(symbol: str | int | None) -> str:
+    return str(symbol or "").zfill(6)
 
 
 def _default_runtime_state() -> Dict[str, Any]:
     return {
         "schema_version": SCHEMA_VERSION,
         "updated_at": None,
         "positions": {},
         "orders": {},
+        "lots": [],
         "memory": {"last_price": {}, "last_seen": {}, "last_strategy_id": {}},
     }
 
 
 def load_state() -> Dict[str, Any]:
     if not RUNTIME_STATE_PATH.exists():
         return _default_runtime_state()
     try:
         with open(RUNTIME_STATE_PATH, "r", encoding="utf-8") as f:
             state = json.load(f)
         if not isinstance(state, dict):
             logger.warning("[RUNTIME_STATE] invalid state format: %s", type(state))
             return _default_runtime_state()
         state.setdefault("schema_version", SCHEMA_VERSION)
         state.setdefault("positions", {})
         state.setdefault("orders", {})
         memory = state.get("memory")
         if not isinstance(memory, dict):
             memory = {}
             state["memory"] = memory
         memory.setdefault("last_price", {})
         memory.setdefault("last_seen", {})
         memory.setdefault("last_strategy_id", {})
         state.setdefault("updated_at", None)
+        lots = state.get("lots")
+        if not isinstance(lots, list):
+            lots = []
+            state["lots"] = lots
         positions = state.get("positions")
         if isinstance(positions, dict):
             for sym, payload in list(positions.items()):
                 if not isinstance(payload, dict):
                     positions[sym] = {}
         return state
     except Exception:
         logger.exception("[RUNTIME_STATE] failed to load %s", RUNTIME_STATE_PATH)
         return _default_runtime_state()
 
 
 def save_state(state: Dict[str, Any]) -> None:
     try:
         RUNTIME_STATE_DIR.mkdir(parents=True, exist_ok=True)
         payload = dict(state)
         payload.setdefault("schema_version", SCHEMA_VERSION)
         payload.setdefault("positions", {})
         payload.setdefault("orders", {})
+        payload.setdefault("lots", [])
         payload.setdefault("memory", {"last_price": {}, "last_seen": {}, "last_strategy_id": {}})
         payload["updated_at"] = datetime.now(KST).isoformat()
         tmp_path = RUNTIME_STATE_PATH.with_name(f"{RUNTIME_STATE_PATH.name}.tmp")
         with open(tmp_path, "w", encoding="utf-8") as f:
             json.dump(payload, f, ensure_ascii=False, indent=2)
             f.flush()
             os.fsync(f.fileno())
         os.replace(tmp_path, RUNTIME_STATE_PATH)
         try:
             size = RUNTIME_STATE_PATH.stat().st_size
             logger.info("[STATE][SAVE] path=%s bytes=%d", RUNTIME_STATE_PATH, size)
         except Exception:
             logger.info("[STATE][SAVE] path=%s", RUNTIME_STATE_PATH)
     except Exception:
         logger.exception("[RUNTIME_STATE] failed to save %s", RUNTIME_STATE_PATH)
 
 
+def _ensure_lots(state: Dict[str, Any]) -> list[dict[str, Any]]:
+    lots = state.get("lots")
+    if not isinstance(lots, list):
+        lots = []
+        state["lots"] = lots
+    return lots
+
+
+def _generate_lot_id(code: str, ts: str | None = None) -> str:
+    suffix = ts or datetime.now(KST).strftime("%Y%m%d%H%M%S%f")
+    return f"{_LOT_ID_PREFIX}-{_normalize_code(code)}-{suffix}-{uuid.uuid4().hex[:6]}"
+
+
+def _norm_sid(value: Any) -> Any:
+    if value is None:
+        return None
+    try:
+        return int(value)
+    except Exception:
+        return str(value)
+
+
+def record_lot_open(
+    state: Dict[str, Any],
+    *,
+    code: str,
+    sid: Any,
+    strategy: str,
+    engine: str,
+    qty: int,
+    entry_price: float,
+    entry_ts: str | None = None,
+    order_id: str | None = None,
+    lot_id: str | None = None,
+) -> Dict[str, Any]:
+    lots = _ensure_lots(state)
+    ts = entry_ts or datetime.now(KST).isoformat()
+    lot_identifier = lot_id or _generate_lot_id(code, ts)
+    payload = {
+        "lot_id": lot_identifier,
+        "code": _normalize_code(code),
+        "pdno": _normalize_code(code),
+        "sid": sid,
+        "strategy_id": sid,
+        "strategy": strategy,
+        "engine": engine,
+        "qty": int(qty),
+        "remaining_qty": int(qty),
+        "entry_ts": ts,
+        "entry_price": float(entry_price),
+        "order_id": order_id,
+        "status": "OPEN",
+    }
+    lots.append(payload)
+    logger.info(
+        "[LOT-OPEN] lot_id=%s code=%s sid=%s strategy=%s qty=%s entry_px=%s",
+        lot_identifier,
+        payload["code"],
+        sid,
+        strategy,
+        qty,
+        entry_price,
+    )
+    return payload
+
+
+def _apply_sell_to_lots(
+    state: Dict[str, Any],
+    *,
+    code: str,
+    qty: int,
+    strategy_id: Any = None,
+    order_id: str | None = None,
+    price: float | None = None,
+    ts: str | None = None,
+) -> None:
+    lots = _ensure_lots(state)
+    remaining = int(qty)
+    if remaining <= 0:
+        return
+    ts_val = ts or datetime.now(KST).isoformat()
+    target_code = _normalize_code(code)
+    sid_filter = _norm_sid(strategy_id)
+
+    def _consume(filter_sid: Any | None, remaining_qty: int) -> int:
+        for lot in lots:
+            if str(lot.get("status") or "OPEN").upper() != "OPEN":
+                continue
+            if _normalize_code(lot.get("code") or lot.get("pdno")) != target_code:
+                continue
+            lot_sid = _norm_sid(lot.get("sid") or lot.get("strategy_id"))
+            if filter_sid is not None and lot_sid != filter_sid:
+                continue
+            lot_rem = int(lot.get("remaining_qty") or lot.get("qty") or 0)
+            if lot_rem <= 0:
+                continue
+            delta = min(lot_rem, remaining_qty)
+            lot["remaining_qty"] = int(lot_rem - delta)
+            lot["qty"] = int(max(0, int(lot.get("qty") or 0) - delta))
+            lot["last_order_id"] = order_id or lot.get("last_order_id")
+            lot["last_exit_ts"] = ts_val
+            if price is not None:
+                lot["last_exit_price"] = float(price)
+            if int(lot.get("remaining_qty") or 0) <= 0:
+                lot["status"] = "CLOSED"
+            remaining_qty -= delta
+            if remaining_qty <= 0:
+                break
+        return remaining_qty
+
+    remaining = _consume(sid_filter, remaining)
+    if remaining > 0 and sid_filter is not None:
+        remaining = _consume(None, remaining)
+    if remaining > 0:
+        logger.warning(
+            "[RUNTIME_STATE][LOT_SELL_MISMATCH] code=%s sid=%s remaining_unmatched=%s",
+            target_code,
+            sid_filter,
+            remaining,
+        )
+
 def get_position(state: Dict[str, Any], symbol: str) -> Dict[str, Any] | None:
     positions = state.get("positions", {})
     if not isinstance(positions, dict):
         return None
     return positions.get(str(symbol).zfill(6))
 
 
 def upsert_position(state: Dict[str, Any], symbol: str) -> Dict[str, Any]:
     positions = state.setdefault("positions", {})
     key = str(symbol).zfill(6)
     pos = positions.get(key)
     if not isinstance(pos, dict):
         pos = {}
     positions[key] = pos
     return pos
 
 
 def update_position_fields(state: Dict[str, Any], symbol: str, fields: Dict[str, Any]) -> Dict[str, Any]:
     pos = upsert_position(state, symbol)
     for field, value in fields.items():
         pos[field] = value
     return pos
 
 
 def _order_bucket(state: Dict[str, Any], symbol: str, side: str) -> Dict[str, Any]:
@@ -156,100 +289,162 @@ def mark_order(
         state,
         symbol,
         {
             "strategy_id": strategy_id,
             "last_action": side.upper(),
             "last_action_ts": ts,
             "last_order_status": status,
             "last_order_qty": int(qty),
             "last_order_price": float(price),
         },
     )
 
 
 def mark_fill(
     state: Dict[str, Any],
     symbol: str,
     side: str,
     strategy_id: Any,
     qty: int,
     price: float,
     ts: str,
     order_id: str | None = None,
     status: str = "filled",
 ) -> None:
     pos = get_position(state, symbol) or {}
+    try:
+        if side.upper() == "BUY":
+            record_lot_open(
+                state,
+                code=symbol,
+                sid=strategy_id,
+                strategy=str(strategy_id),
+                engine=str(pos.get("engine") or "unknown"),
+                qty=int(qty),
+                entry_price=float(price),
+                entry_ts=ts,
+                order_id=order_id,
+            )
+        else:
+            _apply_sell_to_lots(
+                state,
+                code=symbol,
+                qty=int(qty),
+                strategy_id=strategy_id,
+                order_id=order_id,
+                price=float(price),
+                ts=ts,
+            )
+    except Exception:
+        logger.exception("[RUNTIME_STATE] lot update failed for %s", symbol)
     cur_qty = int(pos.get("qty") or 0)
     cur_avg = float(pos.get("avg_price") or 0.0)
     if side.upper() == "BUY":
         total_qty = cur_qty + int(qty)
         avg_price = (
             (cur_avg * cur_qty + float(price) * int(qty)) / total_qty
             if total_qty > 0
             else 0.0
         )
         pos.update({"qty": total_qty, "avg_price": avg_price, "last_buy_ts": ts})
     else:
         pos.update({"qty": max(0, cur_qty - int(qty)), "last_sell_ts": ts})
     pos["strategy_id"] = strategy_id
     pos["last_order_id"] = order_id
     pos["last_action"] = side.upper()
     pos["last_action_ts"] = ts
     pos["last_order_status"] = status
     update_position_fields(state, symbol, pos)
+    try:
+        if side.upper() == "BUY":
+            save_state(state)
+    except Exception:
+        logger.exception("[RUNTIME_STATE] failed to persist after lot open for %s", symbol)
 
 
 def reconcile_with_kis_balance(
     state: Dict[str, Any],
     balance: Dict[str, Any],
     *,
     preferred_strategy: Dict[str, Any] | None = None,
 ) -> Dict[str, Any]:
     preferred_strategy = preferred_strategy or {}
     positions = state.setdefault("positions", {})
+    lots = _ensure_lots(state)
+    open_qty_by_code: Dict[str, int] = {}
+    for lot in lots:
+        if str(lot.get("status") or "OPEN").upper() != "OPEN":
+            continue
+        code_key = _normalize_code(lot.get("code") or lot.get("pdno"))
+        rem = int(lot.get("remaining_qty") or lot.get("qty") or 0)
+        if not code_key or rem <= 0:
+            continue
+        open_qty_by_code[code_key] = open_qty_by_code.get(code_key, 0) + rem
     balance_positions = balance.get("positions") if isinstance(balance, dict) else None
     if not isinstance(balance_positions, list):
         return state
     seen = set()
     for row in balance_positions:
         symbol = str(row.get("code") or row.get("pdno") or "").zfill(6)
         if not symbol:
             continue
         qty = int(row.get("qty") or 0)
         if qty <= 0:
             continue
         seen.add(symbol)
         pos = upsert_position(state, symbol)
         strategy_id = pos.get("strategy_id") or preferred_strategy.get(symbol) or "UNKNOWN"
         pos.update(
             {
                 "strategy_id": strategy_id,
                 "qty": qty,
                 "avg_price": float(row.get("avg_price") or 0.0),
                 "last_action": "RECONCILE",
             }
         )
+        open_qty = open_qty_by_code.get(symbol, 0)
+        if open_qty < qty:
+            orphan_qty = qty - open_qty
+            try:
+                record_lot_open(
+                    state,
+                    code=symbol,
+                    sid="UNKNOWN",
+                    strategy="ORPHAN",
+                    engine="reconcile",
+                    qty=orphan_qty,
+                    entry_price=float(row.get("avg_price") or 0.0),
+                    entry_ts=datetime.now(KST).isoformat(),
+                )
+                logger.warning(
+                    "[ORPHAN-LOT] code=%s qty=%s reason=%s",
+                    symbol,
+                    orphan_qty,
+                    "RECONCILE_NO_LOT",
+                )
+            except Exception:
+                logger.exception("[ORPHAN-LOT][FAIL] code=%s qty=%s", symbol, orphan_qty)
     for symbol, pos in list(positions.items()):
         if symbol not in seen:
             pos["qty"] = 0
             pos["last_action"] = "RECONCILE"
             positions[symbol] = pos
     return state
 
 
 def _default_lot_state() -> Dict[str, Any]:
     return {"version": SCHEMA_VERSION, "lots": [], "updated_at": None}
 
 
 def load_lot_state(path_json: str) -> Dict[str, Any]:
     path = Path(path_json)
     if not path.exists():
         return _default_lot_state()
     try:
         with open(path, "r", encoding="utf-8") as f:
             state = json.load(f)
         if not isinstance(state, dict):
             logger.warning("[STATE_STORE] invalid state format: %s", type(state))
             return _default_lot_state()
         state.setdefault("version", SCHEMA_VERSION)
         state.setdefault("lots", [])
         state.setdefault("updated_at", None)
diff --git a/trader/trader.py b/trader/trader.py
index 0b509bffb1cfe86aee2bd8d2d30fe3538788ac2f..08c47ec127da29d30d088f3b1c36658fa353bdee 100644
--- a/trader/trader.py
+++ b/trader/trader.py
@@ -1,44 +1,65 @@
 # -*- coding: utf-8 -*-
 """Thin entrypoint orchestrating KOSPI core + KOSDAQ alpha engines."""
 from __future__ import annotations
 
 import logging
 import os
 
 from portfolio.portfolio_manager import PortfolioManager
 from trader.kis_wrapper import KisAPI
 from trader import state_store as runtime_state_store
 from trader.time_utils import is_trading_day, now_kst
 from trader.subject_flow import get_subject_flow_with_fallback  # noqa: F401 - exported for engines
-from trader.config import DIAGNOSTIC_FORCE_RUN, DIAGNOSTIC_MODE
+from trader.config import DIAG_ENABLED, DIAGNOSTIC_FORCE_RUN, DIAGNOSTIC_MODE, DIAGNOSTIC_ONLY
 
 logger = logging.getLogger(__name__)
 
 
 def main() -> None:
     now = now_kst()
-    if DIAGNOSTIC_MODE:
+    diag_enabled = DIAG_ENABLED
+    if diag_enabled:
         os.environ["DISABLE_LIVE_TRADING"] = "true"
-        logger.info("[DIAG][PM] forcing DISABLE_LIVE_TRADING=true")
-    if not is_trading_day(now) and not (DIAGNOSTIC_MODE and DIAGNOSTIC_FORCE_RUN):
+        logger.info(
+            "[DIAG][TRADER] forcing DISABLE_LIVE_TRADING=true diag_enabled=%s",
+            diag_enabled,
+        )
+    if not is_trading_day(now) and not (diag_enabled and DIAGNOSTIC_FORCE_RUN):
         logger.warning("[TRADER] 비거래일(%s) → 즉시 종료", now.date())
         return
+    if DIAGNOSTIC_ONLY:
+        from trader.diagnostics_runner import run_diagnostics_once
+
+        run_diagnostics_once()
+        logger.info("[DIAG][TRADER] diagnostic_only complete")
+        return
     try:
         runtime_state = runtime_state_store.load_state()
         kis = KisAPI()
         balance = kis.get_balance()
         runtime_state = runtime_state_store.reconcile_with_kis_balance(
             runtime_state, balance
         )
         runtime_state_store.save_state(runtime_state)
         logger.info("[TRADER] runtime state reconciled")
     except Exception:
         logger.exception("[TRADER] runtime state reconcile failed")
 
+    diag_result = None
+    if DIAGNOSTIC_MODE:
+        try:
+            from trader.diagnostics_runner import run_diagnostics_once
+
+            diag_result = run_diagnostics_once()
+        except Exception:
+            logger.exception("[DIAG][TRADER] diagnostics run failed")
+
     mgr = PortfolioManager()
     result = mgr.run_once()
+    if isinstance(result, dict) and diag_result is not None:
+        result.setdefault("diagnostics", diag_result)
     logger.info("[TRADER] cycle complete %s", result)
 
 
 if __name__ == "__main__":
     main()
