diff --git a/portfolio/base_engine.py b/portfolio/base_engine.py
index 56a5d5216f0f7fc489784539a87311d628ca1a3e..b491ba0d6d10b31a8ae4285a64c2449c97737040 100644
--- a/portfolio/base_engine.py
+++ b/portfolio/base_engine.py
@@ -1,29 +1,29 @@
 from __future__ import annotations
 
 import logging
 from abc import ABC, abstractmethod
 from typing import Any
 
 
 class BaseEngine(ABC):
     """Shared interface for independent trading engines."""
 
     def __init__(self, name: str, capital: float) -> None:
         self.name = name
         self.capital = float(capital)
         self.logger = logging.getLogger(self.__class__.__name__)
 
     @property
     def tag(self) -> str:
         return f"[{self.name.upper()}]"
 
     @abstractmethod
-    def rebalance_if_needed(self) -> Any:
+    def rebalance_if_needed(self, selected_stocks: list[dict[str, Any]] | None = None) -> Any:
         ...
 
     @abstractmethod
-    def trade_loop(self) -> Any:
+    def trade_loop(self, selected_stocks: list[dict[str, Any]] | None = None) -> Any:
         ...
 
     def _log(self, message: str) -> None:
         self.logger.info(f"{self.tag} {message}")
diff --git a/portfolio/kosdaq_alpha_engine.py b/portfolio/kosdaq_alpha_engine.py
index 8c05c1c107371a9a58e2c5a0d5f5ff40dfcda991..f9d138b88802800d1509ae0b9bc7acbdc8ef5439 100644
--- a/portfolio/kosdaq_alpha_engine.py
+++ b/portfolio/kosdaq_alpha_engine.py
@@ -1,20 +1,20 @@
 from __future__ import annotations
 
 from typing import Any, Dict
 
 from .base_engine import BaseEngine
 from strategy.kosdaq.rolling_entry import run_trade_loop
 
 
 class KosdaqAlphaEngine(BaseEngine):
     def __init__(self, capital: float) -> None:
         super().__init__("kosdaq_alpha", capital)
 
-    def rebalance_if_needed(self) -> Dict[str, Any]:
+    def rebalance_if_needed(self, selected_stocks: list[dict[str, Any]] | None = None) -> Dict[str, Any]:
         # kosdaq engine keeps its own intraday logic; rebalance handled inside legacy loop
         return {"status": "delegated"}
 
-    def trade_loop(self) -> Any:
+    def trade_loop(self, selected_stocks: list[dict[str, Any]] | None = None) -> Any:
         self._log("starting legacy KOSDAQ loop")
-        result = run_trade_loop(capital_override=self.capital)
+        result = run_trade_loop(capital_override=self.capital, selected_stocks=selected_stocks)
         return result
diff --git a/portfolio/kospi_core_engine.py b/portfolio/kospi_core_engine.py
index c09e1cd7d3ed2bd93144ef34d42422b62bc82cec..63c2d00588171d6287d5845b3ec222cb82f8015d 100644
--- a/portfolio/kospi_core_engine.py
+++ b/portfolio/kospi_core_engine.py
@@ -1,104 +1,168 @@
 from __future__ import annotations
 
 import logging
 from datetime import datetime, time, timedelta, timezone
 from typing import Any, Dict
 
+from rolling_k_auto_trade_api.adjust_price_to_tick import adjust_price_to_tick
 from trader import state_manager
 from .base_engine import BaseEngine
-from strategy.kospi.rebalance import INDEX_CODE, build_target_allocations, evaluate_regime
+from strategy.kospi.rebalance import (
+    INDEX_CODE,
+    build_target_allocations,
+    evaluate_regime,
+)
 from strategy.kospi.signals import execute_rebalance
 
 logger = logging.getLogger(__name__)
 KST = timezone(timedelta(hours=9))
 INTRADAY_DROP_LIMIT = -2.0
 
 
 class KospiCoreEngine(BaseEngine):
     def __init__(self, capital: float, top_n: int = 100, rebalance_days: int = 30) -> None:
         super().__init__("kospi_core", capital)
         self.top_n = top_n
         self.rebalance_days = rebalance_days
         self._last_rebalance: datetime | None = self._load_last_rebalance()
 
     def _load_last_rebalance(self) -> datetime | None:
         _, _, meta = state_manager.load_state(self.name, include_meta=True)
         ts = meta.get("last_rebalance") if isinstance(meta, dict) else None
         if not ts:
             return None
         try:
-            return datetime.fromisoformat(ts)
+            loaded = datetime.fromisoformat(ts)
+            if loaded.tzinfo is None:
+                loaded = loaded.replace(tzinfo=KST)
+            return loaded
         except Exception:
             logger.warning("[KOSPI_CORE] invalid last_rebalance in state: %s", ts)
             return None
 
     def _should_rebalance(self) -> bool:
         if self._last_rebalance is None:
             return True
-        return datetime.now() - self._last_rebalance >= timedelta(days=self.rebalance_days)
+        return datetime.now(tz=KST) - self._last_rebalance >= timedelta(days=self.rebalance_days)
 
     def _current_index_change_pct(self) -> float | None:
         try:
             from rolling_k_auto_trade_api.kis_api import get_price_quote
 
             quote = get_price_quote(INDEX_CODE)
             current = float(quote.get("stck_prpr") or quote.get("prpr") or 0)
             prev_close = float(quote.get("prdy_clpr") or 0)
             if current and prev_close:
                 return (current / prev_close - 1) * 100
         except Exception:
             logger.exception("[KOSPI_CORE] failed to fetch live index quote")
         return None
 
     def _buys_permitted(self, regime: Dict[str, Any]) -> bool:
         if not regime.get("regime_on"):
             self._log("[KOSPI_CORE][BUYS] blocked (regime OFF)")
             return False
 
         now = datetime.now(tz=KST).time()
         if now < time(9, 30):
             self._log("[KOSPI_CORE][BUYS] blocked (pre-open window)")
             return False
 
         daily_change = float(regime.get("daily_change_pct") or 0)
         if daily_change <= INTRADAY_DROP_LIMIT:
             self._log(
                 f"[KOSPI_CORE][BUYS] blocked (prev change {daily_change:.2f}% <= {INTRADAY_DROP_LIMIT}%)"
             )
             return False
 
         live_change = self._current_index_change_pct()
         if live_change is not None and live_change <= INTRADAY_DROP_LIMIT:
             self._log(
                 f"[KOSPI_CORE][BUYS] blocked (live change {live_change:.2f}% <= {INTRADAY_DROP_LIMIT}%)"
             )
             return False
 
         return True
 
-    def rebalance_if_needed(self) -> Dict[str, Any]:
+    def _targets_from_selected(self, selected_stocks: list[dict[str, Any]]) -> list[dict[str, float]]:
+        """Convert external selection (with weights) into engine targets."""
+
+        if not selected_stocks:
+            return []
+
+        targets: list[dict[str, float]] = []
+        for row in selected_stocks:
+            raw_code = str(row.get("code") or row.get("stock_code") or "").strip()
+            if not raw_code:
+                continue
+
+            code = raw_code.zfill(6)
+            if code == "000000":
+                continue
+
+            weight = float(row.get("weight") or 0.0)
+            if weight <= 0:
+                continue
+
+            price = float(
+                row.get("prev_close")
+                or row.get("close")
+                or row.get("Î™©ÌëúÍ∞Ä")
+                or 0.0
+            )
+            price = adjust_price_to_tick(price, code=code) if price else 0.0
+
+            target_val = float(self.capital) * weight if price > 0 else 0.0
+            target_qty = int(target_val // price) if price > 0 else 0
+
+            if target_qty <= 0:
+                continue
+
+            targets.append(
+                {
+                    "code": code,
+                    "name": row.get("name") or row.get("stock_name") or "",
+                    "weight": weight,
+                    "target_value": target_val,
+                    "last_price": price,
+                    "target_qty": target_qty,
+                }
+            )
+
+        return targets
+
+    def rebalance_if_needed(self, selected_stocks: list[dict[str, Any]] | None = None) -> Dict[str, Any]:
         if not self._should_rebalance():
             return {"status": "skip"}
         regime = evaluate_regime()
         allow_buys = self._buys_permitted(regime)
         if not regime.get("regime_on"):
             targets: list[dict[str, float]] = []
             self._log("[KOSPI_CORE][REGIME] OFF ‚Üí liquidate positions")
         else:
-            targets, meta = build_target_allocations(self.capital, self.top_n)
-            self._log(f"[KOSPI_CORE][SELECTION] selected={meta.get('selected')}")
+            if selected_stocks is not None:
+                targets = self._targets_from_selected(selected_stocks)
+                logger.info(
+                    "[KOSPI_CORE][REBALANCE] using external selection (count=%d)",
+                    len(targets),
+                )
+                if not targets:
+                    self._log("[KOSPI_CORE][SELECTION] external selection empty ‚Üí skip buys")
+            else:
+                targets, meta = build_target_allocations(self.capital, self.top_n)
+                self._log(f"[KOSPI_CORE][SELECTION] selected={meta.get('selected')}")
 
         fills = execute_rebalance(targets, self.capital, self.tag, allow_buys=allow_buys)
-        self._last_rebalance = datetime.now()
+        self._last_rebalance = datetime.now(tz=KST)
         holding, traded, _ = state_manager.load_state(self.name, include_meta=True)
         state_manager.save_state(
             self.name,
             holding,
             traded,
             meta={"last_rebalance": self._last_rebalance.isoformat()},
         )
         self._log(f"[KOSPI_CORE][PORTFOLIO] targets={len(targets)} fills={len(fills)}")
         return {"targets": targets, "fills": fills, "regime": regime}
 
-    def trade_loop(self) -> Dict[str, Any]:
-        return self.rebalance_if_needed()
+    def trade_loop(self, selected_stocks: list[dict[str, Any]] | None = None) -> Dict[str, Any]:
+        return self.rebalance_if_needed(selected_stocks=selected_stocks)
diff --git a/portfolio/portfolio_manager.py b/portfolio/portfolio_manager.py
index 8eaa4062a7cf08c3db3b62ec3c9a3dfce445da07..6229b1c0ed23b24d378e0111510c444c4da0f110 100644
--- a/portfolio/portfolio_manager.py
+++ b/portfolio/portfolio_manager.py
@@ -1,54 +1,76 @@
 from __future__ import annotations
 
 import logging
 from typing import Any, Dict
 
+from rolling_k_auto_trade_api.best_k_meta_strategy import run_rebalance
 from trader.config import DAILY_CAPITAL
+from trader.core_utils import get_rebalance_anchor_date
+from trader.subject_flow import reset_flow_call_count
 from .kospi_core_engine import KospiCoreEngine
 from .kosdaq_alpha_engine import KosdaqAlphaEngine
 from .performance import PerformanceTracker
 
 logger = logging.getLogger(__name__)
 
 
 class PortfolioManager:
     def __init__(
         self,
         total_capital: float | None = None,
         kospi_ratio: float = 0.6,
         kosdaq_ratio: float = 0.4,
     ) -> None:
         self.total_capital = float(total_capital or DAILY_CAPITAL)
         if kospi_ratio + kosdaq_ratio == 0:
             kospi_ratio, kosdaq_ratio = 0.6, 0.4
         norm = kospi_ratio + kosdaq_ratio
         self.kospi_ratio = kospi_ratio / norm
         self.kosdaq_ratio = kosdaq_ratio / norm
         self.kospi_engine = KospiCoreEngine(capital=self.total_capital * self.kospi_ratio)
         self.kosdaq_engine = KosdaqAlphaEngine(capital=self.total_capital * self.kosdaq_ratio)
         self.performance = PerformanceTracker()
         logger.info(
             "[PORTFOLIO] capital=%s kospi=%.0f%% kosdaq=%.0f%%",
             int(self.total_capital),
             self.kospi_ratio * 100,
             self.kosdaq_ratio * 100,
         )
 
     def run_once(self) -> Dict[str, Any]:
+        reset_flow_call_count()
+        selected_by_market: Dict[str, Any] = {}
         try:
-            kospi = self.kospi_engine.rebalance_if_needed()
+            rebalance_date = str(get_rebalance_anchor_date())
+            rebalance_payload = run_rebalance(rebalance_date, return_by_market=True)
+            selected_by_market = rebalance_payload.get("selected_by_market") or {}
+            logger.info(
+                "[PORTFOLIO][REBALANCE] date=%s kospi=%d kosdaq=%d",
+                rebalance_date,
+                len(selected_by_market.get("KOSPI", [])),
+                len(selected_by_market.get("KOSDAQ", [])),
+            )
+        except Exception as e:
+            logger.exception("[PORTFOLIO] rebalance fetch failed: %s", e)
+
+        try:
+            kospi = self.kospi_engine.rebalance_if_needed(
+                selected_stocks=selected_by_market.get("KOSPI")
+            )
         except Exception as e:
             logger.exception("[PORTFOLIO] KOSPI engine failure: %s", e)
             kospi = {"status": "error", "message": str(e)}
         try:
-            kosdaq = self.kosdaq_engine.trade_loop()
+            kosdaq = self.kosdaq_engine.trade_loop(
+                selected_stocks=selected_by_market.get("KOSDAQ")
+            )
         except Exception as e:
             logger.exception("[PORTFOLIO] KOSDAQ engine failure: %s", e)
             kosdaq = {"status": "error", "message": str(e)}
         perf = self.performance.snapshot(
             {
                 "kospi_core": self.kospi_engine.capital,
                 "kosdaq_alpha": self.kosdaq_engine.capital,
             }
         )
         return {"kospi": kospi, "kosdaq": kosdaq, "performance": perf}
diff --git a/rolling_k_auto_trade_api/adjust_price_to_tick.py b/rolling_k_auto_trade_api/adjust_price_to_tick.py
index 6fae28b4123de978b4e3f03582045ed42b20da89..aea5800b22d78769ccb0a574c7e299c3ab239f1b 100644
--- a/rolling_k_auto_trade_api/adjust_price_to_tick.py
+++ b/rolling_k_auto_trade_api/adjust_price_to_tick.py
@@ -1,31 +1,32 @@
 # rolling_k_auto_trade_api/adjust_price_to_tick.py
 
-def adjust_price_to_tick(price: float) -> int:
+def adjust_price_to_tick(price: float, code: str | None = None) -> int:
     """
     ÌïúÍµ≠ Ï£ºÏãù ÏãúÏû• Ìò∏Í∞ÄÎã®ÏúÑ(Ìã±ÏÇ¨Ïù¥Ï¶à)Ïóê ÎßûÍ≤å Í∞ÄÍ≤©ÏùÑ ÏûêÎèô Î≥¥Ï†ï.
     - KOSDAQ/ÏΩîÏä§Ìîº Í∏∞Ï§Ä Ìò∏Í∞ÄÎã®ÏúÑ (1Ïõê ~ 1000Ïõê Îã®ÏúÑÍπåÏßÄ ÏßÄÏõê)
+    - code Ïù∏ÏûêÎäî Ìò∏Í∞Ä Îã®ÏúÑ Í≤∞Ï†ïÏóê ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏúºÎÇò, Ìò∏Ï∂úÎ∂Ä Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥ ÌóàÏö©ÌïúÎã§.
     """
     # 2024ÎÖÑ Í∏∞Ï§Ä Ìã±ÏÇ¨Ïù¥Ï¶à ÌÖåÏù¥Î∏î (KOSPI/KOSDAQ Í≥µÌÜµ)
     tick_table = [
         (1_000_000, 1_000),
         (500_000, 500),
         (100_000, 100),
         (10_000, 50),
         (1_000, 10),
         (100, 1),
         (0, 1),
     ]
     price = float(price)
     for base, tick in tick_table:
         if price >= base:
             # priceÎ•º Ìï¥Îãπ tickÎã®ÏúÑÎ°ú ÎÇ¥Î¶º (Ï£ºÎ¨∏ Ïò§Î•ò Î∞©ÏßÄ)
             return int(price // tick * tick)
     return int(price)
 
 # (Î≥¥Ï°∞) ÏÜåÏàòÏ†ê Í∞ÄÍ≤©(ETF, ETN Îì±)Ïö©
 def adjust_price_to_tick_decimal(price: float) -> float:
     """
     ÏÜåÏàòÏ†ê Ï£ºÏãù/ETF/ETN Îì±ÏóêÏÑú Ïì∏ Ïàò ÏûàÎäî Ìã± Îã®ÏúÑ Î≥¥Ï†ï (1Ïõê, 0.5Ïõê Îì±)
     """
     tick_table = [
         (100_000, 100),
diff --git a/rolling_k_auto_trade_api/best_k_meta_strategy.py b/rolling_k_auto_trade_api/best_k_meta_strategy.py
index 4f4154d7473c47d540941752d96afd44e4611e07..10329877ec5606785381945b536c83397f083ea2 100644
--- a/rolling_k_auto_trade_api/best_k_meta_strategy.py
+++ b/rolling_k_auto_trade_api/best_k_meta_strategy.py
@@ -44,51 +44,51 @@ K_STEP_FINE = float(os.getenv("K_STEP_FINE", "0.05"))
 K_DYNAMIC_STEP_MIN = float(os.getenv("K_DYNAMIC_STEP_MIN", "0.03"))
 K_DYNAMIC_STEP_MAX = float(os.getenv("K_DYNAMIC_STEP_MAX", "0.10"))
 K_DYNAMIC_STEP_MULT = float(os.getenv("K_DYNAMIC_STEP_MULT", "1.5"))
 
 MIN_TRADES = int(os.getenv("MIN_TRADES", "5"))
 MAX_MDD_PCT = float(os.getenv("MAX_MDD_PCT", "30"))
 REQUIRE_POS_RET = os.getenv("REQUIRE_POS_RET", "true").lower() == "true"
 
 TOP_N = int(os.getenv("TOP_N", "50"))
 
 ALWAYS_INCLUDE_CODES = {
     c.strip() for c in os.getenv("ALWAYS_INCLUDE_CODES", "").replace(" ", "").split(",") if c.strip()
 }
 KEEP_HELD_BYPASS_FILTERS = os.getenv("KEEP_HELD_BYPASS_FILTERS", "true").lower() == "true"
 HELD_MIN_WEIGHT = float(os.getenv("HELD_MIN_WEIGHT", "0.01"))
 
 # -----------------------------
 # Ïú†Ìã∏
 # -----------------------------
 def _clip(v: float, lo: float, hi: float) -> float:
     return max(lo, min(hi, v))
 
 def _round2(x: float) -> float:
     return float(np.round(x, 2))
 
-def _safe_float(x: Any, default: float = 0.0) -> float:
+def _safe_float(x: Any, default: float | None = 0.0) -> float | None:
     try:
         return float(x)
     except Exception:
         return default
 
 def _find_column(df: pd.DataFrame, keyword: str) -> Optional[str]:
     kw = keyword.replace(" ", "")
     for c in df.columns:
         if kw in str(c).replace(" ", ""):
             return c
     return None
 
 # -----------------------------
 # 1) ÏãúÍ∞ÄÏ¥ùÏï° Í∏∞Ï§Ä Top-N (KOSDAQ only for rolling-k universe)
 # -----------------------------
 @lru_cache(maxsize=None)
 def _get_listing_df_cached(markets: tuple[str, ...]) -> pd.DataFrame:
     frames: List[pd.DataFrame] = []
     for m in markets:
         try:
             df = fdr.StockListing(m).rename(columns={"Symbol": "Code", "Name": "Name"})
             df["Code"] = df["Code"].astype(str).str.zfill(6)
             frames.append(df[["Code", "Name"]])
         except Exception:
             logger.exception("‚ùå  StockListing(%s) Ïã§Ìå®", m)
@@ -247,257 +247,392 @@ def simulate_k_range_for(
 # -----------------------------
 def get_price_data_segments(code: str, base_date: date) -> Dict[str, List[Dict[str, Any]]]:
     """
     base_dateÎ•º Í∏∞Ï§ÄÏúºÎ°ú Ïù¥Ï†Ñ Í±∞ÎûòÏùºÍπåÏßÄÏùò Îç∞Ïù¥ÌÑ∞Î•º ÏàòÏßëÌïòÏó¨
     year/quarter/month ÏÑ∏Í∑∏Î®ºÌä∏Î°ú Î∞òÌôò.
     """
     try:
         start_date = base_date - timedelta(days=400)
         end_date = base_date - timedelta(days=1)
         df = fdr.DataReader(code, start=start_date, end=end_date)
         df = (
             df.dropna(subset=["Open", "High", "Low", "Close", "Volume"])
             .rename(columns={
                 "Open": "open", "High": "high", "Low": "low",
                 "Close": "close", "Volume": "volume"
             })
             .reset_index()
         )
         if "Date" not in df.columns:
             if df.index.name is not None:
                 df = df.rename_axis("Date").reset_index()
             else:
                 raise ValueError("DataReader Í≤∞Í≥ºÏóê Date Ïª¨ÎüºÏù¥ ÏóÜÏùå")
         df["date"] = pd.to_datetime(df["Date"]).dt.date
         df = df[["date", "open", "high", "low", "close", "volume"]].sort_values("date")
+        prev_records = df[df["date"] < base_date].tail(1).to_dict("records")
         return {
             "year": df[df["date"] >= base_date - timedelta(days=365)].to_dict("records"),
             "quarter": df[df["date"] >= base_date - timedelta(days=90)].to_dict("records"),
             "month": df[df["date"] >= base_date - timedelta(days=30)].to_dict("records"),
+            "prev": prev_records,
         }
     except Exception as e:
         logger.exception(f"[ERROR] ‚ùå Failed to fetch data for {code}: {e}")
-        return {"year": [], "quarter": [], "month": []}
+        return {"year": [], "quarter": [], "month": [], "prev": []}
 
 # -----------------------------
 # 4) K ÏµúÏ†ÅÌôî & ÌïÑÌÑ∞ÎßÅ (+ Î≥¥Ïú†Î∂Ñ Í∞ïÏ†ú Ìè¨Ìï®)
 # -----------------------------
 def _parse_force_include_codes(env_codes: Iterable[str]) -> List[str]:
     out = []
     for c in env_codes:
         c = str(c).strip()
         if not c:
             continue
         out.append(c.zfill(6))
     return sorted(set(out))
 
-def _inject_forced_codes(universe_df: pd.DataFrame, forced_codes: List[str]) -> pd.DataFrame:
+def _inject_forced_codes(universe_df: pd.DataFrame, forced_codes: List[str], markets: Iterable[str]) -> pd.DataFrame:
     if not forced_codes:
         return universe_df
-    fdr_df = _get_listing_df(["KOSDAQ"])
+    fdr_df = _get_listing_df(list(markets))
     force_df = fdr_df[fdr_df["Code"].isin(forced_codes)][["Code", "Name"]].copy()
     missing = [c for c in forced_codes if c not in set(force_df["Code"])]
     if missing:
         force_df = pd.concat(
             [force_df, pd.DataFrame({"Code": missing, "Name": [None] * len(missing)})],
             ignore_index=True,
         )
     uni = universe_df.copy()
     uni = pd.concat([uni[["Code", "Name", "Marcap"]], force_df.assign(Marcap=np.nan)], ignore_index=True)
     uni = uni.drop_duplicates(subset=["Code"], keep="first")
     return uni
 
-def get_best_k_for_kosdaq_topn(rebalance_date_str: str) -> List[Dict[str, Any]]:
-    """
-    Î¶¨Î∞∏Îü∞Ïã± ÎåÄÏÉÅ Î¶¨Ïä§Ìä∏ ÏûëÏÑ±:
-    - code/name/best_k/weight(+qty=None) + prev_* + Î™©ÌëúÍ∞Ä(close Ìè¨Ìï®)ÍπåÏßÄ Ï±ÑÏõÄ
-    - KOSDAQ TopNÎßå Ìè¨Ìï® (KOSPIÎäî Î≥ÑÎèÑ ÏΩîÏñ¥ ÏóîÏßÑÏóêÏÑú Ï≤òÎ¶¨)
-    """
-    rebalance_date = datetime.strptime(rebalance_date_str, "%Y-%m-%d").date()
-
-    kosdaq_df = get_kosdaq_top_n(rebalance_date_str, n=TOP_N)
-    logger.info("üìà Ïú†ÎãàÎ≤ÑÏä§ ÏàòÏßë: KOSDAQ=%d (Top%d)", len(kosdaq_df), TOP_N)
-    top_df = kosdaq_df.copy()
-    forced_codes = _parse_force_include_codes(ALWAYS_INCLUDE_CODES)
-    if forced_codes:
-        top_df = _inject_forced_codes(top_df, forced_codes)
-
-    if top_df.empty:
-        logger.warning("[WARN] KOSDAQ TopN Í≤∞Í≥º ÏóÜÏùå ‚Üí Îπà Î¶¨Ïä§Ìä∏ Î∞òÌôò")
-        return []
-
-    logger.info("üìä KOSDAQ ÏãúÏ¥ù TopN Ïú†ÎãàÎ≤ÑÏä§ ÏàòÎüâ: %dÍ∞ú (Í≥†Ïú†)", len(top_df))
-
+def _calc_best_k_for_universe(
+    universe_df: pd.DataFrame,
+    rebalance_date: date,
+    forced_codes: List[str],
+    market: str,
+) -> List[Dict[str, Any]]:
     results: Dict[str, Dict[str, Any]] = {}
 
-    for _, stock in top_df.iterrows():
+    for _, stock in universe_df.iterrows():
         code, name = str(stock["Code"]).zfill(6), stock.get("Name")
         try:
             segments = get_price_data_segments(code, rebalance_date)
             month_data = segments["month"]
 
             if not month_data:
                 logger.debug(f"[SKIP] {name}({code}) Ï†ÑÏõî Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå")
                 if code in forced_codes and KEEP_HELD_BYPASS_FILTERS:
                     results[code] = {
-                        "code": code, "name": name, "best_k": 0.5,
+                        "code": code, "name": name, "market": market, "best_k": 0.5,
                         "avg_return_pct": 0.0, "win_rate_pct": 0.0,
                         "mdd_pct": 0.0, "trades": 0, "cumulative_return_pct": 0.0,
                         "avg_holding_days": 0.0, "sharpe_m": 0.0,
                         "Î™©ÌëúÍ∞Ä": None, "close": None,
-                        "prev_open": None, "prev_high": None, "prev_low": None, "prev_close": None, "prev_volume": None,
+                        "prev_open": None, "prev_high": None, "prev_low": None, "prev_close": None, "prev_volume": None, "prev_turnover": None,
                         "forced_include": True, "filtered_reason": "NO_DATA",
                         "qty": None, "weight": None, "k_grid_mode": K_GRID_MODE,
                     }
                 continue
 
             # K grid ‚Üí best_k ÏÑ†ÌÉù
             k_range = _build_k_range(code, month_data)
             m_metrics = simulate_k_range_for(code, month_data, k_range=k_range)
             best_k = get_best_k_meta([], [], m_metrics)
 
             # ÏÑ±Îä• ÏßÄÌëú(Ïõî)
             month_perf = simulate_with_k_and_get_metrics(code, best_k, month_data)
             avg_return = float(month_perf.get("avg_return_pct", 0.0))
-            win_rate   = float(month_perf.get("win_rate_pct", 0.0))
-            mdd        = float(month_perf.get("mdd_pct", 0.0))
-            trades     = int(month_perf.get("trades", 0))
-            cum_ret    = float(month_perf.get("cumulative_return_pct", avg_return))
-            hold_days  = float(month_perf.get("avg_holding_days", 1))
-
-            # ÌïÑÌÑ∞
-            filtered_out = False
-            reason = []
-            if REQUIRE_POS_RET and avg_return <= 0:
-                filtered_out = True; reason.append("NEG_RET")
+            win_rate = float(month_perf.get("win_rate_pct", 0.0))
+            mdd = float(abs(month_perf.get("mdd_pct", 0.0)))
+            trades = int(month_perf.get("trades", 0))
+            cumret = float(month_perf.get("cumulative_return_pct", 0.0))
+            sharpe_m = float(month_perf.get("sharpe_m", 0.0))
+            avg_hold = float(month_perf.get("avg_holding_days", 0.0))
+
+            # Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°± or ÌïÑÌÑ∞ÎßÅ
             if trades < MIN_TRADES:
-                filtered_out = True; reason.append("LOW_TRADES")
-            if abs(mdd) > MAX_MDD_PCT:
-                filtered_out = True; reason.append("HIGH_MDD")
-
-            # prev_* (Ï†ÑÏùº Í∞í ÏÑ∏ÌåÖ: month_data[-1]Ïù¥ base_date-1Ïùº, Í∑∏ Ïù¥Ï†ÑÏù¥ -2Ïùº)
-            prev_open = prev_high = prev_low = prev_close = prev_volume = None
-            try:
-                if len(month_data) >= 1:
-                    last = month_data[-1]
-                    prev_open   = _safe_float(last.get("open"), None) or None
-                    prev_high   = _safe_float(last.get("high"), None) or None
-                    prev_low    = _safe_float(last.get("low"), None) or None
-                    prev_close  = _safe_float(last.get("close"), None) or None
-                    prev_volume = _safe_float(last.get("volume"), None) or None
-            except Exception:
-                pass
+                logger.debug(f"[SKIP] {name}({code}) trades<{MIN_TRADES}")
+                if code in forced_codes and KEEP_HELD_BYPASS_FILTERS:
+                    results[code] = {
+                        "code": code, "name": name, "market": market, "best_k": best_k,
+                        "avg_return_pct": avg_return, "win_rate_pct": win_rate,
+                        "mdd_pct": mdd, "trades": trades, "cumulative_return_pct": cumret,
+                        "avg_holding_days": avg_hold, "sharpe_m": sharpe_m,
+                        "Î™©ÌëúÍ∞Ä": None, "close": None,
+                        "prev_open": None, "prev_high": None, "prev_low": None, "prev_close": None, "prev_volume": None, "prev_turnover": None,
+                        "forced_include": True, "filtered_reason": "LOW_TRADES",
+                        "qty": None, "weight": None, "k_grid_mode": K_GRID_MODE,
+                    }
+                continue
 
-            # Î™©ÌëúÍ∞Ä: Ïò§ÎäòÏãúÍ∞Ä(Ïïå Ïàò ÏóÜÏúºÎØÄÎ°ú 'Ï†ÑÏùº Ï¢ÖÍ∞Ä Í∑ºÏÇ¨' ÏÇ¨Ïö©) + (Ï†Ñ-Ï†ÑÏùº Î≥ÄÎèôÌè≠)*best_k
-            target_price = None
-            try:
-                if len(month_data) >= 2:
-                    y  = month_data[-1]   # Ï†ÑÏùº
-                    yy = month_data[-2]   # Ï†Ñ-Ï†ÑÏùº
-                    today_open_proxy = float(y["close"])  # ÏãúÏ¥àÍ∞Ä ÎØ∏ÌôïÏ†ï Ïãú Ï†ÑÏùº Ï¢ÖÍ∞ÄÎ°ú Í∑ºÏÇ¨
-                    rng = float(yy["high"]) - float(yy["low"])
-                    target_price = adjust_price_to_tick(round(today_open_proxy + rng * float(best_k), 2))
-            except Exception:
-                target_price = None
+            if mdd > MAX_MDD_PCT:
+                logger.debug(f"[SKIP] {name}({code}) mdd>{MAX_MDD_PCT}")
+                if code in forced_codes and KEEP_HELD_BYPASS_FILTERS:
+                    results[code] = {
+                        "code": code, "name": name, "market": market, "best_k": best_k,
+                        "avg_return_pct": avg_return, "win_rate_pct": win_rate,
+                        "mdd_pct": mdd, "trades": trades, "cumulative_return_pct": cumret,
+                        "avg_holding_days": avg_hold, "sharpe_m": sharpe_m,
+                        "Î™©ÌëúÍ∞Ä": None, "close": None,
+                        "prev_open": None, "prev_high": None, "prev_low": None, "prev_close": None, "prev_volume": None, "prev_turnover": None,
+                        "forced_include": True, "filtered_reason": "HIGH_MDD",
+                        "qty": None, "weight": None, "k_grid_mode": K_GRID_MODE,
+                    }
+                continue
 
-            close_price = float(month_data[-1]["close"]) if month_data else None
+            if REQUIRE_POS_RET and avg_return <= 0:
+                logger.debug(f"[SKIP] {name}({code}) avg_return<=0")
+                if code in forced_codes and KEEP_HELD_BYPASS_FILTERS:
+                    results[code] = {
+                        "code": code, "name": name, "market": market, "best_k": best_k,
+                        "avg_return_pct": avg_return, "win_rate_pct": win_rate,
+                        "mdd_pct": mdd, "trades": trades, "cumulative_return_pct": cumret,
+                        "avg_holding_days": avg_hold, "sharpe_m": sharpe_m,
+                        "Î™©ÌëúÍ∞Ä": None, "close": None,
+                        "prev_open": None, "prev_high": None, "prev_low": None, "prev_close": None, "prev_volume": None, "prev_turnover": None,
+                        "forced_include": True, "filtered_reason": "NEG_RETURN",
+                        "qty": None, "weight": None, "k_grid_mode": K_GRID_MODE,
+                    }
+                continue
 
-            # k-range ÎÇ¥ ÏµúÍ≥† ÏÉ§ÌîÑ
+            # Ï†ÑÏùº OHLCV Î°úÎìú: 1) month_data ÎßàÏßÄÎßâ Ï∫îÎì§, 2) segs["prev"]
+            prev_candle = None
+            if month_data:
+                prev_candle = month_data[-1]
+            elif segments.get("prev"):
+                prev_candle = segments["prev"][-1]
+
+            prev_open = _safe_float(prev_candle.get("open") if prev_candle else None, None)
+            prev_high = _safe_float(prev_candle.get("high") if prev_candle else None, None)
+            prev_low = _safe_float(prev_candle.get("low") if prev_candle else None, None)
+            prev_close = _safe_float(prev_candle.get("close") if prev_candle else None, None)
+            prev_volume = _safe_float(prev_candle.get("volume") if prev_candle else None, None)
+            prev_turnover = None
             try:
-                max_sharpe = max((float(m.get("sharpe", 0)) for m in m_metrics), default=0.0)
+                if prev_close is not None and prev_volume is not None:
+                    prev_turnover = float(prev_close) * float(prev_volume)
             except Exception:
-                max_sharpe = 0.0
+                prev_turnover = None
 
-            # Í∞ïÏ†ú Ìè¨Ìï® ÏòàÏô∏ Ï≤òÎ¶¨
-            if filtered_out and code in forced_codes and KEEP_HELD_BYPASS_FILTERS:
-                logger.info(f"[FORCE-KEEP] {name}({code}) ÌïÑÌÑ∞ÌÉàÎùΩ({','.join(reason)})Ïù¥ÏßÄÎßå Î≥¥Ïú†Î∂Ñ Ìè¨Ìï®")
-                filtered_out = False
+            # ÏµúÏ¢Ö Ï∂úÎ†•
+            target_price = adjust_price_to_tick(
+                prev_close + (prev_high - prev_low) * best_k,
+                code,
+            ) if prev_close is not None and prev_high is not None and prev_low is not None else None
 
-            if filtered_out:
-                logger.debug(f"[FILTER] {name}({code}) Ï†úÏô∏: {','.join(reason)}")
-                continue
+            close_price = float(prev_close) if prev_close is not None else None
 
             results[code] = {
                 "code": code,
                 "name": name,
-                "best_k": float(best_k),
-                "avg_return_pct": round(avg_return, 2),
-                "win_rate_pct": round(win_rate, 1),
-                "mdd_pct": round(mdd, 1),
+                "market": market,
+                "best_k": best_k,
+                "avg_return_pct": avg_return,
+                "win_rate_pct": win_rate,
+                "mdd_pct": mdd,
                 "trades": trades,
-                "cumulative_return_pct": round(cum_ret, 2),
-                "avg_holding_days": round(hold_days, 1),
-                "sharpe_m": round(max_sharpe, 4),
+                "cumulative_return_pct": cumret,
+                "avg_holding_days": avg_hold,
+                "sharpe_m": sharpe_m,
                 # trader.pyÍ∞Ä ÏùΩÎäî ÌïÑÎìúÎì§
                 "Î™©ÌëúÍ∞Ä": target_price,                # (ÎèôÏùº ÌÇ§ Ïú†ÏßÄ)
                 "target_price": target_price,         # Ìò∏Ìôò ÌÇ§ Ï∂îÍ∞Ä
                 "close": close_price,
                 "prev_open": prev_open,
                 "prev_high": prev_high,
                 "prev_low": prev_low,
                 "prev_close": prev_close,
                 "prev_volume": prev_volume,
+                "prev_turnover": prev_turnover,
                 # Î©îÌÉÄ
                 "forced_include": code in forced_codes,
                 "k_grid_mode": K_GRID_MODE,
                 # ÏàòÎüâÏùÄ trader.pyÍ∞Ä weight‚ÜíqtyÎ°ú Î≥ÄÌôòÌïòÎØÄÎ°ú Í∏∞Î≥∏ None
                 "qty": None,
                 "weight": None,  # assign_weights ÌõÑ Ï±ÑÏõåÏßê
             }
 
             logger.info(
-                f"[SIM] {name}({code}) R={avg_return:.1f}% W={win_rate:.1f}% MDD={mdd:.1f}% "
+                f"[SIM] {name}({code})[{market}] R={avg_return:.1f}% W={win_rate:.1f}% MDD={mdd:.1f}% "
                 f"K={best_k} trades={trades} forced={code in forced_codes}"
             )
 
         except Exception as e:
-            logger.exception(f"[ERR] {name}({code}) ÏãúÎÆ¨ Ïã§Ìå®: {e}")
+            logger.exception(f"[ERR] {name}({code})[{market}] ÏãúÎÆ¨ Ïã§Ìå®: {e}")
             continue
 
-    logger.info(f"üìä ÌïÑÌÑ∞/Í∞ïÏ†úÌè¨Ìï® Î∞òÏòÅ Ï¢ÖÎ™© = {len(results)}Í∞ú")
+    logger.info(f"üìä [{market}] ÌïÑÌÑ∞/Í∞ïÏ†úÌè¨Ìï® Î∞òÏòÅ Ï¢ÖÎ™© = {len(results)}Í∞ú")
+    return list(results.values())
+
+
+def _normalize_weights(selected: List[Dict[str, Any]], forced_codes: List[str]) -> List[Dict[str, Any]]:
+    if not selected:
+        return []
 
-    # Í∞ÄÏ§ëÏπò Î∂ÄÏó¨
-    selected = list(results.values())
     selected = assign_weights(selected)  # ÎÇ¥Î∂ÄÏóêÏÑú 'weight' Ï±ÑÏõåÏßê
 
     # Î≥¥Ïú†Î∂Ñ ÏµúÏÜå ÎπÑÏ§ë ÌïòÌïú Î≥¥Ï†ï (Ìï©Í≥Ñ 1 Ïú†ÏßÄ)
-    if selected and HELD_MIN_WEIGHT > 0:
+    if HELD_MIN_WEIGHT > 0:
         selected = _enforce_min_weight_for_forced(selected, forced_codes, min_weight=HELD_MIN_WEIGHT)
 
     # ÏÇ¨ÌõÑ Ï†ïÍ∑úÌôîÎ°ú weight Ìï©Í≥ÑÎ•º 1.0ÏúºÎ°ú Ïú†ÏßÄ
-    if selected:
-        total_weight = sum(float(it.get("weight") or 0) for it in selected)
-        if total_weight > 0:
-            for it in selected:
-                it["weight"] = float(it.get("weight") or 0) / total_weight
-
+    total_weight = sum(float(it.get("weight") or 0) for it in selected)
+    if total_weight > 0:
+        for it in selected:
+            it["weight"] = float(it.get("weight") or 0) / total_weight
     return selected
 
 
-# Backward compatibility alias for earlier naming that implied KRX scope
-get_best_k_for_krx_topn = get_best_k_for_kosdaq_topn
+def _normalize_weights_by_market(
+    selected_all: List[Dict[str, Any]], forced_codes: List[str]
+) -> Dict[str, List[Dict[str, Any]]]:
+    """Normalize weights per market without cross-market renormalization."""
+
+    grouped: Dict[str, List[Dict[str, Any]]] = {}
+    for row in selected_all:
+        market = (row.get("market") or "UNKNOWN").upper()
+        grouped.setdefault(market, []).append(row)
+
+    for market, rows in grouped.items():
+        grouped[market] = _normalize_weights(rows, forced_codes)
+        weight_sum = sum(float(r.get("weight") or 0.0) for r in grouped[market])
+        logger.info("[WEIGHT] %s weight_sum=%.6f count=%d", market, weight_sum, len(rows))
+
+    return grouped
+
+
+def get_best_k_for_kosdaq_topn(rebalance_date_str: str) -> List[Dict[str, Any]]:
+    """
+    Î¶¨Î∞∏Îü∞Ïã± ÎåÄÏÉÅ Î¶¨Ïä§Ìä∏ ÏûëÏÑ±:
+    - code/name/best_k/weight(+qty=None) + prev_* + Î™©ÌëúÍ∞Ä(close Ìè¨Ìï®)ÍπåÏßÄ Ï±ÑÏõÄ
+    - KOSDAQ TopNÎßå Ìè¨Ìï® (KOSPIÎäî Î≥ÑÎèÑ ÏΩîÏñ¥ ÏóîÏßÑÏóêÏÑú Ï≤òÎ¶¨)
+    """
+    rebalance_date = datetime.strptime(rebalance_date_str, "%Y-%m-%d").date()
+
+    kosdaq_df = get_kosdaq_top_n(rebalance_date_str, n=TOP_N)
+    logger.info("üìà Ïú†ÎãàÎ≤ÑÏä§ ÏàòÏßë: KOSDAQ=%d (Top%d)", len(kosdaq_df), TOP_N)
+    top_df = kosdaq_df.copy()
+    forced_codes = _parse_force_include_codes(ALWAYS_INCLUDE_CODES)
+    if forced_codes:
+        top_df = _inject_forced_codes(top_df, forced_codes, ["KOSDAQ"])
+
+    if top_df.empty:
+        logger.warning("[WARN] KOSDAQ TopN Í≤∞Í≥º ÏóÜÏùå ‚Üí Îπà Î¶¨Ïä§Ìä∏ Î∞òÌôò")
+        return []
+
+    logger.info("üìä KOSDAQ ÏãúÏ¥ù TopN Ïú†ÎãàÎ≤ÑÏä§ ÏàòÎüâ: %dÍ∞ú (Í≥†Ïú†)", len(top_df))
+
+    selected = _calc_best_k_for_universe(top_df, rebalance_date, forced_codes, market="KOSDAQ")
+
+    return _normalize_weights(selected, forced_codes)
+
+
+def get_best_k_for_krx_topn(
+    rebalance_date_str: str,
+    markets: list[str] | tuple[str, ...] = ("KOSDAQ", "KOSPI"),
+    topn_map: dict[str, int] | None = None,
+    return_by_market: bool = False,
+) -> List[Dict[str, Any]] | Dict[str, Any]:
+    """ÏãúÏû•Î≥Ñ Top-NÏùÑ Ìï©Ï≥ê K ÏµúÏ†ÅÌôî Î¶¨Ïä§Ìä∏Î•º ÏÉùÏÑ±ÌïúÎã§."""
+    rebalance_date = datetime.strptime(rebalance_date_str, "%Y-%m-%d").date()
+    markets_seq = list(dict.fromkeys(markets))
+    if not markets_seq:
+        markets_seq = ["KOSDAQ", "KOSPI"]
+    topn_map = topn_map or {"KOSDAQ": TOP_N, "KOSPI": TOP_N}
+    forced_codes = _parse_force_include_codes(ALWAYS_INCLUDE_CODES)
+
+    all_selected: List[Dict[str, Any]] = []
+    for market in markets_seq:
+        n = int(topn_map.get(market, TOP_N))
+        uni_df = _get_top_n_for_market(rebalance_date_str, n=n, market=market)
+        logger.info("üìà Ïú†ÎãàÎ≤ÑÏä§ ÏàòÏßë: %s=%d (Top%d)", market, len(uni_df), n)
+        if forced_codes:
+            uni_df = _inject_forced_codes(uni_df, forced_codes, [market])
+        if uni_df.empty:
+            logger.warning("[WARN] %s TopN Í≤∞Í≥º ÏóÜÏùå ‚Üí Í±¥ÎÑàÎúÄ", market)
+            continue
+        logger.info("üìä %s ÏãúÏ¥ù TopN Ïú†ÎãàÎ≤ÑÏä§ ÏàòÎüâ: %dÍ∞ú (Í≥†Ïú†)", market, len(uni_df))
+        selected = _calc_best_k_for_universe(uni_df, rebalance_date, forced_codes, market=market)
+        logger.info("[SELECT] %s ÏµúÏ¢Ö ÏÑ†Ï†ï %dÍ∞ú", market, len(selected))
+        all_selected.extend(selected)
+
+    if not all_selected:
+        return {"selected": [], "selected_by_market": {}} if return_by_market else []
+
+    by_market = _normalize_weights_by_market(all_selected, forced_codes)
+    merged_per_market: List[Dict[str, Any]] = []
+    for rows in by_market.values():
+        merged_per_market.extend(rows)
+
+    merged_global: List[Dict[str, Any]] = [dict(r) for r in merged_per_market]
+    total_weight = sum(float(it.get("weight") or 0.0) for it in merged_global)
+    if total_weight > 0:
+        for it in merged_global:
+            it["weight"] = float(it.get("weight") or 0.0) / total_weight
+
+    counts: Dict[str, int] = {}
+    for row in merged_per_market:
+        mkt = row.get("market") or "UNKNOWN"
+        counts[mkt] = counts.get(mkt, 0) + 1
+    for mkt, cnt in counts.items():
+        logger.info("[COUNT] %s selected_count=%d", mkt, cnt)
+
+    if return_by_market:
+        return {
+            "selected": merged_global,
+            "selected_by_market": by_market,
+            "weight_scope": {"selected": "global", "selected_by_market": "per_market"},
+        }
+    return merged_global
+
+
+# Backward compatibility alias for callers that still want the KOSDAQ-only variant
+get_best_k_for_kosdaq_only = get_best_k_for_kosdaq_topn
 
 # -----------------------------
 # 5) API ÏßÑÏûÖÏ†ê: /rebalance/run/{date} ÏóêÏÑú Ìò∏Ï∂ú
 # -----------------------------
-def run_rebalance(date: str, force_order: bool = False) -> Dict[str, Any]:
+def run_rebalance(
+    date: str, force_order: bool = False, return_by_market: bool = False
+) -> Dict[str, Any]:
     """
     /rebalance/run/{date} ÏóîÎìúÌè¨Ïù∏Ìä∏ÏóêÏÑú ÏßÅÏ†ë Ìò∏Ï∂úÎêòÎäî ÏßÑÏûÖÏ†ê.
     Î∞òÌôò Ïä§ÌÇ§ÎßàÎäî trader.py/main.pyÍ∞Ä Í∏∞ÎåÄÌïòÎäî ÌòïÌÉúÎ°ú Î≥¥Ïû•ÌïúÎã§.
 
     Returns:
         {
           "selected": [ ... ],
           "selected_stocks": [ ... ]  # ÎèôÏùº Î∞∞Ïó¥(Ìò∏ÌôòÏÑ±)
         }
     """
     try:
-        selected = get_best_k_for_kosdaq_topn(date)
+        results = get_best_k_for_krx_topn(date, return_by_market=return_by_market)
+        if isinstance(results, dict):
+            selected = results.get("selected", [])
+            selected_by_market = results.get("selected_by_market", {})
+            weight_scope = results.get("weight_scope")
+        else:
+            selected = results
+            selected_by_market = {}
+            weight_scope = None
         # force_orderÍ∞Ä TrueÎùºÍ≥† Ìï¥ÏÑú Ïó¨Í∏∞ÏÑú Ïã§Ï£ºÎ¨∏ÏùÑ ÎÇ¥ÏßÄ ÏïäÏùå.
         # (Ï£ºÎ¨∏ÏùÄ trader.pyÍ∞Ä Í¥ÄÎ¶¨) ‚Äî ÌïÑÏöî Ïãú 'strategy'Ïóê ÌîåÎûòÍ∑∏Îßå ÎÇ®ÍπÄ.
         for it in selected:
             it.setdefault("strategy", "Ï†ÑÏõî rolling K ÏµúÏ†ÅÌôî")
     except Exception as e:
         logger.exception("[run_rebalance] failed: %s", e)
         selected = []
-
-    return {"selected": selected, "selected_stocks": selected}
+        selected_by_market = {}
+        weight_scope = None
+
+    payload: Dict[str, Any] = {
+        "selected": selected,
+        "selected_stocks": selected,
+        "selected_by_market": selected_by_market,
+    }
+    if weight_scope:
+        payload["weight_scope"] = weight_scope
+    return payload
diff --git a/rolling_k_auto_trade_api/rebalance_api.py b/rolling_k_auto_trade_api/rebalance_api.py
index e28971adf388e1e98d8a8c20b1838984904fea35..79cdd619b11ac710fc0a715eca3917e1f529779a 100644
--- a/rolling_k_auto_trade_api/rebalance_api.py
+++ b/rolling_k_auto_trade_api/rebalance_api.py
@@ -1,113 +1,120 @@
 import os
 import json
 import uuid
 import logging
 from datetime import datetime, time as dtime
 from typing import Any, Dict, List, Optional
 
 import pytz
 from fastapi import APIRouter, Query, Request, HTTPException
 from fastapi.responses import JSONResponse
 import pandas as pd
 import numpy as np
 from FinanceDataReader import StockListing, DataReader
 
-from rolling_k_auto_trade_api.best_k_meta_strategy import get_best_k_for_kosdaq_topn
+from rolling_k_auto_trade_api.best_k_meta_strategy import get_best_k_for_krx_topn
 from rolling_k_auto_trade_api.logging_config import configure_logging
 
 configure_logging()
 logger = logging.getLogger(__name__)
 
 rebalance_router = APIRouter()
-latest_rebalance_result: Dict[str, Any] = {"date": None, "selected_stocks": []}
+latest_rebalance_result: Dict[str, Any] = {"date": None, "selected_stocks": [], "selected_by_market": {}}
 
 TOTAL_CAPITAL = int(os.getenv("TOTAL_CAPITAL", "10000000"))
 MIN_WINRATE = float(os.getenv("MIN_WINRATE", "50"))
 MAX_MDD = float(os.getenv("MAX_MDD", "10"))
 MIN_CUMRET = float(os.getenv("MIN_CUMRET", "2"))
 TOP_K_LIMIT = int(os.getenv("TOP_K_LIMIT", "20"))
 REBALANCE_OUT_DIR = os.getenv("REBALANCE_OUT_DIR", "rebalance_results")
 REBALANCE_STORE = os.getenv("REBALANCE_STORE", "./data/selected_stocks.json")
 
 KST = pytz.timezone("Asia/Seoul")
 MARKET_OPEN: dtime = dtime(9, 0)
 MARKET_CLOSE: dtime = dtime(15, 20)
 
 def is_market_open(ts: Optional[datetime] = None) -> bool:
     ts = ts or datetime.now(tz=KST)
     if ts.weekday() >= 5:
         return False
     return MARKET_OPEN <= ts.time() <= MARKET_CLOSE
 
 def _assign_weights(selected: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
     if not selected:
         return []
     scores: List[float] = []
     for it in selected:
         try:
             win = float(it.get("win_rate_pct", it.get("ÏäπÎ•†(%)", 0))) / 100.0
             ret = float(it.get("avg_return_pct", it.get("ÏàòÏùµÎ•†(%)", 0))) / 100.0
             mdd = abs(float(it.get("mdd_pct", it.get("MDD(%)", 0)))) / 100.0
         except Exception:
             win, ret, mdd = 0.5, 0.1, 0.1
         vol = float(it.get("prev_volume", 1))
         score = (0.6 * win + 0.6 * ret + 0.1 * np.log1p(vol)) / max(0.05, (0.4 * mdd))
         scores.append(max(0.0, score))
     s = sum(scores) or 1.0
     weights = [sc / s for sc in scores]
     out: List[Dict[str, Any]] = []
     for it, w in zip(selected, weights):
         o = dict(it)
         o["weight"] = round(float(w), 6)
         out.append(o)
     return out
 
 def _ensure_dir(path: str) -> None:
     os.makedirs(path, exist_ok=True)
 
 @rebalance_router.post("/rebalance/run/{date}", tags=["Rebalance"])
 async def run_rebalance(date: str):
     logger.info(f"[RUN] run_rebalance Ìò∏Ï∂ú: date={date}")
 
     try:
-        raw_results = get_best_k_for_kosdaq_topn(date)
+        raw_results = get_best_k_for_krx_topn(date, return_by_market=True)
     except Exception as e:
         logger.exception(f"[ERROR] Best K Í≥ÑÏÇ∞ Ïã§Ìå®: {e}")
         raise HTTPException(status_code=500, detail="Best K Í≥ÑÏÇ∞ Ïã§Ìå®")
 
     results_map: Dict[str, Dict[str, Any]] = {}
+    selected_flat: List[Dict[str, Any]] = []
+    selected_by_market: Dict[str, List[Dict[str, Any]]] = {}
+    weight_scope = None
     if isinstance(raw_results, dict):
-        results_map = raw_results
+        selected_flat = raw_results.get("selected") or []
+        selected_by_market = raw_results.get("selected_by_market") or {}
+        weight_scope = raw_results.get("weight_scope")
     else:
-        for s in raw_results:
-            code_key = s.get("stock_code") or s.get("code") or s.get("Ìã∞Ïª§")
-            if not code_key:
-                logger.warning(f"[WARN] ÏΩîÎìú ÎàÑÎùΩ: {s}")
-                continue
-            s["stock_code"] = code_key
-            results_map[code_key] = s
+        selected_flat = raw_results or []
+
+    for s in selected_flat:
+        code_key = s.get("stock_code") or s.get("code") or s.get("Ìã∞Ïª§")
+        if not code_key:
+            logger.warning(f"[WARN] ÏΩîÎìú ÎàÑÎùΩ: {s}")
+            continue
+        s["stock_code"] = code_key
+        results_map[code_key] = s
 
     logger.info(f"[FILTER] ÌõÑÎ≥¥ Ï¢ÖÎ™© Ïàò = {len(results_map)}Í∞ú")
 
     candidates: List[Dict[str, Any]] = []
     selected: List[Dict[str, Any]] = []
     for code, info0 in results_map.items():
         info = dict(info0)
         candidates.append(info)
         try:
             cumret = float(info.get("cumulative_return_pct", info.get("ÏàòÏùµÎ•†(%)", 0)))
             win = float(info.get("win_rate_pct", info.get("ÏäπÎ•†(%)", 0)))
             mdd = float(info.get("mdd_pct", info.get("MDD(%)", 0)))
         except Exception as e:
             logger.warning(f"[WARN] ÏàòÏπò Î≥ÄÌôò Ïã§Ìå®: {code}: {e}")
             continue
         if (
             cumret > MIN_CUMRET and
             win > MIN_WINRATE and
             mdd <= MAX_MDD
         ):
             selected.append(info)
     # Í±∞ÎûòÎüâ ÎÇ¥Î¶ºÏ∞®Ïàú Ï†ïÎ†¨
     candidates_with_vol = sorted(candidates, key=lambda x: x.get("prev_volume", 0), reverse=True)
     # === [anchor] Í±∞ÎûòÎüâ Top5(ÏÉÅÏäπ Ï¢ÖÎ™©Îßå) ÏÇ∞Ï∂ú Î∞è Í∞ïÏ†úÌé∏ÏûÖ ===
     # 1. Í±∞ÎûòÎüâ ÏÉÅÏúÑ ÌõÑÎ≥¥ Ï§ëÏóêÏÑú, Ï†ÑÏùº 'ÏÉÅÏäπ(ÏñëÎ¥â)' Ï¢ÖÎ™©Îßå ÌïÑÌÑ∞
@@ -128,90 +135,119 @@ async def run_rebalance(date: str):
             selected,
             key=lambda x: (
                 float(x.get("avg_return_pct", x.get("ÏàòÏùµÎ•†(%)", 0))),
                 float(x.get("win_rate_pct", x.get("ÏäπÎ•†(%)", 0))),
                 -float(abs(x.get("mdd_pct", x.get("MDD(%)", 0))))
             ),
             reverse=True,
         )[:TOP_K_LIMIT]
 
     logger.info(f"[SELECTED] ÌïÑÌÑ∞ ÌÜµÍ≥º Ï¢ÖÎ™© Ïàò = {len(selected)}Í∞ú")
     logger.debug(f"selected codes: {[s.get('code') or s.get('stock_code') for s in selected]}")
 
     if len(selected) == 0:
         latest_rebalance_result.update({"date": date, "selected_stocks": []})
         return {
             "status": "skipped",
             "reason": "no_qualified_candidates",
             "candidates": candidates,
             "selected": [],
         }
 
     has_weight = any("weight" in s for s in selected)
     if not has_weight:
         selected = _assign_weights(selected)
 
+    selected_by_market_out: Dict[str, List[Dict[str, Any]]] = {}
+    for info in selected:
+        mkt = (info.get("market") or "UNKNOWN").upper()
+        selected_by_market_out.setdefault(mkt, []).append(info)
+
+    for mkt, rows in selected_by_market_out.items():
+        total_weight = sum(float(r.get("weight") or 0) for r in rows)
+        if total_weight > 0:
+            for r in rows:
+                r["weight"] = float(r.get("weight") or 0) / total_weight
+
+    # ÏÑúÎ≤Ñ Ï∏° ÌïÑÌÑ∞ÎßÅ ÌõÑÏóêÎäî ÏãúÏû•Î≥Ñ Ï†ïÍ∑úÌôîÍ∞Ä Ï†ÅÏö©ÎêòÎØÄÎ°ú Ïä§ÏΩîÌîÑÎ•º Î™ÖÏãúÏ†ÅÏúºÎ°ú per_marketÎ°ú Í≥†Ï†ïÌïúÎã§.
+    weight_scope = {"selected": "per_market", "selected_by_market": "per_market"}
+
+    market_counts: Dict[str, int] = {}
+    for info in selected:
+        mkt = (info.get("market") or "UNKNOWN").upper()
+        market_counts[mkt] = market_counts.get(mkt, 0) + 1
+    for mkt, cnt in market_counts.items():
+        logger.info("[MARKET] %s selected_count=%d", mkt, cnt)
+
     enriched: List[Dict[str, Any]] = []
     for info in selected:
         code = info.get("stock_code") or info.get("code")
         name = info.get("name") or info.get("stock_name")
         row = dict(info)
         row.setdefault("code", code)
         row.setdefault("name", name)
+        row.setdefault("market", info.get("market"))
         try:
             df = DataReader(code)
             if df is not None and len(df) >= 2:
                 prev = df.iloc[-2]
                 row["prev_open"] = float(prev.get("Open", 0))
                 row["prev_high"] = float(prev.get("High", 0))
                 row["prev_low"] = float(prev.get("Low", 0))
                 row["prev_close"] = float(prev.get("Close", 0))
                 row["prev_volume"] = float(prev.get("Volume", 0))
                 row["prev_turnover"] = float(prev.get("Close", 0)) * float(prev.get("Volume", 0))
         except Exception as e:
             logger.warning(f"[REBAL] OHLC enrich fail {code}: {e}")
         enriched.append(row)
 
-    latest_rebalance_result.update({"date": date, "selected_stocks": enriched})
+    latest_rebalance_result.update({
+        "date": date,
+        "selected_stocks": enriched,
+        "selected_by_market": selected_by_market_out,
+        "weight_scope": weight_scope,
+    })
     os.makedirs(REBALANCE_OUT_DIR, exist_ok=True)
     fp = os.path.join(REBALANCE_OUT_DIR, f"rebalance_{date}.json")
     try:
         with open(fp, "w", encoding="utf-8") as f:
             json.dump(enriched, f, ensure_ascii=False, indent=2)
         logger.info(f"[SAVE] {fp} Ï†ÄÏû• (count={len(enriched)})")
     except Exception as e:
         logger.exception(f"[SAVE_FAIL] JSON Ï†ÄÏû• Ïò§Î•ò: {e}")
         raise HTTPException(status_code=500, detail="Î¶¨Î∞∏Îü∞Ïä§ Í≤∞Í≥º Ï†ÄÏû• Ïã§Ìå®")
 
     os.makedirs(os.path.dirname(REBALANCE_STORE), exist_ok=True)
     with open(REBALANCE_STORE, "w", encoding="utf-8") as f:
         json.dump({"date": date, "selected_stocks": enriched}, f, ensure_ascii=False, indent=2)
 
     return {
         "status": "saved",
         "selected_count": len(enriched),
         "selected_stocks": enriched,
+        "selected_by_market": selected_by_market_out,
+        "weight_scope": weight_scope,
         "store": REBALANCE_STORE,
         "out_file": fp,
         "total_capital_hint": TOTAL_CAPITAL,
     }
 
 @rebalance_router.get("/rebalance/latest", tags=["Rebalance"])
 def get_latest_rebalance():
     return latest_rebalance_result
 
 @rebalance_router.get(
     "/rebalance/backtest-monthly",
     tags=["Rebalance"],
     response_class=JSONResponse,
     response_model=None,
     responses={200: {"description": "Ìï≠ÏÉÅ 200 OK, ÏöîÏïΩ ÎòêÎäî Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ Î∞òÌôò"}},
 )
 def rebalance_backtest_monthly(
     start_date: str = Query("2020-01-01", description="ÏãúÏûëÏùº (YYYY-MM-DD)"),
     end_date:   str = Query("2024-04-01", description="Ï¢ÖÎ£åÏùº (YYYY-MM-DD)"),
     request:    Request = None,
 ):
     logger.info(f"[BACKTEST] Ìò∏Ï∂ú: {start_date}~{end_date}")
     ua = (request.headers.get("user-agent") or "").lower() if request else ""
     referer = (request.headers.get("referer") or "").lower() if request else ""
     is_curl = ("curl" in ua) or ("/docs" in referer)
@@ -293,38 +329,41 @@ def rebalance_backtest_monthly(
         final_df.to_json(filepath, force_ascii=False, orient="records", indent=2)
         logger.info(f"[SAVE] Î∞±ÌÖåÏä§Ìä∏ Í≤∞Í≥º Ï†ÄÏû•: {filename} (count={len(final_df)})")
 
         if is_curl:
             with open(filepath, "r", encoding="utf-8") as f:
                 data = json.load(f)
             return JSONResponse(content=data)
         else:
             return JSONResponse(content={
                 "message": f"{len(final_df)}Í∞ú Ï¢ÖÎ™© Î¶¨Î∞∏Îü∞Ïã± ÏôÑÎ£å",
                 "filename": filename,
                 "tip": "Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞Îäî curl ÎòêÎäî ÌååÏùºÏóêÏÑú ÌôïÏù∏",
             })
     except Exception as e:
         logger.exception(f"[ERROR] rebalance-backtest ÏòàÏô∏: {e}")
         return JSONResponse(status_code=500, content={"error": str(e)})
 
 @rebalance_router.get(
     "/rebalance/selected/{date}",
     tags=["Rebalance"],
     response_class=JSONResponse,
 )
 def get_selected_stocks(date: str):
     if latest_rebalance_result.get("date") == date:
         selected = latest_rebalance_result.get("selected_stocks", [])
+        selected_by_market = latest_rebalance_result.get("selected_by_market", {})
         return {
             "status": "ready",
             "rebalance_date": date,
-            "selected": selected
+            "selected": selected,
+            "selected_by_market": selected_by_market,
         }
     else:
         return {
             "status": "not_ready",
             "rebalance_date": date,
             "selected": [],
+            "selected_by_market": {},
             "message": "Î®ºÏ†Ä /rebalance/run/{date} ÏóîÎìúÌè¨Ïù∏Ìä∏Î°ú Î¶¨Î∞∏Îü∞Ïã±ÏùÑ Ïã§ÌñâÌïòÏÑ∏Ïöî."
         }
 # TOTAL_LINES: 320
diff --git a/strategy/kosdaq/rolling_entry.py b/strategy/kosdaq/rolling_entry.py
index c19b5a3fcaee45a40e34ea027eaf4f76bbd62e5b..9ed10f5fb4c5081ee2d033eb7d011610f45e922c 100644
--- a/strategy/kosdaq/rolling_entry.py
+++ b/strategy/kosdaq/rolling_entry.py
@@ -1,11 +1,13 @@
 from __future__ import annotations
 
 from typing import Any
 
 
-def run_trade_loop(capital_override: float | None = None) -> Any:
+def run_trade_loop(capital_override: float | None = None, selected_stocks: list[dict[str, Any]] | None = None) -> Any:
     # Delay import to avoid any potential circular initialization between
     # strategy and trader modules while still delegating to the legacy runner.
     from trader import legacy_kosdaq_runner
 
-    return legacy_kosdaq_runner.main(capital_override=capital_override)
+    return legacy_kosdaq_runner.main(
+        capital_override=capital_override, selected_stocks=selected_stocks
+    )
diff --git a/trader/config.py b/trader/config.py
index 4143adc14a06ae527b0984ef6c3f2a18070e8c58..0d9aa20792775bef49ed590cb637937ff7662cca 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -55,50 +55,61 @@ CONFIG = {
     "REG_PARTIAL_S2": "0.30",
     "TRAIL_PCT_BULL": "0.025",
     "TRAIL_PCT_BEAR": "0.012",
     "TP_PROFIT_PCT_BULL": "3.5",
     # Ïã†Í≥†Í∞Ä ÎèåÌåå ÌõÑ 3Ïùº ÎàåÎ¶º + Î∞òÎì± Îß§ÏàòÏö© ÌååÎùºÎØ∏ÌÑ∞
     "USE_PULLBACK_ENTRY": "true",          # trueÎ©¥ 'Ïã†Í≥†Í∞Ä ‚Üí 3Ïùº Ïó∞ÏÜç ÌïòÎùΩ ‚Üí Î∞òÎì±' Ìå®ÌÑ¥ Ï∂©Ï°± ÏãúÏóêÎßå ÎàåÎ¶ºÎ™© ÏßÑÏûÖ ÌóàÏö©
     "PULLBACK_LOOKBACK": "60",             # Ïã†Í≥†Í∞Ä ÌÉêÏÉâ Î≤îÏúÑ(Í±∞ÎûòÏùº Í∏∞Ï§Ä)
     "PULLBACK_DAYS": "3",                  # Ïó∞ÏÜç ÌïòÎùΩ ÏùºÏàò
     "PULLBACK_REVERSAL_BUFFER_PCT": "0.2", # ÎêòÎèåÎ¶º ÌôïÏù∏ Ïó¨Ïú†(%): ÏßÅÏ†Ñ ÌïòÎùΩÏùº Í≥†Í∞Ä ÎåÄÎπÑ Ïó¨Ïú†Ïú®
     "PULLBACK_TOPN": "50",                 # ÎàåÎ¶ºÎ™© Ïä§Ï∫îÏö© ÏΩîÏä§Îã• ÏãúÏ¥ù ÏÉÅÏúÑ Ï¢ÖÎ™© Ïàò
     "PULLBACK_UNIT_WEIGHT": "0.03",        # ÎàåÎ¶ºÎ™© Îß§Ïàò 1Í±¥Îãπ ÏûêÎ≥∏ Î∞∞Î∂Ñ(ÌôúÏÑ± ÏûêÎ≥∏ ÎπÑÏú®)
     "PULLBACK_MAX_BUYS_PER_DAY": "5",      # ÎàåÎ¶ºÎ™© ÌïòÎ£® ÏµúÎåÄ Ïã†Í∑ú Îß§Ïàò Í±¥Ïàò
     # Ï±îÌîºÏñ∏ ÌõÑÎ≥¥ ÌïÑÌÑ∞
     "CHAMPION_MIN_TRADES": "5",            # ÏµúÏÜå Í±∞ÎûòÏàò
     "CHAMPION_MIN_WINRATE": "45.0",        # ÏµúÏÜå ÏäπÎ•†(%)
     "CHAMPION_MAX_MDD": "30.0",            # ÏµúÎåÄ ÌóàÏö© MDD(%)
     "CHAMPION_MIN_SHARPE": "0.0",          # ÏµúÏÜå ÏÉ§ÌîÑ ÎπÑÏú®
     "NEUTRAL_ENTRY_SCALE": "0.6",          # Ï§ëÎ¶Ω Î†àÏßê Ïã†Í∑ú/Ïû¨ÏßÑÏûÖ Ïä§ÏºÄÏùºÎßÅ ÎπÑÏú®
     # Í∏∞ÌÉÄ
     "MARKET_DATA_WHEN_CLOSED": "false",
     "FORCE_WEEKLY_REBALANCE": "0",
     # NEW: 1Î∂ÑÎ¥â VWAP Î™®Î©òÌÖÄ ÌååÎùºÎØ∏ÌÑ∞
     "MOM_FAST": "5",        # 1Î∂ÑÎ¥â fast MA Í∏∏Ïù¥
     "MOM_SLOW": "20",       # 1Î∂ÑÎ¥â slow MA Í∏∏Ïù¥
     "MOM_TH_PCT": "0.5",    # fast/slow Í¥¥Î¶¨ ÏûÑÍ≥ÑÍ∞í(%) ‚Äì 0.5% Ïù¥ÏÉÅÏù¥Î©¥ Í∞ïÏÑ∏Î°ú Î≥∏Îã§
+    # Subject flow gate Í∏∞Î≥∏Í∞í
+    "MIN_SMART_MONEY_RATIO_KOSPI": "0.02",
+    "MIN_SMART_MONEY_RATIO_KOSDAQ": "0.03",
+    "SUBJECT_FLOW_TIMEOUT_SEC": "1.2",
+    "SUBJECT_FLOW_RETRY": "1",
+    "SUBJECT_FLOW_CACHE_TTL_SEC": "60",
+    "SUBJECT_FLOW_FAIL_POLICY": "CACHE",
+    "SUBJECT_FLOW_EMPTY_POLICY": "TREAT_AS_FAIL",
+    "SUBJECT_FLOW_DEGRADED_TURNOVER_MULT": "1.5",
+    "SUBJECT_FLOW_DEGRADED_OB_ADD": "10",
+    "SUBJECT_FLOW_MAX_CALLS_PER_RUN": "200",
 }
 
 
 def _cfg(key: str) -> str:
     """ÌôòÍ≤ΩÎ≥ÄÏàò > CONFIG Í∏∞Î≥∏Í∞í"""
     return os.getenv(key, CONFIG.get(key, ""))
 
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 LOG_DIR = Path(__file__).parent / "logs"
 LOG_DIR.mkdir(exist_ok=True)
 STATE_FILE = Path(__file__).parent / "trade_state.json"
 
 # Ï¢ÖÎ™©Î≥Ñ ÏãúÏû•ÏΩîÎìú Í≥†Ï†ï Îßµ (Ïã§Ï†ÑÏóêÏÑúÎäî ÎßàÏä§ÌÑ∞ÌÖåÏù¥Î∏î Î°úÎìúÎ°ú ÎåÄÏ≤¥ Í∂åÏû•)
 MARKET_MAP: Dict[str, str] = {
     # ÏòàÏãú: '145020': 'J', '347850': 'J', '257720': 'U', '178320': 'J', '348370': 'U'
 }
 
 # Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå 1Ï∞® Í∞êÏßÄ ÏÉÅÌÉú Ï†ÄÏû•(Ïó∞ÏÜç DATA_EMPTY ÌôïÏù∏Ïö©)
 EXCLUDE_STATE: Dict[str, Dict[str, bool]] = {}
 
 KST = ZoneInfo("Asia/Seoul")
 
@@ -109,50 +120,61 @@ FORCE_SELL_PASSES_CUTOFF = int(_cfg("FORCE_SELL_PASSES_CUTOFF"))
 FORCE_SELL_PASSES_CLOSE = int(_cfg("FORCE_SELL_PASSES_CLOSE"))
 PARTIAL1 = float(_cfg("PARTIAL1"))
 PARTIAL2 = float(_cfg("PARTIAL2"))
 TRAIL_PCT = float(_cfg("TRAIL_PCT"))
 FAST_STOP = float(_cfg("FAST_STOP"))
 ATR_STOP = float(_cfg("ATR_STOP"))
 TIME_STOP_HHMM = _cfg("TIME_STOP_HHMM")
 DEFAULT_PROFIT_PCT = float(_cfg("DEFAULT_PROFIT_PCT"))
 DEFAULT_LOSS_PCT = float(_cfg("DEFAULT_LOSS_PCT"))
 DAILY_CAPITAL = int(_cfg("DAILY_CAPITAL"))
 CAP_CAP = float(_cfg("CAP_CAP"))
 SLIPPAGE_LIMIT_PCT = float(_cfg("SLIPPAGE_LIMIT_PCT"))
 SLIPPAGE_ENTER_GUARD_PCT = float(_cfg("SLIPPAGE_ENTER_GUARD_PCT"))
 VWAP_TOL = float(_cfg("VWAP_TOL"))  # üî∏ VWAP ÌóàÏö© Ïò§Ï∞®(Ïòà: 0.003 = -0.3%ÍπåÏßÄ ÌóàÏö©)
 W_MAX_ONE = float(_cfg("W_MAX_ONE"))
 W_MIN_ONE = float(_cfg("W_MIN_ONE"))
 ALLOW_PYRAMID = (_cfg("ALLOW_PYRAMID") or "false").lower() == "true"
 REBALANCE_ANCHOR = _cfg("REBALANCE_ANCHOR")
 WEEKLY_ANCHOR_REF = _cfg("WEEKLY_ANCHOR_REF").lower()
 MOMENTUM_OVERRIDES_FORCE_SELL = _cfg("MOMENTUM_OVERRIDES_FORCE_SELL").lower() == "true"
 
 # NEW: 1Î∂ÑÎ¥â Î™®Î©òÌÖÄ ÌååÎùºÎØ∏ÌÑ∞
 MOM_FAST = int(_cfg("MOM_FAST") or "5")
 MOM_SLOW = int(_cfg("MOM_SLOW") or "20")
 MOM_TH_PCT = float(_cfg("MOM_TH_PCT") or "0.5")
+# subject flow
+MIN_SMART_MONEY_RATIO_KOSPI = float(_cfg("MIN_SMART_MONEY_RATIO_KOSPI") or "0.02")
+MIN_SMART_MONEY_RATIO_KOSDAQ = float(_cfg("MIN_SMART_MONEY_RATIO_KOSDAQ") or "0.03")
+SUBJECT_FLOW_TIMEOUT_SEC = float(_cfg("SUBJECT_FLOW_TIMEOUT_SEC") or "1.2")
+SUBJECT_FLOW_RETRY = int(_cfg("SUBJECT_FLOW_RETRY") or "1")
+SUBJECT_FLOW_CACHE_TTL_SEC = float(_cfg("SUBJECT_FLOW_CACHE_TTL_SEC") or "60")
+SUBJECT_FLOW_FAIL_POLICY = (_cfg("SUBJECT_FLOW_FAIL_POLICY") or "CACHE").upper()
+SUBJECT_FLOW_EMPTY_POLICY = (_cfg("SUBJECT_FLOW_EMPTY_POLICY") or "TREAT_AS_FAIL").upper()
+SUBJECT_FLOW_DEGRADED_TURNOVER_MULT = float(_cfg("SUBJECT_FLOW_DEGRADED_TURNOVER_MULT") or "1.5")
+SUBJECT_FLOW_DEGRADED_OB_ADD = float(_cfg("SUBJECT_FLOW_DEGRADED_OB_ADD") or "10")
+SUBJECT_FLOW_MAX_CALLS_PER_RUN = int(_cfg("SUBJECT_FLOW_MAX_CALLS_PER_RUN") or "200")
 # Ïã†Í≥†Í∞Ä ‚Üí 3Ïùº ÎàåÎ¶º ‚Üí Î∞òÎì± ÌôïÏù∏ ÌõÑ Îß§Ïàò ÌååÎùºÎØ∏ÌÑ∞
 USE_PULLBACK_ENTRY = _cfg("USE_PULLBACK_ENTRY").lower() != "false"
 PULLBACK_LOOKBACK = int(_cfg("PULLBACK_LOOKBACK") or "60")
 PULLBACK_DAYS = int(_cfg("PULLBACK_DAYS") or "3")
 PULLBACK_REVERSAL_BUFFER_PCT = float(_cfg("PULLBACK_REVERSAL_BUFFER_PCT") or "0.2")
 PULLBACK_TOPN = int(_cfg("PULLBACK_TOPN") or "50")
 PULLBACK_UNIT_WEIGHT = float(_cfg("PULLBACK_UNIT_WEIGHT") or "0.03")
 PULLBACK_MAX_BUYS_PER_DAY = int(_cfg("PULLBACK_MAX_BUYS_PER_DAY") or "5")
 CHAMPION_MIN_TRADES = int(_cfg("CHAMPION_MIN_TRADES") or "5")
 CHAMPION_MIN_WINRATE = float(_cfg("CHAMPION_MIN_WINRATE") or "45.0")
 CHAMPION_MAX_MDD = float(_cfg("CHAMPION_MAX_MDD") or "30.0")
 CHAMPION_MIN_SHARPE = float(_cfg("CHAMPION_MIN_SHARPE") or "0.0")
 
 # Ï±îÌîºÏñ∏ Îì±Í∏â & GOOD/BAD ÌÉÄÏ†ê ÌåêÎ≥Ñ ÌååÎùºÎØ∏ÌÑ∞
 CHAMPION_A_RULES = {
     "min_trades": 30,
     "min_cumret_pct": 40.0,
     "max_mdd_pct": 25.0,
     "min_win_pct": 50.0,
     "min_sharpe": 1.2,
     "min_turnover": 3_000_000_000,  # 30Ïñµ
 }
 
 GOOD_ENTRY_PULLBACK_RANGE = (5.0, 15.0)  # Ïã†Í≥†Í∞Ä ÎåÄÎπÑ ÎàåÎ¶ºÌè≠(%): ÏµúÏÜå~ÏµúÎåÄ
 GOOD_ENTRY_MA20_RANGE = (1.0, 1.15)  # ÌòÑÏû¨Í∞Ä/20MA ÌóàÏö© Íµ¨Í∞Ñ
diff --git a/trader/kis_wrapper.py b/trader/kis_wrapper.py
index 10e0da1e91b96a1a1651c13cc8ef47fe6144491a..6ddf0ff09b3a23930f2fa96065ffd8b6f5976bfd 100644
--- a/trader/kis_wrapper.py
+++ b/trader/kis_wrapper.py
@@ -5,50 +5,51 @@
 # - ÏãúÏÑ∏/ÏùºÎ¥â/ATR
 # - ÏûîÍ≥†/Ï£ºÎ¨∏
 # - ‚úÖ ÏòàÏàòÍ∏à: output2.ord_psbl_cash Ïö∞ÏÑ† ÏÇ¨Ïö© (fallback: nrcvb_buy_amt ‚Üí dnca_tot_amt, ÏµúÌõÑ: ÏµúÍ∑º Ï∫êÏãú)
 # - ‚úÖ SSL EOF/JSON Decode Îì± ÏùºÏãú Ïò§Î•ò ÎÇ¥ÏÑ± Í∞ïÌôî
 # - ‚úÖ ÏãúÏÑ∏ 0Ïõê Î∞©ÏßÄ(J‚ÜîU, AÏ†ëÎëê/Î¨¥Ï†ëÎëê ÍµêÏ∞®, ÏßÄÏàò Î∞±Ïò§ÌîÑ Ïû¨ÏãúÎèÑ)
 # - ‚úÖ ÏûîÍ≥† ÌéòÏù¥Ïßï(ctx_area_*) , empty ÏàúÍ∞ÑÏùëÎãµ ÎîîÎ∞îÏö¥Ïä§
 # - ‚úÖ [NEW] ÏÑ∏ÏÖò Î¶¨ÏÖã/ÏßÄÏàòÌòï Î∞±Ïò§ÌîÑÎ•º Ìè¨Ìï®Ìïú ÏïàÏ†ÑÏöîÏ≤≠(_safe_request), Ï≤¥Í≤∞ ÌõÑ ÏûîÍ≥† ÎèôÍ∏∞Ìôî(refresh_after_order)
 
 import os
 import json
 import time
 import random
 import logging
 import threading
 import csv
 from datetime import datetime, timedelta
 from typing import Dict, List, Optional, Tuple, Any
 
 import requests
 import pytz
 from requests.adapters import HTTPAdapter
 from urllib3.util.retry import Retry
 
 from settings import APP_KEY, APP_SECRET, API_BASE_URL, CANO, ACNT_PRDT_CD, KIS_ENV
 from trader.time_utils import is_trading_day, is_trading_window, now_kst
+from trader.config import MARKET_MAP, SUBJECT_FLOW_TIMEOUT_SEC, SUBJECT_FLOW_RETRY
 
 logger = logging.getLogger(__name__)
 _ORDER_BLOCK_STATE: Dict[str, Any] = {"date": None, "reason": None}
 
 
 class NetTemporaryError(Exception):
     """ÎÑ§Ìä∏ÏõåÌÅ¨/SSL Îì± ÏùºÏãúÏ†Å Ïò§Î•òÎ•º ÏùòÎØ∏ (Ï†úÏô∏ Í∏àÏßÄ, Î£®ÌîÑ Ïä§ÌÇµ)."""
     pass
 
 
 class DataEmptyError(Exception):
     """Ï†ïÏÉÅÏùëÎãµÏù¥ÎÇò Ï∫îÎì§Ïù¥ 0Í∞ú (Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå)."""
     pass
 
 
 class DataShortError(Exception):
     """Ï†ïÏÉÅÏùëÎãµÏù¥ÎÇò Ï∫îÎì§Ïù¥ need_n ÎØ∏Îßå."""
     pass
 
 
 def _build_session():
     s = requests.Session()
     retry = Retry(
         total=6, connect=5, read=5, status=3,
         backoff_factor=0.6,
@@ -703,50 +704,108 @@ class KisAPI:
                                     "close": float(c),
                                 })
                         except Exception as e:
                             logger.debug("[DAILY_ROW_SKIP] %s rec=%s err=%s", iscd, r, e)
 
                     rows.sort(key=lambda x: x["date"])
 
                     if len(rows) == 0:
                         raise DataEmptyError(f"A{iscd} 0 candles")
                     if len(rows) < 21:
                         raise DataShortError(f"A{iscd} {len(rows)} candles (<21)")
 
                     need = max(count, 21)
                     return rows[-need:][-count:]
 
                 last_err = RuntimeError(
                     f"BAD_RESP rt_cd={data.get('rt_cd')} msg={data.get('msg1')} arr=None"
                 )
                 logger.warning("[DAILY_FAIL] A%s: %s | raw=%s", iscd, last_err, data)
                 time.sleep(0.35 + random.uniform(0, 0.15))
 
         if last_err:
             logger.warning("[DAILY_FAIL] A%s: %s", iscd, last_err)
         raise NetTemporaryError(f"DAILY A{iscd} net fail")
 
+    def inquire_investor(self, code: str, market: str = "KOSDAQ") -> dict:
+        """Ï£ºÏ≤¥ÏàòÍ∏â Ï°∞Ìöå(inquire-investor) ‚Äî Ïã§Ìå® ÏãúÏóêÎèÑ ÏòàÏô∏Î•º ÎçòÏßÄÏßÄ ÏïäÎäîÎã§."""
+        iscd = code.strip().lstrip("A")
+        # FID_COND_MRKT_DIV_CODEÎäî ÏãúÏû•(KOSPI/KOSDAQ) ÏΩîÎìúÍ∞Ä ÏïÑÎãàÎùº ÏÉÅÌíàÍµ∞ ÏΩîÎìú(J=Ï£ºÏãù/ETF/ETN, W=ELW Îì±)Î°ú
+        # Ïì∞Ïù¥Îäî ÏÇ¨Î°ÄÍ∞Ä ÎßéÎã§. Ï£ºÏãù/ETF/ETN Í∏∞Î≥∏Í∞í "J"Î•º ÏÇ¨Ïö©ÌïòÍ≥†, Îß§ÌïëÏóê WÍ∞Ä Î™ÖÏãúÎêú Í≤ΩÏö∞ÏóêÎßå WÎ°ú Ï†ÑÏÜ°ÌïúÎã§.
+        mapped = MARKET_MAP.get(iscd)
+        market_code = mapped if mapped in ("J", "W") else "J"
+        url = f"{API_BASE_URL}/uapi/domestic-stock/v1/quotations/inquire-investor"
+        headers = self._headers("FHKST01010900")
+        params = {"FID_COND_MRKT_DIV_CODE": market_code, "FID_INPUT_ISCD": iscd}
+
+        def _safe_num(val: Any) -> int:
+            try:
+                if val is None:
+                    return 0
+                if isinstance(val, (int, float)):
+                    return int(val)
+                return int(str(val).replace(",", ""))
+            except Exception:
+                return 0
+
+        attempts = max(1, int(SUBJECT_FLOW_RETRY) + 1)
+        timeout = (SUBJECT_FLOW_TIMEOUT_SEC, SUBJECT_FLOW_TIMEOUT_SEC + 0.5)
+
+        for attempt in range(1, attempts + 1):
+            try:
+                self._limiter.wait("investor")
+                resp = self._safe_request(
+                    "get",
+                    url,
+                    headers=headers,
+                    params=params,
+                    timeout=timeout,
+                )
+                data = resp.json()
+                output = data.get("output") or data.get("OutBlock_1") or data.get("outblock")
+                if isinstance(output, list):
+                    output = output[0] if output else {}
+                if not isinstance(output, dict):
+                    raise ValueError(f"unexpected output type: {type(output)}")
+                if not output:
+                    raise ValueError(f"empty output: {data}")
+
+                inv = {
+                    "prsn_ntby_tr_pbmn": _safe_num(output.get("prsn_ntby_tr_pbmn")),
+                    "frgn_ntby_tr_pbmn": _safe_num(output.get("frgn_ntby_tr_pbmn")),
+                    "orgn_ntby_tr_pbmn": _safe_num(output.get("orgn_ntby_tr_pbmn")),
+                }
+                for key in ("prsn_ntby_qty", "frgn_ntby_qty", "orgn_ntby_qty"):
+                    if key in output:
+                        inv[key] = _safe_num(output.get(key))
+                return {"ok": True, "inv": inv}
+            except Exception as e:
+                logger.info("[INVESTOR_FAIL] %s attempt=%s err=%s", code, attempt, e)
+                if attempt >= attempts:
+                    return {"ok": False, "error": str(e), "inv": None}
+                time.sleep(0.2 * (2 ** (attempt - 1)))
+
     # === ATR ===
     def get_atr(self, code: str, window: int = 14) -> Optional[float]:
         try:
             candles = self.get_daily_candles(code, count=window + 2)
             if len(candles) < window + 1:
                 return None
             trs: List[float] = []
             for i in range(1, len(candles)):
                 h = candles[i]["high"]
                 l = candles[i]["low"]
                 c_prev = candles[i - 1]["close"]
                 tr = max(h - l, abs(h - c_prev), abs(l - c_prev))
                 trs.append(tr)
             if not trs:
                 return None
             return sum(trs[-window:]) / float(window)
         except Exception as e:
             logger.warning(f"[ATR] Í≥ÑÏÇ∞ Ïã§Ìå® code={code}: {e}")
             return None
 
     def get_intraday_candles_today(self, code: str, start_hhmm: str = "090000") -> List[Dict[str, Any]]:
         """KIS Ï£ºÏãùÎãπÏùºÎ∂ÑÎ¥âÏ°∞Ìöå (FHKST03010200 / inquire-time-itemchartprice)
         - FID_COND_MRKT_DIV_CODE: 'J'
         - FID_INPUT_ISCD: 6ÏûêÎ¶¨ Ï¢ÖÎ™©ÏΩîÎìú('A' Ï†úÍ±∞)
         - FID_INPUT_HOUR_1: ÏãúÏûë ÏãúÍ∞Ñ(HHMMSS), Ïòà: '090000'
diff --git a/trader/legacy_kosdaq_runner.py b/trader/legacy_kosdaq_runner.py
index ecbed52a6d71f70d6cadb7cfc1034afc89583a09..a6ffcbddaee428334b98f3da9de1beca12d5abea 100644
--- a/trader/legacy_kosdaq_runner.py
+++ b/trader/legacy_kosdaq_runner.py
@@ -31,78 +31,80 @@ try:
     )
 except ImportError:
     # ALLOW_WHEN_CLOSEDÍ∞Ä ÎàÑÎùΩÎèºÎèÑ Îü¨ÎÑàÍ∞Ä Ï¶âÏãú Ï§ëÎã®ÎêòÏßÄ ÏïäÎèÑÎ°ù ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞íÏùÑ Ï†úÍ≥µÌïúÎã§.
     from .config import (
         DAILY_CAPITAL,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         KST,
         RATE_SLEEP_SEC,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         _cfg,
         logger,
     )
 
     ALLOW_WHEN_CLOSED = False
     logger.warning("[CONFIG] ALLOW_WHEN_CLOSED missing; defaulting to False")
     ALLOW_PYRAMID = False
     logger.warning("[CONFIG] ALLOW_PYRAMID missing; defaulting to False")
 from . import signals
 from trader.time_utils import MARKET_CLOSE, MARKET_OPEN, is_trading_day
+from trader.subject_flow import get_subject_flow_with_fallback, reset_flow_call_count
 from .core import *  # noqa: F401,F403 - Ï†ÑÎûµ Ïú†Ìã∏ Ï†ÑÏ≤¥ ÎÖ∏Ï∂úÎ°ú ÌôïÏû•ÏÑ± ÌôïÎ≥¥
 
 if TYPE_CHECKING:
     # core Ï™ΩÏóê Íµ¨ÌòÑÎèº ÏûàÎäî Ìó¨ÌçºÎì§ÏùÑ ÌÉÄÏûÖÏ≤¥Ïª§ÏóêÍ≤åÎßå Î™ÖÏãúÏ†ÅÏúºÎ°ú ÏïåÎ†§Ï§ÄÎã§.
     from .core import (
         _this_iso_week_key,
         _get_effective_ord_cash,
         _to_float,
         _to_int,
         _weight_to_qty,
         _classify_champion_grade,
         _update_market_regime,
         _notional_to_qty,
         _fetch_balances,
         _init_position_state_from_balance,
         _sell_once,
         _adaptive_exit,
         _compute_daily_entry_context,
         _compute_intraday_entry_context,
         _safe_get_price,
         _round_to_tick,
         _init_position_state,
         _detect_pullback_reversal,
         _has_bullish_trend_structure,
     )
 
 
-def main(capital_override: float | None = None):
+def main(capital_override: float | None = None, selected_stocks: list[dict[str, Any]] | None = None):
+    reset_flow_call_count()
     effective_capital = int(capital_override) if capital_override is not None else DAILY_CAPITAL
     kis = KisAPI()
 
     rebalance_date = get_rebalance_anchor_date()
     logger.info(f"[‚ÑπÔ∏è Î¶¨Î∞∏Îü∞Ïã± Í∏∞Ï§ÄÏùº(KST)]: {rebalance_date} (anchor={REBALANCE_ANCHOR}, ref={WEEKLY_ANCHOR_REF})")
     logger.info(
         f"[‚è±Ô∏è Ïª§Ìä∏Ïò§ÌîÑ(KST)] SELL_FORCE_TIME={SELL_FORCE_TIME.strftime('%H:%M')} / Ï†ÑÏ≤¥ÏûîÍ≥†Îß§ÎèÑ={SELL_ALL_BALANCES_AT_CUTOFF} / "
         f"Ìå®Ïä§(Ïª§Ìä∏Ïò§ÌîÑ/ÎßàÍ∞ê)={FORCE_SELL_PASSES_CUTOFF}/{FORCE_SELL_PASSES_CLOSE}"
     )
     logger.info(f"[üí∞ CAPITAL] {effective_capital:,}Ïõê (configured DAILY_CAPITAL={DAILY_CAPITAL:,})")
     logger.info(f"[üõ°Ô∏è SLIPPAGE_ENTER_GUARD_PCT] {SLIPPAGE_ENTER_GUARD_PCT:.2f}%")
 
     # ÏÉÅÌÉú Î≥µÍµ¨
     state_loaded_at = datetime.now(KST)
     state_loaded_date = state_loaded_at.strftime("%Y-%m-%d")
     state_loaded_str = state_loaded_at.strftime("%Y-%m-%d %H:%M:%S")
     state_loaded_midnight = f"{state_loaded_date} 00:00:00"
 
     holding, traded = load_state()
     triggered_today: set[str] = set()
     last_price_map: dict[str, float] = {}
     last_today_prefix: str | None = None
 
     if isinstance(traded, (set, list, tuple)):
         logger.warning(
@@ -188,93 +190,166 @@ def main(capital_override: float | None = None):
         except Exception:
             return True
 
     def _is_balance_reflected(code: str, prev_qty: int = 0, delay_sec: float = 1.0) -> bool:
         try:
             time.sleep(delay_sec)
             balances = _fetch_balances(kis, ttl_sec=0)
         except Exception as e:
             logger.warning(f"[BAL-REFRESH-FAIL] {code}: ÏûîÍ≥† ÌôïÏù∏ Ïã§Ìå® {e}")
             return False
 
         for row in balances:
             try:
                 if str(row.get("code")).zfill(6) != str(code).zfill(6):
                     continue
                 qty_here = _to_int(row.get("qty") or 0)
                 sellable_here = _to_int((row.get("sell_psbl_qty") or row.get("ord_psbl_qty")) or 0)
                 baseline_qty = max(0, int(prev_qty))
                 if qty_here > baseline_qty or sellable_here > baseline_qty:
                     return True
             except Exception:
                 continue
 
         return False
 
+    def _subject_flow_gate(
+        code: str,
+        info: Dict[str, Any],
+        current_price: float,
+        target_price: float | None,
+        vwap_val: float | None,
+    ) -> tuple[bool, Dict[str, Any], float]:
+        day_turnover_krw = _to_float(
+            info.get("prev_turnover") or info.get("avg_turnover") or info.get("turnover"), 0.0
+        )
+        market = (info.get("market") or "KOSDAQ").upper()
+        flow = get_subject_flow_with_fallback(
+            kis, code, market, float(day_turnover_krw or 0.0)
+        )
+        score = flow.get("score") or {}
+
+        turnover_guard = float(CHAMPION_A_RULES.get("min_turnover") or 0.0)
+        ob_guard = 0.0
+        ob_strength_val: float = 0.0
+        try:
+            ob_strength_val = float(_to_float(kis.get_orderbook_strength(code), 0.0) or 0.0)
+        except Exception as e:
+            logger.warning(f"[OB_STRENGTH_FAIL] {code}: {e}")
+
+        if flow.get("degraded"):
+            turnover_guard *= float(flow.get("turnover_guard_mult") or 1.0)
+            ob_guard += float(flow.get("ob_strength_add") or 0.0)
+
+        ok = bool(flow.get("flow_ok"))
+        reason_tag = None
+
+        if turnover_guard > 0 and float(day_turnover_krw or 0.0) < turnover_guard:
+            ok = False
+            reason_tag = "LOW_TURNOVER"
+        if ob_guard > 0 and ob_strength_val < ob_guard:
+            ok = False
+            reason_tag = "OB_WEAK"
+
+        if not ok:
+            if reason_tag is None:
+                decision = str(flow.get("decision") or "")
+                if decision.startswith("BLOCK"):
+                    reason_tag = "SUBJECT_FLOW_FAIL_BLOCK"
+                else:
+                    reason_tag = "SUBJECT_FLOW_WEAK"
+
+            logger.info(
+                "[%s] code=%s market=%s last=%s target=%s vwap=%s turnover_krw=%.0f "
+                "spread_ticks=%s orderbook_strength=%s smart_money_krw=%s smart_money_ratio=%.6f "
+                "flow_used=%s flow_policy=%s degraded_mode=%s",
+                reason_tag,
+                code,
+                market,
+                current_price,
+                target_price,
+                vwap_val,
+                float(day_turnover_krw or 0.0),
+                None,
+                ob_strength_val,
+                score.get("smart_money_krw"),
+                float(score.get("smart_money_ratio") or 0.0),
+                flow.get("used"),
+                flow.get("policy"),
+                flow.get("degraded"),
+            )
+
+        return ok, flow, ob_strength_val
+
     def _is_order_success(res: Any) -> bool:
         if not isinstance(res, dict):
             return False
         rt_cd = str(res.get("rt_cd") or res.get("rtCode") or "").strip()
         return rt_cd in ("0", "0000", "OK")
 
     def _extract_fill_price(res: Any, fallback_price: float) -> float:
         if isinstance(res, dict):
             output = res.get("output") or {}
             for payload in (output, res):
                 for key in (
                     # Ï≤¥Í≤∞Í∞Ä/ÌèâÍ∑†Í∞Ä ÌõÑÎ≥¥
                     "ccld_prc",
                     "ccld_unpr",
                     "tot_ccld_unpr",
                     "tot_ccld_prc",
                     "avg_price",
                     "avg_prvs",
                     "fill_price",
                     # Ï£ºÎ¨∏Í∞Ä(ÌõÑÏàúÏúÑ)
                     "prdt_price",
                     "ord_unpr",
                     "ord_prc",
                     "order_price",
                 ):
                     val = None
                     if isinstance(payload, dict):
                         val = payload.get(key)
                     if val not in (None, ""):
                         try:
                             return float(val)
                         except Exception:
                             continue
         return float(fallback_price)
 
     logger.info(f"[ÏÉÅÌÉúÎ≥µÍµ¨] holding: {list(holding.keys())}, traded: {_traded_codes(traded)}")
 
     pullback_buys_today = 0
     pullback_buy_date = datetime.now(KST).date()
 
     # === [NEW] Ï£ºÍ∞Ñ Î¶¨Î∞∏Îü∞Ïã± Í∞ïÏ†ú/Ï§ëÎ≥µ Î∞©ÏßÄ ===
     targets: List[Dict[str, Any]] = []
-    if REBALANCE_ANCHOR == "weekly":
+    if selected_stocks is not None:
+        targets = list(selected_stocks)
+        logger.info(
+            "[REBALANCE] injected selected_stocks count=%d (skip API fetch)", len(targets)
+        )
+    elif REBALANCE_ANCHOR == "weekly":
         if should_weekly_rebalance_now():
             targets = fetch_rebalancing_targets(rebalance_date)
             # Ï§ëÎ≥µ Ïã§Ìñâ Î∞©ÏßÄÎ•º ÏúÑÌï¥ Ï¶âÏãú Ïä§ÌÉ¨ÌîÑ(ÌïÑÏöî Ïãú FORCEÎ°ú Ïû¨Ïã§Ìñâ Í∞ÄÎä•)
             stamp_weekly_done()
             logger.info(f"[REBALANCE] Ïù¥Î≤à Ï£º Î¶¨Î∞∏Îü∞Ïã± Ïã§Ìñâ Í∏∞Î°ù Ï†ÄÏû•({_this_iso_week_key()})")
         else:
             logger.info("[REBALANCE] Ïù¥Î≤à Ï£º Ïù¥ÎØ∏ Ïã§ÌñâÎê® ‚Üí Ïã†Í∑ú Î¶¨Î∞∏Îü∞Ïã± ÏÉùÎûµ (Î≥¥Ïú† Í¥ÄÎ¶¨Îßå)")
     else:
         # today/monthly Îì± Îã§Î•∏ ÏïµÏª§ Î™®ÎìúÎäî Í∏∞Ï°¥ Î∞©ÏãùÏúºÎ°ú Î∞îÎ°ú Ìò∏Ï∂ú
         targets = fetch_rebalancing_targets(rebalance_date)
 
     # === [NEW] ÏòàÏÇ∞ Í∞ÄÎìú: ÏòàÏàòÍ∏àÏù¥ 0/Î∂ÄÏ°±Ïù¥Î©¥ Ïã†Í∑ú Îß§ÏàòÎßå Ïä§ÌÇµ ===
     effective_cash = _get_effective_ord_cash(kis, soft_cap=effective_capital)
     if effective_cash <= 0:
         can_buy = False
         logger.warning("[BUDGET] Ïú†Ìö® ÏòàÏÇ∞ 0 ‚Üí Ïã†Í∑ú Îß§Ïàò Ïä§ÌÇµ(Î≥¥Ïú† Í¥ÄÎ¶¨Îßå ÏàòÌñâ)")
     else:
         can_buy = True
     logger.info(
         f"[BUDGET] today effective cash = {effective_cash:,} KRW (capital base={effective_capital:,})"
     )
 
     # Î¶¨Î∞∏Îü∞Ïã± ÎåÄÏÉÅ ÌõÑÏ≤òÎ¶¨: qty ÏóÜÍ≥† weightÎßå ÏûàÏúºÎ©¥ Î∞∞Ï†ï ÏûêÎ≥∏ÏúºÎ°ú ÏàòÎüâ Í≥ÑÏÇ∞
     processed_targets: Dict[str, Any] = {}
     for t in targets:
@@ -933,50 +1008,60 @@ def main(capital_override: float | None = None):
                     trigger_name=trigger_label,
                 )
                 if not trigger_state.get("ok"):
                     logger.info(
                         "[TRIGGER-NO] %s | trigger=%s current=%s tgt_px=%s gap_pct=%s missing=%s signals=%s",
                         code,
                         trigger_state.get("trigger_name"),
                         trigger_state.get("current_price"),
                         trigger_state.get("target_price"),
                         trigger_state.get("gap_pct"),
                         trigger_state.get("missing_conditions"),
                         trigger_state.get("trigger_signals"),
                     )
                     continue
                 logger.info(
                     "[TRIGGER-OK] %s | trigger=%s current=%s tgt_px=%s gap_pct=%s signals=%s rr=%.2f",
                     code,
                     trigger_state.get("trigger_name"),
                     trigger_state.get("current_price"),
                     trigger_state.get("target_price"),
                     trigger_state.get("gap_pct"),
                     trigger_state.get("trigger_signals"),
                     trigger_state.get("risk_reward") or 0.0,
                 )
 
+                flow_ok, flow_ctx, ob_strength = _subject_flow_gate(
+                    code,
+                    info,
+                    float(current_price),
+                    target_price,
+                    intraday_ctx.get("vwap"),
+                )
+                if not flow_ok:
+                    continue
+
                 # === VWAP Í∞ÄÎìú(Ïä¨Î¶¨ÌîºÏßÄ Î∞©Ïñ¥) ===
                 try:
                     guard_passed = vwap_guard(kis, code, SLIPPAGE_ENTER_GUARD_PCT)
                 except Exception as e:
                     logger.warning(f"[VWAP_GUARD_FAIL] {code}: VWAP Í∞ÄÎìú Ïò§Î•ò ‚Üí ÏßÑÏûÖ Î≥¥Î•ò ({e})")
                     continue
 
                 if not guard_passed:
                     logger.info(f"[VWAP_GUARD] {code}: Ïä¨Î¶¨ÌîºÏßÄ ÏúÑÌóò ‚Üí Îß§Ïàò Ïä§ÌÇµ")
                     continue
 
                 qty = target_qty
                 if mode == "neutral":
                     scaled_qty = max(1, int(qty * NEUTRAL_ENTRY_SCALE))
                     if scaled_qty < qty:
                         logger.info(
                             f"[ENTRY-SIZE] {code}: neutral Î†àÏßê Í∞êÏ∂ï {qty}‚Üí{scaled_qty} (Ïä§ÏºÄÏùº={NEUTRAL_ENTRY_SCALE})"
                         )
                     qty = scaled_qty
                 trade_ctx = {
                     "datetime": now_str,
                     "code": code,
                     "name": info.get("name"),
                     "qty": int(qty),
                     "K": k_value,
@@ -1127,50 +1212,60 @@ def main(capital_override: float | None = None):
                             continue
 
                         if not pullback_ok:
                             continue
 
                         if trigger_price is None:
                             logger.info(f"[PULLBACK-SKIP] {code}: trigger_price None")
                             continue
 
                         qty = _notional_to_qty(kis, code, base_notional)
                         if qty <= 0:
                             logger.info(f"[PULLBACK-SKIP] {code}: ÏàòÎüâ ÏÇ∞Ï∂ú 0")
                             continue
 
                         current_price = _safe_get_price(kis, code)
                         if not current_price:
                             logger.warning(f"[PULLBACK-PRICE] {code}: ÌòÑÏû¨Í∞Ä Ï°∞Ìöå Ïã§Ìå®")
                             continue
 
                         if trigger_price and current_price < trigger_price * 0.98:
                             logger.info(
                                 f"[PULLBACK-DELAY] {code}: Í∞ÄÍ≤©Ïù¥ Ìä∏Î¶¨Í±∞ ÎåÄÎπÑ 2% Ïù¥ÏÉÅ ÌïòÎùΩ ‚Üí ÎåÄÍ∏∞ (cur={current_price}, trigger={trigger_price})"
                             )
                             continue
 
+                        flow_ok, flow_ctx, ob_strength = _subject_flow_gate(
+                            code,
+                            info,
+                            float(current_price),
+                            trigger_price,
+                            None,
+                        )
+                        if not flow_ok:
+                            continue
+
                         prev_qty = int((holding.get(code) or {}).get("qty", 0))
                         result = place_buy_with_fallback(
                             kis,
                             code,
                             int(qty),
                             _round_to_tick(trigger_price or current_price),
                         )
 
                         if not _is_order_success(result):
                             logger.warning(f"[PULLBACK-BUY-FAIL] {code}: result={result}")
                             continue
 
                         triggered_today.add(code)
                         exec_price = _extract_fill_price(result, trigger_price or current_price)
                         _record_trade(
                             traded,
                             code,
                             {
                                 "buy_time": now_str,
                                 "qty": int(qty),
                                 "price": float(exec_price),
                                 "status": "pending",
                                 "pending_since": now_str,
                             },
                         )
diff --git a/trader/metrics.py b/trader/metrics.py
index c1773bd202da1ce0b02d8edbdb3cad8233dabf36..ed969bf074fee5a79e22c8b58aa8a84f7a902d13 100644
--- a/trader/metrics.py
+++ b/trader/metrics.py
@@ -1,42 +1,47 @@
 # -*- coding: utf-8 -*-
 """
 metrics.py ‚Äî ORB/VWAP/Í±∞ÎûòÎåÄÍ∏à/Ïä¨Î¶¨ÌîºÏßÄ Îì± 'ÏßÄÌëú Í≥ÑÏÇ∞ & ÌíàÏßà Í∞ÄÎìú' Ïú†Ìã∏Î¶¨Ìã∞
 
 Ïó≠Ìï†
 - Í∞úÏû• ÌõÑ NÎ∂Ñ ÎèôÏïà ORB(Opening Range) ÏÉÅÎã®/ÌïòÎã®ÏùÑ Ï∂îÏ†ÅÌïòÍ≥†, Í≥†Ï†ï(Freeze) ÏãúÏ†êÏùÑ Í∏∞Î°ù
 - VWAP/Ïä§ÌîÑÎ†àÎìú/Í±∞ÎûòÎåÄÍ∏à Îì± ÌíàÏßà Í∞ÄÎìú Ìï®Ïàò Ï†úÍ≥µ
 - Ï¢ÖÎ™© ÌäπÏÑ±(Ï†ÑÏùº Í±∞ÎûòÎåÄÍ∏à, ÌòÑÏû¨ Í∞ÄÍ≤©)Ïóê Îî∞Îùº Ïä¨Î¶¨ÌîºÏßÄ ÏûÑÍ≥ÑÏπòÎ•º Ï†ÅÏùëÏãùÏúºÎ°ú ÏÇ∞Ï∂ú
 
 Ï£ºÏùò
 - Ïù¥ Î™®ÎìàÏùÄ 'Í≥ÑÏÇ∞/ÌåêÎã®'Îßå Îã¥ÎãπÌï©ÎãàÎã§. Ïã§Ï†ú Ï£ºÎ¨∏ÏùÄ trader.pyÏóêÏÑú ÏàòÌñâÌï©ÎãàÎã§.
 - VWAP / Ïä§ÌîÑÎ†àÎìú / Í±∞ÎûòÎåÄÍ∏à 1Î∂ÑÏπò Í∞íÏùÄ Í∞ÅÏûê Î≥¥Ïú†Ìïú Îç∞Ïù¥ÌÑ∞ Í≥µÍ∏â Î°úÏßÅÍ≥º Ïó∞Í≤∞ÌïòÏÑ∏Ïöî.
 """
 from __future__ import annotations
 import math
 import logging
 
+from trader.config import (
+    MIN_SMART_MONEY_RATIO_KOSPI,
+    MIN_SMART_MONEY_RATIO_KOSDAQ,
+)
+
 logger = logging.getLogger(__name__)
 
 
 class OpeningRange:
     """
     Í∞úÏû• Ïù¥ÌõÑ ORB_MIN Î∂Ñ ÎèôÏïàÏùò Í≥†Í∞Ä/Ï†ÄÍ∞ÄÎ•º Ï∂îÏ†ÅÌïòÏó¨,
     ORB_MIN Í≤ΩÍ≥º ÏãúÏ†êÏóê Î∞ïÏä§Î•º 'Í≥†Ï†ï'ÌïòÍ≥† Î∏åÎ†àÏù¥ÌÅ¨ÏïÑÏõÉ Ïó¨Î∂Ä ÌåêÎã®Ïóê ÏÇ¨Ïö©.
     """
     def __init__(self, orb_min: int):
         if orb_min <= 0:
             raise ValueError("orb_min must be > 0")
         self.orb_min = orb_min
         self._orh = {}      # code -> float
         self._orl = {}      # code -> float
         self._frozen = set()  # code
 
     def update(self, code: str, last_price: float, minutes_from_open: int) -> None:
         """Í∞úÏû• Ïù¥ÌõÑ Î∂Ñ(min) Ï†ïÎ≥¥ÏôÄ ÌòÑÏû¨Í∞ÄÎ•º Î∞õÏïÑ ORH/ORL ÏóÖÎç∞Ïù¥Ìä∏."""
         if minutes_from_open <= self.orb_min:
             # ORB Í¥ÄÏ∏° Íµ¨Í∞Ñ
             self._orh[code] = max(self._orh.get(code, -math.inf), float(last_price))
             self._orl[code] = min(self._orl.get(code,  math.inf), float(last_price))
         else:
             # ÏµúÏ¥à Í≥†Ï†ï Î°úÍ∑∏ 1Ìöå
             if code not in self._frozen:
@@ -83,25 +88,50 @@ def adaptive_slip(prev_turnover: float | None, price: float | None, base_pct: fl
     Ï†ÅÏùëÏãù Ïä¨Î¶¨ÌîºÏßÄ Í∞ÄÎìú ÏÇ∞Ï∂ú.
     - prev_turnover: Ï†ÑÏùº Í±∞ÎûòÎåÄÍ∏à(Ïõê), ÎÇÆÏùÑÏàòÎ°ù Í∞ÄÎìúÌè≠ ÌôïÎåÄ
     - price: ÌòÑÏû¨Í∞Ä, 10ÎßåÏõê Ïù¥ÏÉÅ Í≥†Í∞ÄÏ£ºÎäî ÏïΩÍ∞Ñ Í∞ÄÎìúÌè≠ ÌôïÎåÄ
     - base_pct: .envÏùò SLIPPAGE_BASE_PCT(Ïòà: 1.0%)
     Î∞òÌôò: 'ÎπÑÏú®' (Ïòà: 0.012 = 1.2%)
     """
     p = float(price or 0.0)
     t = float(prev_turnover or 0.0)
 
     # Í±∞ÎûòÎåÄÍ∏à Íµ¨Í∞ÑÎ≥Ñ Í∞ÄÏ§ëÏπò
     #   > 5e10 (500Ïñµ) ‚Üí 1.0
     #   > 1e10 (100Ïñµ) ‚Üí 1.3
     #   Í∑∏ Ïù¥ÌïòÎäî ‚Üí 1.6
     if t > 5e10:
         factor_t = 1.0
     elif t > 1e10:
         factor_t = 1.3
     else:
         factor_t = 1.6
 
     # Í≥†Í∞ÄÏ£º(>= 100,000) ÏïΩÍ∞Ñ ÌôïÎåÄ
     factor_p = 1.1 if p >= 100_000 else 1.0
 
     slip = (base_pct / 100.0) * factor_t * factor_p
     return slip
+
+
+def smart_money_score(inv: dict, day_turnover_krw: float) -> dict:
+    orgn = inv.get("orgn_ntby_tr_pbmn", 0) if isinstance(inv, dict) else 0
+    frgn = inv.get("frgn_ntby_tr_pbmn", 0) if isinstance(inv, dict) else 0
+    prsn = inv.get("prsn_ntby_tr_pbmn", 0) if isinstance(inv, dict) else 0
+    # pbmn(purchase balance in million KRW) Í∞íÏùÑ ÏõêÌôîÎ°ú ÌôòÏÇ∞Ìï¥ ÎπÑÍµê (Îã®ÏúÑ Î∂àÏùºÏπò Î∞©ÏßÄ)
+    smart_money_krw = (orgn + frgn) * 1_000_000
+    turnover = float(day_turnover_krw or 0.0)
+    smart_money_ratio = smart_money_krw / turnover if turnover > 0 else 0.0
+    return {
+        "smart_money_krw": smart_money_krw,
+        "smart_money_ratio": smart_money_ratio,
+        "orgn": orgn,
+        "frgn": frgn,
+        "prsn": prsn,
+    }
+
+
+def subject_flow_gate(market: str, smart_money_ratio: float) -> bool:
+    if market == "KOSPI":
+        th = MIN_SMART_MONEY_RATIO_KOSPI
+    else:
+        th = MIN_SMART_MONEY_RATIO_KOSDAQ
+    return smart_money_ratio >= th
diff --git a/trader/subject_flow.py b/trader/subject_flow.py
new file mode 100644
index 0000000000000000000000000000000000000000..60146e61d94170c4379ee32ea1fbf7e1531d7538
--- /dev/null
+++ b/trader/subject_flow.py
@@ -0,0 +1,283 @@
+# -*- coding: utf-8 -*-
+"""Subject flow wrapper with caching/fallback so trader never halts."""
+from __future__ import annotations
+
+import logging
+import threading
+import time
+from typing import Any, Dict, Optional, Tuple
+
+from trader.config import (
+    SUBJECT_FLOW_CACHE_TTL_SEC,
+    SUBJECT_FLOW_DEGRADED_OB_ADD,
+    SUBJECT_FLOW_DEGRADED_TURNOVER_MULT,
+    SUBJECT_FLOW_EMPTY_POLICY,
+    SUBJECT_FLOW_FAIL_POLICY,
+    SUBJECT_FLOW_MAX_CALLS_PER_RUN,
+)
+from trader.metrics import smart_money_score, subject_flow_gate
+from trader.time_utils import now_kst
+
+logger = logging.getLogger(__name__)
+
+_FLOW_CACHE: Dict[Tuple[str, str], Dict[str, Any]] = {}
+_FLOW_CACHE_LOCK = threading.Lock()
+_FLOW_CALL_COUNT = 0
+
+
+def reset_flow_call_count() -> None:
+    """Reset per-run subject flow call counter."""
+    global _FLOW_CALL_COUNT
+    with _FLOW_CACHE_LOCK:
+        _FLOW_CALL_COUNT = 0
+
+
+def _safe_num(val: Any) -> int:
+    try:
+        if val is None:
+            return 0
+        if isinstance(val, (int, float)):
+            return int(val)
+        return int(str(val).replace(",", ""))
+    except Exception:
+        return 0
+
+
+def _cache_get(key: Tuple[str, str]) -> Optional[Dict[str, Any]]:
+    with _FLOW_CACHE_LOCK:
+        payload = _FLOW_CACHE.get(key)
+    if not payload:
+        return None
+    if time.time() - float(payload.get("ts", 0)) > SUBJECT_FLOW_CACHE_TTL_SEC:
+        return None
+    return payload
+
+
+def _cache_set(key: Tuple[str, str], value: Dict[str, Any]) -> None:
+    payload = dict(value)
+    payload["ts"] = time.time()
+    with _FLOW_CACHE_LOCK:
+        _FLOW_CACHE[key] = payload
+
+
+def _increment_call_count() -> int:
+    global _FLOW_CALL_COUNT
+    with _FLOW_CACHE_LOCK:
+        _FLOW_CALL_COUNT += 1
+        return _FLOW_CALL_COUNT
+
+
+def _current_call_count() -> int:
+    with _FLOW_CACHE_LOCK:
+        return _FLOW_CALL_COUNT
+
+
+def _log_flow(
+    *,
+    code: str,
+    market: str,
+    ok: bool,
+    used: str,
+    policy: str,
+    score: Dict[str, Any] | None,
+    turnover: float,
+    degraded: bool,
+    error: str | None,
+) -> None:
+    score = score or {}
+    logger.info(
+        "[FLOW] code=%s market=%s ok=%s used=%s policy=%s smart_money_krw=%s ratio=%.6f "
+        "orgn=%s frgn=%s prsn=%s turnover=%.0f degraded=%s error=%s",
+        code,
+        market,
+        ok,
+        used,
+        policy,
+        score.get("smart_money_krw"),
+        float(score.get("smart_money_ratio") or 0.0),
+        score.get("orgn"),
+        score.get("frgn"),
+        score.get("prsn"),
+        float(turnover or 0.0),
+        degraded,
+        error,
+    )
+
+
+def get_subject_flow_with_fallback(
+    kis: Any,
+    code: str,
+    market: str,
+    day_turnover_krw: float,
+) -> Dict[str, Any]:
+    """Fetch investor flow with cache/fallback; never raises."""
+    policy = SUBJECT_FLOW_FAIL_POLICY.upper()
+    empty_policy = SUBJECT_FLOW_EMPTY_POLICY.upper()
+    used = "none"
+    degraded = False
+    score: Dict[str, Any] | None = None
+    inv: Dict[str, Any] | None = None
+    error: str | None = None
+    flow_ok = False
+    decision = "UNKNOWN"
+    turnover_guard_mult = 1.0
+    ob_strength_add = 0.0
+
+    try:
+        today = now_kst().strftime("%Y%m%d")
+        key = (today, code)
+        cached = _cache_get(key)
+        if cached:
+            used = "cache"
+            inv = cached.get("inv")
+            score = cached.get("score")
+            if cached.get("ok") and score:
+                flow_ok = subject_flow_gate(market, float(score.get("smart_money_ratio") or 0))
+                decision = "CACHE_OK"
+                _log_flow(
+                    code=code,
+                    market=market,
+                    ok=flow_ok,
+                    used=used,
+                    policy=policy,
+                    score=score,
+                    turnover=day_turnover_krw,
+                    degraded=False,
+                    error=None,
+                )
+                return {
+                    "flow_ok": flow_ok,
+                    "decision": decision,
+                    "used": used,
+                    "policy": policy,
+                    "score": score,
+                    "inv": inv,
+                    "degraded": degraded,
+                    "turnover_guard_mult": turnover_guard_mult,
+                    "ob_strength_add": ob_strength_add,
+                    "cache_hit": True,
+                }
+
+        if _current_call_count() >= SUBJECT_FLOW_MAX_CALLS_PER_RUN:
+            error = "CALL_LIMIT"
+            policy = "CACHE"
+        else:
+            _increment_call_count()
+            resp: Dict[str, Any] = kis.inquire_investor(code, market)
+            used = "live"
+            if resp.get("ok"):
+                inv = resp.get("inv") or {}
+                orgn = _safe_num(inv.get("orgn_ntby_tr_pbmn"))
+                frgn = _safe_num(inv.get("frgn_ntby_tr_pbmn"))
+                prsn = _safe_num(inv.get("prsn_ntby_tr_pbmn"))
+                inv.update({
+                    "orgn_ntby_tr_pbmn": orgn,
+                    "frgn_ntby_tr_pbmn": frgn,
+                    "prsn_ntby_tr_pbmn": prsn,
+                })
+                if empty_policy == "TREAT_AS_FAIL" and (orgn == 0 and frgn == 0 and prsn == 0):
+                    error = "EMPTY_FLOW"
+                else:
+                    score = smart_money_score(inv, day_turnover_krw)
+                    flow_ok = subject_flow_gate(market, score["smart_money_ratio"])
+                    decision = "LIVE_OK"
+                    _cache_set(key, {"ok": True, "inv": inv, "score": score})
+            else:
+                error = str(resp.get("error") or "UNKNOWN_ERROR")
+
+        if score and used == "live":
+            _log_flow(
+                code=code,
+                market=market,
+                ok=flow_ok,
+                used=used,
+                policy=policy,
+                score=score,
+                turnover=day_turnover_krw,
+                degraded=False,
+                error=None,
+            )
+            return {
+                "flow_ok": flow_ok,
+                "decision": decision,
+                "used": used,
+                "policy": policy,
+                "score": score,
+                "inv": inv,
+                "degraded": degraded,
+                "turnover_guard_mult": turnover_guard_mult,
+                "ob_strength_add": ob_strength_add,
+                "cache_hit": False,
+            }
+
+        cache_after_fail = cached if cached else _cache_get(key)
+        if error and policy == "CACHE" and cache_after_fail:
+            used = "cache"
+            inv = cache_after_fail.get("inv")
+            score = cache_after_fail.get("score")
+            flow_ok = subject_flow_gate(market, float(score.get("smart_money_ratio") or 0)) if score else False
+            decision = "CACHE_ON_FAIL"
+        elif policy == "PASS":
+            flow_ok = True
+            decision = "PASS_NO_FLOW"
+        elif policy == "DEGRADED":
+            flow_ok = True
+            degraded = True
+            turnover_guard_mult = SUBJECT_FLOW_DEGRADED_TURNOVER_MULT
+            ob_strength_add = SUBJECT_FLOW_DEGRADED_OB_ADD
+            decision = "PASS_DEGRADED"
+        else:  # BLOCK or CACHE without cache
+            flow_ok = False
+            decision = "BLOCK_NO_FLOW"
+
+        _log_flow(
+            code=code,
+            market=market,
+            ok=flow_ok,
+            used=used,
+            policy=policy,
+            score=score,
+            turnover=day_turnover_krw,
+            degraded=degraded,
+            error=error,
+        )
+        return {
+            "flow_ok": flow_ok,
+            "decision": decision,
+            "used": used,
+            "policy": policy,
+            "score": score,
+            "inv": inv,
+            "degraded": degraded,
+            "turnover_guard_mult": turnover_guard_mult,
+            "ob_strength_add": ob_strength_add,
+            "cache_hit": cached is not None,
+            "error": error,
+        }
+
+    except Exception as e:  # noqa: BLE001 - ÏµúÏÉÅÏúÑ ÏïàÏ†ÑÎßù
+        logger.exception("[FLOW-FAILSAFE] %s(%s) ÏòàÏô∏: %s", code, market, e)
+        _log_flow(
+            code=code,
+            market=market,
+            ok=False,
+            used=used,
+            policy=policy,
+            score=score,
+            turnover=day_turnover_krw,
+            degraded=False,
+            error=str(e),
+        )
+        return {
+            "flow_ok": False,
+            "decision": "EXCEPTION",
+            "used": used,
+            "policy": policy,
+            "score": score,
+            "inv": inv,
+            "degraded": False,
+            "turnover_guard_mult": 1.0,
+            "ob_strength_add": 0.0,
+            "cache_hit": False,
+            "error": str(e),
+        }
diff --git a/trader/trader.py b/trader/trader.py
index 15dae007b8e876fe99556ad9726a40a6d05128a8..4165a29f897b3aad46e735d131448a2084f5c83b 100644
--- a/trader/trader.py
+++ b/trader/trader.py
@@ -1,25 +1,26 @@
 # -*- coding: utf-8 -*-
 """Thin entrypoint orchestrating KOSPI core + KOSDAQ alpha engines."""
 from __future__ import annotations
 
 import logging
 
 from portfolio.portfolio_manager import PortfolioManager
 from trader.time_utils import is_trading_day, now_kst
+from trader.subject_flow import get_subject_flow_with_fallback  # noqa: F401 - exported for engines
 
 logger = logging.getLogger(__name__)
 
 
 def main() -> None:
     now = now_kst()
     if not is_trading_day(now):
         logger.warning("[TRADER] ÎπÑÍ±∞ÎûòÏùº(%s) ‚Üí Ï¶âÏãú Ï¢ÖÎ£å", now.date())
         return
 
     mgr = PortfolioManager()
     result = mgr.run_once()
     logger.info("[TRADER] cycle complete %s", result)
 
 
 if __name__ == "__main__":
     main()
