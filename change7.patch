diff --git a/.github/workflows/trade-monitor.yml b/.github/workflows/trade-monitor.yml
index 9c2474574ced92e5c2a061a27301e2aea60894ca..e3640551808f417b54889a6bd0853299f4cd321f 100644
--- a/.github/workflows/trade-monitor.yml
+++ b/.github/workflows/trade-monitor.yml
@@ -1,43 +1,43 @@
 name: Trade Monitor (trader_refactor branch)
 
 permissions:
   contents: write
 
 concurrency:
   group: trade-bot-state
   cancel-in-progress: false
 
 on:
   push:
     branches: [ main, trader_r1 ]
     paths-ignore:
       - "bot_state/**"
   pull_request:
     branches: [ main, trader_r1 ]
   schedule:
-    - cron: "57 23 * * 0-6"
+    - cron: "*/5 0-6 * * 1-5"
   workflow_dispatch:
 
 
 jobs:
   monitor-trade:
     # ğŸ”’ ì•ˆì „ì¥ì¹˜: main ë¸Œëœì¹˜ì—ì„œë§Œ ëª¨ë‹ˆí„°ë§/ìë™ë§¤ë§¤ ì‹¤í–‰
     # if: github.ref == 'refs/heads/main'
     # if: github.ref != 'refs/heads/bot-state'
     runs-on: ubuntu-latest
 
     env:
       #FORCE_TRADING_DAY: "1"   # ğŸ‘ˆ í…ŒìŠ¤íŠ¸ ì‹œì—ë§Œ
       #ALLOW_NON_TRADING_ORDER: "1"
       # === KIS ì¸ì¦í‚¤(ë‘ ì´ë¦„ ëª¨ë‘ ëŒ€ì‘: ë¨¼ì € KIS_*ê°€ ìˆìœ¼ë©´ ê·¸ê±¸, ì—†ìœ¼ë©´ APP_* ì‚¬ìš©) ===
       KIS_APP_KEY:    ${{ secrets.KIS_APP_KEY != '' && secrets.KIS_APP_KEY || secrets.APP_KEY }}
       KIS_APP_SECRET: ${{ secrets.KIS_APP_SECRET != '' && secrets.KIS_APP_SECRET || secrets.APP_SECRET }}
       # (ì¼ë¶€ ëª¨ë“ˆì´ APP_*ë¥¼ ì½ì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ ë™ì¼ ê°’ ë™ì‹œ ì£¼ì…)
       APP_KEY:        ${{ secrets.KIS_APP_KEY != '' && secrets.KIS_APP_KEY || secrets.APP_KEY }}
       APP_SECRET:     ${{ secrets.KIS_APP_SECRET != '' && secrets.KIS_APP_SECRET || secrets.APP_SECRET }}
 
       CANO:           ${{ secrets.CANO }}
       ACNT_PRDT_CD:   ${{ secrets.ACNT_PRDT_CD }}
       KIS_ENV:        ${{ secrets.KIS_ENV }}          # practice / real
 
       # settings.pyê°€ KIS_ENVë¡œ ìë™íŒë‹¨í•˜ë¯€ë¡œ API_BASE_URLì€ ë³´í†µ ë¶ˆí•„ìš”
@@ -199,56 +199,85 @@ jobs:
           python - << 'PY'
           import trader
           from trader import trader as t
           print("trader package path:", trader.__file__)
           print("trader.trader module path:", t.__file__)
           print("=== HEAD OF trader.trader ===")
           try:
               with open(t.__file__, 'r', encoding='utf-8') as f:
                   for i in range(1, 80):
                       line = f.readline()
                       if not line:
                           break
                       print(f"{i:03}: {line.rstrip()}")
           except Exception as e:
               print("ERROR while reading trader.trader:", e)
           PY
 
       - name: ë¦¬ë°¸ëŸ°ì‹± API ì„œë²„ ì‹¤í–‰ (FastAPI, ë°±ê·¸ë¼ìš´ë“œ, ë¡œê·¸íŒŒì¼)
         run: |
           nohup uvicorn rolling_k_auto_trade_api.main:app --host 0.0.0.0 --port 8000 > fastapi.log 2>&1 &
           sleep 30  # ì„œë²„ ê¸°ë™ ëŒ€ê¸°
 
       - name: Compile modules
         run: |
           python -m compileall trader rolling_k_auto_trade_api
-      - name: trader ìë™ë§¤ë§¤ ë¡œì§ ì‹¤í–‰
+      - name: trader ìë™ë§¤ë§¤ ë¡œì§ ì‹¤í–‰ (DRY RUN - push/pr)
+        if: github.event_name == 'push' || github.event_name == 'pull_request'
         env:
           PYTHONPATH: ${{ github.workspace }}
+          DRY_RUN: "true"
+          LIVE_TRADING_ENABLED: "false"
+          ACTIVE_STRATEGIES: "1"
+          STRATEGY_MODE: "INTENT_ONLY"
+          DISABLE_LIVE_TRADING: "true"
+          DISABLE_KOSDAQ_LOOP: "true"
+          DISABLE_KOSPI_ENGINE: "true"
         run: |
           python -m trader.trader
 
+      - name: trader ìë™ë§¤ë§¤ ë¡œì§ ì‹¤í–‰ (LIVE - schedule/dispatch)
+        if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
+        env:
+          PYTHONPATH: ${{ github.workspace }}
+          DRY_RUN: "false"
+          LIVE_TRADING_ENABLED: "true"
+          ACTIVE_STRATEGIES: "1"
+          STRATEGY_MODE: "LIVE"
+          STRATEGY_DRY_RUN: "false"
+          DISABLE_LIVE_TRADING: "false"
+          DISABLE_KOSDAQ_LOOP: "false"
+          DISABLE_KOSPI_ENGINE: "false"
+        run: |
+          python -m trader.trader
+
+      - name: Copy reconciled state to trader/state/state.json
+        if: always()
+        run: |
+          mkdir -p trader/state
+          test -f .runtime/state.json && cp -f .runtime/state.json trader/state/state.json || true
+
       - name: CEO ë¦¬í¬íŠ¸ ìë™ ìƒì„±
         if: always()
         env:
           PYTHONPATH: ${{ github.workspace }}
         run: |
           python -m trader.report_ceo || true
 
       - name: Verify CEO report exists
         if: always()
         run: |
           ls -al trader/logs || true
 
       - name: Push state (plain)
         if: github.event_name != 'pull_request'
         run: |
           test -f scripts/state_push_plain.sh && bash scripts/state_push_plain.sh || true
 
       - name: Save state snapshot as artifact (audit only)
         if: always()
         uses: actions/upload-artifact@v4
         with:
           name: trader-state-${{ github.run_id }}
           path: |
             trader/state/state.json
             bot_state/state.json
diff --git a/portfolio/portfolio_manager.py b/portfolio/portfolio_manager.py
index 3c18e0aee322cdfc586d2e4ad313a6801199ba6c..ef621f03f7cefe3f49b2bb2f3aa02df5d43b0075 100644
--- a/portfolio/portfolio_manager.py
+++ b/portfolio/portfolio_manager.py
@@ -12,131 +12,146 @@ from trader.config import (
     DAILY_CAPITAL,
     DIAG_ENABLED,
     DIAGNOSTIC_ONLY,
     DISABLE_KOSDAQ_LOOP,
     DISABLE_KOSPI_ENGINE,
     STRATEGY_INTENTS_PATH,
 )
 from trader.diagnostics_runner import run_diagnostics_once
 from trader.intent_executor import IntentExecutor
 import trader.state_store as state_store
 from trader.core_utils import get_rebalance_anchor_date
 from trader.subject_flow import reset_flow_call_count
 from .kospi_core_engine import KospiCoreEngine
 from .kosdaq_alpha_engine import KosdaqAlphaEngine
 from .performance import PerformanceTracker
 
 logger = logging.getLogger(__name__)
 
 
 class PortfolioManager:
     def __init__(
         self,
         total_capital: float | None = None,
         kospi_ratio: float = 0.6,
         kosdaq_ratio: float = 0.4,
+        active_strategies: set[int] | None = None,
     ) -> None:
         self.total_capital = float(total_capital or DAILY_CAPITAL)
+        self.active_strategies = set(active_strategies) if active_strategies else set()
         if kospi_ratio + kosdaq_ratio == 0:
             kospi_ratio, kosdaq_ratio = 0.6, 0.4
         norm = kospi_ratio + kosdaq_ratio
         self.kospi_ratio = kospi_ratio / norm
         self.kosdaq_ratio = kosdaq_ratio / norm
         self.kospi_engine = KospiCoreEngine(capital=self.total_capital * self.kospi_ratio)
         self.kosdaq_engine = KosdaqAlphaEngine(capital=self.total_capital * self.kosdaq_ratio)
         self.performance = PerformanceTracker()
-        self.strategy_manager = StrategyManager(total_capital=self.total_capital)
+        self.strategy_manager = StrategyManager(
+            total_capital=self.total_capital,
+            active_strategies=self.active_strategies or None,
+        )
         self.intent_executor = IntentExecutor()
         logger.info(
-            "[PORTFOLIO] capital=%s kospi=%.0f%% kosdaq=%.0f%%",
+            "[PORTFOLIO] capital=%s kospi=%.0f%% kosdaq=%.0f%% active_strategies=%s",
             int(self.total_capital),
             self.kospi_ratio * 100,
             self.kosdaq_ratio * 100,
+            sorted(self.strategy_manager.active_strategies),
         )
 
     def run_once(self) -> Dict[str, Any]:
         reset_flow_call_count()
         selected_by_market: Dict[str, Any] = {}
         diag_result: Dict[str, Any] | None = None
         try:
             rebalance_date = str(get_rebalance_anchor_date())
             rebalance_payload = run_rebalance(rebalance_date, return_by_market=True)
             selected_by_market = rebalance_payload.get("selected_by_market") or {}
             logger.info(
                 "[PORTFOLIO][REBALANCE] date=%s kospi=%d kosdaq=%d",
                 rebalance_date,
                 len(selected_by_market.get("KOSPI", [])),
                 len(selected_by_market.get("KOSDAQ", [])),
             )
         except Exception as e:
             logger.exception("[PORTFOLIO] rebalance fetch failed: %s", e)
 
         runtime_state = state_store.load_state()
         logger.info(
-            "[DIAG][PM] diagnostic_mode=%s diagnostic_only=%s",
+            "[DIAG][PM] diagnostic_mode=%s diagnostic_only=%s active_strategies=%s",
             DIAG_ENABLED,
             DIAGNOSTIC_ONLY,
+            sorted(self.strategy_manager.active_strategies),
         )
         if DIAG_ENABLED:
             os.environ["DISABLE_LIVE_TRADING"] = "true"
             logger.info("[DIAG][PM] forcing DISABLE_LIVE_TRADING=true diag_enabled=%s", DIAG_ENABLED)
             diag_result = run_diagnostics_once(selected_by_market=selected_by_market)
             if DIAGNOSTIC_ONLY:
+                skip_reason = "diagnostic_only_mode"
                 return {
                     "diagnostics": diag_result,
-                    "kospi": {"status": "skipped"},
-                    "kosdaq": {"status": "skipped"},
+                    "kospi": {"status": "skipped", "reason": skip_reason},
+                    "kosdaq": {"status": "skipped", "reason": skip_reason},
+                    "active_strategies": sorted(self.strategy_manager.active_strategies),
                 }
 
         try:
             market_data = build_market_data(selected_by_market)
             strategy_result = self.strategy_manager.run_once(
                 market_data=market_data, portfolio_state=runtime_state
             )
             intents = strategy_result.get("intents") or []
         except Exception as e:
             logger.exception("[PORTFOLIO] strategy manager failure: %s", e)
             strategy_result = {"status": "error", "message": str(e), "enabled": [], "intents": []}
             intents = []
 
         try:
             STRATEGY_INTENTS_PATH.parent.mkdir(parents=True, exist_ok=True)
             STRATEGY_INTENTS_PATH.touch(exist_ok=True)
             intent_store.append_intents(intents, STRATEGY_INTENTS_PATH)
             executor_result = self.intent_executor.run_once()
         except Exception as e:
             logger.exception("[PORTFOLIO] intent executor failure: %s", e)
             executor_result = {"status": "error", "message": str(e)}
 
         try:
             if DISABLE_KOSPI_ENGINE:
-                kospi = {"status": "disabled"}
+                kospi_disable_reason = "env DISABLE_KOSPI_ENGINE=true"
+                logger.warning("[KOSPI][DISABLED] reason=%s active_strategies=%s", kospi_disable_reason, sorted(self.strategy_manager.active_strategies))
+                kospi = {"status": "disabled", "reason": kospi_disable_reason}
             else:
                 kospi = self.kospi_engine.rebalance_if_needed(
                     selected_stocks=selected_by_market.get("KOSPI")
                 )
         except Exception as e:
             logger.exception("[PORTFOLIO] KOSPI engine failure: %s", e)
             kospi = {"status": "error", "message": str(e)}
         try:
             if DISABLE_KOSDAQ_LOOP:
-                kosdaq = {"status": "disabled"}
+                kosdaq_disable_reason = "env DISABLE_KOSDAQ_LOOP=true"
+                logger.warning("[KOSDAQ][DISABLED] reason=%s active_strategies=%s", kosdaq_disable_reason, sorted(self.strategy_manager.active_strategies))
+                kosdaq = {"status": "disabled", "reason": kosdaq_disable_reason}
             else:
                 kosdaq = self.kosdaq_engine.trade_loop(
                     selected_stocks=selected_by_market.get("KOSDAQ")
                 )
         except Exception as e:
             logger.exception("[PORTFOLIO] KOSDAQ engine failure: %s", e)
             kosdaq = {"status": "error", "message": str(e)}
         perf = self.performance.snapshot(
             {
                 "kospi_core": self.kospi_engine.capital,
                 "kosdaq_alpha": self.kosdaq_engine.capital,
             }
         )
+        strategy_result.setdefault("active_strategies", sorted(self.strategy_manager.active_strategies))
         return {
             "strategies": {"manager": strategy_result, "executor": executor_result},
             "diagnostics": diag_result,
             "kospi": kospi,
             "kosdaq": kosdaq,
             "performance": perf,
+            "active_strategies": sorted(self.strategy_manager.active_strategies),
         }
diff --git a/strategy/manager.py b/strategy/manager.py
index 397f6d80e8ef044f57bd6f131f19d777fb7c1245..3b170f05b15ab06e3b6316133da87da82da3ccf2 100644
--- a/strategy/manager.py
+++ b/strategy/manager.py
@@ -18,84 +18,85 @@ from strategy.strategies import (
 from strategy.types import OrderIntent
 from trader.config import (
     ACTIVE_STRATEGIES,
     ALLOW_ADOPT_UNMANAGED,
     DAILY_CAPITAL,
     ENABLED_STRATEGIES_SET,
     KST,
     STRATEGY_MAX_POSITION_PCT,
     STRATEGY_WEIGHTS,
     UNMANAGED_STRATEGY_ID,
 )
 from trader import state_store as runtime_state_store
 
 logger = logging.getLogger(__name__)
 
 
 @dataclass
 class StrategySlot:
     name: str
     sid: int
     weight: float
     strategy: BaseStrategy
 
 
 class StrategyManager:
-    def __init__(self, total_capital: float | None = None) -> None:
+    def __init__(self, total_capital: float | None = None, active_strategies: set[int] | None = None) -> None:
         self.total_capital = float(total_capital or DAILY_CAPITAL)
         self._seq = 0
         self._zero_weight_warned: set[str] = set()
+        self.active_strategies = set(active_strategies) if active_strategies else set(ACTIVE_STRATEGIES)
         self.slots: list[StrategySlot] = self._register_strategies()
 
     def _register_strategies(self) -> list[StrategySlot]:
         return [
             StrategySlot("breakout", 1, float(STRATEGY_WEIGHTS.get("breakout", 0.0)), BreakoutStrategy()),
             StrategySlot("pullback", 2, float(STRATEGY_WEIGHTS.get("pullback", 0.0)), PullbackStrategy()),
             StrategySlot("momentum", 3, float(STRATEGY_WEIGHTS.get("momentum", 0.0)), MomentumStrategy()),
             StrategySlot(
                 "mean_reversion",
                 4,
                 float(STRATEGY_WEIGHTS.get("mean_reversion", 0.0)),
                 MeanReversionStrategy(),
             ),
             StrategySlot(
                 "volatility",
                 5,
                 float(STRATEGY_WEIGHTS.get("volatility", 0.0)),
                 VolatilityStrategy(),
             ),
         ]
 
     def enabled_slots(self) -> list[StrategySlot]:
         enabled: list[StrategySlot] = []
         for slot in self.slots:
-            if slot.sid not in ACTIVE_STRATEGIES:
+            if slot.sid not in self.active_strategies:
                 logger.info(
-                    "[STRATEGY_MANAGER] strategy %s sid=%s not in active_strategies=%s -> skipped",
+                    "[STRATEGY_MANAGER] strategy %s sid=%s not in active_strategies=%s -> skipped reason=not_active",
                     slot.name,
                     slot.sid,
-                    sorted(ACTIVE_STRATEGIES),
+                    sorted(self.active_strategies),
                 )
                 continue
             if slot.name not in ENABLED_STRATEGIES_SET:
                 continue
             if float(slot.weight) <= 0:
                 if slot.name not in self._zero_weight_warned:
                     logger.info(
                         "[STRATEGY_MANAGER] strategy %s enabled but weight=0 -> skipped", slot.name
                     )
                     self._zero_weight_warned.add(slot.name)
                 continue
             enabled.append(slot)
         return enabled
 
     def _next_intent_id(self, strategy: str, side: str, symbol: str, ts: str) -> str:
         self._seq += 1
         return f"{ts}-{strategy}-{side}-{symbol}-{self._seq}"
 
     def _last_price(self, symbol: str, market_data: Dict[str, Any]) -> float | None:
         prices = market_data.get("prices") if isinstance(market_data, dict) else None
         if isinstance(prices, dict):
             data = prices.get(symbol) or prices.get(str(symbol).zfill(6)) or {}
             try:
                 return float(data.get("last_price") or data.get("price") or 0.0)
             except Exception:
@@ -265,26 +266,30 @@ class StrategyManager:
         state = portfolio_state or state_store.load_state()
         market_data = market_data or {}
         intents: list[OrderIntent] = []
         enabled: list[str] = []
         dedupe_keys: set[Tuple[str, str, str]] = set()
 
         for slot in self.enabled_slots():
             enabled.append(slot.name)
             try:
                 slot.strategy.update_state(market_data)
             except Exception:
                 logger.exception("[STRATEGY_MANAGER] failed to update state for %s", slot.name)
             for intent in self._entry_intents_for_slot(slot, market_data, state):
                 key = (slot.name, intent.symbol, intent.side)
                 if key in dedupe_keys:
                     continue
                 dedupe_keys.add(key)
                 intents.append(intent)
             for intent in self._exit_intents_for_slot(slot, market_data, state):
                 key = (slot.name, intent.symbol, intent.side)
                 if key in dedupe_keys:
                     continue
                 dedupe_keys.add(key)
                 intents.append(intent)
 
-        return {"enabled": enabled, "intents": [asdict(intent) for intent in intents]}
+        return {
+            "enabled": enabled,
+            "intents": [asdict(intent) for intent in intents],
+            "active_strategies": sorted(self.active_strategies),
+        }
diff --git a/trader/config.py b/trader/config.py
index 78a415521a71edca8c847d27a9fcc537503518a3..7a3ba1e6c1024bc905411d3d3b1194ff7b6d4601 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -91,67 +91,70 @@ CONFIG = {
     "SUBJECT_FLOW_DEGRADED_OB_ADD": "10",
     "SUBJECT_FLOW_MAX_CALLS_PER_RUN": "200",
     "EMERGENCY_GLOBAL_SELL": "false",
     "STRATEGY_REDUCTION_PRIORITY": "5,4,3,2,1",
     # Diagnostics
     "DIAGNOSTIC_MODE": "false",
     "DIAGNOSTIC_ONLY": "false",
     "DIAGNOSTIC_FORCE_RUN": "false",
     "DIAGNOSTIC_DUMP_PATH": "trader/state/diagnostics",
     "DIAGNOSTIC_TARGET_MARKETS": "",
     "DIAGNOSTIC_MAX_SYMBOLS": "200",
     # === Strategy intent/exec defaults ===
     "ENABLED_STRATEGIES": "",
     "STRATEGY_MODE": "INTENT_ONLY",  # INTENT_ONLY | LIVE
     "STRATEGY_DRY_RUN": "true",
     "STRATEGY_INTENTS_PATH": "trader/state/strategy_intents.jsonl",
     "STRATEGY_INTENTS_STATE_PATH": "trader/state/strategy_intents_state.json",
     "STRATEGY_MAX_OPEN_INTENTS": "20",
     "STRATEGY_MAX_POSITION_PCT": "0.10",
     "STRATEGY_ALLOW_SELL_ONLY": "false",
     "STRATEGY_WEIGHTS": "",
     "DISABLE_KOSDAQ_LOOP": "false",
     "DISABLE_KOSPI_ENGINE": "false",
     "ACTIVE_STRATEGIES": "1",  # CSV of strategy IDs eligible for managed exits/entries
     "ALLOW_ADOPT_UNMANAGED": "false",
+    "STATE_PATH": "trader/state/state.json",
 }
 
 
 def _cfg(key: str) -> str:
     """í™˜ê²½ë³€ìˆ˜ > CONFIG ê¸°ë³¸ê°’"""
     return os.getenv(key, CONFIG.get(key, ""))
 
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 LOG_DIR = Path(__file__).parent / "logs"
 LOG_DIR.mkdir(exist_ok=True)
 STATE_FILE = Path(__file__).parent / "trade_state.json"  # legacy; position state uses STATE_PATH
-STATE_DIR = Path(__file__).parent / "state"
-STATE_PATH = STATE_DIR / "state.json"
+STATE_DIR_RAW = _cfg("STATE_DIR")
+STATE_DIR = Path(STATE_DIR_RAW) if STATE_DIR_RAW else Path(__file__).parent / "state"
+STATE_PATH = Path(_cfg("STATE_PATH") or STATE_DIR / "state.json")
 STATE_DIR.mkdir(parents=True, exist_ok=True)
+STATE_PATH.parent.mkdir(parents=True, exist_ok=True)
 
 # ì¢…ëª©ë³„ ì‹œì¥ì½”ë“œ ê³ ì • ë§µ (ì‹¤ì „ì—ì„œëŠ” ë§ˆìŠ¤í„°í…Œì´ë¸” ë¡œë“œë¡œ ëŒ€ì²´ ê¶Œì¥)
 MARKET_MAP: Dict[str, str] = {
     # ì˜ˆì‹œ: '145020': 'J', '347850': 'J', '257720': 'U', '178320': 'J', '348370': 'U'
 }
 
 # ë°ì´í„° ì—†ìŒ 1ì°¨ ê°ì§€ ìƒíƒœ ì €ì¥(ì—°ì† DATA_EMPTY í™•ì¸ìš©)
 EXCLUDE_STATE: Dict[str, Dict[str, bool]] = {}
 
 KST = ZoneInfo("Asia/Seoul")
 
 SELL_FORCE_TIME_STR = _cfg("SELL_FORCE_TIME").strip()
 SELL_ALL_BALANCES_AT_CUTOFF = _cfg("SELL_ALL_BALANCES_AT_CUTOFF").lower() == "true"
 EMERGENCY_GLOBAL_SELL = _cfg("EMERGENCY_GLOBAL_SELL").lower() in ("1", "true", "yes")
 RATE_SLEEP_SEC = float(_cfg("API_RATE_SLEEP_SEC"))
 FORCE_SELL_PASSES_CUTOFF = int(_cfg("FORCE_SELL_PASSES_CUTOFF"))
 FORCE_SELL_PASSES_CLOSE = int(_cfg("FORCE_SELL_PASSES_CLOSE"))
 FORCE_SELL_BLOCKED_LOTS = _cfg("FORCE_SELL_BLOCKED_LOTS").lower() in ("1", "true", "yes")
 PARTIAL1 = float(_cfg("PARTIAL1"))
 PARTIAL2 = float(_cfg("PARTIAL2"))
 TRAIL_PCT = float(_cfg("TRAIL_PCT"))
 FAST_STOP = float(_cfg("FAST_STOP"))
 ATR_STOP = float(_cfg("ATR_STOP"))
 TIME_STOP_HHMM = _cfg("TIME_STOP_HHMM")
 DEFAULT_PROFIT_PCT = float(_cfg("DEFAULT_PROFIT_PCT"))
@@ -210,51 +213,54 @@ def _parse_strategy_weights(raw: str) -> Dict[str, float]:
             key, value = item.split(":", 1)
         else:
             key, value = item, "0"
         key = key.strip().lower()
         try:
             weight = float(value)
         except ValueError:
             weight = 0.0
         if key:
             weights[key] = weight
     return weights
 
 
 ENABLED_STRATEGIES_SET = parse_enabled_strategies(_cfg("ENABLED_STRATEGIES"))
 RAW_STRATEGY_WEIGHTS = _parse_strategy_weights(_cfg("STRATEGY_WEIGHTS"))
 
 if ENABLED_STRATEGIES_SET:
     STRATEGY_WEIGHTS = {
         name: (RAW_STRATEGY_WEIGHTS.get(name, 0.0) if name in ENABLED_STRATEGIES_SET else 0.0)
         for name in ENABLED_STRATEGIES_SET.union(RAW_STRATEGY_WEIGHTS.keys())
     }
 else:
     STRATEGY_WEIGHTS = {name: 0.0 for name in RAW_STRATEGY_WEIGHTS.keys()}
 
 STRATEGY_MODE = (_cfg("STRATEGY_MODE") or "INTENT_ONLY").upper()
-STRATEGY_DRY_RUN = (_cfg("STRATEGY_DRY_RUN") or "true").lower() in ("1", "true", "yes")
+_RAW_STRATEGY_DRY_RUN = os.getenv("DRY_RUN")
+if not _RAW_STRATEGY_DRY_RUN:
+    _RAW_STRATEGY_DRY_RUN = _cfg("STRATEGY_DRY_RUN") or "true"
+STRATEGY_DRY_RUN = str(_RAW_STRATEGY_DRY_RUN).lower() in ("1", "true", "yes")
 STRATEGY_INTENTS_PATH = Path(_cfg("STRATEGY_INTENTS_PATH") or CONFIG["STRATEGY_INTENTS_PATH"])
 STRATEGY_INTENTS_STATE_PATH = Path(
     _cfg("STRATEGY_INTENTS_STATE_PATH") or CONFIG["STRATEGY_INTENTS_STATE_PATH"]
 )
 STRATEGY_MAX_OPEN_INTENTS = int(_cfg("STRATEGY_MAX_OPEN_INTENTS") or "20")
 STRATEGY_MAX_POSITION_PCT = float(_cfg("STRATEGY_MAX_POSITION_PCT") or "0.10")
 STRATEGY_ALLOW_SELL_ONLY = (_cfg("STRATEGY_ALLOW_SELL_ONLY") or "false").lower() in (
     "1",
     "true",
     "yes",
 )
 
 DIAGNOSTIC_MODE = (_cfg("DIAGNOSTIC_MODE") or "false").lower() in ("1", "true", "yes")
 DIAGNOSTIC_ONLY = (_cfg("DIAGNOSTIC_ONLY") or "false").lower() in ("1", "true", "yes")
 DIAGNOSTIC_FORCE_RUN = (_cfg("DIAGNOSTIC_FORCE_RUN") or "false").lower() in (
     "1",
     "true",
     "yes",
 )
 DIAGNOSTIC_DUMP_DIR = Path(
     _cfg("DIAGNOSTIC_DUMP_DIR") or _cfg("DIAGNOSTIC_DUMP_PATH") or CONFIG["DIAGNOSTIC_DUMP_PATH"]
 )
 DIAGNOSTIC_DUMP_DIR.mkdir(parents=True, exist_ok=True)
 DIAGNOSTIC_MAX_SYMBOLS = int(_cfg("DIAGNOSTIC_MAX_SYMBOLS") or CONFIG["DIAGNOSTIC_MAX_SYMBOLS"])
 DIAGNOSTIC_TARGET_MARKETS = (_cfg("DIAGNOSTIC_TARGET_MARKETS") or "").strip()
@@ -326,50 +332,60 @@ PULLBACK_DAYS = int(_cfg("PULLBACK_DAYS") or "3")
 PULLBACK_REVERSAL_BUFFER_PCT = float(_cfg("PULLBACK_REVERSAL_BUFFER_PCT") or "0.2")
 PULLBACK_TOPN = int(_cfg("PULLBACK_TOPN") or "50")
 PULLBACK_UNIT_WEIGHT = float(_cfg("PULLBACK_UNIT_WEIGHT") or "0.03")
 PULLBACK_MAX_BUYS_PER_DAY = int(_cfg("PULLBACK_MAX_BUYS_PER_DAY") or "5")
 CHAMPION_MIN_TRADES = int(_cfg("CHAMPION_MIN_TRADES") or "5")
 CHAMPION_MIN_WINRATE = float(_cfg("CHAMPION_MIN_WINRATE") or "45.0")
 CHAMPION_MAX_MDD = float(_cfg("CHAMPION_MAX_MDD") or "30.0")
 CHAMPION_MIN_SHARPE = float(_cfg("CHAMPION_MIN_SHARPE") or "0.0")
 
 # ì±”í”¼ì–¸ ë“±ê¸‰ & GOOD/BAD íƒ€ì  íŒë³„ íŒŒë¼ë¯¸í„°
 CHAMPION_A_RULES = {
     "min_trades": 30,
     "min_cumret_pct": 40.0,
     "max_mdd_pct": 25.0,
     "min_win_pct": 50.0,
     "min_sharpe": 1.2,
     "min_turnover": 3_000_000_000,  # 30ì–µ
 }
 
 GOOD_ENTRY_PULLBACK_RANGE = (5.0, 15.0)  # ì‹ ê³ ê°€ ëŒ€ë¹„ ëˆŒë¦¼í­(%): ìµœì†Œ~ìµœëŒ€
 GOOD_ENTRY_MA20_RANGE = (1.0, 1.15)  # í˜„ì¬ê°€/20MA í—ˆìš© êµ¬ê°„
 GOOD_ENTRY_MAX_FROM_PEAK = 0.97  # í˜„ì¬ê°€/ìµœê·¼ê³ ì  ìµœëŒ€ì¹˜(â‰¤0.97)
 GOOD_ENTRY_MIN_RR = 2.0  # ê¸°ëŒ€ìˆ˜ìµ/ë¦¬ìŠ¤í¬ ìµœì†Œ ë¹„ìœ¨
 GOOD_ENTRY_MIN_INTRADAY_SIG = 2  # GOOD íƒ€ì ìœ¼ë¡œ ì¸ì •í•˜ê¸° ìœ„í•œ ìµœì†Œ intraday ì‹œê·¸ë„ ê°œìˆ˜
 
+
+def resolve_active_strategies(raw: str | None = None) -> set[int]:
+    """í™˜ê²½ë³€ìˆ˜ ACTIVE_STRATEGIESë¥¼ ìš°ì„  ì ìš©í•˜ì—¬ í™œì„± ì „ëµ ì§‘í•©ì„ ë°˜í™˜í•œë‹¤."""
+
+    raw_env = os.getenv("ACTIVE_STRATEGIES") if raw is None else raw
+    parsed = _parse_active_strategies(raw_env or "")
+    if parsed:
+        return parsed
+    return ACTIVE_STRATEGIES
+
 BAD_ENTRY_MAX_MA20_DIST = 1.25  # í˜„ì¬ê°€/20MA ìƒí•œ(ì¶”ê²©ë§¤ìˆ˜ ë°©ì§€)
 BAD_ENTRY_MAX_PULLBACK = 20.0  # ì‹ ê³ ê°€ ëŒ€ë¹„ ëˆŒë¦¼í­ ìƒí•œ(ê³¼ë„í•œ ë¶•ê´´ ë°©ì§€)
 BAD_ENTRY_MAX_BELOW_VWAP_RATIO = 0.7  # ë¶„ë´‰ì—ì„œ VWAP ì•„ë˜ ì²´ë¥˜ ë¹„ì¤‘ì´ ì´ ì´ìƒì´ë©´ BAD
 NEUTRAL_ENTRY_SCALE = float(_cfg("NEUTRAL_ENTRY_SCALE") or "0.6")
 
 
 def _parse_hhmm(hhmm: str) -> dtime:
     try:
         hh, mm = hhmm.split(":")
         return dtime(hour=int(hh), minute=int(mm))
     except Exception:
         logger.warning(f"[ì„¤ì •ê²½ê³ ] SELL_FORCE_TIME í˜•ì‹ ì˜¤ë¥˜ â†’ ê¸°ë³¸ê°’ 14:40 ì ìš©: {hhmm}")
         return dtime(hour=14, minute=40)
 
 
 SELL_FORCE_TIME = _parse_hhmm(SELL_FORCE_TIME_STR)
 TIME_STOP_TIME = _parse_hhmm(TIME_STOP_HHMM)
 ALLOW_WHEN_CLOSED = _cfg("MARKET_DATA_WHEN_CLOSED").lower() == "true"
 DISABLE_KOSDAQ_LOOP = (_cfg("DISABLE_KOSDAQ_LOOP") or "false").lower() in ("1", "true", "yes")
 DISABLE_KOSPI_ENGINE = (_cfg("DISABLE_KOSPI_ENGINE") or "false").lower() in ("1", "true", "yes")
 
 # === [NEW] ì£¼ê°„ ë¦¬ë°¸ëŸ°ì‹± ê°•ì œ íŠ¸ë¦¬ê±° ìƒíƒœ íŒŒì¼ ===
 STATE_WEEKLY_PATH = Path(__file__).parent / "state_weekly.json"
 
 def _this_iso_week_key(now=None):
diff --git a/trader/intent_executor.py b/trader/intent_executor.py
index e47749536e012a925ea551abfb9a04a79a7b6ae0..1dafbbd03f8716c5ab64a5bcaf1916b9a79862d3 100644
--- a/trader/intent_executor.py
+++ b/trader/intent_executor.py
@@ -5,67 +5,81 @@ import os
 from typing import Any, Dict
 
 import trader.intent_store as intent_store
 from strategy.types import ExecutionAck
 from trader.config import (
     STRATEGY_ALLOW_SELL_ONLY,
     STRATEGY_DRY_RUN,
     STRATEGY_INTENTS_PATH,
     STRATEGY_INTENTS_STATE_PATH,
     STRATEGY_MAX_OPEN_INTENTS,
     STRATEGY_MODE,
 )
 
 logger = logging.getLogger(__name__)
 
 
 class IntentExecutor:
     """Strategy intent executor (Phase 1: dry-run)."""
 
     def __init__(self) -> None:
         self.intents_path = STRATEGY_INTENTS_PATH
         self.cursor_state_path = STRATEGY_INTENTS_STATE_PATH
         self.allow_sell_only = STRATEGY_ALLOW_SELL_ONLY
         self.max_open_intents = int(STRATEGY_MAX_OPEN_INTENTS)
 
-    def _should_dry_run(self) -> bool:
+    def _should_dry_run(self) -> tuple[bool, str]:
         disable_live = os.getenv("DISABLE_LIVE_TRADING", "").lower() in {"1", "true", "yes", "on"}
-        return disable_live or STRATEGY_DRY_RUN or STRATEGY_MODE == "INTENT_ONLY"
+        reasons = []
+        if disable_live:
+            reasons.append("DISABLE_LIVE_TRADING env=true")
+        if STRATEGY_DRY_RUN:
+            reasons.append("STRATEGY_DRY_RUN config=true")
+        if STRATEGY_MODE == "INTENT_ONLY":
+            reasons.append("STRATEGY_MODE=INTENT_ONLY")
+        dry_run = bool(reasons)
+        return dry_run, ",".join(reasons) if dry_run else ""
 
     def run_once(self) -> Dict[str, Any]:
         intents: list[Dict[str, Any]] = []
         cursor: Dict[str, Any] = {"offset": 0, "last_intent_id": None, "last_ts": None, "start_offset": 0}
         try:
             intents, cursor = intent_store.load_intents_since_cursor(
                 self.intents_path, self.cursor_state_path
             )
             intents = intent_store.dedupe_intents(intents)
         except Exception:
             logger.exception("[INTENT_EXECUTOR] failed to load intents")
             return {"acks": [], "status": "error"}
 
-        dry_run = self._should_dry_run()
+        dry_run, dry_run_reason = self._should_dry_run()
+        logger.info(
+            "[INTENT_EXECUTOR] dry_run=%s reason=%s max_open_intents=%s",
+            dry_run,
+            dry_run_reason or "live",
+            self.max_open_intents,
+        )
         acks: list[ExecutionAck] = []
         processed = 0
         last_processed_offset = int(cursor.get("start_offset") or cursor.get("offset") or 0)
         last_intent_id = cursor.get("last_intent_id")
         last_ts = cursor.get("last_ts")
         for idx, intent in enumerate(intents):
             intent_id = intent.get("intent_id") or f"unknown-{idx}"
             side = str(intent.get("side") or "").upper()
             intent_offset = intent.get("_end_offset")
 
             if processed >= self.max_open_intents:
                 acks.append(
                     ExecutionAck(
                         intent_id=intent_id,
                         ok=False,
                         message="max_open_intents_cap",
                         order_id=None,
                     )
                 )
                 break
 
             if self.allow_sell_only and side == "BUY":
                 acks.append(
                     ExecutionAck(
                         intent_id=intent_id,
@@ -106,26 +120,31 @@ class IntentExecutor:
                         last_processed_offset = max(last_processed_offset, int(intent_offset))
                     except Exception:
                         pass
                 last_intent_id = intent_id
                 last_ts = intent.get("ts") or last_ts
                 continue
 
             acks.append(
                 ExecutionAck(intent_id=intent_id, ok=False, message="live_mode_not_implemented")
             )
             processed += 1
             if intent_offset is not None:
                 try:
                     last_processed_offset = max(last_processed_offset, int(intent_offset))
                 except Exception:
                     pass
             last_intent_id = intent_id
             last_ts = intent.get("ts") or last_ts
 
         intent_store.save_cursor(
             self.cursor_state_path,
             offset=last_processed_offset,
             last_intent_id=last_intent_id,
             last_ts=last_ts,
         )
-        return {"acks": [ack.__dict__ for ack in acks], "processed": processed, "dry_run": dry_run}
+        return {
+            "acks": [ack.__dict__ for ack in acks],
+            "processed": processed,
+            "dry_run": dry_run,
+            "dry_run_reason": dry_run_reason if dry_run else "",
+        }
diff --git a/trader/state_store.py b/trader/state_store.py
index e2fa7fc6d4d500c84cb218a69667cc25333d0aab..904d2a05a96fd815901e1f8184130f9f3e4e78ba 100644
--- a/trader/state_store.py
+++ b/trader/state_store.py
@@ -1,153 +1,171 @@
 from __future__ import annotations
 
 import json
 import logging
 import os
 import uuid
 from datetime import datetime
 from pathlib import Path
 from typing import Any, Dict
 
 from .config import ACTIVE_STRATEGIES, KST, STATE_PATH, UNMANAGED_STRATEGY_ID
 
 logger = logging.getLogger(__name__)
 
 SCHEMA_VERSION = 3
-RUNTIME_STATE_DIR = Path(".runtime")
-RUNTIME_STATE_PATH = RUNTIME_STATE_DIR / "state.json"
+STATE_PRIMARY_PATH = Path(os.getenv("STATE_PATH") or STATE_PATH)
+RUNTIME_STATE_DIR = STATE_PRIMARY_PATH.parent
+RUNTIME_STATE_PATH = STATE_PRIMARY_PATH
+LEGACY_RUNTIME_DIR = Path(".runtime")
+LEGACY_RUNTIME_PATH = LEGACY_RUNTIME_DIR / "state.json"
 _LOT_ID_PREFIX = "LOT"
 
 
 def _normalize_code(symbol: str | int | None) -> str:
     return str(symbol or "").zfill(6)
 
 
 def _normalize_strategy_id(value: Any) -> Any:
     if value is None:
         return None
     try:
         return int(value)
     except Exception:
         return value
 
 
 def _is_managed(strategy_id: Any, active_strategies: set[int] | None = None) -> bool:
     try:
         sid_int = int(strategy_id)
     except Exception:
         return False
     return sid_int in (active_strategies or ACTIVE_STRATEGIES)
 
 
 def _default_runtime_state() -> Dict[str, Any]:
     return {
         "schema_version": SCHEMA_VERSION,
         "updated_at": None,
         "positions": {},
         "orders": {},
         "lots": [],
         "memory": {"last_price": {}, "last_seen": {}, "last_strategy_id": {}},
     }
 
 
-def load_state() -> Dict[str, Any]:
-    if not RUNTIME_STATE_PATH.exists():
-        return _default_runtime_state()
+def _load_from_path(path: Path) -> Dict[str, Any] | None:
+    if not path.exists():
+        return None
     try:
-        with open(RUNTIME_STATE_PATH, "r", encoding="utf-8") as f:
+        with open(path, "r", encoding="utf-8") as f:
             state = json.load(f)
         if not isinstance(state, dict):
             logger.warning("[RUNTIME_STATE] invalid state format: %s", type(state))
-            return _default_runtime_state()
+            return None
         state.setdefault("schema_version", SCHEMA_VERSION)
         state.setdefault("positions", {})
         state.setdefault("orders", {})
         memory = state.get("memory")
         if not isinstance(memory, dict):
             memory = {}
             state["memory"] = memory
         memory.setdefault("last_price", {})
         memory.setdefault("last_seen", {})
         memory.setdefault("last_strategy_id", {})
         state.setdefault("updated_at", None)
         lots = state.get("lots")
         if not isinstance(lots, list):
             lots = []
             state["lots"] = lots
         positions = state.get("positions")
         if isinstance(positions, dict):
             for sym, payload in list(positions.items()):
                 if not isinstance(payload, dict):
                     positions[sym] = {}
                     payload = positions[sym]
                 code_norm = _normalize_code(sym)
                 payload.setdefault("code", code_norm)
                 sid = _normalize_strategy_id(payload.get("strategy_id"))
                 payload["strategy_id"] = sid if sid is not None else UNMANAGED_STRATEGY_ID
                 payload["managed"] = _is_managed(payload.get("strategy_id"))
                 payload.setdefault("opened_at", payload.get("opened_at") or None)
                 payload.setdefault("updated_at", payload.get("updated_at") or None)
                 payload.setdefault("meta", {})
                 payload["position_key"] = f"{code_norm}:{payload.get('strategy_id')}"
         return state
     except Exception:
-        logger.exception("[RUNTIME_STATE] failed to load %s", RUNTIME_STATE_PATH)
-        return _default_runtime_state()
+        logger.exception("[RUNTIME_STATE] failed to load %s", path)
+        return None
+
+
+def load_state() -> Dict[str, Any]:
+    primary = _load_from_path(RUNTIME_STATE_PATH)
+    if primary is not None:
+        logger.info("[STATE][LOAD] path=%s source=primary", RUNTIME_STATE_PATH)
+        return primary
+    legacy = _load_from_path(LEGACY_RUNTIME_PATH)
+    if legacy is not None:
+        logger.info("[STATE][LOAD] path=%s source=legacy_runtime", LEGACY_RUNTIME_PATH)
+        return legacy
+    logger.info("[STATE][LOAD] path=%s source=default", RUNTIME_STATE_PATH)
+    return _default_runtime_state()
 
 
 def save_state(state: Dict[str, Any]) -> None:
     try:
         RUNTIME_STATE_DIR.mkdir(parents=True, exist_ok=True)
         payload = dict(state)
         payload.setdefault("schema_version", SCHEMA_VERSION)
         payload.setdefault("positions", {})
         payload.setdefault("orders", {})
         payload.setdefault("lots", [])
         payload.setdefault("memory", {"last_price": {}, "last_seen": {}, "last_strategy_id": {}})
         payload["updated_at"] = datetime.now(KST).isoformat()
         tmp_path = RUNTIME_STATE_PATH.with_name(f"{RUNTIME_STATE_PATH.name}.tmp")
         with open(tmp_path, "w", encoding="utf-8") as f:
             json.dump(payload, f, ensure_ascii=False, indent=2)
             f.flush()
             os.fsync(f.fileno())
         os.replace(tmp_path, RUNTIME_STATE_PATH)
         try:
             size = RUNTIME_STATE_PATH.stat().st_size
             logger.info("[STATE][SAVE] path=%s bytes=%d", RUNTIME_STATE_PATH, size)
         except Exception:
             logger.info("[STATE][SAVE] path=%s", RUNTIME_STATE_PATH)
-        try:
-            STATE_PATH.parent.mkdir(parents=True, exist_ok=True)
-            tmp_state_path = STATE_PATH.with_name(f"{STATE_PATH.name}.tmp")
-            with open(tmp_state_path, "w", encoding="utf-8") as f:
-                json.dump(payload, f, ensure_ascii=False, indent=2)
-                f.flush()
-                os.fsync(f.fileno())
-            os.replace(tmp_state_path, STATE_PATH)
-        except Exception:
-            logger.exception("[STATE][SAVE] failed to mirror %s", STATE_PATH)
+        if LEGACY_RUNTIME_PATH != RUNTIME_STATE_PATH:
+            try:
+                LEGACY_RUNTIME_DIR.mkdir(parents=True, exist_ok=True)
+                tmp_legacy_path = LEGACY_RUNTIME_PATH.with_name(f"{LEGACY_RUNTIME_PATH.name}.tmp")
+                with open(tmp_legacy_path, "w", encoding="utf-8") as f:
+                    json.dump(payload, f, ensure_ascii=False, indent=2)
+                    f.flush()
+                    os.fsync(f.fileno())
+                os.replace(tmp_legacy_path, LEGACY_RUNTIME_PATH)
+                logger.info("[STATE][SAVE] path=%s bytes=%d (legacy_mirror)", LEGACY_RUNTIME_PATH, LEGACY_RUNTIME_PATH.stat().st_size)
+            except Exception:
+                logger.exception("[STATE][SAVE] failed to mirror legacy path %s", LEGACY_RUNTIME_PATH)
     except Exception:
         logger.exception("[RUNTIME_STATE] failed to save %s", RUNTIME_STATE_PATH)
 
 
 def _ensure_lots(state: Dict[str, Any]) -> list[dict[str, Any]]:
     lots = state.get("lots")
     if isinstance(lots, dict):
         combined: list[dict[str, Any]] = []
         for bucket in lots.values():
             if isinstance(bucket, list):
                 combined.extend([lot for lot in bucket if isinstance(lot, dict)])
         lots = combined
         state["lots"] = lots
     if not isinstance(lots, list):
         lots = []
         state["lots"] = lots
     return lots
 
 
 def _generate_lot_id(code: str, ts: str | None = None) -> str:
     suffix = ts or datetime.now(KST).strftime("%Y%m%d%H%M%S%f")
     return f"{_LOT_ID_PREFIX}-{_normalize_code(code)}-{suffix}-{uuid.uuid4().hex[:6]}"
 
 
 def _norm_sid(value: Any) -> Any:
diff --git a/trader/trader.py b/trader/trader.py
index 9cb9441f123cb920c5ee993ef7ce789094069e5b..f8a583e949c3e31f34edc75b7cf3f1317bed7853 100644
--- a/trader/trader.py
+++ b/trader/trader.py
@@ -1,104 +1,134 @@
 # -*- coding: utf-8 -*-
 """Thin entrypoint orchestrating KOSPI core + KOSDAQ alpha engines."""
 from __future__ import annotations
 
 import logging
 import os
 
 from portfolio.portfolio_manager import PortfolioManager
 from trader.kis_wrapper import KisAPI
 from trader import state_store as runtime_state_store
 from trader.time_utils import is_trading_day, now_kst
 from trader.subject_flow import get_subject_flow_with_fallback  # noqa: F401 - exported for engines
 from trader.config import (
-    ACTIVE_STRATEGIES,
     ALLOW_ADOPT_UNMANAGED,
     DIAG_ENABLED,
     DIAGNOSTIC_FORCE_RUN,
     DIAGNOSTIC_MODE,
     DIAGNOSTIC_ONLY,
+    resolve_active_strategies,
 )
 
 logger = logging.getLogger(__name__)
 
 
+def _env_flag(name: str, default: bool = False) -> bool:
+    raw = os.getenv(name)
+    if raw is None:
+        return default
+    return raw.lower() in {"1", "true", "yes", "on"}
+
+
 def main() -> None:
     now = now_kst()
+    event_name = os.getenv("GITHUB_EVENT_NAME", "")
+    trading_day = is_trading_day(now)
+    active_strategies = resolve_active_strategies()
+    live_trading_enabled_env = _env_flag("LIVE_TRADING_ENABLED", True)
+    disable_live_env = _env_flag("DISABLE_LIVE_TRADING", False)
+    dry_run_env_raw = os.getenv("DRY_RUN", "")
+    dry_run_env = dry_run_env_raw.lower() in {"1", "true", "yes", "on"}
+    dry_run_reasons: list[str] = []
+    if dry_run_env:
+        dry_run_reasons.append(f"DRY_RUN env={dry_run_env_raw}")
+    if event_name in {"push", "pull_request"}:
+        dry_run_reasons.append(f"event={event_name} forces dry_run")
+    if disable_live_env:
+        dry_run_reasons.append("DISABLE_LIVE_TRADING env=true")
+    if not live_trading_enabled_env:
+        dry_run_reasons.append("LIVE_TRADING_ENABLED env=false")
     diag_enabled = bool(DIAG_ENABLED or DIAGNOSTIC_FORCE_RUN)
-    disable_live_env = os.getenv("DISABLE_LIVE_TRADING", "").lower()
+    if diag_enabled:
+        dry_run_reasons.append("diagnostic_mode")
+    dry_run = bool(dry_run_reasons)
+    dry_run_reason = ",".join(dry_run_reasons) if dry_run_reasons else "live"
+    if dry_run:
+        os.environ["DISABLE_LIVE_TRADING"] = "true"
     logger.info(
         "[DIAG][TRADER] now=%s trading_day=%s diag_enabled=%s force_run=%s only=%s mode=%s",
         now.isoformat(),
-        is_trading_day(now),
+        trading_day,
         DIAG_ENABLED,
         DIAGNOSTIC_FORCE_RUN,
         DIAGNOSTIC_ONLY,
         DIAGNOSTIC_MODE,
     )
     logger.info(
-        "[TRADER][STARTUP] active_strategies=%s live_trading_enabled_env=%s allow_adopt_unmanaged=%s",
-        sorted(ACTIVE_STRATEGIES),
-        disable_live_env not in {"1", "true", "yes", "on"},
+        "[TRADER][STARTUP] event=%s trading_day=%s dry_run=%s dry_run_reason=%s live_trading_enabled=%s active_strategies=%s allow_adopt_unmanaged=%s engine_disabled_reason=%s",
+        event_name or "unknown",
+        trading_day,
+        dry_run,
+        dry_run_reason,
+        live_trading_enabled_env and not dry_run and not disable_live_env,
+        sorted(active_strategies),
         ALLOW_ADOPT_UNMANAGED,
+        dry_run_reason if dry_run else ("DISABLE_LIVE_TRADING" if disable_live_env else "enabled"),
     )
-    if diag_enabled:
-        os.environ["DISABLE_LIVE_TRADING"] = "true"
-        logger.info(
-            "[DIAG][TRADER] forcing DISABLE_LIVE_TRADING=true (diag_enabled=%s)",
-            diag_enabled,
-        )
-    trading_day = is_trading_day(now)
     if (not trading_day) and (not (DIAG_ENABLED and DIAGNOSTIC_FORCE_RUN)):
-        logger.warning("[TRADER] ë¹„ê±°ë˜ì¼(%s) â†’ ì¦‰ì‹œ ì¢…ë£Œ", now.date())
+        logger.warning("[TRADER] ë¹„ê±°ë˜ì¼(%s) â†’ ì¦‰ì‹œ ì¢…ë£Œ dry_run=%s reason=%s", now.date(), dry_run, dry_run_reason)
         return
     if (not trading_day) and diag_enabled:
         logger.warning(
             "[DIAG][TRADER] non-trading-day(%s) but running diagnostics (only=%s force_run=%s)",
             now.date(),
             DIAGNOSTIC_ONLY,
             DIAGNOSTIC_FORCE_RUN,
         )
     runtime_state = {}
     kis: KisAPI | None = None
     try:
         runtime_state = runtime_state_store.load_state()
         kis = KisAPI()
         balance = kis.get_balance()
         runtime_state = runtime_state_store.reconcile_with_kis_balance(
             runtime_state,
             balance,
-            active_strategies=ACTIVE_STRATEGIES,
+            active_strategies=active_strategies,
         )
         runtime_state_store.save_state(runtime_state)
         logger.info("[TRADER] runtime state reconciled")
     except Exception:
         logger.exception("[TRADER] runtime state reconcile failed")
         runtime_state = runtime_state or runtime_state_store.load_state()
 
     if DIAGNOSTIC_ONLY:
         from trader.diagnostics_runner import run_diagnostics
 
         run_diagnostics(kis=kis, runtime_state=runtime_state, selected_by_market=None)
         logger.info("[DIAG][TRADER] diagnostic_only complete")
         return
 
     diag_result = None
     if DIAGNOSTIC_MODE:
         try:
             from trader.diagnostics_runner import run_diagnostics
 
             diag_result = run_diagnostics(
                 kis=kis, runtime_state=runtime_state, selected_by_market=None
             )
         except Exception:
             logger.exception("[DIAG][TRADER] diagnostics run failed")
 
-    mgr = PortfolioManager()
+    mgr = PortfolioManager(active_strategies=active_strategies)
     result = mgr.run_once()
     if isinstance(result, dict) and diag_result is not None:
         result.setdefault("diagnostics", diag_result)
+    if isinstance(result, dict):
+        result.setdefault("active_strategies", sorted(active_strategies))
+        result.setdefault("dry_run", dry_run)
+        result.setdefault("dry_run_reason", dry_run_reason)
     logger.info("[TRADER] cycle complete %s", result)
 
 
 if __name__ == "__main__":
     main()
