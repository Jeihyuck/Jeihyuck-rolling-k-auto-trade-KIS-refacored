diff --git a/.github/workflows/trade-monitor.yml b/.github/workflows/trade-monitor.yml
index 94810b40a1ad862ed60105851c2a7a85d0d71fff..49faebeee1272d5f68e014ab0202635882f37725 100644
--- a/.github/workflows/trade-monitor.yml
+++ b/.github/workflows/trade-monitor.yml
@@ -101,50 +101,68 @@ jobs:
       # í•œêµ­íˆ¬ìì¦ê¶Œ ì—‘ì…€ ê¸°ì¤€ ì£¼ì‹ë‹¹ì¼ë¶„ë´‰ì¡°íšŒ TR_ID (FHKST03010200)
       KIS_TR_ID_INTRADAY_CHART: "FHKST03010200"
       KIS_TR_ID_INTRADAY_CHART_REAL: "FHKST03010200"
 
       # === FastAPI ë¦¬ë°¸ëŸ°ì‹± ì„œë²„(ì„ ì • í•„í„°) ===
       MIN_TRADES: "5"
       MAX_MDD_PCT: "30"
       MIN_WINRATE: "50"
       MIN_CUMRET: "2"
       TOP_K_LIMIT: "20"
       TOTAL_CAPITAL: "10000000"
       MIN_QTY_PER_TICKET: "1"
       K_MIN: "0.1"
       K_MAX: "0.9"
       K_STEP: "0.1"
       ALLOW_AFTER_HOURS: "0"
       REBALANCE_OUT_DIR: "rebalance_results"
 
     steps:
       - uses: actions/checkout@v4
         with:
           fetch-depth: 0
           persist-credentials: true
           token: ${{ secrets.GITHUB_TOKEN }}
 
+      - name: Restore state cache (fallback only)
+        uses: actions/cache/restore@v4
+        with:
+          path: |
+            bot_state/state.json
+            trader/state/state.json
+          key: trader-state-${{ github.ref_name }}
+          restore-keys: |
+            trader-state-${{ github.ref_name }}-
+      - name: Save state cache (dispatch only)
+        if: github.event_name == 'workflow_dispatch'
+        uses: actions/cache/save@v4
+        with:
+          path: |
+            bot_state/state.json
+            trader/state/state.json
+          key: trader-state-${{ github.ref_name }}
+
       - name: Set git identity
         run: |
           git config user.name "trade-bot"
           git config user.email "trade-bot@users.noreply.github.com"
 
       - uses: actions/setup-python@v5
         with:
           python-version: "3.11"
 
       - name: Ensure state scripts executable
         if: github.event_name != 'pull_request'
         run: |
           chmod +x scripts/state_pull_plain.sh scripts/state_push_plain.sh || true
 
       - name: Pull state (plain)
         if: github.event_name != 'pull_request'
         run: |
           bash scripts/state_pull_plain.sh
 
       - name: Dependencies ì„¤ì¹˜
         run: |
           python -m pip install --upgrade pip
           pip install -r requirements.txt
 
       - name: Ledger smoke test
diff --git a/scripts/state_pull_plain.sh b/scripts/state_pull_plain.sh
index 270f53b534f94f6eb5b3cefa4dfea67810046f80..cff9153180673aaab6215b42edafb0be0c073cac 100755
--- a/scripts/state_pull_plain.sh
+++ b/scripts/state_pull_plain.sh
@@ -1,23 +1,36 @@
 #!/usr/bin/env bash
 set -euo pipefail
 
 STATE_DIR="bot_state"
 JSON_PATH="${STATE_DIR}/state.json"
 REMOTE_PATH="${STATE_DIR}/state.json"
 DEFAULT_STATE='{"version": 1, "lots": [], "updated_at": null}'
+POS_STATE_DIR="trader/state"
+POS_JSON_PATH="${POS_STATE_DIR}/state.json"
+POS_REMOTE_PATH="${POS_STATE_DIR}/state.json"
+DEFAULT_POS_STATE='{"schema_version": 2, "updated_at": null, "positions": {}, "memory": {"last_price": {}, "last_seen": {}}}'
 
 mkdir -p "${STATE_DIR}"
+mkdir -p "${POS_STATE_DIR}"
 
 if git ls-remote --exit-code --heads origin bot-state >/dev/null 2>&1; then
   git fetch --no-tags origin bot-state:refs/remotes/origin/bot-state >/dev/null 2>&1 || true
   if git cat-file -e "origin/bot-state:${REMOTE_PATH}" 2>/dev/null; then
     git show "origin/bot-state:${REMOTE_PATH}" > "${JSON_PATH}"
     echo "[STATE] Pulled ${REMOTE_PATH} from bot-state branch."
   else
     echo "[STATE] WARN: state.json not found in bot-state branch. Initializing."
     echo "${DEFAULT_STATE}" > "${JSON_PATH}"
   fi
+  if git cat-file -e "origin/bot-state:${POS_REMOTE_PATH}" 2>/dev/null; then
+    git show "origin/bot-state:${POS_REMOTE_PATH}" > "${POS_JSON_PATH}"
+    echo "[STATE] Pulled ${POS_REMOTE_PATH} from bot-state branch."
+  else
+    echo "[STATE] WARN: position state not found in bot-state branch. Initializing."
+    echo "${DEFAULT_POS_STATE}" > "${POS_JSON_PATH}"
+  fi
 else
   echo "[STATE] WARN: bot-state branch not found. Initializing."
   echo "${DEFAULT_STATE}" > "${JSON_PATH}"
+  echo "${DEFAULT_POS_STATE}" > "${POS_JSON_PATH}"
 fi
diff --git a/scripts/state_push_plain.sh b/scripts/state_push_plain.sh
index bce0d96ce6a5afadb4254cfc2afe07eaa3b7c93b..6a888bf3c538b06306a5665065d01db35e057019 100755
--- a/scripts/state_push_plain.sh
+++ b/scripts/state_push_plain.sh
@@ -1,39 +1,51 @@
 #!/usr/bin/env bash
 set -euo pipefail
 
 STATE_DIR="bot_state"
 JSON_PATH="${STATE_DIR}/state.json"
+POS_STATE_DIR="trader/state"
+POS_JSON_PATH="${POS_STATE_DIR}/state.json"
 
 if [[ ! -f "${JSON_PATH}" ]]; then
   echo "[STATE] WARN: ${JSON_PATH} not found. Skipping."
   exit 0
 fi
+if [[ ! -f "${POS_JSON_PATH}" ]]; then
+  echo "[STATE] WARN: ${POS_JSON_PATH} not found. Skipping."
+  exit 0
+fi
 
 tmp_state="$(mktemp)"
-trap 'rm -f "${tmp_state}"' EXIT
+tmp_pos_state="$(mktemp)"
+trap 'rm -f "${tmp_state}" "${tmp_pos_state}"' EXIT
 cp -f "${JSON_PATH}" "${tmp_state}"
+cp -f "${POS_JSON_PATH}" "${tmp_pos_state}"
 
 # IMPORTANT: avoid "untracked would be overwritten by checkout"
 rm -f "${JSON_PATH}" || true
+rm -f "${POS_JSON_PATH}" || true
 
 if git ls-remote --exit-code --heads origin bot-state >/dev/null 2>&1; then
   git fetch --no-tags origin bot-state:refs/remotes/origin/bot-state >/dev/null 2>&1 || true
   git checkout -B bot-state origin/bot-state
 else
   git checkout --orphan bot-state
   git rm -r --cached . >/dev/null 2>&1 || true
 fi
 
 mkdir -p "${STATE_DIR}"
 cp -f "${tmp_state}" "${JSON_PATH}"
+mkdir -p "${POS_STATE_DIR}"
+cp -f "${tmp_pos_state}" "${POS_JSON_PATH}"
 
 git add -f "${JSON_PATH}"
+git add -f "${POS_JSON_PATH}"
 git status --porcelain
 if git diff --cached --quiet; then
   echo "[STATE] No changes to commit."
   exit 0
 fi
 
 git commit -m "Update bot state (plain) [skip ci]"
 git push --force-with-lease origin HEAD:bot-state
 echo "[STATE] Pushed ${JSON_PATH} to bot-state branch."
diff --git a/trader/config.py b/trader/config.py
index f1902d337e6cc3bdc7e3b88eb95f07653f76c3ea..0b854427d77f1c1ede90f3cf7928bf3711ec523b 100644
--- a/trader/config.py
+++ b/trader/config.py
@@ -68,125 +68,147 @@ CONFIG = {
     "PULLBACK_MAX_BUYS_PER_DAY": "5",      # ëˆŒë¦¼ëª© í•˜ë£¨ ìµœëŒ€ ì‹ ê·œ ë§¤ìˆ˜ ê±´ìˆ˜
     # ì±”í”¼ì–¸ í›„ë³´ í•„í„°
     "CHAMPION_MIN_TRADES": "5",            # ìµœì†Œ ê±°ë˜ìˆ˜
     "CHAMPION_MIN_WINRATE": "45.0",        # ìµœì†Œ ìŠ¹ë¥ (%)
     "CHAMPION_MAX_MDD": "30.0",            # ìµœëŒ€ í—ˆìš© MDD(%)
     "CHAMPION_MIN_SHARPE": "0.0",          # ìµœì†Œ ìƒ¤í”„ ë¹„ìœ¨
     "NEUTRAL_ENTRY_SCALE": "0.6",          # ì¤‘ë¦½ ë ˆì§ ì‹ ê·œ/ì¬ì§„ì… ìŠ¤ì¼€ì¼ë§ ë¹„ìœ¨
     # ê¸°íƒ€
     "MARKET_DATA_WHEN_CLOSED": "false",
     "FORCE_WEEKLY_REBALANCE": "0",
     # NEW: 1ë¶„ë´‰ VWAP ëª¨ë©˜í…€ íŒŒë¼ë¯¸í„°
     "MOM_FAST": "5",        # 1ë¶„ë´‰ fast MA ê¸¸ì´
     "MOM_SLOW": "20",       # 1ë¶„ë´‰ slow MA ê¸¸ì´
     "MOM_TH_PCT": "0.5",    # fast/slow ê´´ë¦¬ ì„ê³„ê°’(%) â€“ 0.5% ì´ìƒì´ë©´ ê°•ì„¸ë¡œ ë³¸ë‹¤
     # Subject flow gate ê¸°ë³¸ê°’
     "MIN_SMART_MONEY_RATIO_KOSPI": "0.02",
     "MIN_SMART_MONEY_RATIO_KOSDAQ": "0.03",
     "SUBJECT_FLOW_TIMEOUT_SEC": "1.2",
     "SUBJECT_FLOW_RETRY": "1",
     "SUBJECT_FLOW_CACHE_TTL_SEC": "60",
     "SUBJECT_FLOW_FAIL_POLICY": "CACHE",
     "SUBJECT_FLOW_EMPTY_POLICY": "TREAT_AS_FAIL",
     "SUBJECT_FLOW_DEGRADED_TURNOVER_MULT": "1.5",
     "SUBJECT_FLOW_DEGRADED_OB_ADD": "10",
     "SUBJECT_FLOW_MAX_CALLS_PER_RUN": "200",
+    "EMERGENCY_GLOBAL_SELL": "false",
+    "STRATEGY_REDUCTION_PRIORITY": "5,4,3,2,1",
 }
 
 
 def _cfg(key: str) -> str:
     """í™˜ê²½ë³€ìˆ˜ > CONFIG ê¸°ë³¸ê°’"""
     return os.getenv(key, CONFIG.get(key, ""))
 
 
 logging.basicConfig(level=logging.INFO)
 logger = logging.getLogger(__name__)
 
 LOG_DIR = Path(__file__).parent / "logs"
 LOG_DIR.mkdir(exist_ok=True)
 STATE_FILE = Path(__file__).parent / "trade_state.json"  # legacy; position state uses STATE_PATH
 STATE_DIR = Path(__file__).parent / "state"
 STATE_PATH = STATE_DIR / "state.json"
 STATE_DIR.mkdir(parents=True, exist_ok=True)
 
 # ì¢…ëª©ë³„ ì‹œì¥ì½”ë“œ ê³ ì • ë§µ (ì‹¤ì „ì—ì„œëŠ” ë§ˆìŠ¤í„°í…Œì´ë¸” ë¡œë“œë¡œ ëŒ€ì²´ ê¶Œì¥)
 MARKET_MAP: Dict[str, str] = {
     # ì˜ˆì‹œ: '145020': 'J', '347850': 'J', '257720': 'U', '178320': 'J', '348370': 'U'
 }
 
 # ë°ì´í„° ì—†ìŒ 1ì°¨ ê°ì§€ ìƒíƒœ ì €ì¥(ì—°ì† DATA_EMPTY í™•ì¸ìš©)
 EXCLUDE_STATE: Dict[str, Dict[str, bool]] = {}
 
 KST = ZoneInfo("Asia/Seoul")
 
 SELL_FORCE_TIME_STR = _cfg("SELL_FORCE_TIME").strip()
 SELL_ALL_BALANCES_AT_CUTOFF = _cfg("SELL_ALL_BALANCES_AT_CUTOFF").lower() == "true"
+EMERGENCY_GLOBAL_SELL = _cfg("EMERGENCY_GLOBAL_SELL").lower() in ("1", "true", "yes")
 RATE_SLEEP_SEC = float(_cfg("API_RATE_SLEEP_SEC"))
 FORCE_SELL_PASSES_CUTOFF = int(_cfg("FORCE_SELL_PASSES_CUTOFF"))
 FORCE_SELL_PASSES_CLOSE = int(_cfg("FORCE_SELL_PASSES_CLOSE"))
 FORCE_SELL_BLOCKED_LOTS = _cfg("FORCE_SELL_BLOCKED_LOTS").lower() in ("1", "true", "yes")
 PARTIAL1 = float(_cfg("PARTIAL1"))
 PARTIAL2 = float(_cfg("PARTIAL2"))
 TRAIL_PCT = float(_cfg("TRAIL_PCT"))
 FAST_STOP = float(_cfg("FAST_STOP"))
 ATR_STOP = float(_cfg("ATR_STOP"))
 TIME_STOP_HHMM = _cfg("TIME_STOP_HHMM")
 DEFAULT_PROFIT_PCT = float(_cfg("DEFAULT_PROFIT_PCT"))
 DEFAULT_LOSS_PCT = float(_cfg("DEFAULT_LOSS_PCT"))
 DAILY_CAPITAL = int(_cfg("DAILY_CAPITAL"))
 CAP_CAP = float(_cfg("CAP_CAP"))
 SLIPPAGE_LIMIT_PCT = float(_cfg("SLIPPAGE_LIMIT_PCT"))
 SLIPPAGE_ENTER_GUARD_PCT = float(_cfg("SLIPPAGE_ENTER_GUARD_PCT"))
 VWAP_TOL = float(_cfg("VWAP_TOL"))  # ğŸ”¸ VWAP í—ˆìš© ì˜¤ì°¨(ì˜ˆ: 0.003 = -0.3%ê¹Œì§€ í—ˆìš©)
 W_MAX_ONE = float(_cfg("W_MAX_ONE"))
 W_MIN_ONE = float(_cfg("W_MIN_ONE"))
 ALLOW_PYRAMID = (_cfg("ALLOW_PYRAMID") or "false").lower() == "true"
 REBALANCE_ANCHOR = _cfg("REBALANCE_ANCHOR")
 WEEKLY_ANCHOR_REF = _cfg("WEEKLY_ANCHOR_REF").lower()
 MOMENTUM_OVERRIDES_FORCE_SELL = _cfg("MOMENTUM_OVERRIDES_FORCE_SELL").lower() == "true"
 BASE_QTY_MODE = (_cfg("BASE_QTY_MODE") or "initial").lower()
 if BASE_QTY_MODE not in {"initial", "current"}:
     logging.getLogger(__name__).warning(
         f"[CONFIG] BASE_QTY_MODE={BASE_QTY_MODE} ì§€ì› ì•ˆ í•¨ â†’ initialë¡œ ëŒ€ì²´"
     )
     BASE_QTY_MODE = "initial"
 
 # NEW: 1ë¶„ë´‰ ëª¨ë©˜í…€ íŒŒë¼ë¯¸í„°
 MOM_FAST = int(_cfg("MOM_FAST") or "5")
 MOM_SLOW = int(_cfg("MOM_SLOW") or "20")
 MOM_TH_PCT = float(_cfg("MOM_TH_PCT") or "0.5")
 # subject flow
 MIN_SMART_MONEY_RATIO_KOSPI = float(_cfg("MIN_SMART_MONEY_RATIO_KOSPI") or "0.02")
 MIN_SMART_MONEY_RATIO_KOSDAQ = float(_cfg("MIN_SMART_MONEY_RATIO_KOSDAQ") or "0.03")
 SUBJECT_FLOW_TIMEOUT_SEC = float(_cfg("SUBJECT_FLOW_TIMEOUT_SEC") or "1.2")
 SUBJECT_FLOW_RETRY = int(_cfg("SUBJECT_FLOW_RETRY") or "1")
 SUBJECT_FLOW_CACHE_TTL_SEC = float(_cfg("SUBJECT_FLOW_CACHE_TTL_SEC") or "60")
 SUBJECT_FLOW_FAIL_POLICY = (_cfg("SUBJECT_FLOW_FAIL_POLICY") or "CACHE").upper()
 SUBJECT_FLOW_EMPTY_POLICY = (_cfg("SUBJECT_FLOW_EMPTY_POLICY") or "TREAT_AS_FAIL").upper()
 SUBJECT_FLOW_DEGRADED_TURNOVER_MULT = float(_cfg("SUBJECT_FLOW_DEGRADED_TURNOVER_MULT") or "1.5")
 SUBJECT_FLOW_DEGRADED_OB_ADD = float(_cfg("SUBJECT_FLOW_DEGRADED_OB_ADD") or "10")
 SUBJECT_FLOW_MAX_CALLS_PER_RUN = int(_cfg("SUBJECT_FLOW_MAX_CALLS_PER_RUN") or "200")
+# ì „ëµë³„ ë ˆì§ ì¶•ì†Œ ìš°ì„ ìˆœìœ„
+def _parse_strategy_priority(raw: str) -> list[int]:
+    priorities: list[int] = []
+    for item in raw.split(","):
+        item = item.strip()
+        if not item:
+            continue
+        try:
+            value = int(item)
+        except ValueError:
+            continue
+        if 1 <= value <= 5 and value not in priorities:
+            priorities.append(value)
+    return priorities or [5, 4, 3, 2, 1]
+
+
+STRATEGY_REDUCTION_PRIORITY = _parse_strategy_priority(
+    _cfg("STRATEGY_REDUCTION_PRIORITY")
+)
 # ì‹ ê³ ê°€ â†’ 3ì¼ ëˆŒë¦¼ â†’ ë°˜ë“± í™•ì¸ í›„ ë§¤ìˆ˜ íŒŒë¼ë¯¸í„°
 USE_PULLBACK_ENTRY = _cfg("USE_PULLBACK_ENTRY").lower() != "false"
 PULLBACK_LOOKBACK = int(_cfg("PULLBACK_LOOKBACK") or "60")
 PULLBACK_DAYS = int(_cfg("PULLBACK_DAYS") or "3")
 PULLBACK_REVERSAL_BUFFER_PCT = float(_cfg("PULLBACK_REVERSAL_BUFFER_PCT") or "0.2")
 PULLBACK_TOPN = int(_cfg("PULLBACK_TOPN") or "50")
 PULLBACK_UNIT_WEIGHT = float(_cfg("PULLBACK_UNIT_WEIGHT") or "0.03")
 PULLBACK_MAX_BUYS_PER_DAY = int(_cfg("PULLBACK_MAX_BUYS_PER_DAY") or "5")
 CHAMPION_MIN_TRADES = int(_cfg("CHAMPION_MIN_TRADES") or "5")
 CHAMPION_MIN_WINRATE = float(_cfg("CHAMPION_MIN_WINRATE") or "45.0")
 CHAMPION_MAX_MDD = float(_cfg("CHAMPION_MAX_MDD") or "30.0")
 CHAMPION_MIN_SHARPE = float(_cfg("CHAMPION_MIN_SHARPE") or "0.0")
 
 # ì±”í”¼ì–¸ ë“±ê¸‰ & GOOD/BAD íƒ€ì  íŒë³„ íŒŒë¼ë¯¸í„°
 CHAMPION_A_RULES = {
     "min_trades": 30,
     "min_cumret_pct": 40.0,
     "max_mdd_pct": 25.0,
     "min_win_pct": 50.0,
     "min_sharpe": 1.2,
     "min_turnover": 3_000_000_000,  # 30ì–µ
 }
 
 GOOD_ENTRY_PULLBACK_RANGE = (5.0, 15.0)  # ì‹ ê³ ê°€ ëŒ€ë¹„ ëˆŒë¦¼í­(%): ìµœì†Œ~ìµœëŒ€
 GOOD_ENTRY_MA20_RANGE = (1.0, 1.15)  # í˜„ì¬ê°€/20MA í—ˆìš© êµ¬ê°„
diff --git a/trader/ctx_schema.py b/trader/ctx_schema.py
new file mode 100644
index 0000000000000000000000000000000000000000..c246e69fdad346238cf9fea4873765ef70b89a9e
--- /dev/null
+++ b/trader/ctx_schema.py
@@ -0,0 +1,38 @@
+from __future__ import annotations
+
+from typing import Any, Dict
+
+
+def normalize_daily_ctx(payload: Dict[str, Any] | None) -> Dict[str, Any]:
+    payload = dict(payload or {})
+    payload.setdefault("setup_flag", False)
+    payload.setdefault("setup_ok", bool(payload.get("setup_flag")))
+    for key in (
+        "ma5",
+        "ma10",
+        "ma20",
+        "atr",
+        "recent_high_20",
+        "pullback_depth_pct",
+        "distance_to_peak",
+        "ma20_ratio",
+        "ma20_risk",
+        "current_price",
+        "peak_price",
+        "prev_close",
+    ):
+        payload.setdefault(key, None)
+    payload.setdefault("max_pullback_pct", None)
+    payload.setdefault("strong_trend", False)
+    return payload
+
+
+def normalize_intraday_ctx(payload: Dict[str, Any] | None) -> Dict[str, Any]:
+    payload = dict(payload or {})
+    payload.setdefault("vwap", None)
+    payload.setdefault("below_vwap_ratio", None)
+    payload.setdefault("prev_high_retest", False)
+    payload.setdefault("range_break", False)
+    payload.setdefault("vwap_reclaim", False)
+    payload.setdefault("volume_spike", False)
+    return payload
diff --git a/trader/execution.py b/trader/execution.py
index f2b8ee0ad24221b98ef794f21c9671d80fdf87d6..7a281e4f3f22c93c42a16c0191ccb1321f493bbd 100644
--- a/trader/execution.py
+++ b/trader/execution.py
@@ -98,132 +98,181 @@ def _normalize_flags(payload: Dict[str, Any] | None) -> Dict[str, Any]:
     }
 
 
 def record_entry_state(
     *,
     state: Dict[str, Any],
     code: str,
     qty: int,
     avg_price: float,
     strategy_id: Any,
     engine: str,
     entry_reason: str,
     order_type: str | None,
     best_k: Any,
     tgt_px: Any,
     gap_pct_at_entry: Any,
     meta: Dict[str, Any] | None = None,
     flags: Dict[str, Any] | None = None,
     entry_time: str | None = None,
 ) -> Dict[str, Any]:
     code_key = str(code).zfill(6)
     sid_key = str(strategy_id)
     pos = state.setdefault("positions", {}).setdefault(
         code_key,
         {
-            "entries": {},
-            "flags": {"bear_s1_done": False, "bear_s2_done": False},
-            "broker_qty": None,
-            "broker_avg_price": None,
-            "miss_count": 0,
+            "strategies": {},
         },
     )
-    entries = pos.setdefault("entries", {})
-    entries[sid_key] = {
-        "qty": int(qty),
-        "avg_price": float(avg_price),
-        "entry": _normalize_entry_meta(
-            code=str(code),
-            strategy_id=strategy_id,
-            engine=engine,
-            entry_reason=entry_reason,
-            order_type=order_type,
-            best_k=best_k,
-            tgt_px=tgt_px,
-            gap_pct_at_entry=gap_pct_at_entry,
-            entry_time=entry_time,
-        ),
-        "meta": _normalize_meta(meta),
-    }
-    if flags:
-        update_position_flags(state, code, flags)
+    strategies = pos.setdefault("strategies", {})
+    existing = strategies.get(sid_key)
+    if not isinstance(existing, dict):
+        entry_flags = {
+            "bear_s1_done": False,
+            "bear_s2_done": False,
+            "sold_p1": False,
+            "sold_p2": False,
+        }
+        if flags:
+            entry_flags.update(
+                {k: bool(flags.get(k)) for k in entry_flags.keys() if k in flags}
+            )
+        entry_meta = _normalize_meta(meta)
+        entry_meta.setdefault("high", float(avg_price))
+        entry_meta["high"] = max(float(entry_meta.get("high") or 0.0), float(avg_price))
+        strategies[sid_key] = {
+            "qty": int(qty),
+            "avg_price": float(avg_price),
+            "entry": _normalize_entry_meta(
+                code=str(code),
+                strategy_id=strategy_id,
+                engine=engine,
+                entry_reason=entry_reason,
+                order_type=order_type,
+                best_k=best_k,
+                tgt_px=tgt_px,
+                gap_pct_at_entry=gap_pct_at_entry,
+                entry_time=entry_time,
+            ),
+            "meta": entry_meta,
+            "flags": entry_flags,
+        }
+    else:
+        prev_qty = int(existing.get("qty") or 0)
+        add_qty = int(qty)
+        total_qty = prev_qty + add_qty
+        prev_avg = float(existing.get("avg_price") or 0.0)
+        new_avg = (
+            (prev_avg * prev_qty + float(avg_price) * add_qty) / total_qty
+            if total_qty > 0
+            else 0.0
+        )
+        existing["qty"] = int(total_qty)
+        existing["avg_price"] = float(new_avg)
+        entry = existing.setdefault("entry", {})
+        entry_time_value = entry_time or datetime.now(KST).isoformat()
+        entry["last_entry_time"] = entry_time_value
+        entry["strategy_id"] = entry.get("strategy_id") or str(strategy_id)
+        entry_meta = existing.setdefault("meta", {})
+        if not entry_meta.get("high") or float(entry_meta.get("high") or 0.0) <= 0:
+            entry_meta["high"] = float(new_avg)
+        entry_meta["high"] = max(float(entry_meta.get("high") or 0.0), float(new_avg))
+        entry_flags = existing.setdefault(
+            "flags",
+            {
+                "bear_s1_done": False,
+                "bear_s2_done": False,
+                "sold_p1": False,
+                "sold_p2": False,
+            },
+        )
+        if flags:
+            for key, value in flags.items():
+                if key in entry_flags:
+                    entry_flags[key] = bool(value)
     logger.info(
         "[ENTRY] code=%s strategy=%s engine=%s best_k=%s tgt_px=%s saved_state=OK",
         code_key,
         strategy_id,
         engine,
         best_k,
         tgt_px,
     )
     return state
 
 
 def update_position_meta(
     state: Dict[str, Any],
     code: str,
     strategy_id: Any,
     meta_updates: Dict[str, Any] | None = None,
 ) -> Dict[str, Any]:
     code_key = str(code).zfill(6)
     sid_key = str(strategy_id)
     pos = state.get("positions", {}).get(code_key)
     if not isinstance(pos, dict):
         return state
-    entries = pos.get("entries", {})
-    entry = entries.get(sid_key)
+    strategies = pos.get("strategies", {})
+    entry = strategies.get(sid_key)
     if not isinstance(entry, dict):
         return state
     meta = entry.setdefault(
         "meta",
         {
             "pullback_peak_price": None,
             "pullback_reversal_price": None,
             "pullback_reason": None,
         },
     )
     if meta_updates:
         for key in ("pullback_peak_price", "pullback_reversal_price", "pullback_reason"):
             if key in meta_updates:
                 meta[key] = meta_updates.get(key)
     return state
 
 
 def update_position_flags(
     state: Dict[str, Any],
     code: str,
+    strategy_id: Any,
     flag_updates: Dict[str, Any],
 ) -> Dict[str, Any]:
+    assert strategy_id is not None, "strategy_id required for update_position_flags"
     code_key = str(code).zfill(6)
     pos = state.get("positions", {}).get(code_key)
     if not isinstance(pos, dict):
         return state
-    flags = pos.setdefault(
+    strategies = pos.setdefault("strategies", {})
+    entry = strategies.get(str(strategy_id))
+    if not isinstance(entry, dict):
+        return state
+    flags = entry.setdefault(
         "flags",
-        {"bear_s1_done": False, "bear_s2_done": False},
+        {"bear_s1_done": False, "bear_s2_done": False, "sold_p1": False, "sold_p2": False},
     )
     before_flags = dict(flags)
-    for key in ("bear_s1_done", "bear_s2_done"):
+    for key in ("bear_s1_done", "bear_s2_done", "sold_p1", "sold_p2"):
         if key in flag_updates:
             flags[key] = bool(flag_updates.get(key))
     logger.info(
         "[FLAGS] code=%s flags_before=%s flags_after=%s",
         code_key,
         before_flags,
         flags,
     )
     return state
 
 def fetch_rebalancing_targets(date: str) -> list[dict[str, Any]]:
     REBALANCE_API_URL = f"http://localhost:8000/rebalance/run/{date}?force_order=true"
     response = requests.post(REBALANCE_API_URL)
     logger.info(f"[ğŸ›°ï¸ ë¦¬ë°¸ëŸ°ì‹± API ì „ì²´ ì‘ë‹µ]: {response.text}")
     if response.status_code == 200:
         data = response.json()
         selected = data.get("selected") or data.get("selected_stocks") or []
         logger.info(f"[ğŸ¯ ë¦¬ë°¸ëŸ°ì‹± ì¢…ëª©]: {selected}")
         try:
             champion = selected[0] if selected else None
             log_champion_and_regime(logger, champion, REGIME_STATE, context="rebalance_api")
         except Exception as e:
             logger.exception(f"[VWAP_CHAMPION_LOG_ERROR] {e}")
         return selected
     raise Exception(f"ë¦¬ë°¸ëŸ°ì‹± API í˜¸ì¶œ ì‹¤íŒ¨: {response.text}")
@@ -1034,82 +1083,82 @@ def log_champion_and_regime(
             context,
             code,
             name,
             detail,
         )
 
     # 2) ë ˆì§ ìƒíƒœ ìƒì„¸ ë¡œê·¸
     if regime_state:
         logger.info(
             "[VWAP_REGIME] %s | %s | mode=%s, score=%s, kosdaq_ret5=%s, drop_stage=%s, since=%s, comment=%s",
             now_str,
             context,
             regime_state.get("mode"),
             regime_state.get("score"),
             regime_state.get("kosdaq_ret5"),
             regime_state.get("bear_stage"),
             regime_state.get("since"),
             regime_state.get("comment"),
         )
 
 def _adaptive_exit(
     kis: KisAPI,
     code: str,
     pos: Dict[str, Any],
     regime_mode: str = "neutral",
-) -> Tuple[Optional[str], Optional[float], Optional[Any], Optional[int]]:
+) -> Tuple[Optional[str], Optional[int]]:
     """
     ë ˆì§(ê°•ì„¸/ì•½ì„¸/ì¤‘ë¦½) + 1ë¶„ë´‰ ëª¨ë©˜í…€ ê¸°ë°˜
     - ë¶€ë¶„ ìµì ˆ(1ì°¨/2ì°¨)
     - íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘
     - ì†ì ˆ
     ì„ ë™ì ìœ¼ë¡œ ì ìš©í•˜ëŠ” ë§¤ë„ ì—”ì§„.
     í•œ ë²ˆ í˜¸ì¶œì—ì„œ "í•œ ë²ˆì˜ ë§¤ë„"ë§Œ ì‹¤í–‰í•˜ê³ , ê·¸ ê²°ê³¼ë§Œ ë°˜í™˜í•œë‹¤.
     """
     now = datetime.now(KST)
     reason: Optional[str] = None
 
     # í˜„ì¬ê°€ ì¡°íšŒ
     try:
         cur = _safe_get_price(kis, code)
         if cur is None or cur <= 0:
             logger.warning(f"[EXIT-FAIL] {code} í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨")
-            return None, None, None, None
+            return None, None
     except Exception as e:
         logger.error(f"[EXIT-FAIL] {code} í˜„ì¬ê°€ ì¡°íšŒ ì˜ˆì™¸: {e}")
-        return None, None, None, None
+        return None, None
 
     # === ìƒíƒœ/ê¸°ì´ˆ ê°’ ===
     qty = _to_int(pos.get("qty"), 0)
     if qty <= 0:
         logger.warning(f"[EXIT-FAIL] {code} qty<=0")
-        return None, None, None, None
+        return None, None
 
     buy_price = float(pos.get("buy_price", 0.0)) or 0.0
     if buy_price <= 0:
         logger.warning(f"[EXIT-FAIL] {code} buy_price<=0")
-        return None, None, None, None
+        return None, None
 
     # ìµœê³ ê°€(high) ê°±ì‹ 
     pos["high"] = max(float(pos.get("high", cur)), float(cur))
     max_price = float(pos["high"])
 
     # í˜„ì¬ ëˆ„ì  ìˆ˜ìµë¥ 
     pnl_pct = (cur - buy_price) / buy_price * 100.0
 
     # ë¶€ë¶„ ìµì ˆ í”Œë˜ê·¸ & ë¹„ìœ¨
     sold_p1 = bool(pos.get("sold_p1", False))
     sold_p2 = bool(pos.get("sold_p2", False))
     qty_p1 = max(1, int(qty * PARTIAL1))
     qty_p2 = max(1, int(qty * PARTIAL2))
 
     # === ë ˆì§ ê¸°ë°˜ TP/íŠ¸ë ˆì¼ë§ ì„¤ì • ===
     base_tp1 = DEFAULT_PROFIT_PCT        # ë³´í†µ 3.0
     base_tp2 = DEFAULT_PROFIT_PCT * 2    # 6.0
     trail_down_frac = 0.018              # ê¸°ë³¸: ê³ ì ëŒ€ë¹„ 1.8% ë˜ëŒë¦¬ë©´ ì»·
 
     # (ì„ íƒ) ëª¨ë©˜í…€ ì •ë³´ë¥¼ ì“°ê³  ì‹¶ìœ¼ë©´ ì—¬ê¸°ì„œ strong_mom ê³„ì‚°
     strong_mom = False
     try:
         # metricsì— is_strong_momentumì´ ìˆë‹¤ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ False ìœ ì§€
         strong_mom = bool(is_strong_momentum(kis, code))
     except Exception:
@@ -1154,59 +1203,28 @@ def _adaptive_exit(
 
     # === 1) ì†ì ˆ ===
     if pnl_pct <= hard_stop_pct:
         reason = f"ì†ì ˆ {hard_stop_pct:.1f}%"
         sell_size = qty
 
     # === 2) 2ì°¨ TP (ë” ë†’ì€ ìˆ˜ìµ êµ¬ê°„) ===
     elif (pnl_pct >= tp2) and (not sold_p2) and qty > 1:
         reason = f"2ì°¨ ìµì ˆ {tp2:.1f}%"
         sell_size = min(qty, qty_p2)
         pos["sold_p2"] = True
 
     # === 3) 1ì°¨ TP ===
     elif (pnl_pct >= tp1) and (not sold_p1) and qty > 1:
         reason = f"1ì°¨ ìµì ˆ {tp1:.1f}%"
         sell_size = min(qty, qty_p1)
         pos["sold_p1"] = True
 
     else:
         # === 4) íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ===
         if max_price >= buy_price * (1 + tp1 / 100.0) and cur <= max_price * (1 - trail_down_frac):
             reason = f"íŠ¸ë ˆì¼ë§ìŠ¤í†±({trail_down_frac*100:.1f}%)"
             sell_size = qty
         else:
             # ì²­ì‚° ì¡°ê±´ ì—†ìŒ â†’ ë³´ìœ  ìœ ì§€
-            return None, None, None, None
-
-    # === ì‹¤ì œ ë§¤ë„ ì‹¤í–‰ ===
-    try:
-        exec_px, result = _sell_once(kis, code, sell_size, prefer_market=True)
-        sold_qty = sell_size
-
-        # ë³´ìœ  ìˆ˜ëŸ‰ ê°ì†Œ
-        pos["qty"] = max(0, qty - sell_size)
-
-        # ì‹¤í˜„ì†ìµ ë¡œê·¸
-        try:
-            log_trade(
-                {
-                    "datetime": now.strftime("%Y-%m-%d %H:%M:%S"),
-                    "code": code,
-                    "name": pos.get("name"),
-                    "side": "SELL",
-                    "qty": int(sold_qty),
-                    "price": float(exec_px) if exec_px is not None else float(cur),
-                    "amount": int(sold_qty) * int(exec_px or cur),
-                    "reason": reason,
-                    "regime_mode": regime_mode,
-                }
-            )
-        except Exception as e:
-            logger.warning(f"[EXIT-LOG-FAIL] {code}: {e}")
-
-    except Exception as e:
-        logger.error(f"[SELL-FAIL] {code} qty={sell_size} err={e}")
-        # ë§¤ë„ ì‹¤íŒ¨ ì‹œì—ëŠ” ìƒíƒœ ì›ë³µí•˜ì§€ ì•Šê³ , ë‹¤ìŒ ë£¨í”„ì—ì„œ ë‹¤ì‹œ íŒë‹¨
-        return None, None, None, None
+            return None, None
 
-    return reason, exec_px, result, sold_qty
+    return reason, sell_size
diff --git a/trader/exit_allocation.py b/trader/exit_allocation.py
index ed91cf578f3652e75b1d659ae0970af8d0db59a7..965183cc2efc541a0670913c0f77ff71e94bd3e9 100644
--- a/trader/exit_allocation.py
+++ b/trader/exit_allocation.py
@@ -39,50 +39,82 @@ def allocate_sell_qty(
 
     if scope == "strategy":
         if trigger_strategy_id is None:
             return []
         totals = _strategy_qty_map(lot_state, code)
         trigger_key = str(trigger_strategy_id)
         qty = min(requested_qty, int(totals.get(trigger_key, 0)))
         return (
             [{"strategy_id": trigger_key, "qty": int(qty)}]
             if qty > 0
             else []
         )
 
     totals = _strategy_qty_map(lot_state, code)
     if not totals:
         return []
 
     if scope == "dominant":
         dominant = dominant_strategy_for(lot_state, code)
         if dominant is None:
             return []
         dominant_key = str(dominant)
         qty = min(requested_qty, totals.get(dominant_key, 0))
         return [{"strategy_id": dominant_key, "qty": int(qty)}] if qty > 0 else []
 
+    if scope == "global":
+        totals = _strategy_qty_map(lot_state, code)
+        if not totals:
+            return []
+        orphan_qty = int(totals.get("ORPHAN", 0))
+        allocations: List[Dict[str, Any]] = []
+        remaining_qty = min(requested_qty, sum(totals.values()))
+        if orphan_qty > 0 and remaining_qty > 0:
+            take = min(orphan_qty, remaining_qty)
+            allocations.append({"strategy_id": "ORPHAN", "qty": int(take)})
+            remaining_qty -= take
+        if remaining_qty <= 0:
+            return allocations
+        non_orphan_totals = {k: v for k, v in totals.items() if k != "ORPHAN"}
+        if not non_orphan_totals:
+            return allocations
+        total_qty = sum(non_orphan_totals.values())
+        remaining_qty = min(remaining_qty, total_qty)
+        strategy_ids = sorted(non_orphan_totals.keys())
+        for sid in strategy_ids[:-1]:
+            ratio_qty = int(remaining_qty * (non_orphan_totals[sid] / total_qty))
+            qty = min(ratio_qty, non_orphan_totals[sid], remaining_qty)
+            if qty > 0:
+                allocations.append({"strategy_id": sid, "qty": int(qty)})
+                remaining_qty -= qty
+        if remaining_qty > 0:
+            last_sid = strategy_ids[-1]
+            qty = min(remaining_qty, non_orphan_totals[last_sid])
+            if qty > 0:
+                allocations.append({"strategy_id": last_sid, "qty": int(qty)})
+        return allocations
+
     if scope != "proportional":
         return []
 
     total_qty = sum(totals.values())
     if total_qty <= 0:
         return []
     requested_qty = min(requested_qty, total_qty)
     allocations: List[Dict[str, Any]] = []
     remaining = requested_qty
     strategy_ids = sorted(totals.keys())
     for sid in strategy_ids[:-1]:
         ratio_qty = int(requested_qty * (totals[sid] / total_qty))
         qty = min(ratio_qty, totals[sid], remaining)
         if qty > 0:
             allocations.append({"strategy_id": sid, "qty": int(qty)})
             remaining -= qty
     if remaining > 0:
         last_sid = strategy_ids[-1]
         qty = min(remaining, totals[last_sid])
         if qty > 0:
             allocations.append({"strategy_id": last_sid, "qty": int(qty)})
     return allocations
 
 
 def apply_sell_allocation(
diff --git a/trader/ledger.py b/trader/ledger.py
index dbe514da80475d53a49ccf29e3ac79c2f2ecb57f..a76a83216120d7abe0d0df1221f64e484ce2f491 100644
--- a/trader/ledger.py
+++ b/trader/ledger.py
@@ -74,136 +74,153 @@ def apply_sell_fill_fifo(
     def _consume(remaining_qty: int, sid_filter: int | str | None) -> int:
         for lot in lots:
             if _normalize_code(lot.get("pdno")) != _normalize_code(pdno):
                 continue
             if not allow_blocked and lot.get("meta", {}).get("sell_blocked") is True:
                 continue
 
             lot_sid = _norm_sid(lot.get("strategy_id"))
             if sid_filter is not None and lot_sid != sid_filter:
                 continue
 
             lot_remaining = int(lot.get("remaining_qty") or 0)
             if lot_remaining <= 0:
                 continue
 
             delta = min(lot_remaining, remaining_qty)
             lot["remaining_qty"] = int(lot_remaining - delta)
             if delta > 0:
                 lot["last_sell_ts"] = sell_ts
 
             remaining_qty -= delta
             if remaining_qty <= 0:
                 break
         return remaining_qty
 
-    # 1) ë¨¼ì € ìš”ì²­ ì „ëµì—ì„œ ì°¨ê°
-    remaining = _consume(remaining, req_sid)
-
-    # 2) ë¶€ì¡±í•˜ë©´ ë‹¤ë¥¸ ì „ëµ lotì—ì„œë„ ì°¨ê°(ê³„ì¢Œ ë§¤ë„ ë°˜ì˜ spill)
-    if remaining > 0 and req_sid is not None:
-        remaining = _consume(remaining, None)
+    _consume(remaining, req_sid)
 
 
 def owned_lots_by_strategy(state: Dict[str, Any], strategy_id: int | str) -> List[Dict[str, Any]]:
     lots = _ensure_state(state)
     return [
         lot
         for lot in lots
         if int(lot.get("remaining_qty") or 0) > 0
         and _norm_sid(lot.get("strategy_id")) == _norm_sid(strategy_id)
     ]
 
 
 def remaining_qty_for_strategy(state: Dict[str, Any], pdno: str, strategy_id: int | str) -> int:
     lots = _ensure_state(state)
     total = 0
     for lot in lots:
         if _normalize_code(lot.get("pdno")) != _normalize_code(pdno):
             continue
         if int(lot.get("remaining_qty") or 0) <= 0:
             continue
         if _norm_sid(lot.get("strategy_id")) != _norm_sid(strategy_id):
             continue
         total += int(lot.get("remaining_qty") or 0)
     return total
 
 
 def dominant_strategy_for(state: Dict[str, Any], pdno: str) -> int | None:
     lots = _ensure_state(state)
     totals: Dict[int, int] = {}
     for lot in lots:
         if _normalize_code(lot.get("pdno")) != _normalize_code(pdno):
             continue
         remaining = int(lot.get("remaining_qty") or 0)
         if remaining <= 0:
             continue
         sid = _norm_sid(lot.get("strategy_id"))
         if isinstance(sid, int) and 1 <= sid <= 5:
             totals[sid] = totals.get(sid, 0) + remaining
     if not totals:
         return None
     return max(totals.items(), key=lambda item: item[1])[0]
 
 
+def strategy_avg_price(
+    state: Dict[str, Any], pdno: str, strategy_id: int | str
+) -> float | None:
+    lots = _ensure_state(state)
+    total_qty = 0
+    total_cost = 0.0
+    for lot in lots:
+        if _normalize_code(lot.get("pdno")) != _normalize_code(pdno):
+            continue
+        if _norm_sid(lot.get("strategy_id")) != _norm_sid(strategy_id):
+            continue
+        remaining = int(lot.get("remaining_qty") or 0)
+        if remaining <= 0:
+            continue
+        entry_price = float(lot.get("entry_price") or 0.0)
+        total_qty += remaining
+        total_cost += entry_price * remaining
+    if total_qty <= 0:
+        return None
+    return total_cost / total_qty
+
+
 def reconcile_with_broker_holdings(state: Dict[str, Any], holdings: List[Dict[str, Any]]) -> None:
     lots = _ensure_state(state)
     holdings_map: Dict[str, Dict[str, Any]] = {}
     for row in holdings:
         code = _normalize_code(row.get("code") or row.get("pdno") or "")
         if not code:
             continue
         qty = int(row.get("qty") or 0)
         avg_price = row.get("avg_price")
         existing = holdings_map.get(code)
         if existing:
             existing["qty"] += qty
             if existing.get("avg_price") is None:
                 existing["avg_price"] = avg_price
         else:
             holdings_map[code] = {"qty": qty, "avg_price": avg_price}
 
     now_ts = datetime.now(KST).isoformat()
 
     for lot in lots:
         pdno = _normalize_code(lot.get("pdno"))
         if pdno not in holdings_map or holdings_map[pdno]["qty"] <= 0:
             if int(lot.get("remaining_qty") or 0) > 0:
                 lot["remaining_qty"] = 0
 
     for pdno, payload in holdings_map.items():
         hold_qty = int(payload.get("qty") or 0)
         if hold_qty <= 0:
             continue
         total_remaining = sum(
             int(lot.get("remaining_qty") or 0)
             for lot in lots
             if _normalize_code(lot.get("pdno")) == pdno
         )
         if total_remaining < hold_qty:
             diff = hold_qty - total_remaining
             lots.append(
                 {
                     "lot_id": f"{pdno}-RECON-{now_ts}",
                     "pdno": pdno,
-                    "strategy_id": "UNKNOWN",
+                    "strategy_id": "ORPHAN",
                     "engine": "reconcile",
                     "entry_ts": now_ts,
                     "entry_price": float(payload.get("avg_price") or 0.0),
                     "qty": int(diff),
                     "remaining_qty": int(diff),
-                    "meta": {"reconciled": True, "sell_blocked": True},
+                    "meta": {"reconciled": True, "orphan": True},
                 }
             )
         elif total_remaining > hold_qty:
             extra = total_remaining - hold_qty
             for lot in reversed(lots):
                 if _normalize_code(lot.get("pdno")) != pdno:
                     continue
                 lot_remaining = int(lot.get("remaining_qty") or 0)
                 if lot_remaining <= 0:
                     continue
                 delta = min(lot_remaining, extra)
                 lot["remaining_qty"] = int(lot_remaining - delta)
                 extra -= delta
                 if extra <= 0:
                     break
diff --git a/trader/ledger_test.py b/trader/ledger_test.py
index 24e5eabb7af43b286aeca438043220600c176a5e..0dfbd740de7c3250ab53acfa31f572589967c8e8 100644
--- a/trader/ledger_test.py
+++ b/trader/ledger_test.py
@@ -1,63 +1,218 @@
 from __future__ import annotations
 
-from trader.ledger import apply_sell_fill_fifo, record_buy_fill
+from trader.exit_allocation import allocate_sell_qty, apply_sell_allocation
+from trader.ctx_schema import normalize_daily_ctx
+from trader.execution import record_entry_state
+from trader.ledger import apply_sell_fill_fifo, record_buy_fill, remaining_qty_for_strategy
+from trader.position_state_store import migrate_position_state
+from trader import state_store as runtime_state_store
 
 
 def _sample_state() -> dict:
     return {"version": 1, "lots": [], "updated_at": None}
 
 
 def test_fifo_and_fallback() -> None:
     state = _sample_state()
     record_buy_fill(
         state,
         lot_id="L1",
         pdno="005930",
         strategy_id=1,
         engine="test",
         entry_ts="2025-01-01T09:00:00+09:00",
         entry_price=70000.0,
         qty=5,
         meta={},
     )
     record_buy_fill(
         state,
         lot_id="L2",
         pdno="005930",
         strategy_id=2,
         engine="test",
         entry_ts="2025-01-01T09:05:00+09:00",
         entry_price=70500.0,
         qty=5,
         meta={},
     )
 
     apply_sell_fill_fifo(
         state,
         pdno="005930",
         qty_filled=3,
         sell_ts="2025-01-01T10:00:00+09:00",
         strategy_id=1,
     )
     lots = state["lots"]
     assert lots[0]["remaining_qty"] == 2
     assert lots[1]["remaining_qty"] == 5
 
     apply_sell_fill_fifo(
         state,
         pdno="005930",
         qty_filled=4,
         sell_ts="2025-01-01T10:10:00+09:00",
         strategy_id=1,
     )
     assert lots[0]["remaining_qty"] == 0
-    assert lots[1]["remaining_qty"] == 3
+    assert lots[1]["remaining_qty"] == 5
+
+
+def test_record_entry_state_accumulates() -> None:
+    state = {"positions": {}}
+    state = record_entry_state(
+        state=state,
+        code="000001",
+        qty=10,
+        avg_price=100.0,
+        strategy_id=1,
+        engine="test",
+        entry_reason="init",
+        order_type="limit",
+        best_k=None,
+        tgt_px=None,
+        gap_pct_at_entry=None,
+        flags={"bear_s1_done": True},
+    )
+    state = record_entry_state(
+        state=state,
+        code="000001",
+        qty=5,
+        avg_price=110.0,
+        strategy_id=1,
+        engine="test",
+        entry_reason="add",
+        order_type="limit",
+        best_k=None,
+        tgt_px=None,
+        gap_pct_at_entry=None,
+        flags={"bear_s2_done": True},
+    )
+    entry = state["positions"]["000001"]["strategies"]["1"]
+    assert entry["qty"] == 15
+    assert round(entry["avg_price"], 2) == round((10 * 100 + 5 * 110) / 15, 2)
+    assert entry["flags"]["bear_s1_done"] is True
+    assert entry["flags"]["bear_s2_done"] is True
+    assert entry["flags"]["sold_p1"] is False
+    assert entry["entry"].get("time")
+    assert entry["entry"].get("last_entry_time")
+
+
+def test_strategy_scoped_sell() -> None:
+    lot_state = {
+        "lots": [
+            {"pdno": "000001", "strategy_id": 1, "remaining_qty": 5, "entry_price": 100.0},
+            {"pdno": "000001", "strategy_id": 2, "remaining_qty": 4, "entry_price": 105.0},
+        ]
+    }
+    allocations = allocate_sell_qty(
+        lot_state,
+        "000001",
+        3,
+        scope="strategy",
+        trigger_strategy_id=1,
+    )
+    sold_total = apply_sell_allocation(
+        lot_state,
+        "000001",
+        allocations,
+        sell_ts="2025-01-01T10:00:00+09:00",
+    )
+    assert sold_total == 3
+    assert remaining_qty_for_strategy(lot_state, "000001", 1) == 2
+    assert remaining_qty_for_strategy(lot_state, "000001", 2) == 4
+
+
+def test_migrate_position_state_v1() -> None:
+    legacy_state = {
+        "schema_version": 1,
+        "positions": {
+            "000001": {
+                "entries": {
+                    "1": {
+                        "qty": 3,
+                        "avg_price": 100.0,
+                        "entry": {"time": "t1"},
+                        "meta": {},
+                    }
+                },
+                "flags": {"bear_s1_done": True, "bear_s2_done": False},
+            }
+        },
+        "memory": {"last_price": {}, "last_seen": {}},
+    }
+    migrated = migrate_position_state(legacy_state)
+    assert migrated["schema_version"] == 2
+    strategies = migrated["positions"]["000001"]["strategies"]
+    assert "1" in strategies
+    assert strategies["1"]["qty"] == 3
+    assert strategies["1"]["avg_price"] == 100.0
+    assert strategies["1"]["flags"]["bear_s1_done"] is True
+
+
+def test_global_liquidation_orphan_priority() -> None:
+    lot_state = {
+        "lots": [
+            {"pdno": "000001", "strategy_id": "ORPHAN", "remaining_qty": 2, "entry_price": 90.0},
+            {"pdno": "000001", "strategy_id": 1, "remaining_qty": 4, "entry_price": 100.0},
+            {"pdno": "000001", "strategy_id": 2, "remaining_qty": 3, "entry_price": 105.0},
+        ]
+    }
+    allocations = allocate_sell_qty(
+        lot_state,
+        "000001",
+        9,
+        scope="global",
+        trigger_strategy_id=None,
+    )
+    assert allocations[0]["strategy_id"] == "ORPHAN"
+    sold_total = apply_sell_allocation(
+        lot_state,
+        "000001",
+        allocations,
+        sell_ts="2025-01-01T10:00:00+09:00",
+    )
+    assert sold_total == 9
+    assert remaining_qty_for_strategy(lot_state, "000001", "ORPHAN") == 0
+    assert remaining_qty_for_strategy(lot_state, "000001", 1) == 0
+    assert remaining_qty_for_strategy(lot_state, "000001", 2) == 0
+
+
+def test_normalize_ctx_missing_setup_flag() -> None:
+    ctx = normalize_daily_ctx({"strong_trend": True})
+    assert ctx.get("setup_flag") is False
+    assert ctx.get("setup_ok") is False
+
+
+def test_idempotent_order_block() -> None:
+    state = runtime_state_store.load_state()
+    ts = "2025-01-01T10:00:00+09:00"
+    runtime_state_store.mark_order(
+        state,
+        "000001",
+        "BUY",
+        1,
+        1,
+        100.0,
+        ts,
+        status="submitted",
+    )
+    assert runtime_state_store.should_block_order(
+        state, "000001", "BUY", "2025-01-01T10:01:00+09:00"
+    )
 
 
 def main() -> None:
     test_fifo_and_fallback()
+    test_record_entry_state_accumulates()
+    test_strategy_scoped_sell()
+    test_migrate_position_state_v1()
+    test_global_liquidation_orphan_priority()
+    test_normalize_ctx_missing_setup_flag()
+    test_idempotent_order_block()
     print("OK")
 
 
 if __name__ == "__main__":
     main()
diff --git a/trader/legacy_kosdaq_runner.py b/trader/legacy_kosdaq_runner.py
index de3a1d23b3335168a0c5b396c7be8a671a0357a4..87cd4fe6ea27a163c26594a35af8d1d5ae8b0eb5 100644
--- a/trader/legacy_kosdaq_runner.py
+++ b/trader/legacy_kosdaq_runner.py
@@ -1,332 +1,403 @@
 # -*- coding: utf-8 -*-
 """ê±°ë˜ ë©”ì¸ ë£¨í”„.
 
 ê¸°ì¡´ trader.pyì˜ ì„¤ì •/ìœ í‹¸ì„ ë¶„ë¦¬í•˜ê³ , ë©”ì¸ ì§„ì…ì ë§Œ ë‚¨ê²¨ ì „ëµ ì¶”ê°€ê°€
 ì‰¬ìš´ êµ¬ì¡°ë¡œ ë³€ê²½í–ˆë‹¤.
 """
 from __future__ import annotations
 
 import json
 import re
 import time
+import os
 from datetime import date, datetime, time as dtime, timedelta
 from typing import Any, Dict, List, Tuple, TYPE_CHECKING
 
 
 try:
     from .config import (
         DAILY_CAPITAL,
         FAST_STOP,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         FORCE_SELL_BLOCKED_LOTS,
         ALLOW_WHEN_CLOSED,
         ALLOW_PYRAMID,
         BASE_QTY_MODE,
         KST,
         LOG_DIR,
         RATE_SLEEP_SEC,
+        EMERGENCY_GLOBAL_SELL,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
         STATE_PATH,
+        STRATEGY_REDUCTION_PRIORITY,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         _cfg,
         logger,
     )
 except ImportError:
     # ALLOW_WHEN_CLOSEDê°€ ëˆ„ë½ë¼ë„ ëŸ¬ë„ˆê°€ ì¦‰ì‹œ ì¤‘ë‹¨ë˜ì§€ ì•Šë„ë¡ ì•ˆì „í•œ ê¸°ë³¸ê°’ì„ ì œê³µí•œë‹¤.
     from .config import (
         DAILY_CAPITAL,
         FAST_STOP,
         FORCE_SELL_PASSES_CLOSE,
         FORCE_SELL_PASSES_CUTOFF,
         FORCE_SELL_BLOCKED_LOTS,
         KST,
         LOG_DIR,
         BASE_QTY_MODE,
         RATE_SLEEP_SEC,
+        EMERGENCY_GLOBAL_SELL,
         SELL_ALL_BALANCES_AT_CUTOFF,
         SELL_FORCE_TIME,
         SLIPPAGE_ENTER_GUARD_PCT,
         STATE_PATH,
+        STRATEGY_REDUCTION_PRIORITY,
         USE_PULLBACK_ENTRY,
         PULLBACK_MAX_BUYS_PER_DAY,
         NEUTRAL_ENTRY_SCALE,
         _cfg,
         logger,
     )
 
     ALLOW_WHEN_CLOSED = False
     logger.warning("[CONFIG] ALLOW_WHEN_CLOSED missing; defaulting to False")
     ALLOW_PYRAMID = False
     logger.warning("[CONFIG] ALLOW_PYRAMID missing; defaulting to False")
 from . import signals
 from trader.time_utils import MARKET_CLOSE, MARKET_OPEN, is_trading_day
 from trader.subject_flow import get_subject_flow_with_fallback, reset_flow_call_count
 from trader.execution import record_entry_state
 from trader.exit_allocation import allocate_sell_qty, apply_sell_allocation
 from trader.ledger import (
-    apply_sell_fill_fifo,
-    dominant_strategy_for,
     record_buy_fill,
     remaining_qty_for_strategy,
     reconcile_with_broker_holdings,
+    strategy_avg_price,
 )
+from trader.ctx_schema import normalize_daily_ctx, normalize_intraday_ctx
+from trader import state_store as runtime_state_store
 from trader.lot_state_store import load_lot_state, save_lot_state
 from trader.position_state_store import (
     load_position_state,
     reconcile_with_broker,
     save_position_state,
 )
 from .core import *  # noqa: F401,F403 - ì „ëµ ìœ í‹¸ ì „ì²´ ë…¸ì¶œë¡œ í™•ì¥ì„± í™•ë³´
 
 if TYPE_CHECKING:
     # core ìª½ì— êµ¬í˜„ë¼ ìˆëŠ” í—¬í¼ë“¤ì„ íƒ€ì…ì²´ì»¤ì—ê²Œë§Œ ëª…ì‹œì ìœ¼ë¡œ ì•Œë ¤ì¤€ë‹¤.
     from .core import (
         _this_iso_week_key,
         _get_effective_ord_cash,
         _to_float,
         _to_int,
         _weight_to_qty,
         _classify_champion_grade,
         _update_market_regime,
         _notional_to_qty,
         _fetch_balances,
         _init_position_state_from_balance,
         _sell_once,
         _adaptive_exit,
         _compute_daily_entry_context,
         _compute_intraday_entry_context,
         _safe_get_price,
         _round_to_tick,
         _init_position_state,
         _detect_pullback_reversal,
         _has_bullish_trend_structure,
     )
 
 
 def main(
     capital_override: float | None = None,
     selected_stocks: list[dict[str, Any]] | None = None,
 ):
     reset_flow_call_count()
     effective_capital = (
         int(capital_override) if capital_override is not None else DAILY_CAPITAL
     )
     kis = KisAPI()
+    dry_run = os.getenv("DRY_RUN", "0") == "1"
 
     rebalance_date = get_rebalance_anchor_date()
     logger.info(
         f"[â„¹ï¸ ë¦¬ë°¸ëŸ°ì‹± ê¸°ì¤€ì¼(KST)]: {rebalance_date} (anchor={REBALANCE_ANCHOR}, ref={WEEKLY_ANCHOR_REF})"
     )
     logger.info(
         f"[â±ï¸ ì»¤íŠ¸ì˜¤í”„(KST)] SELL_FORCE_TIME={SELL_FORCE_TIME.strftime('%H:%M')} / ì „ì²´ì”ê³ ë§¤ë„={SELL_ALL_BALANCES_AT_CUTOFF} / "
         f"íŒ¨ìŠ¤(ì»¤íŠ¸ì˜¤í”„/ë§ˆê°)={FORCE_SELL_PASSES_CUTOFF}/{FORCE_SELL_PASSES_CLOSE}"
     )
     logger.info(
         f"[ğŸ’° CAPITAL] {effective_capital:,}ì› (configured DAILY_CAPITAL={DAILY_CAPITAL:,})"
     )
     logger.info(f"[ğŸ›¡ï¸ SLIPPAGE_ENTER_GUARD_PCT] {SLIPPAGE_ENTER_GUARD_PCT:.2f}%")
 
     # ìƒíƒœ ë³µêµ¬
     state_loaded_at = datetime.now(KST)
     state_loaded_date = state_loaded_at.strftime("%Y-%m-%d")
     state_loaded_str = state_loaded_at.strftime("%Y-%m-%d %H:%M:%S")
     state_loaded_midnight = f"{state_loaded_date} 00:00:00"
 
     holding, traded = load_state()
     lot_state_path = "bot_state/state.json"
     lot_state = load_lot_state(lot_state_path)
     position_state_path = str(STATE_PATH)
     position_state = load_position_state(position_state_path)
     position_state_dirty = False
+    runtime_state = runtime_state_store.load_state()
     triggered_today: set[str] = set()
-    s1_done_today: set[str] = set()
+    s1_done_today: set[tuple[str, str]] = set()
     last_today_prefix: str | None = None
 
     if isinstance(traded, (set, list, tuple)):
         logger.warning(
             f"[STATE-MIGRATE] traded íƒ€ì… {type(traded)} â†’ dictë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜(ì¤‘ë³µ ì§„ì… ê°€ë“œ ìœ ì§€)"
         )
         traded = {
             code: {"buy_time": state_loaded_midnight, "qty": 0, "price": 0.0}
             for code in traded
         }
     elif not isinstance(traded, dict):
         logger.warning(
             f"[STATE-FORMAT] traded íƒ€ì… {type(traded)} ì§€ì› ì•ˆ í•¨ â†’ ë¹ˆ dictë¡œ ì¬ì„¤ì •"
         )
         traded = {}
 
     def _traded_codes(traded_state: Any) -> List[str]:
         if isinstance(traded_state, dict):
             return list(traded_state.keys())
         return []
 
     def _traded_today(traded_state: Any, today_prefix: str) -> set:
         if not isinstance(traded_state, dict):
             return set()
 
         today_codes = set()
         for code, payload in traded_state.items():
             payload = payload or {}
             buy_time = payload.get("buy_time")
             status = payload.get("status")
             # pending/other ìƒíƒœëŠ” ì¬ì‹œë„ í—ˆìš©, filled/ê¸°ì¡´(None)ë§Œ ì¤‘ë³µ ë°©ì§€
             if status not in (None, "filled"):
                 continue
             if isinstance(buy_time, str) and buy_time.startswith(today_prefix):
                 today_codes.add(code)
         return today_codes
 
     def _record_trade(traded_state: Any, code: str, payload: Dict[str, Any]) -> None:
         try:
             traded_state[code] = payload
         except Exception:
             logger.warning(
                 f"[TRADED-STATE] tradedì— ì½”ë“œ ì¶”ê°€ ì‹¤íŒ¨: type={type(traded_state)}"
             )
 
+    def _save_runtime_state() -> None:
+        try:
+            runtime_state_store.save_state(runtime_state)
+        except Exception:
+            logger.exception("[RUNTIME_STATE] save failed")
+
     def _lot_state_signature(state: dict) -> tuple:
         lots = state.get("lots")
         if not isinstance(lots, list):
             return tuple()
         return tuple(
             (
                 str(lot.get("lot_id")),
                 str(lot.get("pdno")),
                 int(lot.get("remaining_qty") or 0),
             )
             for lot in lots
         )
 
     def _maybe_save_lot_state(before_signature: tuple) -> None:
         after_signature = _lot_state_signature(lot_state)
         if after_signature != before_signature:
             save_lot_state(lot_state_path, lot_state)
 
     def _ensure_position_entry(
         code: str, strategy_id: int | str
     ) -> Dict[str, Any]:
         code_key = str(code).zfill(6)
         sid_key = str(strategy_id)
         pos = position_state.setdefault("positions", {}).setdefault(
             code_key,
             {
-                "entries": {},
-                "flags": {"bear_s1_done": False, "bear_s2_done": False},
-                "broker_qty": None,
-                "broker_avg_price": None,
-                "miss_count": 0,
+                "strategies": {},
             },
         )
-        entries = pos.setdefault("entries", {})
+        entries = pos.setdefault("strategies", {})
         entry = entries.get(sid_key)
         if isinstance(entry, dict):
             return entry
         now_ts = datetime.now(KST).isoformat()
         entry = {
-            "qty": int((holding.get(code) or {}).get("qty") or 0),
+            "qty": int(remaining_qty_for_strategy(lot_state, code_key, sid_key)),
             "avg_price": float((holding.get(code) or {}).get("buy_price") or 0.0),
             "entry": {
                 "time": now_ts,
                 "strategy_id": sid_key,
                 "engine": "unknown",
                 "entry_reason": "RECONCILE",
                 "order_type": "unknown",
                 "best_k": None,
                 "tgt_px": None,
                 "gap_pct_at_entry": None,
             },
             "meta": {
                 "pullback_peak_price": None,
                 "pullback_reversal_price": None,
                 "pullback_reason": None,
             },
+            "flags": {
+                "bear_s1_done": False,
+                "bear_s2_done": False,
+                "sold_p1": False,
+                "sold_p2": False,
+            },
         }
         entries[sid_key] = entry
         return entry
 
-    def _set_position_flags(code: str, **flags: bool) -> None:
+    def _set_position_flags(code: str, strategy_id: int | str, **flags: bool) -> None:
         nonlocal position_state_dirty
         pos = position_state.setdefault("positions", {}).setdefault(
             str(code).zfill(6),
             {
-                "entries": {},
-                "flags": {"bear_s1_done": False, "bear_s2_done": False},
-                "broker_qty": None,
-                "broker_avg_price": None,
-                "miss_count": 0,
+                "strategies": {},
             },
         )
-        flags_before = dict(pos.get("flags") or {})
-        entry_flags = pos.setdefault(
+        entries = pos.setdefault("strategies", {})
+        entry = entries.setdefault(str(strategy_id), {})
+        entry_flags = entry.setdefault(
             "flags",
-            {"bear_s1_done": False, "bear_s2_done": False},
+            {"bear_s1_done": False, "bear_s2_done": False, "sold_p1": False, "sold_p2": False},
         )
+        flags_before = dict(entry_flags)
         for key, value in flags.items():
             entry_flags[key] = bool(value)
-            if code in holding:
-                holding[code][key] = bool(value)
         logger.info(
             "[FLAGS] code=%s flags_before=%s flags_after=%s",
             str(code).zfill(6),
             flags_before,
             entry_flags,
         )
         position_state_dirty = True
 
     def _update_last_price_memory(code: str, current_price: float, now_ts: str) -> None:
         nonlocal position_state_dirty
         memory = position_state.setdefault("memory", {})
         memory.setdefault("last_price", {})[str(code).zfill(6)] = float(current_price)
         memory.setdefault("last_seen", {})[str(code).zfill(6)] = now_ts
         position_state_dirty = True
 
     def _pullback_stop_hit(
         code: str, current_price: float, strategy_id: int | str = 5
     ) -> bool:
         pos = position_state.get("positions", {}).get(str(code).zfill(6))
         if not isinstance(pos, dict):
             return False
-        entries = pos.get("entries", {})
+        entries = pos.get("strategies", {})
         entry = entries.get(str(strategy_id))
         if not isinstance(entry, dict):
             return False
         meta = entry.get("meta", {}) or {}
         reversal_price = meta.get("pullback_reversal_price")
         if reversal_price is None:
             return False
         try:
             return float(current_price) < float(reversal_price) * (1 - FAST_STOP)
         except Exception:
             return False
 
+    def _build_exit_intents(code: str, regime_mode: str) -> list[dict[str, Any]]:
+        nonlocal position_state_dirty
+        intents: list[dict[str, Any]] = []
+        code_key = str(code).zfill(6)
+        pos_state = position_state.get("positions", {}).get(code_key)
+        if not isinstance(pos_state, dict):
+            return intents
+        strategies = pos_state.get("strategies", {})
+        if not isinstance(strategies, dict):
+            return intents
+        for sid, entry in strategies.items():
+            if not isinstance(entry, dict):
+                continue
+            available_qty = remaining_qty_for_strategy(lot_state, code_key, sid)
+            if available_qty <= 0:
+                continue
+            avg_price = strategy_avg_price(lot_state, code_key, sid)
+            if avg_price is None:
+                continue
+            flags = entry.get("flags", {}) or {}
+            meta = entry.get("meta", {}) or {}
+            high_value = float(meta.get("high") or 0.0)
+            if not high_value or high_value <= 0:
+                high_value = float(avg_price)
+            high_value = max(high_value, float(avg_price))
+            meta["high"] = high_value
+            pos_view = {
+                "qty": int(available_qty),
+                "buy_price": float(avg_price),
+                "high": high_value,
+                "sold_p1": bool(flags.get("sold_p1", False)),
+                "sold_p2": bool(flags.get("sold_p2", False)),
+                "name": entry.get("entry", {}).get("name"),
+                "k_value": entry.get("entry", {}).get("best_k"),
+                "target_price_src": entry.get("entry", {}).get("tgt_px"),
+            }
+            reason, sell_qty = _adaptive_exit(
+                kis,
+                code_key,
+                pos_view,
+                regime_mode=regime_mode,
+            )
+            if sell_qty:
+                intents.append(
+                    {
+                        "code": code_key,
+                        "strategy_id": sid,
+                        "sell_qty": int(sell_qty),
+                        "reason": reason or "adaptive_exit",
+                    }
+                )
+            meta["high"] = float(pos_view.get("high") or meta.get("high") or 0.0)
+            entry["meta"] = meta
+            flags["sold_p1"] = bool(pos_view.get("sold_p1", flags.get("sold_p1")))
+            flags["sold_p2"] = bool(pos_view.get("sold_p2", flags.get("sold_p2")))
+            entry["flags"] = flags
+            position_state_dirty = True
+        return intents
+
     def _remaining_qty_for(pdno: str) -> int:
         return sum(
             int(lot.get("remaining_qty") or 0)
             for lot in lot_state.get("lots", [])
             if str(lot.get("pdno")).zfill(6) == str(pdno).zfill(6)
         )
 
     def _ledger_total_available_qty(code: str) -> int:
         return sum(
             int(lot.get("remaining_qty") or 0)
             for lot in lot_state.get("lots", [])
             if str(lot.get("pdno")).zfill(6) == str(code).zfill(6)
         )
 
     def _cap_sell_qty(code: str, requested_qty: int) -> int:
         return min(int(requested_qty), int(_ledger_total_available_qty(code)))
 
     def _normalize_strategy_id(value: Any) -> int:
         try:
             strategy_num = int(value)
         except Exception:
             return 1
         if 1 <= strategy_num <= 5:
             return strategy_num
         return 1
@@ -370,209 +441,246 @@ def main(
         if isinstance(result, dict):
             out = result.get("output") or {}
             order_no = (
                 out.get("ODNO")
                 or out.get("ord_no")
                 or out.get("order_no")
                 or result.get("ODNO")
                 or result.get("ord_no")
                 or result.get("order_no")
                 or ""
             )
             fill_seq = (
                 out.get("CCLD_SQ")
                 or out.get("ccld_sq")
                 or out.get("fill_seq")
                 or out.get("CCLD_NO")
                 or out.get("ccld_no")
                 or ""
             )
         if not order_no:
             order_no = f"NOORDER-{str(pdno).zfill(6)}-{fallback_ts}"
         if not fill_seq:
             fill_seq = "0"
         return f"{kis.CANO}-{kis.ACNT_PRDT_CD}-{order_no}-{fill_seq}"
 
-    def _resolve_sell_sid(code: str) -> int | None:
-        try:
-            sid = (holding.get(code) or {}).get("strategy_id")
-        except Exception:
-            sid = None
-        if sid is not None:
-            try:
-                return int(sid)
-            except Exception:
-                sid = None
-        dominant = dominant_strategy_for(lot_state, code)
-        if dominant is None:
-            return None
-        try:
-            return int(dominant)
-        except Exception:
-            return None
-
     def _estimate_sold_qty(
         code: str, requested_qty: int, prev_qty: int, delay_sec: float = 1.0
     ) -> int:
         if requested_qty <= 0:
             return 0
         try:
             time.sleep(delay_sec)
             try:
                 balances = _fetch_balances(kis, ttl_sec=0)
             except TypeError:
                 balances = _fetch_balances(kis)
         except Exception:
             return int(requested_qty)
         for row in balances:
             if str(row.get("code")).zfill(6) != str(code).zfill(6):
                 continue
             new_qty = int(row.get("qty") or 0)
             sold = max(0, int(prev_qty) - int(new_qty))
             if sold <= 0:
                 return 0
             return min(int(requested_qty), int(sold))
         return int(requested_qty)
 
+    def _sync_position_state_qty(code: str) -> None:
+        nonlocal position_state_dirty
+        code_key = str(code).zfill(6)
+        pos = position_state.get("positions", {}).get(code_key)
+        if not isinstance(pos, dict):
+            return
+        strategies = pos.get("strategies", {})
+        if not isinstance(strategies, dict):
+            return
+        for sid in list(strategies.keys()):
+            remaining = remaining_qty_for_strategy(lot_state, code_key, sid)
+            if remaining <= 0:
+                strategies.pop(sid, None)
+                continue
+            entry = strategies.get(sid)
+            if not isinstance(entry, dict):
+                strategies.pop(sid, None)
+                continue
+            if int(entry.get("qty") or 0) > int(remaining):
+                logger.warning(
+                    "[STATE] qty exceeds ledger after sell: code=%s sid=%s state=%s ledger=%s",
+                    code_key,
+                    sid,
+                    entry.get("qty"),
+                    remaining,
+                )
+            entry["qty"] = int(remaining)
+        if not strategies:
+            position_state.get("positions", {}).pop(code_key, None)
+        position_state_dirty = True
+
     def _apply_sell_to_ledger_with_balance(
         code: str,
         requested_qty: int,
         sell_ts: str,
         result: Any,
-        scope: str = "proportional",
+        scope: str = "strategy",
         trigger_strategy_id: int | None = None,
         prev_qty_before: int | None = None,
         allow_blocked: bool = False,
     ) -> None:
         if not _is_order_success(result):
             return
-        prev_qty = int(prev_qty_before if prev_qty_before is not None else (holding.get(code) or {}).get("qty") or requested_qty)
-        sold_qty = _estimate_sold_qty(code, requested_qty, prev_qty)
+        if scope != "strategy" and not (SELL_ALL_BALANCES_AT_CUTOFF or EMERGENCY_GLOBAL_SELL):
+            raise RuntimeError(
+                f"[SELL-ALLOC] global scope used without force sell: code={code} scope={scope}"
+            )
+        prev_qty = int(
+            prev_qty_before
+            if prev_qty_before is not None
+            else (holding.get(code) or {}).get("qty") or requested_qty
+        )
+        sold_qty = 0
+        for delay_sec in (0.5, 1.0, 2.0):
+            sold_qty = _estimate_sold_qty(
+                code, requested_qty, prev_qty, delay_sec=delay_sec
+            )
+            if sold_qty > 0:
+                break
         if sold_qty <= 0:
+            logger.warning(
+                "[SELL-ALLOC] sold_qty unresolved: code=%s requested=%s prev_qty=%s",
+                str(code).zfill(6),
+                requested_qty,
+                prev_qty,
+            )
+            try:
+                balances = _fetch_balances(kis, ttl_sec=0)
+            except TypeError:
+                balances = _fetch_balances(kis)
+            reconcile_with_broker_holdings(lot_state, balances)
             return
         if scope == "strategy" and trigger_strategy_id is None:
-            scope = "proportional"
+            raise RuntimeError(
+                f"[SELL-ALLOC] strategy scope requires trigger_strategy_id: code={code}"
+            )
+        if scope == "strategy":
+            available_qty = remaining_qty_for_strategy(
+                lot_state, code, trigger_strategy_id
+            )
+            if available_qty < int(requested_qty):
+                raise RuntimeError(
+                    "[SELL-ALLOC] insufficient strategy qty: code=%s sid=%s available=%s requested=%s"
+                    % (str(code).zfill(6), trigger_strategy_id, available_qty, requested_qty)
+                )
         before_lot_signature = _lot_state_signature(lot_state)
+        before_qty_total = _ledger_total_available_qty(code)
+        before_qty_strategy = (
+            remaining_qty_for_strategy(lot_state, code, trigger_strategy_id)
+            if scope == "strategy"
+            else before_qty_total
+        )
         allocations = allocate_sell_qty(
             lot_state,
             code,
             int(sold_qty),
             scope=scope,
             trigger_strategy_id=trigger_strategy_id,
         )
         if not allocations:
-            if sold_qty > 0:
+            if sold_qty > 0 and scope != "strategy":
                 now_ts = datetime.now(KST).isoformat()
                 lot_state.setdefault("lots", []).append(
                     {
                         "lot_id": f"{str(code).zfill(6)}-ORPHAN-{now_ts}",
                         "pdno": str(code).zfill(6),
                         "strategy_id": "ORPHAN",
                         "engine": "orphan",
                         "entry_ts": now_ts,
                         "entry_price": 0.0,
                         "qty": int(sold_qty),
                         "remaining_qty": int(sold_qty),
-                        "meta": {"reconciled": True},
+                        "meta": {"reconciled": True, "orphan": True},
                     }
                 )
-                apply_sell_fill_fifo(
-                    lot_state,
-                    pdno=str(code).zfill(6),
-                    qty_filled=int(sold_qty),
-                    sell_ts=sell_ts,
-                    strategy_id="ORPHAN",
-                    allow_blocked=allow_blocked,
+                allocations = [{"strategy_id": "ORPHAN", "qty": int(sold_qty)}]
+            else:
+                raise RuntimeError(
+                    f"[SELL-ALLOC] no allocations for strategy sell: code={code} sid={trigger_strategy_id}"
                 )
-                _maybe_save_lot_state(before_lot_signature)
-            return
         broker_qty_after = max(0, int(prev_qty) - int(sold_qty))
         logger.info(
             "[SELL-ALLOC] code=%s requested_qty=%s scope=%s allocations=%s sold_qty=%s broker_qty_before=%s broker_qty_after=%s",
             str(code).zfill(6),
             int(requested_qty),
             scope,
             allocations,
             int(sold_qty),
             int(prev_qty),
             int(broker_qty_after),
         )
-        apply_sell_allocation(
+        sold_total = apply_sell_allocation(
             lot_state,
             code,
             allocations,
             sell_ts,
             allow_blocked=allow_blocked,
         )
-        _maybe_save_lot_state(before_lot_signature)
-
-    def _apply_sell_to_ledger(
-        pdno: str,
-        qty: int,
-        sell_ts: str,
-        result: Any,
-        strategy_id: int | None = None,
-        allow_blocked: bool = False,
-    ) -> None:
-        if not _is_order_success(result):
-            return
-        before = _remaining_qty_for(pdno)
-        apply_sell_fill_fifo(
-            lot_state,
-            pdno=pdno,
-            qty_filled=qty,
-            sell_ts=sell_ts,
-            strategy_id=strategy_id,
-            allow_blocked=allow_blocked,
-        )
-        after = _remaining_qty_for(pdno)
-        logger.info(
-            "[LEDGER][SELL] code=%s sid=%s sold=%s before=%s after=%s",
-            pdno,
-            strategy_id,
-            qty,
-            before,
-            after,
+        after_qty_total = _ledger_total_available_qty(code)
+        after_qty_strategy = (
+            remaining_qty_for_strategy(lot_state, code, trigger_strategy_id)
+            if scope == "strategy"
+            else after_qty_total
         )
-        if strategy_id is not None and after == before:
-            apply_sell_fill_fifo(
-                lot_state,
-                pdno=pdno,
-                qty_filled=qty,
-                sell_ts=sell_ts,
-                strategy_id=None,
-                allow_blocked=allow_blocked,
-            )
-            fallback_after = _remaining_qty_for(pdno)
-            logger.info(
-                "[LEDGER][SELL][FALLBACK] code=%s sid=%s sold=%s before=%s after=%s",
-                pdno,
-                strategy_id,
-                qty,
-                before,
-                fallback_after,
-            )
+        expected_before = before_qty_strategy
+        expected_after = max(0, int(expected_before) - int(sold_total))
+        if after_qty_strategy != expected_after:
+            resolved = False
+            for delay_sec in (0.5, 1.0, 2.0):
+                time.sleep(delay_sec)
+                retry_sold = _estimate_sold_qty(code, requested_qty, prev_qty, delay_sec=0)
+                retry_expected = max(0, int(expected_before) - int(retry_sold))
+                if after_qty_strategy == retry_expected:
+                    resolved = True
+                    break
+            if not resolved:
+                logger.warning(
+                    "[SELL-ALLOC] ledger mismatch: code=%s sid=%s before=%s sold=%s after=%s"
+                    % (
+                        str(code).zfill(6),
+                        trigger_strategy_id,
+                        expected_before,
+                        sold_total,
+                        after_qty_strategy,
+                    )
+                )
+                try:
+                    balances = _fetch_balances(kis, ttl_sec=0)
+                except TypeError:
+                    balances = _fetch_balances(kis)
+                reconcile_with_broker_holdings(lot_state, balances)
+        _maybe_save_lot_state(before_lot_signature)
+        _sync_position_state_qty(code)
 
     def _cleanup_expired_pending(
         traded_state: dict, now_dt: datetime, ttl_sec: int = 300
     ) -> set:
         expired: set[str] = set()
         if not isinstance(traded_state, dict):
             return expired
 
         for code, payload in list(traded_state.items()):
             payload = payload or {}
             if payload.get("status") != "pending":
                 continue
 
             ts = payload.get("pending_since") or payload.get("buy_time")
             if not isinstance(ts, str):
                 continue
 
             try:
                 pending_dt = datetime.strptime(ts, "%Y-%m-%d %H:%M:%S").replace(
                     tzinfo=now_dt.tzinfo
                 )
                 if (now_dt - pending_dt).total_seconds() > ttl_sec:
                     logger.warning(
                         f"[PENDING-EXPIRE] {code}: {ttl_sec}s ì´ˆê³¼ â†’ pending ì œê±°"
                     )
@@ -613,76 +721,87 @@ def main(
                 for key in state.keys():
                     if key == "period":
                         state[key] = payload.get("period", "daily")
                     else:
                         state[key] = payload.get(key, {}) or {}
             except Exception as e:
                 logger.warning(f"[REGIME-GUARD][LOAD] {day} ì‹¤íŒ¨: {e}")
         return state
 
     def _persist_guard_state(day: date) -> None:
         try:
             path = _guard_state_file(day)
             path.parent.mkdir(parents=True, exist_ok=True)
             payload = {"date": str(day), **guard_state}
             with open(path, "w", encoding="utf-8") as f:
                 json.dump(payload, f, ensure_ascii=False, indent=2)
         except Exception as e:
             logger.warning(f"[REGIME-GUARD][SAVE] {day} ì‹¤íŒ¨: {e}")
 
     def _ensure_guard_state(day: date) -> None:
         nonlocal guard_state_date, guard_state
         if guard_state_date != day:
             guard_state = _load_guard_state(day)
             guard_state_date = day
 
-    def _guard_entry(bucket: str, day: date, code: str, base_qty: int) -> dict:
+    def _guard_entry(
+        bucket: str, day: date, code: str, strategy_id: int | str, base_qty: int
+    ) -> dict:
         _ensure_guard_state(day)
         bucket_state = guard_state.setdefault(bucket, {})
-        entry = bucket_state.get(code)
+        key = f"{str(code).zfill(6)}:{strategy_id}"
+        entry = bucket_state.get(key)
         if entry is None:
             entry = {"base_qty": int(base_qty), "sold": 0}
-            bucket_state[code] = entry
+            bucket_state[key] = entry
             _persist_guard_state(day)
         elif BASE_QTY_MODE == "current":
             base_int = int(base_qty)
             if entry.get("base_qty") != base_int:
                 entry["base_qty"] = base_int
                 _persist_guard_state(day)
         return entry
 
-    def _s1_guard_target(today_date, code: str, base_qty: int) -> dict:
-        return _guard_entry("s1_target", today_date, code, base_qty)
+    def _s1_guard_target(
+        today_date, code: str, strategy_id: int | str, base_qty: int
+    ) -> dict:
+        return _guard_entry("s1_target", today_date, code, strategy_id, base_qty)
 
-    def _s1_guard_nontarget(today_date, code: str, base_qty: int) -> dict:
-        return _guard_entry("s1_nontarget", today_date, code, base_qty)
+    def _s1_guard_nontarget(
+        today_date, code: str, strategy_id: int | str, base_qty: int
+    ) -> dict:
+        return _guard_entry("s1_nontarget", today_date, code, strategy_id, base_qty)
 
-    def _s2_guard_target(today_date, code: str, base_qty: int) -> dict:
-        return _guard_entry("s2_target", today_date, code, base_qty)
+    def _s2_guard_target(
+        today_date, code: str, strategy_id: int | str, base_qty: int
+    ) -> dict:
+        return _guard_entry("s2_target", today_date, code, strategy_id, base_qty)
 
-    def _s2_guard_nontarget(today_date, code: str, base_qty: int) -> dict:
-        return _guard_entry("s2_nontarget", today_date, code, base_qty)
+    def _s2_guard_nontarget(
+        today_date, code: str, strategy_id: int | str, base_qty: int
+    ) -> dict:
+        return _guard_entry("s2_nontarget", today_date, code, strategy_id, base_qty)
 
     def _sell_result_status(result: Any) -> tuple[str, str | None]:
         try:
             if isinstance(result, dict):
                 if str(result.get("status")) == "SKIPPED":
                     return "SKIP", str(result.get("skip_reason") or "")
                 if str(result.get("rt_cd")) == "0":
                     return "SENT", None
         except Exception:
             pass
         return "ERROR", None
 
     def _pending_block(
         traded_state: dict, code: str, now_dt: datetime, block_sec: int = 45
     ) -> bool:
         if not isinstance(traded_state, dict):
             return False
         payload = traded_state.get(code) or {}
         if payload.get("status") != "pending":
             return False
 
         ts = payload.get("pending_since") or payload.get("buy_time")
         if not isinstance(ts, str):
             return True
 
@@ -1176,233 +1295,647 @@ def main(
 
             # ì¥ ìƒíƒœ
             now_dt_kst = datetime.now(KST)
             is_open = kis.is_market_open()
             now_str = now_dt_kst.strftime("%Y-%m-%d %H:%M:%S")
             today_prefix = now_dt_kst.strftime("%Y-%m-%d")
             _ensure_guard_state(now_dt_kst.date())
             if last_today_prefix != today_prefix:
                 triggered_today.clear()
                 s1_done_today.clear()
                 last_today_prefix = today_prefix
             expired_pending = _cleanup_expired_pending(traded, now_dt_kst, ttl_sec=300)
             if expired_pending:
                 triggered_today.difference_update(expired_pending)
             traded_today: set[str] = set()
             regime_s1_summary = {
                 "sent_qty": 0,
                 "sent_orders": 0,
                 "skipped": 0,
                 "total_qty": 0,
                 "by_stock": {},
             }
 
             def _log_s1_action(
                 code: str,
+                strategy_id: int | str,
                 status: str,
                 base_qty: int,
                 target_qty: int,
                 sold_today: int,
                 remaining: int,
                 sell_qty: int,
                 reason_msg: str | None = None,
             ) -> None:
-                regime_s1_summary["by_stock"][code] = {
+                key = f"{str(code).zfill(6)}:{strategy_id}"
+                regime_s1_summary["by_stock"][key] = {
                     "status": status,
                     "base_qty": int(base_qty),
                     "target": int(target_qty),
                     "sold_today": int(sold_today),
                     "remaining": int(remaining),
                     "sell_qty": int(sell_qty),
                     "reason": reason_msg or None,
                 }
                 prefix = (
                     "[SELL][SENT]"
                     if status == "SENT"
                     else "[SELL][SKIP]" if status == "SKIP" else "[SELL][ERROR]"
                 )
                 msg = (
-                    f"{prefix} [REGIME_S1] {code} base_qty={base_qty} target={target_qty} "
+                    f"{prefix} [REGIME_S1] {code}:{strategy_id} base_qty={base_qty} target={target_qty} "
                     f"sold={sold_today} remaining={remaining} sell_qty={sell_qty}"
                 )
                 if reason_msg:
                     msg += f" reason={reason_msg}"
                 if status == "ERROR":
                     logger.error(msg)
                 else:
                     logger.info(msg)
 
             def _log_s2_action(
                 code: str,
+                strategy_id: int | str,
                 status: str,
                 base_qty: int,
                 target_qty: int,
                 sold_today: int,
                 remaining: int,
                 sell_qty: int,
                 reason_msg: str | None = None,
             ) -> None:
                 prefix = (
                     "[SELL][SENT]"
                     if status == "SENT"
                     else "[SELL][SKIP]" if status == "SKIP" else "[SELL][ERROR]"
                 )
                 msg = (
-                    f"{prefix} [REGIME_S2] {code} base_qty={base_qty} target={target_qty} "
+                    f"{prefix} [REGIME_S2] {code}:{strategy_id} base_qty={base_qty} target={target_qty} "
                     f"sold={sold_today} remaining={remaining} sell_qty={sell_qty}"
                 )
                 if reason_msg:
                     msg += f" reason={reason_msg}"
                 if status == "ERROR":
                     logger.error(msg)
                 else:
                     logger.info(msg)
 
-            if now_dt_kst.date() != pullback_buy_date:
-                pullback_buy_date = now_dt_kst.date()
-                pullback_buys_today = 0
-
-            if not is_open:
-                if not is_trading_day(now_dt_kst):
-                    logger.error("[CLOSED] ë¹„ê±°ë˜ì¼ ê°ì§€ â†’ ë£¨í”„ ì¢…ë£Œ")
-                    break
-
-                if now_dt_kst.time() < MARKET_OPEN:
-                    seconds_to_open = int(
-                        (
-                            datetime.combine(now_dt_kst.date(), MARKET_OPEN, tzinfo=KST)
-                            - now_dt_kst
-                        ).total_seconds()
-                    )
-                    sleep_for = max(1, min(seconds_to_open, 300))
-                    logger.info(
-                        "[PREOPEN] ì¥ ì‹œì‘ê¹Œì§€ %ss ë‚¨ìŒ â†’ %ss ëŒ€ê¸° í›„ ì¬í™•ì¸",
-                        seconds_to_open,
-                        sleep_for,
+            def _strategy_ids_for_code(code: str) -> list[str]:
+                code_key = str(code).zfill(6)
+                totals: dict[str, int] = {}
+                lots = lot_state.get("lots", [])
+                if isinstance(lots, list):
+                    for lot in lots:
+                        if str(lot.get("pdno")).zfill(6) != code_key:
+                            continue
+                        remaining = int(lot.get("remaining_qty") or 0)
+                        if remaining <= 0:
+                            continue
+                        sid = lot.get("strategy_id")
+                        if sid is None:
+                            continue
+                        if str(sid).isdigit():
+                            sid_int = int(sid)
+                            if 1 <= sid_int <= 5:
+                                totals[str(sid_int)] = totals.get(str(sid_int), 0) + remaining
+                ordered: list[str] = []
+                for sid in STRATEGY_REDUCTION_PRIORITY:
+                    key = str(sid)
+                    if key in totals:
+                        ordered.append(key)
+                for sid in sorted(totals.keys()):
+                    if sid not in ordered:
+                        ordered.append(sid)
+                return ordered
+
+            def _run_bear_reduction(
+                code: str,
+                *,
+                is_target: bool,
+                regime: dict[str, Any],
+            ) -> None:
+                sellable_qty = ord_psbl_map.get(code, 0)
+                if sellable_qty <= 0:
+                    return
+                for sid in _strategy_ids_for_code(code):
+                    remaining_strategy = remaining_qty_for_strategy(lot_state, code, sid)
+                    if remaining_strategy <= 0:
+                        continue
+                    entry = _ensure_position_entry(code, sid)
+                    flags = entry.setdefault(
+                        "flags",
+                        {"bear_s1_done": False, "bear_s2_done": False, "sold_p1": False, "sold_p2": False},
                     )
-                    time.sleep(sleep_for)
-                    closed_checks = 0
-                    continue
-
-                if now_dt_kst.time() >= MARKET_CLOSE:
-                    logger.error("[CLOSED] ì¥ ë§ˆê° ì´í›„ â†’ ë£¨í”„ ì¢…ë£Œ")
-                    break
-
-                closed_checks += 1
-                if not ALLOW_WHEN_CLOSED:
-                    if closed_checks > max_closed_checks:
-                        logger.error(
-                            "[CLOSED] ì¥ ì¢…ë£Œ ë°˜ë³µ %síšŒ ì´ˆê³¼ â†’ ë£¨í”„ ì¢…ë£Œ",
-                            max_closed_checks,
+                    if regime.get("bear_stage", 0) >= 1:
+                        if flags.get("bear_s1_done"):
+                            continue
+                        guard = (
+                            _s1_guard_target(now_dt_kst.date(), code, sid, remaining_strategy)
+                            if is_target
+                            else _s1_guard_nontarget(now_dt_kst.date(), code, sid, remaining_strategy)
                         )
-                        break
-                    logger.info(
-                        "[CLOSED] ì¥ì¤‘ì¸ë° APIê°€ ë‹«í˜ ì‘ë‹µ â†’ 10ì´ˆ ëŒ€ê¸° í›„ ì¬í™•ì¸ (%s/%s)",
-                        closed_checks,
-                        max_closed_checks,
-                    )
-                    time.sleep(10)
-                    continue
-                else:
-                    logger.warning(
-                        "[CLOSED-DATA] ì¥ ì¢…ë£Œì§€ë§Œ í™˜ê²½ì„¤ì • í—ˆìš© â†’ ì‹œì„¸ ì¡°íšŒ í›„ ì§„í–‰"
-                    )
-            else:
-                closed_checks = 0
-
-            if kis.should_cooldown(now_dt_kst):
-                logger.warning("[COOLDOWN] 2ì´ˆê°„ ëŒ€ê¸° (API ì œí•œ ë³´í˜¸)")
-                time.sleep(2)
-
-            # ì”ê³  ê°€ì ¸ì˜¤ê¸°
-            prev_holding = holding if isinstance(holding, dict) else {}
-            balances = _fetch_balances(kis)
-            holding = {}
-            for bal in balances:
-                code = bal.get("code")
-                qty = int(bal.get("qty", 0))
-                if qty <= 0:
-                    continue
-                price = float(bal.get("avg_price", 0.0))
-                holding[code] = {
-                    "qty": qty,
-                    "buy_price": price,
-                    "bear_s1_done": False,
-                    "bear_s2_done": False,
-                }
-                _init_position_state_from_balance(kis, holding, code, price, qty)
-
-            before_lot_signature = _lot_state_signature(lot_state)
-            reconcile_with_broker_holdings(lot_state, balances)
-            _maybe_save_lot_state(before_lot_signature)
-
-            for code, info in holding.items():
-                sid = dominant_strategy_for(lot_state, code)
-                if sid is not None:
-                    holding[code]["strategy_id"] = sid
-                    logger.info(
-                        "[HOLDING_STRATEGY_RESTORE] code=%s sid=%s source=ledger",
-                        code,
-                        sid,
-                    )
-
-            position_state = reconcile_with_broker(position_state, balances)
-            position_state_dirty = True
-
-            for code, info in holding.items():
-                pos_state = position_state.get("positions", {}).get(str(code).zfill(6))
-                if not isinstance(pos_state, dict):
-                    continue
-                entries = pos_state.get("entries", {})
-                if not entries:
-                    sid = info.get("strategy_id") or "ORPHAN"
-                    _ensure_position_entry(code, sid)
-                    position_state_dirty = True
-                    entries = pos_state.get("entries", {})
-                entry = entries.get(str(info.get("strategy_id"))) if entries else None
-                if not isinstance(entry, dict):
-                    continue
-                meta = entry.get("meta", {})
-                flags = pos_state.get("flags", {})
-                info["engine"] = entry.get("entry", {}).get("engine") or info.get("engine")
-                info["bear_s1_done"] = bool(flags.get("bear_s1_done", False))
-                info["bear_s2_done"] = bool(flags.get("bear_s2_done", False))
-                info["pullback_peak_price"] = meta.get("pullback_peak_price")
-                info["pullback_reversal_price"] = meta.get("pullback_reversal_price")
+                        base_qty = int(guard.get("base_qty") or 0)
+                        if base_qty <= 0:
+                            regime_s1_summary["skipped"] += 1
+                            _log_s1_action(
+                                code,
+                                sid,
+                                "SKIP",
+                                base_qty,
+                                0,
+                                int(guard.get("sold", 0)),
+                                0,
+                                0,
+                                "base_qty_zero",
+                            )
+                        else:
+                            target_qty = max(1, int(base_qty * REG_PARTIAL_S1))
+                            sold_today = int(guard.get("sold", 0))
+                            remaining = max(0, target_qty - sold_today)
 
-            # ì”ê³  ê¸°ì¤€ìœ¼ë¡œ ë³´ìœ ì¢…ëª© ë§¤ë„ ê°€ëŠ¥ ìˆ˜ëŸ‰ ë§µ ìƒì„±
-            ord_psbl_map = {
-                bal.get("code"): int(bal.get("sell_psbl_qty", 0)) for bal in balances
-            }
+                            if remaining <= 0 or sellable_qty <= 0:
+                                if remaining <= 0:
+                                    _set_position_flags(code, sid, bear_s1_done=True)
+                                    s1_done_today.add((str(code).zfill(6), str(sid)))
+                                regime_s1_summary["skipped"] += 1
+                                _log_s1_action(
+                                    code,
+                                    sid,
+                                    "SKIP",
+                                    base_qty,
+                                    target_qty,
+                                    sold_today,
+                                    remaining,
+                                    0,
+                                    "target_met" if remaining <= 0 else "no_sellable_qty",
+                                )
+                            else:
+                                sell_qty = min(remaining, sellable_qty, remaining_strategy)
+                                sell_qty = _cap_sell_qty(code, sell_qty)
+                                if sell_qty <= 0:
+                                    regime_s1_summary["skipped"] += 1
+                                    _log_s1_action(
+                                        code,
+                                        sid,
+                                        "SKIP",
+                                        base_qty,
+                                        target_qty,
+                                        sold_today,
+                                        remaining,
+                                        0,
+                                        "strategy_qty_zero",
+                                    )
+                                    continue
+                                regime_s1_summary["total_qty"] += int(sell_qty)
+                                try:
+                                    prev_qty_before = int(
+                                        (holding.get(code) or {}).get("qty") or 0
+                                    )
+                                    if dry_run:
+                                        logger.info(
+                                            "[DRY-RUN][SELL] code=%s qty=%s strategy_id=%s reason=%s",
+                                            code,
+                                            sell_qty,
+                                            sid,
+                                            reason_msg,
+                                        )
+                                        runtime_state_store.mark_order(
+                                            runtime_state,
+                                            code,
+                                            "SELL",
+                                            sid,
+                                            int(sell_qty),
+                                            float(holding.get(code, {}).get("buy_price") or 0.0),
+                                            now_dt_kst.isoformat(),
+                                            status="submitted(dry)",
+                                        )
+                                        _save_runtime_state()
+                                        status, skip_reason = "SKIP", "DRY_RUN"
+                                        exec_px, result = None, {"status": "SKIPPED", "skip_reason": "DRY_RUN"}
+                                    else:
+                                        exec_px, result = _sell_once(
+                                            kis, code, sell_qty, prefer_market=True
+                                        )
+                                        runtime_state_store.mark_order(
+                                            runtime_state,
+                                            code,
+                                            "SELL",
+                                            sid,
+                                            int(sell_qty),
+                                            float(exec_px or 0.0),
+                                            now_dt_kst.isoformat(),
+                                            status="submitted",
+                                        )
+                                        _save_runtime_state()
+                                    status, skip_reason = _sell_result_status(result)
+                                except Exception as e:
+                                    exec_px, result = None, None
+                                    status, skip_reason = "ERROR", str(e)
 
-            if isinstance(traded, dict):
-                for code, payload in list(traded.items()):
-                    if (payload or {}).get("status") == "pending" and code in holding:
-                        traded[code]["status"] = "filled"
+                                reason_msg = skip_reason or (
+                                    "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ"
+                                    if is_target
+                                    else "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)"
+                                )
 
-            traded_today = _traded_today(traded, today_prefix)
-            for bal in balances:
+                                if status == "SENT":
+                                    guard["sold"] = sold_today + int(sell_qty)
+                                    holding[code]["qty"] = max(
+                                        0, holding[code]["qty"] - int(sell_qty)
+                                    )
+                                    if guard["sold"] >= target_qty:
+                                        _set_position_flags(code, sid, bear_s1_done=True)
+                                        s1_done_today.add((str(code).zfill(6), str(sid)))
+                                    _persist_guard_state(now_dt_kst.date())
+                                    regime_s1_summary["sent_qty"] += int(sell_qty)
+                                    regime_s1_summary["sent_orders"] += 1
+                                    trade_payload = {
+                                        "datetime": now_str,
+                                        "code": code,
+                                        "name": None,
+                                        "qty": int(sell_qty),
+                                        "K": holding[code].get("k_value"),
+                                        "target_price": holding[code].get("target_price_src"),
+                                        "strategy": "ë ˆì§ì¶•ì†Œ" if is_target else "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
+                                        "side": "SELL",
+                                        "price": exec_px,
+                                        "amount": int((exec_px or 0)) * int(sell_qty),
+                                        "reason": reason_msg,
+                                    }
+                                    if result is not None:
+                                        trade_payload["result"] = result
+                                    log_trade(trade_payload)
+                                    _apply_sell_to_ledger_with_balance(
+                                        code,
+                                        int(sell_qty),
+                                        now_dt_kst.isoformat(),
+                                        result,
+                                        scope="strategy",
+                                        trigger_strategy_id=int(sid) if sid.isdigit() else sid,
+                                        prev_qty_before=prev_qty_before,
+                                    )
+                                    runtime_state_store.mark_fill(
+                                        runtime_state,
+                                        code,
+                                        "SELL",
+                                        sid,
+                                        int(sell_qty),
+                                        float(exec_px or 0.0),
+                                        now_dt_kst.isoformat(),
+                                        status="filled",
+                                    )
+                                    _save_runtime_state()
+                                    save_state(holding, traded)
+                                    time.sleep(RATE_SLEEP_SEC)
+                                    sellable_qty = max(0, int(sellable_qty) - int(sell_qty))
+                                elif status == "SKIP":
+                                    regime_s1_summary["skipped"] += 1
+                                else:
+                                    regime_s1_summary["skipped"] += 1
+
+                                _log_s1_action(
+                                    code,
+                                    sid,
+                                    status,
+                                    base_qty,
+                                    target_qty,
+                                    sold_today,
+                                    remaining,
+                                    sell_qty,
+                                    reason_msg,
+                                )
+
+                    if regime.get("bear_stage", 0) >= 2:
+                        if flags.get("bear_s2_done"):
+                            continue
+                        if not flags.get("bear_s1_done"):
+                            _log_s2_action(
+                                code,
+                                sid,
+                                "SKIP",
+                                int(remaining_strategy),
+                                0,
+                                0,
+                                0,
+                                0,
+                                "s1_not_done",
+                            )
+                            continue
+                        if (str(code).zfill(6), str(sid)) in s1_done_today:
+                            logger.warning(
+                                "[REGIME_S2][SEQ] %s:%s ë™ì¼ ì¼ì S1 ì™„ë£Œ ì§í›„ S2 ì§„ì…",
+                                str(code).zfill(6),
+                                sid,
+                            )
+                        sellable_qty = ord_psbl_map.get(code, 0)
+                        remaining_strategy_stage2 = remaining_qty_for_strategy(
+                            lot_state, code, sid
+                        )
+                        guard = (
+                            _s2_guard_target(
+                                now_dt_kst.date(), code, sid, remaining_strategy_stage2
+                            )
+                            if is_target
+                            else _s2_guard_nontarget(
+                                now_dt_kst.date(), code, sid, remaining_strategy_stage2
+                            )
+                        )
+                        base_qty = int(guard.get("base_qty") or 0)
+                        if base_qty <= 0:
+                            _log_s2_action(
+                                code,
+                                sid,
+                                "SKIP",
+                                base_qty,
+                                0,
+                                int(guard.get("sold", 0)),
+                                0,
+                                0,
+                                "base_qty_zero",
+                            )
+                        else:
+                            target_qty = max(1, int(base_qty * REG_PARTIAL_S2))
+                            sold_today = int(guard.get("sold", 0))
+                            remaining = max(0, target_qty - sold_today)
+
+                            if remaining <= 0 or sellable_qty <= 0:
+                                if remaining <= 0:
+                                    _set_position_flags(code, sid, bear_s2_done=True)
+                                _log_s2_action(
+                                    code,
+                                    sid,
+                                    "SKIP",
+                                    base_qty,
+                                    target_qty,
+                                    sold_today,
+                                    remaining,
+                                    0,
+                                    "target_met" if remaining <= 0 else "no_sellable_qty",
+                                )
+                            else:
+                                sell_qty = min(
+                                    remaining, sellable_qty, remaining_strategy_stage2
+                                )
+                                sell_qty = _cap_sell_qty(code, sell_qty)
+                                if sell_qty <= 0:
+                                    _log_s2_action(
+                                        code,
+                                        sid,
+                                        "SKIP",
+                                        base_qty,
+                                        target_qty,
+                                        sold_today,
+                                        remaining,
+                                        0,
+                                        "strategy_qty_zero",
+                                    )
+                                    continue
+                                try:
+                                    prev_qty_before = int(
+                                        (holding.get(code) or {}).get("qty") or 0
+                                    )
+                                    if dry_run:
+                                        logger.info(
+                                            "[DRY-RUN][SELL] code=%s qty=%s strategy_id=%s reason=%s",
+                                            code,
+                                            sell_qty,
+                                            sid,
+                                            reason_msg,
+                                        )
+                                        runtime_state_store.mark_order(
+                                            runtime_state,
+                                            code,
+                                            "SELL",
+                                            sid,
+                                            int(sell_qty),
+                                            float(holding.get(code, {}).get("buy_price") or 0.0),
+                                            now_dt_kst.isoformat(),
+                                            status="submitted(dry)",
+                                        )
+                                        _save_runtime_state()
+                                        status, skip_reason = "SKIP", "DRY_RUN"
+                                        exec_px, result = None, {"status": "SKIPPED", "skip_reason": "DRY_RUN"}
+                                    else:
+                                        exec_px, result = _sell_once(
+                                            kis, code, sell_qty, prefer_market=True
+                                        )
+                                        runtime_state_store.mark_order(
+                                            runtime_state,
+                                            code,
+                                            "SELL",
+                                            sid,
+                                            int(sell_qty),
+                                            float(exec_px or 0.0),
+                                            now_dt_kst.isoformat(),
+                                            status="submitted",
+                                        )
+                                        _save_runtime_state()
+                                    status, skip_reason = _sell_result_status(result)
+                                except Exception as e:
+                                    exec_px, result = None, None
+                                    status, skip_reason = "ERROR", str(e)
+
+                                reason_msg = skip_reason or (
+                                    "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ"
+                                    if is_target
+                                    else "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)"
+                                )
+
+                                if status == "SENT":
+                                    guard["sold"] = sold_today + int(sell_qty)
+                                    holding[code]["qty"] = max(
+                                        0, holding[code]["qty"] - int(sell_qty)
+                                    )
+                                    if guard["sold"] >= target_qty:
+                                        _set_position_flags(code, sid, bear_s2_done=True)
+                                    _persist_guard_state(now_dt_kst.date())
+                                    log_trade(
+                                        {
+                                            "datetime": now_str,
+                                            "code": code,
+                                            "name": None,
+                                            "qty": int(sell_qty),
+                                            "K": holding[code].get("k_value"),
+                                            "target_price": holding[code].get("target_price_src"),
+                                            "strategy": "ë ˆì§ì¶•ì†Œ" if is_target else "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
+                                            "side": "SELL",
+                                            "price": exec_px,
+                                            "amount": int((exec_px or 0)) * int(sell_qty),
+                                            "result": result,
+                                            "reason": reason_msg,
+                                        }
+                                    )
+                                    _apply_sell_to_ledger_with_balance(
+                                        code,
+                                        int(sell_qty),
+                                        now_dt_kst.isoformat(),
+                                        result,
+                                        scope="strategy",
+                                        trigger_strategy_id=int(sid) if sid.isdigit() else sid,
+                                        prev_qty_before=prev_qty_before,
+                                    )
+                                    runtime_state_store.mark_fill(
+                                        runtime_state,
+                                        code,
+                                        "SELL",
+                                        sid,
+                                        int(sell_qty),
+                                        float(exec_px or 0.0),
+                                        now_dt_kst.isoformat(),
+                                        status="filled",
+                                    )
+                                    _save_runtime_state()
+                                    save_state(holding, traded)
+                                    time.sleep(RATE_SLEEP_SEC)
+                                    sellable_qty = max(0, int(sellable_qty) - int(sell_qty))
+                                elif status == "SKIP":
+                                    pass
+
+                                _log_s2_action(
+                                    code,
+                                    sid,
+                                    status,
+                                    base_qty,
+                                    target_qty,
+                                    sold_today,
+                                    remaining,
+                                    sell_qty,
+                                    reason_msg,
+                                )
+
+            if now_dt_kst.date() != pullback_buy_date:
+                pullback_buy_date = now_dt_kst.date()
+                pullback_buys_today = 0
+
+            if not is_open:
+                if not is_trading_day(now_dt_kst):
+                    logger.error("[CLOSED] ë¹„ê±°ë˜ì¼ ê°ì§€ â†’ ë£¨í”„ ì¢…ë£Œ")
+                    break
+
+                if now_dt_kst.time() < MARKET_OPEN:
+                    seconds_to_open = int(
+                        (
+                            datetime.combine(now_dt_kst.date(), MARKET_OPEN, tzinfo=KST)
+                            - now_dt_kst
+                        ).total_seconds()
+                    )
+                    sleep_for = max(1, min(seconds_to_open, 300))
+                    logger.info(
+                        "[PREOPEN] ì¥ ì‹œì‘ê¹Œì§€ %ss ë‚¨ìŒ â†’ %ss ëŒ€ê¸° í›„ ì¬í™•ì¸",
+                        seconds_to_open,
+                        sleep_for,
+                    )
+                    time.sleep(sleep_for)
+                    closed_checks = 0
+                    continue
+
+                if now_dt_kst.time() >= MARKET_CLOSE:
+                    logger.error("[CLOSED] ì¥ ë§ˆê° ì´í›„ â†’ ë£¨í”„ ì¢…ë£Œ")
+                    break
+
+                closed_checks += 1
+                if not ALLOW_WHEN_CLOSED:
+                    if closed_checks > max_closed_checks:
+                        logger.error(
+                            "[CLOSED] ì¥ ì¢…ë£Œ ë°˜ë³µ %síšŒ ì´ˆê³¼ â†’ ë£¨í”„ ì¢…ë£Œ",
+                            max_closed_checks,
+                        )
+                        break
+                    logger.info(
+                        "[CLOSED] ì¥ì¤‘ì¸ë° APIê°€ ë‹«í˜ ì‘ë‹µ â†’ 10ì´ˆ ëŒ€ê¸° í›„ ì¬í™•ì¸ (%s/%s)",
+                        closed_checks,
+                        max_closed_checks,
+                    )
+                    time.sleep(10)
+                    continue
+                else:
+                    logger.warning(
+                        "[CLOSED-DATA] ì¥ ì¢…ë£Œì§€ë§Œ í™˜ê²½ì„¤ì • í—ˆìš© â†’ ì‹œì„¸ ì¡°íšŒ í›„ ì§„í–‰"
+                    )
+            else:
+                closed_checks = 0
+
+            if kis.should_cooldown(now_dt_kst):
+                logger.warning("[COOLDOWN] 2ì´ˆê°„ ëŒ€ê¸° (API ì œí•œ ë³´í˜¸)")
+                time.sleep(2)
+
+            # ì”ê³  ê°€ì ¸ì˜¤ê¸°
+            prev_holding = holding if isinstance(holding, dict) else {}
+            balances = _fetch_balances(kis)
+            holding = {}
+            for bal in balances:
+                code = bal.get("code")
+                qty = int(bal.get("qty", 0))
+                if qty <= 0:
+                    continue
+                price = float(bal.get("avg_price", 0.0))
+                holding[code] = {
+                    "qty": qty,
+                    "buy_price": price,
+                    "bear_s1_done": False,
+                    "bear_s2_done": False,
+                }
+                _init_position_state_from_balance(kis, holding, code, price, qty)
+
+            before_lot_signature = _lot_state_signature(lot_state)
+            reconcile_with_broker_holdings(lot_state, balances)
+            _maybe_save_lot_state(before_lot_signature)
+
+            position_state = reconcile_with_broker(
+                position_state, balances, lot_state=lot_state
+            )
+            position_state_dirty = True
+
+            for code, info in holding.items():
+                pos_state = position_state.get("positions", {}).get(str(code).zfill(6))
+                if not isinstance(pos_state, dict):
+                    continue
+                strategies = pos_state.get("strategies", {})
+                if not strategies:
+                    _ensure_position_entry(code, "ORPHAN")
+                    position_state_dirty = True
+                    strategies = pos_state.get("strategies", {})
+                entry = next(iter(strategies.values()), None)
+                if not isinstance(entry, dict):
+                    continue
+                meta = entry.get("meta", {})
+                info["engine"] = entry.get("entry", {}).get("engine") or info.get("engine")
+                info["pullback_peak_price"] = meta.get("pullback_peak_price")
+                info["pullback_reversal_price"] = meta.get("pullback_reversal_price")
+
+            # ì”ê³  ê¸°ì¤€ìœ¼ë¡œ ë³´ìœ ì¢…ëª© ë§¤ë„ ê°€ëŠ¥ ìˆ˜ëŸ‰ ë§µ ìƒì„±
+            ord_psbl_map = {
+                bal.get("code"): int(bal.get("sell_psbl_qty", 0)) for bal in balances
+            }
+
+            if isinstance(traded, dict):
+                for code, payload in list(traded.items()):
+                    if (payload or {}).get("status") == "pending" and code in holding:
+                        traded[code]["status"] = "filled"
+
+            traded_today = _traded_today(traded, today_prefix)
+            for bal in balances:
                 code = bal.get("code")
                 raw = bal.get("raw") or {}
                 raw_l = {str(k).lower(): v for k, v in raw.items()}
                 thdt_buy_qty = _to_int(
                     raw_l.get("thdt_buyqty")
                     or raw_l.get("thdt_buy_qty")
                     or raw_l.get("thdt_buy_q")
                 )
                 if thdt_buy_qty > 0:
                     traded_today.add(code)
 
             if not ALLOW_PYRAMID:
                 traded_today.update(holding.keys())
 
             for code, info in list(holding.items()):
                 prev_qty = int(
                     (prev_holding.get(code) or {}).get("qty", info.get("qty", 0))
                 )
                 balance_qty = int(info.get("qty", 0))
                 # ì”ê³ ê°€ ì¼ì‹œì ìœ¼ë¡œ ì¤„ì–´ë“  ì¼€ì´ìŠ¤ë§Œ ë³´í˜¸í•˜ê³ , ì •ìƒì ì¸ ìˆ˜ëŸ‰ ì¦ê°€ëŠ” ìœ ì§€í•œë‹¤.
                 if prev_qty > 0 and 0 < balance_qty < prev_qty:
                     holding[code]["qty"] = prev_qty
                     logger.info(
                         f"[HOLDING-QTY-CLAMP] {code}: balance_qty={balance_qty} prev_qty={prev_qty} â†’ {prev_qty}"
                     )
@@ -1412,472 +1945,365 @@ def main(
                 if code in holding:
                     continue
                 buy_time_str = None
                 if isinstance(traded, dict):
                     buy_time_str = (traded.get(code) or {}).get("buy_time")
                 if buy_time_str:
                     try:
                         buy_dt = datetime.strptime(buy_time_str, "%Y-%m-%d %H:%M:%S")
                         buy_dt = buy_dt.replace(tzinfo=now_dt_kst.tzinfo)
                         if now_dt_kst - buy_dt <= timedelta(
                             minutes=recent_keep_minutes
                         ):
                             holding[code] = info
                             ord_psbl_map.setdefault(code, int(info.get("qty", 0)))
                             logger.info(
                                 f"[HOLDING-MERGE] {code} ìµœê·¼ ë§¤ìˆ˜({buy_time_str}) ë°˜ì˜ â†’ ì”ê³  ë¯¸ë°˜ì˜ ë³´í˜¸"
                             )
                     except Exception as e:
                         logger.warning(f"[HOLDING-MERGE-FAIL] {code}: {e}")
 
             logger.info(
                 f"[STATUS] holdings={holding} traded_today={sorted(traded_today)} ord_psbl={ord_psbl_map}"
             )
 
             # ì»¤íŠ¸ì˜¤í”„ íƒ€ì„ ë„ë‹¬ ì‹œ ê°•ì œë§¤ë„ ë£¨í‹´
-            if now_dt_kst.time() >= SELL_FORCE_TIME and SELL_ALL_BALANCES_AT_CUTOFF:
-                logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ë„ë‹¬: ì „ëŸ‰ë§¤ë„ ë£¨í‹´ ì‹¤í–‰]")
+            force_global_liquidation = (
+                EMERGENCY_GLOBAL_SELL
+                or (SELL_ALL_BALANCES_AT_CUTOFF and now_dt_kst.time() >= SELL_FORCE_TIME)
+            )
+            if force_global_liquidation:
+                logger.info("[â° ê°•ì œ ì „ëŸ‰ë§¤ë„ ë£¨í‹´ ì‹¤í–‰] emergency=%s cutoff=%s", EMERGENCY_GLOBAL_SELL, SELL_ALL_BALANCES_AT_CUTOFF)
                 pass_count = FORCE_SELL_PASSES_CUTOFF
                 if now_dt_kst.time() >= dtime(hour=15, minute=0):
                     pass_count = FORCE_SELL_PASSES_CLOSE
                 for code, qty in ord_psbl_map.items():
                     if qty <= 0:
                         continue
                     prev_qty_before = int((holding.get(code) or {}).get("qty") or 0)
                     qty = _cap_sell_qty(code, qty)
                     if qty <= 0:
                         continue
+                    if dry_run:
+                        logger.info(
+                            "[DRY-RUN][SELL] code=%s qty=%s strategy_id=GLOBAL reason=force_liquidation",
+                            code,
+                            qty,
+                        )
+                        runtime_state_store.mark_order(
+                            runtime_state,
+                            code,
+                            "SELL",
+                            "GLOBAL",
+                            int(qty),
+                            float(holding.get(code, {}).get("buy_price") or 0.0),
+                            now_dt_kst.isoformat(),
+                            status="submitted(dry)",
+                        )
+                        _save_runtime_state()
+                        continue
                     exec_px, result = _sell_once(kis, code, qty, prefer_market=True)
+                    runtime_state_store.mark_order(
+                        runtime_state,
+                        code,
+                        "SELL",
+                        "GLOBAL",
+                        int(qty),
+                        float(exec_px or 0.0),
+                        now_dt_kst.isoformat(),
+                        status="submitted",
+                    )
+                    _save_runtime_state()
                     log_trade(
                         {
                             "datetime": now_str,
                             "code": code,
                             "name": None,
                             "qty": int(qty),
                             "K": None,
                             "target_price": None,
                             "strategy": "ê°•ì œë§¤ë„",
                             "side": "SELL",
                             "price": exec_px,
                             "amount": int((exec_px or 0)) * int(qty),
                             "result": result,
                             "reason": "ì»¤íŠ¸ì˜¤í”„ ê°•ì œë§¤ë„",
                         }
                     )
                     _apply_sell_to_ledger_with_balance(
                         code,
                         int(qty),
                         now_dt_kst.isoformat(),
                         result,
-                        scope="proportional",
+                        scope="global",
                         trigger_strategy_id=None,
                         prev_qty_before=prev_qty_before,
                         allow_blocked=FORCE_SELL_BLOCKED_LOTS,
                     )
+                    runtime_state_store.mark_fill(
+                        runtime_state,
+                        code,
+                        "SELL",
+                        "GLOBAL",
+                        int(qty),
+                        float(exec_px or 0.0),
+                        now_dt_kst.isoformat(),
+                        status="filled",
+                    )
+                    _save_runtime_state()
                     time.sleep(RATE_SLEEP_SEC)
                 for _ in range(pass_count - 1):
                     logger.info(
                         f"[ì»¤íŠ¸ì˜¤í”„ ì¶”ê°€íŒ¨ìŠ¤] {pass_count}íšŒ ì¤‘ ë‚¨ì€ íŒ¨ìŠ¤ ì‹¤í–‰ (ì”ê³ ë³€ë™ ê°ì§€ìš©)"
                     )
-                    time.sleep(loop_sleep_sec)
-                    continue
-                logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ì¢…ë£Œ] ë£¨í”„ ì¢…ë£Œ")
-                break
-
-            # === (1) ì”ì—¬ ë¬¼ëŸ‰ ëŒ€ìƒ ìŠ¤íƒ‘/ë¦¬ë°¸ëŸ°ìŠ¤ ê´€ë¦¬ ===
-            for code in list(holding.keys()):
-                pos_state = position_state.get("positions", {}).get(str(code).zfill(6))
-                if isinstance(pos_state, dict):
-                    entries = pos_state.get("entries", {})
-                    entry_ids = ",".join(sorted(entries.keys())) if entries else "ORPHAN"
-                    entry_sample = None
-                    if entries:
-                        entry_sample = next(iter(entries.values()))
-                    entry_meta = entry_sample.get("entry", {}) if isinstance(entry_sample, dict) else {}
-                    flags = pos_state.get("flags", {}) if isinstance(pos_state, dict) else {}
-                    logger.info(
-                        "[EXIT-CHECK] code=%s strategy=%s engine=%s flags=bear_s1_done=%s bear_s2_done=%s source=state.json",
-                        str(code).zfill(6),
-                        entry_ids,
-                        entry_meta.get("engine"),
-                        flags.get("bear_s1_done", False),
-                        flags.get("bear_s2_done", False),
-                    )
-                else:
-                    logger.info(
-                        "[EXIT-CHECK] code=%s strategy=ORPHAN engine=unknown flags=bear_s1_done=False bear_s2_done=False source=ORPHAN_POSITION",
-                        str(code).zfill(6),
-                    )
-                # ì‹ ê·œ ì§„ì… ê¸ˆì§€ ëª¨ë“œ
-                if code not in code_to_target:
-                    continue
-
-                # --- 1a) ê°•ì œ ë ˆì§ë³„ ì¶•ì†Œ ë¡œì§ ---
-                sellable_qty = ord_psbl_map.get(code, 0)
-                if sellable_qty <= 0:
-                    continue
-
-                regime_key = regime.get("key")
-                mode = regime.get("mode")
-                if regime_key and regime_key[0] == "bear":
-                    if regime["bear_stage"] >= 1:
-                        sellable_qty = ord_psbl_map.get(code, 0)
-                        guard = _s1_guard_target(
-                            now_dt_kst.date(), code, holding[code].get("qty", 0)
-                        )
-                        base_qty = int(guard.get("base_qty") or 0)
-                        if base_qty <= 0:
-                            regime_s1_summary["skipped"] += 1
-                            _log_s1_action(
-                                code,
-                                "SKIP",
-                                base_qty,
-                                0,
-                                int(guard.get("sold", 0)),
-                                0,
-                                0,
-                                "base_qty_zero",
-                            )
-                        else:
-                            target_qty = max(1, int(base_qty * REG_PARTIAL_S1))
-                            sold_today = int(guard.get("sold", 0))
-                            remaining = max(0, target_qty - sold_today)
-
-                            if remaining <= 0 or sellable_qty <= 0:
-                                if remaining <= 0:
-                                    _set_position_flags(code, bear_s1_done=True)
-                                    s1_done_today.add(code)
-                                regime_s1_summary["skipped"] += 1
-                                _log_s1_action(
-                                    code,
-                                    "SKIP",
-                                    base_qty,
-                                    target_qty,
-                                    sold_today,
-                                    remaining,
-                                    0,
-                                    (
-                                        "target_met"
-                                        if remaining <= 0
-                                        else "no_sellable_qty"
-                                    ),
-                                )
-                            else:
-                                sell_qty = min(remaining, sellable_qty)
-                                sell_qty = _cap_sell_qty(code, sell_qty)
-                                if sell_qty <= 0:
-                                    regime_s1_summary["skipped"] += 1
-                                    _log_s1_action(
-                                        code,
-                                        "SKIP",
-                                        base_qty,
-                                        target_qty,
-                                        sold_today,
-                                        remaining,
-                                        0,
-                                        "strategy_qty_zero",
-                                    )
-                                    continue
-                                regime_s1_summary["total_qty"] += int(sell_qty)
-                                try:
-                                    prev_qty_before = int(
-                                        (holding.get(code) or {}).get("qty") or 0
-                                    )
-                                    exec_px, result = _sell_once(
-                                        kis, code, sell_qty, prefer_market=True
-                                    )
-                                    status, skip_reason = _sell_result_status(result)
-                                except Exception as e:
-                                    exec_px, result = None, None
-                                    status, skip_reason = "ERROR", str(e)
-
-                                reason_msg = skip_reason or "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ"
-
-                                if status == "SENT":
-                                    guard["sold"] = sold_today + int(sell_qty)
-                                    holding[code]["qty"] = max(
-                                        0, holding[code]["qty"] - int(sell_qty)
-                                    )
-                                    if guard["sold"] >= target_qty:
-                                        _set_position_flags(code, bear_s1_done=True)
-                                        s1_done_today.add(code)
-                                    _persist_guard_state(now_dt_kst.date())
-                                    regime_s1_summary["sent_qty"] += int(sell_qty)
-                                    regime_s1_summary["sent_orders"] += 1
-                                    trade_payload = {
-                                        "datetime": now_str,
-                                        "code": code,
-                                        "name": None,
-                                        "qty": int(sell_qty),
-                                        "K": holding[code].get("k_value"),
-                                        "target_price": holding[code].get(
-                                            "target_price_src"
-                                        ),
-                                        "strategy": "ë ˆì§ì¶•ì†Œ",  # ì‹ ê·œ ì „ëµ êµ¬ë¶„ì„ ìœ„í•´ strategy í•„ë“œ í™œìš©
-                                        "side": "SELL",
-                                        "price": exec_px,
-                                        "amount": int((exec_px or 0)) * int(sell_qty),
-                                        "reason": reason_msg,
-                                    }
-                                    if result is not None:
-                                        trade_payload["result"] = result
-                                    log_trade(trade_payload)
-                                    _apply_sell_to_ledger_with_balance(
-                                        code,
-                                        int(sell_qty),
-                                        now_dt_kst.isoformat(),
-                                        result,
-                                        scope="strategy",
-                                        trigger_strategy_id=_resolve_sell_sid(code),
-                                        prev_qty_before=prev_qty_before,
-                                    )
-                                    save_state(holding, traded)
-                                    time.sleep(RATE_SLEEP_SEC)
-                                elif status == "SKIP":
-                                    regime_s1_summary["skipped"] += 1
-                                else:
-                                    regime_s1_summary["skipped"] += 1
-
-                                _log_s1_action(
-                                    code,
-                                    status,
-                                    base_qty,
-                                    target_qty,
-                                    sold_today,
-                                    remaining,
-                                    sell_qty,
-                                    reason_msg,
-                                )
-
-                    if regime["bear_stage"] >= 2 and not holding[code].get(
-                        "bear_s2_done"
-                    ):
-                        if not holding[code].get("bear_s1_done"):
-                            _log_s2_action(
-                                code,
-                                "SKIP",
-                                int(holding[code].get("qty", 0)),
-                                0,
-                                0,
-                                0,
-                                0,
-                                "s1_not_done",
-                            )
-                            continue
-                        if code in s1_done_today:
-                            logger.warning(
-                                f"[REGIME_S2][SEQ] {code}: ë™ì¼ ì¼ì S1 ì™„ë£Œ ì§í›„ S2 ì§„ì…"
-                            )
-                        sellable_qty = ord_psbl_map.get(code, 0)
-                        guard = _s2_guard_target(
-                            now_dt_kst.date(), code, holding[code].get("qty", 0)
-                        )
-                        base_qty = int(guard.get("base_qty") or 0)
-                        if base_qty <= 0:
-                            _log_s2_action(
-                                code,
-                                "SKIP",
-                                base_qty,
-                                0,
-                                int(guard.get("sold", 0)),
-                                0,
-                                0,
-                                "base_qty_zero",
-                            )
-                        else:
-                            target_qty = max(1, int(base_qty * REG_PARTIAL_S2))
-                            sold_today = int(guard.get("sold", 0))
-                            remaining = max(0, target_qty - sold_today)
+                    time.sleep(loop_sleep_sec)
+                    continue
+                logger.info("[â° ì»¤íŠ¸ì˜¤í”„ ì¢…ë£Œ] ë£¨í”„ ì¢…ë£Œ")
+                break
 
-                            if remaining <= 0 or sellable_qty <= 0:
-                                if remaining <= 0:
-                                    _set_position_flags(code, bear_s2_done=True)
-                                _log_s2_action(
-                                    code,
-                                    "SKIP",
-                                    base_qty,
-                                    target_qty,
-                                    sold_today,
-                                    remaining,
-                                    0,
-                                    (
-                                        "target_met"
-                                        if remaining <= 0
-                                        else "no_sellable_qty"
-                                    ),
-                                )
-                            else:
-                                sell_qty = min(remaining, sellable_qty)
-                                sell_qty = _cap_sell_qty(code, sell_qty)
-                                if sell_qty <= 0:
-                                    _log_s2_action(
-                                        code,
-                                        "SKIP",
-                                        base_qty,
-                                        target_qty,
-                                        sold_today,
-                                        remaining,
-                                        0,
-                                        "strategy_qty_zero",
-                                    )
-                                    continue
-                                try:
-                                    prev_qty_before = int(
-                                        (holding.get(code) or {}).get("qty") or 0
-                                    )
-                                    exec_px, result = _sell_once(
-                                        kis, code, sell_qty, prefer_market=True
-                                    )
-                                    status, skip_reason = _sell_result_status(result)
-                                except Exception as e:
-                                    exec_px, result = None, None
-                                    status, skip_reason = "ERROR", str(e)
+            # === (1) ì”ì—¬ ë¬¼ëŸ‰ ëŒ€ìƒ ìŠ¤íƒ‘/ë¦¬ë°¸ëŸ°ìŠ¤ ê´€ë¦¬ ===
+            for code in list(holding.keys()):
+                pos_state = position_state.get("positions", {}).get(str(code).zfill(6))
+                if isinstance(pos_state, dict):
+                    entries = pos_state.get("strategies", {})
+                    entry_ids = ",".join(sorted(entries.keys())) if entries else "ORPHAN"
+                    logger.info(
+                        "[EXIT-CHECK] code=%s strategies=%s",
+                        str(code).zfill(6),
+                        len(entries),
+                    )
+                    if entries:
+                        for sid, entry in entries.items():
+                            if not isinstance(entry, dict):
+                                continue
+                            avg_price = strategy_avg_price(lot_state, code, sid)
+                            entry_meta = entry.get("meta", {}) or {}
+                            high = float(entry_meta.get("high") or 0.0)
+                            if avg_price is not None:
+                                high = max(high, float(avg_price))
+                            flags = entry.get("flags", {}) or {}
+                            avg_label = f"{avg_price:.2f}" if avg_price is not None else None
+                            high_label = f"{high:.2f}" if high else None
+                            logger.info(
+                                "  - sid=%s qty=%s avg=%s high=%s flags=%s",
+                                sid,
+                                entry.get("qty"),
+                                avg_label,
+                                high_label,
+                                flags,
+                            )
+                else:
+                    logger.info(
+                        "[EXIT-CHECK] code=%s strategy=ORPHAN engine=unknown flags=bear_s1_done=False bear_s2_done=False source=ORPHAN_POSITION",
+                        str(code).zfill(6),
+                    )
+                # ì‹ ê·œ ì§„ì… ê¸ˆì§€ ëª¨ë“œ
+                if code not in code_to_target:
+                    continue
 
-                                reason_msg = skip_reason or "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ"
+                # --- 1a) ê°•ì œ ë ˆì§ë³„ ì¶•ì†Œ ë¡œì§ ---
+                sellable_qty = ord_psbl_map.get(code, 0)
+                if sellable_qty <= 0:
+                    continue
 
-                                if status == "SENT":
-                                    guard["sold"] = sold_today + int(sell_qty)
-                                    holding[code]["qty"] = max(
-                                        0, holding[code]["qty"] - int(sell_qty)
-                                    )
-                                    if guard["sold"] >= target_qty:
-                                        _set_position_flags(code, bear_s2_done=True)
-                                    _persist_guard_state(now_dt_kst.date())
-                                    log_trade(
-                                        {
-                                            "datetime": now_str,
-                                            "code": code,
-                                            "name": None,
-                                            "qty": int(sell_qty),
-                                            "K": holding[code].get("k_value"),
-                                            "target_price": holding[code].get(
-                                                "target_price_src"
-                                            ),
-                                            "strategy": "ë ˆì§ì¶•ì†Œ",
-                                            "side": "SELL",
-                                            "price": exec_px,
-                                            "amount": int((exec_px or 0))
-                                            * int(sell_qty),
-                                            "result": result,
-                                            "reason": reason_msg,
-                                        }
-                                    )
-                                    _apply_sell_to_ledger_with_balance(
-                                        code,
-                                        int(sell_qty),
-                                        now_dt_kst.isoformat(),
-                                        result,
-                                        scope="strategy",
-                                        trigger_strategy_id=_resolve_sell_sid(code),
-                                        prev_qty_before=prev_qty_before,
-                                    )
-                                    save_state(holding, traded)
-                                    time.sleep(RATE_SLEEP_SEC)
-                                elif status == "SKIP":
-                                    pass
-                                _log_s2_action(
-                                    code,
-                                    status,
-                                    base_qty,
-                                    target_qty,
-                                    sold_today,
-                                    remaining,
-                                    sell_qty,
-                                    reason_msg,
-                                )
+                regime_key = regime.get("key")
+                mode = regime.get("mode")
+                if regime_key and regime_key[0] == "bear":
+                    _run_bear_reduction(code, is_target=True, regime=regime)
 
                 # --- 1b) TP/SL/íŠ¸ë ˆì¼ë§, VWAP ê°€ë“œ ---
                 try:
-                    exit_reason, exec_px, exit_result, sold_qty = _adaptive_exit(
-                        kis,
-                        code,
-                        holding[code],
-                        regime_mode=mode or "neutral",
+                    exit_intents = _build_exit_intents(
+                        code, mode or "neutral"
                     )
                 except Exception as e:
                     logger.error(f"[_adaptive_exit ì‹¤íŒ¨] {code}: {e}")
-                    exit_reason = exec_px = exit_result = sold_qty = None
+                    exit_intents = []
 
-                if sold_qty:
-                    if sold_qty <= 0:
+                for intent in exit_intents:
+                    sell_qty = int(intent.get("sell_qty") or 0)
+                    if sell_qty <= 0:
                         continue
-                    prev_qty_before = int((holding.get(code) or {}).get("qty") or 0)
-                    sold_qty = _cap_sell_qty(code, sold_qty)
-                    if sold_qty <= 0:
+                    sid = intent.get("strategy_id")
+                    sell_qty = _cap_sell_qty(code, sell_qty)
+                    if sell_qty <= 0:
+                        continue
+                    if dry_run:
+                        logger.info(
+                            "[DRY-RUN][SELL] code=%s qty=%s strategy_id=%s reason=%s",
+                            code,
+                            sell_qty,
+                            sid,
+                            intent.get("reason"),
+                        )
+                        runtime_state_store.mark_order(
+                            runtime_state,
+                            code,
+                            "SELL",
+                            sid,
+                            int(sell_qty),
+                            float(holding.get(code, {}).get("buy_price") or 0.0),
+                            now_dt_kst.isoformat(),
+                            status="submitted(dry)",
+                        )
+                        _save_runtime_state()
                         continue
+                    prev_qty_before = int((holding.get(code) or {}).get("qty") or 0)
+                    exec_px, result = _sell_once(
+                        kis, code, sell_qty, prefer_market=True
+                    )
+                    runtime_state_store.mark_order(
+                        runtime_state,
+                        code,
+                        "SELL",
+                        sid,
+                        int(sell_qty),
+                        float(exec_px or 0.0),
+                        now_dt_kst.isoformat(),
+                        status="submitted",
+                    )
+                    _save_runtime_state()
+                    log_trade(
+                        {
+                            "datetime": now_str,
+                            "code": code,
+                            "name": None,
+                            "qty": int(sell_qty),
+                            "K": None,
+                            "target_price": None,
+                            "strategy": f"adaptive_exit_{sid}",
+                            "side": "SELL",
+                            "price": exec_px,
+                            "amount": int((exec_px or 0)) * int(sell_qty),
+                            "result": result,
+                            "reason": intent.get("reason"),
+                        }
+                    )
                     _apply_sell_to_ledger_with_balance(
                         code,
-                        int(sold_qty),
+                        int(sell_qty),
                         now_dt_kst.isoformat(),
-                        exit_result,
+                        result,
                         scope="strategy",
-                        trigger_strategy_id=_resolve_sell_sid(code),
+                        trigger_strategy_id=int(sid) if sid is not None and str(sid).isdigit() else sid,
                         prev_qty_before=prev_qty_before,
                     )
+                    runtime_state_store.mark_fill(
+                        runtime_state,
+                        code,
+                        "SELL",
+                        sid,
+                        int(sell_qty),
+                        float(exec_px or 0.0),
+                        now_dt_kst.isoformat(),
+                        status="filled",
+                    )
+                    _save_runtime_state()
                     save_state(holding, traded)
                     time.sleep(RATE_SLEEP_SEC)
-                else:
+
+                if not exit_intents:
                     try:
                         current_price = _safe_get_price(kis, code)
                     except Exception:
                         current_price = None
                     if current_price and _pullback_stop_hit(code, current_price):
                         sellable_qty = ord_psbl_map.get(code, 0)
                         pb_avail = remaining_qty_for_strategy(lot_state, code, 5)
                         sell_qty = min(int(sellable_qty), int(pb_avail))
                         if sell_qty > 0:
                             prev_qty_before = int(
                                 (holding.get(code) or {}).get("qty") or 0
                             )
+                            if dry_run:
+                                logger.info(
+                                    "[DRY-RUN][SELL] code=%s qty=%s strategy_id=5 reason=pullback_reversal_break",
+                                    code,
+                                    sell_qty,
+                                )
+                                runtime_state_store.mark_order(
+                                    runtime_state,
+                                    code,
+                                    "SELL",
+                                    5,
+                                    int(sell_qty),
+                                    float(holding.get(code, {}).get("buy_price") or 0.0),
+                                    now_dt_kst.isoformat(),
+                                    status="submitted(dry)",
+                                )
+                                _save_runtime_state()
+                                continue
                             exec_px, result = _sell_once(
                                 kis, code, sell_qty, prefer_market=True
                             )
+                            runtime_state_store.mark_order(
+                                runtime_state,
+                                code,
+                                "SELL",
+                                5,
+                                int(sell_qty),
+                                float(exec_px or 0.0),
+                                now_dt_kst.isoformat(),
+                                status="submitted",
+                            )
+                            _save_runtime_state()
                             log_trade(
                                 {
                                     "datetime": now_str,
                                     "code": code,
                                     "name": None,
                                     "qty": int(sell_qty),
-                                    "K": holding[code].get("k_value"),
-                                    "target_price": holding[code].get("target_price_src"),
+                                    "K": None,
+                                    "target_price": None,
                                     "strategy": "ëˆŒë¦¼ëª© ì†ì ˆ",
                                     "side": "SELL",
                                     "price": exec_px,
                                     "amount": int((exec_px or 0)) * int(sell_qty),
                                     "result": result,
                                     "reason": "pullback_reversal_break",
                                 }
                             )
                             _apply_sell_to_ledger_with_balance(
                                 code,
                                 int(sell_qty),
                                 now_dt_kst.isoformat(),
                                 result,
                                 scope="strategy",
                                 trigger_strategy_id=5,
                                 prev_qty_before=prev_qty_before,
                             )
+                            runtime_state_store.mark_fill(
+                                runtime_state,
+                                code,
+                                "SELL",
+                                5,
+                                int(sell_qty),
+                                float(exec_px or 0.0),
+                                now_dt_kst.isoformat(),
+                                status="filled",
+                            )
+                            _save_runtime_state()
                             save_state(holding, traded)
                             time.sleep(RATE_SLEEP_SEC)
                             logger.info(
                                 "[PULLBACK-STOP] code=%s current=%s reason=reversal_break",
                                 code,
                                 current_price,
                             )
 
             # === (2) ì‹ ê·œ ì§„ì… ë¡œì§ (ì±”í”¼ì–¸) ===
             for code, info in code_to_target.items():
                 if not can_buy:
                     continue
 
                 if code in traded_today:
                     continue
 
                 if code in holding and not ALLOW_PYRAMID:
                     continue
 
                 if code in triggered_today:
                     logger.info(f"[TRIGGER-SKIP] {code}: ê¸ˆì¼ ì´ë¯¸ íŠ¸ë¦¬ê±° ë°œìƒ")
                     continue
 
                 target_qty = int(info.get("qty", 0))
                 if target_qty <= 0:
@@ -1895,107 +2321,116 @@ def main(
                 logger.info(
                     f"[TARGET] {code} qty={target_qty} tgt_px={target_price} notional={planned_notional} K={k_value}"
                 )
 
                 # [ì¤‘ë³µ ì§„ì… ë°©ì§€] ì´ë¯¸ ì£¼ë¬¸ëœ ì¢…ëª©ì¸ì§€ í™•ì¸
                 if code in traded_today:
                     logger.info(f"[SKIP] {code}: ì´ë¯¸ ê¸ˆì¼ ê±°ë˜ë¨")
                     continue
 
                 strategy_id = info.get("strategy_id") or _derive_strategy_id(info)
                 if strategy_id is not None and remaining_qty_for_strategy(
                     lot_state, code, strategy_id
                 ) > 0:
                     logger.info(
                         "[ENTRY-SKIP] already owned in ledger: code=%s sid=%s",
                         code,
                         strategy_id,
                     )
                     continue
 
                 if _pending_block(traded, code, now_dt_kst, block_sec=45):
                     logger.info(
                         f"[SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘ â†’ ì¬ì£¼ë¬¸ ë°©ì§€"
                     )
                     continue
+                if runtime_state_store.should_block_order(
+                    runtime_state, code, "BUY", now_dt_kst.isoformat()
+                ):
+                    logger.info(
+                        "[IDEMPOTENT-SKIP] %s BUY blocked within window",
+                        code,
+                    )
+                    continue
 
                 prev_price = (
                     position_state.get("memory", {})
                     .get("last_price", {})
                     .get(str(code).zfill(6))
                 )
                 if prev_price is None:
                     try:
                         cached = signals._LAST_PRICE_CACHE.get(code) or {}
                         ts = cached.get("ts")
                         if ts and (time.time() - float(ts) <= 120):
                             prev_price = cached.get("px")
                     except Exception:
                         prev_price = None
 
                 price_res = _safe_get_price(kis, code, with_source=True)
                 if isinstance(price_res, tuple):
                     current_price, price_source = price_res
                 else:
                     current_price, price_source = price_res, None
 
                 if not current_price or current_price <= 0:
                     logger.warning(f"[PRICE_FAIL] {code}: í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ")
                     continue
 
                 _update_last_price_memory(code, float(current_price), now_dt_kst.isoformat())
 
                 # === GOOD/BAD íƒ€ì  í‰ê°€ ===
                 daily_ctx = _compute_daily_entry_context(
                     kis, code, current_price, price_source
                 )
+                daily_ctx = normalize_daily_ctx(daily_ctx)
                 intra_ctx = _compute_intraday_entry_context(
                     kis, code, fast=MOM_FAST, slow=MOM_SLOW
                 )
+                intra_ctx = normalize_intraday_ctx(intra_ctx)
 
                 momentum_confirmed = bool(
                     daily_ctx.get("strong_trend")
                     or intra_ctx.get("vwap_reclaim")
                     or intra_ctx.get("range_break")
                 )
 
                 if mode == "neutral" and not (
                     info.get("champion_grade") in ("A", "B") or momentum_confirmed
                 ):
                     logger.info(
                         f"[ENTRY-SKIP] {code}: neutral ë ˆì§ì—ì„œ ë¹„ì±”í”¼ì–¸/ëª¨ë©˜í…€ ë¯¸í™•ì¸ â†’ ì‹ ê·œ ì§„ì… ë³´ë¥˜"
                     )
                     continue
 
                 setup_state = signals.evaluate_setup_gate(
                     daily_ctx, intra_ctx, regime_state=regime_state
                 )
                 if not setup_state.get("ok"):
                     logger.info(
-                        "[SETUP-BAD] %s | missing=%s reasons=%s | daily=%s intra=%s regime=%s",
+                        "[SETUP-BAD] %s | reasons=%s | daily=%s intra=%s regime=%s",
                         code,
-                        setup_state.get("missing_conditions"),
                         setup_state.get("reasons"),
                         daily_ctx,
                         intra_ctx,
                         regime_state,
                     )
                     continue
                 logger.info(
                     "[SETUP-OK] %s | daily=%s intra=%s regime=%s",
                     code,
                     daily_ctx,
                     intra_ctx,
                     regime_state,
                 )
 
                 trigger_label = "breakout_cross"
                 strategy_name = str(strategy or "").lower()
                 if "pullback" in strategy_name:
                     trigger_label = "pullback_rebound"
                 elif "close" in strategy_name:
                     trigger_label = "close_betting"
 
                 trigger_state = signals.evaluate_trigger_gate(
                     daily_ctx,
                     intra_ctx,
                     prev_price=prev_price,
@@ -2068,201 +2503,251 @@ def main(
                     "side": "BUY",
                 }
 
                 limit_px, mo_px = compute_entry_target(kis, info)
                 if limit_px is None and mo_px is None:
                     logger.warning(
                         f"[TARGET-PRICE] {code}: limit/mo ê°€ê²© ì‚°ì¶œ ì‹¤íŒ¨ â†’ ìŠ¤í‚µ"
                     )
                     continue
 
                 if (
                     limit_px
                     and abs(limit_px - current_price) / current_price * 100
                     > SLIPPAGE_LIMIT_PCT
                 ):
                     logger.info(
                         f"[SLIPPAGE_LIMIT] {code}: í˜¸ê°€ä¹–é›¢ {abs(limit_px - current_price) / current_price * 100:.2f}% â†’ ìŠ¤í‚µ"
                     )
                     continue
 
                 logger.info(
                     f"[BUY-TRY] {code}: qty={qty} limit={limit_px} mo={mo_px} target={target_price} k={k_value}"
                 )
 
                 prev_qty = int((holding.get(code) or {}).get("qty", 0))
+                if dry_run:
+                    logger.info(
+                        "[DRY-RUN][BUY] code=%s qty=%s price=%s strategy_id=%s",
+                        code,
+                        int(qty),
+                        current_price,
+                        strategy_id,
+                    )
+                    runtime_state_store.mark_order(
+                        runtime_state,
+                        code,
+                        "BUY",
+                        strategy_id,
+                        int(qty),
+                        float(current_price),
+                        now_dt_kst.isoformat(),
+                        status="submitted(dry)",
+                    )
+                    _save_runtime_state()
+                    continue
                 result = place_buy_with_fallback(
                     kis, code, qty, limit_px or _round_to_tick(current_price)
                 )
+                runtime_state_store.mark_order(
+                    runtime_state,
+                    code,
+                    "BUY",
+                    strategy_id,
+                    int(qty),
+                    float(current_price),
+                    now_dt_kst.isoformat(),
+                    status="submitted",
+                )
+                _save_runtime_state()
                 if not _is_order_success(result):
                     logger.warning(f"[BUY-FAIL] {code}: result={result}")
                     continue
 
                 triggered_today.add(code)
 
                 exec_price = _extract_fill_price(result, current_price)
                 _record_trade(
                     traded,
                     code,
                     {
                         "buy_time": now_str,
                         "qty": int(qty),
                         "price": float(exec_price),
                         "status": "pending",
                         "pending_since": now_str,
                     },
                 )
                 traded_today.add(code)
                 save_state(holding, traded)
                 if not _is_balance_reflected(code, prev_qty=prev_qty):
                     logger.warning(
                         f"[BUY-PENDING] {code}: ì”ê³ ì— ë°˜ì˜ë˜ì§€ ì•Šì•„ ìƒíƒœ ê¸°ë¡ ë³´ë¥˜(result={result})"
                     )
                     continue
                 traded[code]["status"] = "filled"
                 _record_trade(
                     traded,
                     code,
                     {
                         "buy_time": now_str,
                         "qty": int(qty),
                         "price": float(exec_price),
                         "status": "filled",
                         "pending_since": None,
                     },
                 )
+                runtime_state_store.mark_fill(
+                    runtime_state,
+                    code,
+                    "BUY",
+                    strategy_id,
+                    int(qty),
+                    float(exec_price),
+                    now_dt_kst.isoformat(),
+                    status="filled",
+                )
+                _save_runtime_state()
 
                 _init_position_state(
                     kis,
                     holding,
                     code,
                     float(exec_price),
                     int(qty),
                     k_value,
                     target_price,
                 )
                 position_state = record_entry_state(
                     state=position_state,
                     code=code,
                     qty=int(qty),
                     avg_price=float(exec_price),
                     strategy_id=strategy_id,
                     engine=trigger_label,
                     entry_reason="SETUP-OK + TRIGGER-YES",
                     order_type="marketable_limit",
                     best_k=k_value,
                     tgt_px=target_price,
                     gap_pct_at_entry=trigger_state.get("gap_pct"),
-                    flags={
-                        "bear_s1_done": holding[code].get("bear_s1_done", False),
-                        "bear_s2_done": holding[code].get("bear_s2_done", False),
-                    },
                     entry_time=now_dt_kst.isoformat(),
                 )
                 position_state_dirty = True
 
                 lot_id = _build_lot_id(
                     result,
                     now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
                     code,
                 )
                 before_lot_signature = _lot_state_signature(lot_state)
                 record_buy_fill(
                     lot_state,
                     lot_id=lot_id,
                     pdno=code,
                     strategy_id=strategy_id,
                     engine="legacy_kosdaq_runner",
                     entry_ts=now_dt_kst.isoformat(),
                     entry_price=float(exec_price),
                     qty=int(qty),
                     meta={
                         "strategy_name": strategy,
                         "entry_reason": "SETUP-OK + TRIGGER-YES",
                         "k": k_value,
                         "target_price": target_price,
                         "best_k": k_value,
                         "tgt_px": target_price,
                         "engine": "legacy_kosdaq_runner",
                         "rebalance_date": str(rebalance_date),
                     },
                 )
                 logger.info(
                     "[LEDGER][BUY] code=%s sid=%s lot_id=%s qty=%s",
                     code,
                     strategy_id,
                     lot_id,
                     qty,
                 )
                 _maybe_save_lot_state(before_lot_signature)
+                if _lot_state_signature(lot_state) == before_lot_signature:
+                    raise RuntimeError(
+                        f"[LEDGER][BUY] failed to persist lot: code={code} sid={strategy_id}"
+                    )
 
                 log_trade(
                     {
                         **trade_ctx,
                         "price": float(exec_price),
                         "amount": int(float(exec_price) * int(qty)),
                         "result": result,
                     }
                 )
                 effective_cash = _get_effective_ord_cash(
                     kis, soft_cap=effective_capital
                 )
                 if effective_cash <= 0:
                     can_buy = False
                 save_state(holding, traded)
                 time.sleep(RATE_SLEEP_SEC)
 
             # ====== ëˆŒë¦¼ëª© ì „ìš© ë§¤ìˆ˜ (ì±”í”¼ì–¸ê³¼ ë…ë¦½ì ìœ¼ë¡œ Top-N ì‹œì´ ë¦¬ìŠ¤íŠ¸ ìŠ¤ìº”) ======
             if USE_PULLBACK_ENTRY and is_open:
                 if not can_buy:
                     logger.info("[PULLBACK-SKIP] can_buy=False â†’ ì‹ ê·œ ë§¤ìˆ˜ ìŠ¤í‚µ")
                 else:
                     if pullback_watch:
                         logger.info(f"[PULLBACK-SCAN] {len(pullback_watch)}ì¢…ëª© ê²€ì‚¬")
 
                     for code, info in list(pullback_watch.items()):
                         if pullback_buys_today >= PULLBACK_MAX_BUYS_PER_DAY:
                             logger.info(
                                 f"[PULLBACK-LIMIT] í•˜ë£¨ ìµœëŒ€ {PULLBACK_MAX_BUYS_PER_DAY}ê±´ ë„ë‹¬ â†’ ìŠ¤ìº” ì¤‘ë‹¨"
                             )
                             break
 
                         if code in traded_today or code in holding:
                             continue  # ì±”í”¼ì–¸ ë£¨í”„ì™€ ë³„ë„ë¡œë§Œ ì²˜ë¦¬
 
                         if remaining_qty_for_strategy(lot_state, code, 5) > 0:
                             logger.info(
                                 "[ENTRY-SKIP] already owned in ledger: code=%s sid=5",
                                 code,
                             )
                             continue
 
                         if _pending_block(traded, code, now_dt_kst, block_sec=45):
                             logger.info(
                                 f"[PULLBACK-SKIP-PENDING] {code}: pending ì¿¨ë‹¤ìš´ ì¤‘"
                             )
                             continue
+                        if runtime_state_store.should_block_order(
+                            runtime_state, code, "BUY", now_dt_kst.isoformat()
+                        ):
+                            logger.info(
+                                "[IDEMPOTENT-SKIP] %s BUY blocked within window",
+                                code,
+                            )
+                            continue
 
                         base_notional = int(info.get("notional") or 0)
                         if base_notional <= 0:
                             logger.info(f"[PULLBACK-SKIP] {code}: ì˜ˆì‚° 0")
                             continue
 
                         try:
                             resp = _detect_pullback_reversal(
                                 kis,
                                 code,
                                 lookback=PULLBACK_LOOKBACK,
                                 pullback_days=PULLBACK_DAYS,
                                 reversal_buffer_pct=PULLBACK_REVERSAL_BUFFER_PCT,
                             )
 
                             pullback_ok = False
                             trigger_price = None
 
                             if isinstance(resp, dict):
                                 pullback_ok = bool(resp.get("setup")) and bool(
                                     resp.get("reversing")
                                 )
                                 trigger_price = resp.get("reversal_price")
                                 if not pullback_ok:
                                     reason = resp.get("reason")
@@ -2294,508 +2779,266 @@ def main(
                             logger.info(f"[PULLBACK-SKIP] {code}: ìˆ˜ëŸ‰ ì‚°ì¶œ 0")
                             continue
 
                         current_price = _safe_get_price(kis, code)
                         if not current_price:
                             logger.warning(f"[PULLBACK-PRICE] {code}: í˜„ì¬ê°€ ì¡°íšŒ ì‹¤íŒ¨")
                             continue
 
                         if trigger_price and current_price < trigger_price * 0.98:
                             logger.info(
                                 f"[PULLBACK-DELAY] {code}: ê°€ê²©ì´ íŠ¸ë¦¬ê±° ëŒ€ë¹„ 2% ì´ìƒ í•˜ë½ â†’ ëŒ€ê¸° (cur={current_price}, trigger={trigger_price})"
                             )
                             continue
 
                         flow_ok, flow_ctx, ob_strength = _subject_flow_gate(
                             code,
                             info,
                             float(current_price),
                             trigger_price,
                             None,
                         )
                         if not flow_ok:
                             continue
 
                         prev_qty = int((holding.get(code) or {}).get("qty", 0))
+                        if dry_run:
+                            logger.info(
+                                "[DRY-RUN][BUY] code=%s qty=%s price=%s strategy_id=5",
+                                code,
+                                int(qty),
+                                trigger_price or current_price,
+                            )
+                            runtime_state_store.mark_order(
+                                runtime_state,
+                                code,
+                                "BUY",
+                                5,
+                                int(qty),
+                                float(trigger_price or current_price),
+                                now_dt_kst.isoformat(),
+                                status="submitted(dry)",
+                            )
+                            _save_runtime_state()
+                            continue
                         result = place_buy_with_fallback(
                             kis,
                             code,
                             int(qty),
                             _round_to_tick(trigger_price or current_price),
                         )
+                        runtime_state_store.mark_order(
+                            runtime_state,
+                            code,
+                            "BUY",
+                            5,
+                            int(qty),
+                            float(trigger_price or current_price),
+                            now_dt_kst.isoformat(),
+                            status="submitted",
+                        )
+                        _save_runtime_state()
 
                         if not _is_order_success(result):
                             logger.warning(
                                 f"[PULLBACK-BUY-FAIL] {code}: result={result}"
                             )
                             continue
 
                         triggered_today.add(code)
                         exec_price = _extract_fill_price(
                             result, trigger_price or current_price
                         )
                         _record_trade(
                             traded,
                             code,
                             {
                                 "buy_time": now_str,
                                 "qty": int(qty),
                                 "price": float(exec_price),
                                 "status": "pending",
                                 "pending_since": now_str,
                             },
                         )
                         traded_today.add(code)
                         save_state(holding, traded)
                         if not _is_balance_reflected(code, prev_qty=prev_qty):
                             logger.warning(
                                 f"[PULLBACK-PENDING] {code}: ì”ê³ ì— ë°˜ì˜ë˜ì§€ ì•Šì•„ ìƒíƒœ ê¸°ë¡ ë³´ë¥˜(result={result})"
                             )
                             continue
 
                         traded[code]["status"] = "filled"
                         holding[code] = {
                             "qty": int(qty),
                             "buy_price": float(exec_price),
                             "bear_s1_done": False,
                             "bear_s2_done": False,
                         }
                         _record_trade(
                             traded,
                             code,
                             {
                                 "buy_time": now_str,
                                 "qty": int(qty),
                                 "price": float(exec_price),
                                 "status": "filled",
                                 "pending_since": None,
                             },
                         )
+                        runtime_state_store.mark_fill(
+                            runtime_state,
+                            code,
+                            "BUY",
+                            5,
+                            int(qty),
+                            float(exec_price),
+                            now_dt_kst.isoformat(),
+                            status="filled",
+                        )
+                        _save_runtime_state()
                         pullback_buys_today += 1
 
                         try:
                             _init_position_state(
                                 kis,
                                 holding,
                                 code,
                                 float(exec_price),
                                 int(qty),
                                 None,
                                 trigger_price,
                             )
                         except Exception as e:
                             logger.warning(f"[PULLBACK-INIT-FAIL] {code}: {e}")
 
                         pullback_meta = {}
                         if isinstance(resp, dict):
                             pullback_meta = {
                                 "pullback_peak_price": resp.get("peak_price"),
                                 "pullback_reversal_price": resp.get("reversal_price"),
                                 "pullback_reason": resp.get("reason"),
                             }
                         position_state = record_entry_state(
                             state=position_state,
                             code=code,
                             qty=int(qty),
                             avg_price=float(exec_price),
                             strategy_id=5,
                             engine="pullback",
                             entry_reason="PULLBACK-SETUP + REVERSAL",
                             order_type="marketable_limit",
                             best_k=None,
                             tgt_px=trigger_price,
                             gap_pct_at_entry=None,
                             meta=pullback_meta,
-                            flags={
-                                "bear_s1_done": holding[code].get("bear_s1_done", False),
-                                "bear_s2_done": holding[code].get("bear_s2_done", False),
-                            },
                             entry_time=now_dt_kst.isoformat(),
                         )
                         position_state_dirty = True
 
                         lot_id = _build_lot_id(
                             result,
                             now_dt_kst.strftime("%Y%m%d%H%M%S%f"),
                             code,
                         )
                         before_lot_signature = _lot_state_signature(lot_state)
                         record_buy_fill(
                             lot_state,
                             lot_id=lot_id,
                             pdno=code,
                             strategy_id=5,
                             engine="legacy_kosdaq_runner",
                             entry_ts=now_dt_kst.isoformat(),
                             entry_price=float(exec_price),
                             qty=int(qty),
                             meta={
                                 "strategy_name": f"ì½”ìŠ¤ë‹¥ Top{PULLBACK_TOPN} ëˆŒë¦¼ëª©",
                                 "entry_reason": "PULLBACK-SETUP + REVERSAL",
                                 "k": None,
                                 "target_price": trigger_price,
                                 "best_k": None,
                                 "tgt_px": trigger_price,
                                 "pullback_peak_price": resp.get("peak_price")
                                 if isinstance(resp, dict)
                                 else None,
                                 "pullback_reversal_price": resp.get("reversal_price")
                                 if isinstance(resp, dict)
                                 else None,
                                 "engine": "legacy_kosdaq_runner",
                                 "rebalance_date": str(rebalance_date),
                             },
                         )
                         logger.info(
                             "[LEDGER][BUY] code=%s sid=%s lot_id=%s qty=%s",
                             code,
                             5,
                             lot_id,
                             qty,
                         )
                         _maybe_save_lot_state(before_lot_signature)
+                        if _lot_state_signature(lot_state) == before_lot_signature:
+                            raise RuntimeError(
+                                f"[LEDGER][BUY] failed to persist lot: code={code} sid=5"
+                            )
 
                         logger.info(
                             f"[âœ… ëˆŒë¦¼ëª© ë§¤ìˆ˜] {code}, qty={qty}, price={exec_price}, trigger={trigger_price}, result={result}"
                         )
 
                         log_trade(
                             {
                                 "datetime": now_str,
                                 "code": code,
                                 "name": info.get("name"),
                                 "qty": int(qty),
                                 "K": None,
                                 "target_price": trigger_price,
                                 "strategy": f"ì½”ìŠ¤ë‹¥ Top{PULLBACK_TOPN} ëˆŒë¦¼ëª©",
                                 "strategy_id": 5,
                                 "side": "BUY",
                                 "price": float(exec_price),
                                 "amount": int(float(exec_price) * int(qty)),
                                 "result": result,
                             }
                         )
                         effective_cash = _get_effective_ord_cash(
                             kis, soft_cap=effective_capital
                         )
                         if effective_cash <= 0:
                             can_buy = False
                         save_state(holding, traded)
                         time.sleep(RATE_SLEEP_SEC)
 
             # ====== (A) ë¹„íƒ€ê²Ÿ ë³´ìœ ë¶„ë„ ì¥ì¤‘ ëŠ¥ë™ê´€ë¦¬ ======
             if is_open:
                 for code in list(holding.keys()):
                     if code in code_to_target:
                         continue  # ìœ„ ë£¨í”„ì—ì„œ ì´ë¯¸ ì²˜ë¦¬
 
                     # ì•½ì„¸ ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)
                     if regime["mode"] == "bear":
-                        sellable_here = ord_psbl_map.get(code, 0)
-                        if sellable_here > 0:
-                            if regime["bear_stage"] >= 1:
-                                guard = _s1_guard_nontarget(
-                                    now_dt_kst.date(),
-                                    code,
-                                    holding[code].get("qty", 0),
-                                )
-                                base_qty = int(guard.get("base_qty") or 0)
-                                if base_qty <= 0:
-                                    regime_s1_summary["skipped"] += 1
-                                    _log_s1_action(
-                                        code,
-                                        "SKIP",
-                                        base_qty,
-                                        0,
-                                        int(guard.get("sold", 0)),
-                                        0,
-                                        0,
-                                        "base_qty_zero",
-                                    )
-                                else:
-                                    target_qty = max(1, int(base_qty * REG_PARTIAL_S1))
-                                    sold_today = int(guard.get("sold", 0))
-                                    remaining = max(0, target_qty - sold_today)
-
-                                    if remaining <= 0 or sellable_here <= 0:
-                                        if remaining <= 0:
-                                            _set_position_flags(code, bear_s1_done=True)
-                                            s1_done_today.add(code)
-                                        regime_s1_summary["skipped"] += 1
-                                        _log_s1_action(
-                                            code,
-                                            "SKIP",
-                                            base_qty,
-                                            target_qty,
-                                            sold_today,
-                                            remaining,
-                                            0,
-                                            (
-                                                "target_met"
-                                                if remaining <= 0
-                                                else "no_sellable_qty"
-                                            ),
-                                        )
-                                    else:
-                                        sell_qty = min(remaining, sellable_here)
-                                        sell_qty = _cap_sell_qty(code, sell_qty)
-                                        if sell_qty <= 0:
-                                            regime_s1_summary["skipped"] += 1
-                                            _log_s1_action(
-                                                code,
-                                                "SKIP",
-                                                base_qty,
-                                                target_qty,
-                                                sold_today,
-                                                remaining,
-                                                0,
-                                                "strategy_qty_zero",
-                                            )
-                                            continue
-                                        regime_s1_summary["total_qty"] += int(sell_qty)
-                                        try:
-                                            prev_qty_before = int(
-                                                (holding.get(code) or {}).get("qty")
-                                                or 0
-                                            )
-                                            exec_px, result = _sell_once(
-                                                kis, code, sell_qty, prefer_market=True
-                                            )
-                                            status, skip_reason = _sell_result_status(
-                                                result
-                                            )
-                                        except Exception as e:
-                                            exec_px, result = None, None
-                                            status, skip_reason = "ERROR", str(e)
-
-                                        reason_msg = (
-                                            skip_reason or "ì‹œì¥ì•½ì„¸ 1ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)"
-                                        )
-
-                                        if status == "SENT":
-                                            guard["sold"] = sold_today + int(sell_qty)
-                                            holding[code]["qty"] = max(
-                                                0, holding[code]["qty"] - int(sell_qty)
-                                            )
-                                            if guard["sold"] >= target_qty:
-                                                _set_position_flags(code, bear_s1_done=True)
-                                                s1_done_today.add(code)
-                                            _persist_guard_state(now_dt_kst.date())
-                                            regime_s1_summary["sent_qty"] += int(
-                                                sell_qty
-                                            )
-                                            regime_s1_summary["sent_orders"] += 1
-                                            trade_payload = {
-                                                "datetime": now_str,
-                                                "code": code,
-                                                "name": None,
-                                                "qty": int(sell_qty),
-                                                "K": holding[code].get("k_value"),
-                                                "target_price": holding[code].get(
-                                                    "target_price_src"
-                                                ),
-                                                "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
-                                                "side": "SELL",
-                                                "price": exec_px,
-                                                "amount": int((exec_px or 0))
-                                                * int(sell_qty),
-                                                "reason": reason_msg,
-                                            }
-                                            if result is not None:
-                                                trade_payload["result"] = result
-                                            log_trade(trade_payload)
-                                            _apply_sell_to_ledger_with_balance(
-                                                code,
-                                                int(sell_qty),
-                                                now_dt_kst.isoformat(),
-                                                result,
-                                                scope="strategy",
-                                                trigger_strategy_id=_resolve_sell_sid(code),
-                                                prev_qty_before=prev_qty_before,
-                                            )
-                                            save_state(holding, traded)
-                                            time.sleep(RATE_SLEEP_SEC)
-                                        elif status == "SKIP":
-                                            regime_s1_summary["skipped"] += 1
-                                        else:
-                                            regime_s1_summary["skipped"] += 1
-
-                                        _log_s1_action(
-                                            code,
-                                            status,
-                                            base_qty,
-                                            target_qty,
-                                            sold_today,
-                                            remaining,
-                                            sell_qty,
-                                            reason_msg,
-                                        )
-
-                            if regime["bear_stage"] >= 2 and not holding[code].get(
-                                "bear_s2_done"
-                            ):
-                                if not holding[code].get("bear_s1_done"):
-                                    _log_s2_action(
-                                        code,
-                                        "SKIP",
-                                        int(holding[code].get("qty", 0)),
-                                        0,
-                                        0,
-                                        0,
-                                        0,
-                                        "s1_not_done",
-                                    )
-                                    continue
-                                if code in s1_done_today:
-                                    logger.warning(
-                                        f"[REGIME_S2][SEQ] {code}: ë™ì¼ ì¼ì S1 ì™„ë£Œ ì§í›„ S2 ì§„ì…"
-                                    )
-                                sellable_here = ord_psbl_map.get(code, 0)
-                                guard = _s2_guard_nontarget(
-                                    now_dt_kst.date(),
-                                    code,
-                                    holding[code].get("qty", 0),
-                                )
-                                base_qty = int(guard.get("base_qty") or 0)
-                                if base_qty <= 0:
-                                    _log_s2_action(
-                                        code,
-                                        "SKIP",
-                                        base_qty,
-                                        0,
-                                        int(guard.get("sold", 0)),
-                                        0,
-                                        0,
-                                        "base_qty_zero",
-                                    )
-                                else:
-                                    target_qty = max(1, int(base_qty * REG_PARTIAL_S2))
-                                    sold_today = int(guard.get("sold", 0))
-                                    remaining = max(0, target_qty - sold_today)
-
-                                    if remaining <= 0 or sellable_here <= 0:
-                                        if remaining <= 0:
-                                            _set_position_flags(code, bear_s2_done=True)
-                                        _log_s2_action(
-                                            code,
-                                            "SKIP",
-                                            base_qty,
-                                            target_qty,
-                                            sold_today,
-                                            remaining,
-                                            0,
-                                            (
-                                                "target_met"
-                                                if remaining <= 0
-                                                else "no_sellable_qty"
-                                            ),
-                                        )
-                                    else:
-                                        sell_qty = min(remaining, sellable_here)
-                                        sell_qty = _cap_sell_qty(code, sell_qty)
-                                        if sell_qty <= 0:
-                                            _log_s2_action(
-                                                code,
-                                                "SKIP",
-                                                base_qty,
-                                                target_qty,
-                                                sold_today,
-                                                remaining,
-                                                0,
-                                                "strategy_qty_zero",
-                                            )
-                                            continue
-                                        try:
-                                            prev_qty_before = int(
-                                                (holding.get(code) or {}).get("qty")
-                                                or 0
-                                            )
-                                            exec_px, result = _sell_once(
-                                                kis, code, sell_qty, prefer_market=True
-                                            )
-                                            status, skip_reason = _sell_result_status(
-                                                result
-                                            )
-                                        except Exception as e:
-                                            exec_px, result = None, None
-                                            status, skip_reason = "ERROR", str(e)
-
-                                        reason_msg = (
-                                            skip_reason or "ì‹œì¥ì•½ì„¸ 2ë‹¨ê³„ ì¶•ì†Œ(ë¹„íƒ€ê²Ÿ)"
-                                        )
-
-                                        if status == "SENT":
-                                            guard["sold"] = sold_today + int(sell_qty)
-                                            holding[code]["qty"] = max(
-                                                0, holding[code]["qty"] - int(sell_qty)
-                                            )
-                                            if guard["sold"] >= target_qty:
-                                                _set_position_flags(code, bear_s2_done=True)
-                                            _persist_guard_state(now_dt_kst.date())
-                                            log_trade(
-                                                {
-                                                    "datetime": now_str,
-                                                    "code": code,
-                                                    "name": None,
-                                                    "qty": int(sell_qty),
-                                                    "K": holding[code].get("k_value"),
-                                                    "target_price": holding[code].get(
-                                                        "target_price_src"
-                                                    ),
-                                                    "strategy": "ê¸°ì¡´ë³´ìœ  ëŠ¥ë™ê´€ë¦¬",
-                                                    "side": "SELL",
-                                                    "price": exec_px,
-                                                    "amount": int((exec_px or 0))
-                                                    * int(sell_qty),
-                                                    "result": result,
-                                                    "reason": reason_msg,
-                                                }
-                                            )
-                                            _apply_sell_to_ledger_with_balance(
-                                                code,
-                                                int(sell_qty),
-                                                now_dt_kst.isoformat(),
-                                                result,
-                                                scope="strategy",
-                                                trigger_strategy_id=_resolve_sell_sid(code),
-                                                prev_qty_before=prev_qty_before,
-                                            )
-                                            save_state(holding, traded)
-                                            time.sleep(RATE_SLEEP_SEC)
-                                        elif status == "SKIP":
-                                            pass
-
-                                        _log_s2_action(
-                                            code,
-                                            status,
-                                            base_qty,
-                                            target_qty,
-                                            sold_today,
-                                            remaining,
-                                            sell_qty,
-                                            reason_msg,
-                                        )
+                        _run_bear_reduction(code, is_target=False, regime=regime)
 
                     try:
                         momentum_intact, trend_ctx = _has_bullish_trend_structure(
                             kis, code
                         )
                     except NetTemporaryError:
                         logger.warning(
                             f"[20D_TREND_TEMP_SKIP] {code}: ë„¤íŠ¸ì›Œí¬ ì¼ì‹œ ì‹¤íŒ¨ â†’ ì´ë²ˆ ë£¨í”„ ìŠ¤í‚µ"
                         )
                         continue
                     except DataEmptyError:
                         logger.warning(
                             f"[DATA_EMPTY] {code}: 0ìº”ë“¤ â†’ ë‹¤ìŒ ë£¨í”„ì—ì„œ ì¬í™•ì¸"
                         )
                         continue
                     except DataShortError:
                         logger.error(
                             f"[DATA_SHORT] {code}: 21ê°œ ë¯¸ë§Œ â†’ ì´ë²ˆ ë£¨í”„ íŒë‹¨ ìŠ¤í‚µ"
                         )
                         continue
 
                     if momentum_intact:
                         logger.info(
                             (
                                 f"[ëª¨ë©˜í…€ ë³´ìœ ] {code}: 5/10/20 ì •ë°°ì—´ & 20ì¼ì„  ìƒìŠ¹ & ì¢…ê°€>20ì¼ì„  ìœ ì§€ "
diff --git a/trader/position_state_store.py b/trader/position_state_store.py
index 8e9cfadc3950999188662920c4fd44671ecc9aff..650ec9a33134bee89c1c4c20ba63b81511d36b1c 100644
--- a/trader/position_state_store.py
+++ b/trader/position_state_store.py
@@ -1,100 +1,195 @@
 from __future__ import annotations
 
 import json
 import logging
 import os
 from datetime import datetime
 from pathlib import Path
 from typing import Any, Dict, Iterable
 
 from .config import KST
 
 logger = logging.getLogger(__name__)
 
-SCHEMA_VERSION = 1
+SCHEMA_VERSION = 2
 
 
 def _empty_state() -> Dict[str, Any]:
     return {
         "schema_version": SCHEMA_VERSION,
         "updated_at": None,
         "positions": {},
         "memory": {"last_price": {}, "last_seen": {}},
     }
 
 
 def _coerce_state(state: Dict[str, Any]) -> Dict[str, Any]:
     if not isinstance(state, dict):
         return _empty_state()
-    state.setdefault("schema_version", SCHEMA_VERSION)
+    state["schema_version"] = SCHEMA_VERSION
     state.setdefault("updated_at", None)
     positions = state.get("positions")
     if not isinstance(positions, dict):
         positions = {}
         state["positions"] = positions
     memory = state.get("memory")
     if not isinstance(memory, dict):
         memory = {}
         state["memory"] = memory
     memory.setdefault("last_price", {})
     memory.setdefault("last_seen", {})
-    for code, payload in positions.items():
+    for code, payload in list(positions.items()):
         if not isinstance(payload, dict):
-            positions[code] = {
-                "entries": {},
-                "broker_qty": None,
-                "broker_avg_price": None,
-                "miss_count": 0,
-            }
+            positions[code] = {"strategies": {}}
+            continue
+        if "strategies" not in payload and "entries" in payload:
+            entries = payload.get("entries") or {}
+            flags = payload.get("flags") or {}
+            strategies: Dict[str, Any] = {}
+            if isinstance(entries, dict):
+                for sid, entry in entries.items():
+                    if not isinstance(entry, dict):
+                        continue
+                    strategies[str(sid)] = {
+                        "qty": int(entry.get("qty") or 0),
+                        "avg_price": float(entry.get("avg_price") or 0.0),
+                        "entry": entry.get("entry") or {},
+                        "meta": entry.get("meta") or {},
+                        "flags": {
+                            "bear_s1_done": bool(flags.get("bear_s1_done", False)),
+                            "bear_s2_done": bool(flags.get("bear_s2_done", False)),
+                            "sold_p1": bool(entry.get("sold_p1", False)),
+                            "sold_p2": bool(entry.get("sold_p2", False)),
+                        },
+                    }
+            positions[code] = {"strategies": strategies}
+        else:
+            payload.setdefault("strategies", {})
+        strategies = positions[code].get("strategies")
+        if not isinstance(strategies, dict):
+            positions[code]["strategies"] = {}
+            strategies = positions[code]["strategies"]
+        for sid, entry in list(strategies.items()):
+            if not isinstance(entry, dict):
+                strategies.pop(sid, None)
+                continue
+            entry.setdefault("qty", 0)
+            entry.setdefault("avg_price", 0.0)
+            entry.setdefault("entry", {})
+            entry.setdefault("meta", {})
+            meta = entry["meta"]
+            avg_price = float(entry.get("avg_price") or 0.0)
+            if not meta.get("high") or float(meta.get("high") or 0.0) <= 0:
+                meta["high"] = avg_price
+            meta["high"] = max(float(meta.get("high") or 0.0), avg_price)
+            entry.setdefault(
+                "flags",
+                {"bear_s1_done": False, "bear_s2_done": False, "sold_p1": False, "sold_p2": False},
+            )
+    return state
+
+
+def migrate_position_state(state: Dict[str, Any]) -> Dict[str, Any]:
+    if not isinstance(state, dict):
+        return _empty_state()
+    schema_version = int(state.get("schema_version") or 1)
+    if schema_version >= SCHEMA_VERSION:
+        return state
+    positions = state.get("positions")
+    if not isinstance(positions, dict):
+        state["positions"] = {}
+        state["schema_version"] = SCHEMA_VERSION
+        return state
+    for code, payload in list(positions.items()):
+        if not isinstance(payload, dict):
+            positions[code] = {"strategies": {}}
             continue
-        payload.setdefault("entries", {})
-        payload.setdefault("flags", {"bear_s1_done": False, "bear_s2_done": False})
-        payload.setdefault("broker_qty", None)
-        payload.setdefault("broker_avg_price", None)
-        payload.setdefault("miss_count", 0)
+        if "strategies" in payload:
+            continue
+        entries = payload.get("entries") or {}
+        legacy_flags = payload.get("flags") or {}
+        strategies: Dict[str, Any] = {}
+        if isinstance(entries, dict) and entries:
+            for sid, entry in entries.items():
+                if not isinstance(entry, dict):
+                    continue
+                entry_meta = entry.get("meta") or {}
+                avg_price = float(entry.get("avg_price") or 0.0)
+                entry_meta.setdefault("high", avg_price)
+                entry_meta["high"] = max(float(entry_meta.get("high") or 0.0), avg_price)
+                strategies[str(sid)] = {
+                    "qty": int(entry.get("qty") or 0),
+                    "avg_price": avg_price,
+                    "entry": entry.get("entry") or {},
+                    "meta": entry_meta,
+                    "flags": {
+                        "bear_s1_done": bool(legacy_flags.get("bear_s1_done", False)),
+                        "bear_s2_done": bool(legacy_flags.get("bear_s2_done", False)),
+                        "sold_p1": bool(entry.get("sold_p1", False)),
+                        "sold_p2": bool(entry.get("sold_p2", False)),
+                    },
+                }
+        else:
+            strategies["1"] = {
+                "qty": 0,
+                "avg_price": 0.0,
+                "entry": {},
+                "meta": {"high": 0.0},
+                "flags": {
+                    "bear_s1_done": bool(legacy_flags.get("bear_s1_done", False)),
+                    "bear_s2_done": bool(legacy_flags.get("bear_s2_done", False)),
+                    "sold_p1": False,
+                    "sold_p2": False,
+                },
+            }
+        positions[code] = {"strategies": strategies}
+    state["schema_version"] = SCHEMA_VERSION
     return state
 
 
 def _backup_corrupt(path: Path) -> None:
     timestamp = datetime.now(KST).strftime("%Y%m%d%H%M%S")
     backup = path.with_name(f"{path.name}.broken-{timestamp}")
     try:
         os.replace(path, backup)
     except Exception:
         logger.exception("[STATE] failed to backup corrupt file: %s", path)
 
 
 def load_position_state(path: str) -> Dict[str, Any]:
     path_obj = Path(path)
     if not path_obj.exists():
         logger.info("[STATE] no file, start fresh path=%s", path_obj)
         return _empty_state()
     try:
         with open(path_obj, "r", encoding="utf-8") as f:
             payload = json.load(f)
-        state = _coerce_state(payload)
+        migrated = migrate_position_state(payload)
+        state = _coerce_state(migrated)
+        if int(payload.get("schema_version") or 1) < SCHEMA_VERSION:
+            save_position_state(path, state)
         logger.info(
             "[STATE] loaded path=%s positions=%s updated_at=%s",
             path_obj,
             len(state.get("positions", {})),
             state.get("updated_at"),
         )
         return state
     except json.JSONDecodeError:
         logger.warning("[STATE] corrupted json, backing up: %s", path_obj)
         _backup_corrupt(path_obj)
         return _empty_state()
     except Exception:
         logger.exception("[STATE] failed to load %s", path_obj)
         return _empty_state()
 
 
 def save_position_state(path: str, state: Dict[str, Any]) -> None:
     path_obj = Path(path)
     try:
         path_obj.parent.mkdir(parents=True, exist_ok=True)
         payload = _coerce_state(dict(state))
         payload["updated_at"] = datetime.now(KST).isoformat()
         tmp_path = path_obj.with_name(f"{path_obj.name}.tmp")
         with open(tmp_path, "w", encoding="utf-8") as f:
             json.dump(payload, f, ensure_ascii=False, indent=2)
@@ -110,95 +205,173 @@ def _normalize_code(value: Any) -> str:
 
 def _orphan_entry(code: str, qty: int, avg_price: float | None) -> Dict[str, Any]:
     now_ts = datetime.now(KST).isoformat()
     return {
         "qty": int(qty),
         "avg_price": float(avg_price or 0.0),
         "entry": {
             "time": now_ts,
             "strategy_id": "ORPHAN",
             "engine": "unknown",
             "entry_reason": "RECONCILE",
             "order_type": "unknown",
             "best_k": None,
             "tgt_px": None,
             "gap_pct_at_entry": None,
         },
         "meta": {
             "pullback_peak_price": None,
             "pullback_reversal_price": None,
             "pullback_reason": None,
         },
     }
 
 
 def reconcile_with_broker(
-    state: Dict[str, Any], broker_positions: Iterable[Dict[str, Any]]
+    state: Dict[str, Any],
+    broker_positions: Iterable[Dict[str, Any]],
+    *,
+    lot_state: Dict[str, Any],
 ) -> Dict[str, Any]:
+    from .ledger import remaining_qty_for_strategy
+
     state = _coerce_state(state)
     positions = state["positions"]
     memory = state["memory"]
 
     broker_map: Dict[str, Dict[str, Any]] = {}
     for row in broker_positions:
         code = _normalize_code(row.get("code") or row.get("pdno") or "")
         if not code:
             continue
         qty = int(row.get("qty") or 0)
         if qty <= 0:
             continue
         broker_map[code] = {
             "qty": qty,
             "avg_price": row.get("avg_price"),
         }
 
-    for code, payload in broker_map.items():
-        qty = int(payload.get("qty") or 0)
-        avg_price = payload.get("avg_price")
-        if code not in positions:
-            positions[code] = {
-                "entries": {},
-                "flags": {"bear_s1_done": False, "bear_s2_done": False},
-                "broker_qty": int(qty),
-                "broker_avg_price": float(avg_price or 0.0),
-                "miss_count": 0,
-            }
+    def _strategies_for_code(code: str) -> Dict[str, int]:
+        strategies: Dict[str, int] = {}
+        lots = lot_state.get("lots", [])
+        if not isinstance(lots, list):
+            return strategies
+        for lot in lots:
+            if _normalize_code(lot.get("pdno")) != code:
+                continue
+            remaining = int(lot.get("remaining_qty") or 0)
+            if remaining <= 0:
+                continue
+            sid = lot.get("strategy_id")
+            if sid is None:
+                continue
+            key = str(sid)
+            strategies[key] = strategies.get(key, 0) + remaining
+        return strategies
+
+    active_codes = set()
+    for code in set(list(broker_map.keys()) + list(positions.keys())):
+        code_key = _normalize_code(code)
+        strategies = _strategies_for_code(code_key)
+        if not strategies and broker_map.get(code_key):
+            orphan_qty = int(broker_map[code_key].get("qty") or 0)
+            if orphan_qty > 0:
+                strategies = {"ORPHAN": orphan_qty}
+                logger.warning(
+                    "[STATE] broker has qty but ledger empty: code=%s qty=%s -> ORPHAN",
+                    code_key,
+                    orphan_qty,
+                )
+        if not strategies:
+            positions.pop(code_key, None)
+            memory.get("last_price", {}).pop(code_key, None)
+            memory.get("last_seen", {}).pop(code_key, None)
             continue
-        pos = positions[code]
-        pos["broker_qty"] = int(qty)
-        pos["broker_avg_price"] = (
-            float(avg_price) if avg_price is not None else pos.get("broker_avg_price")
-        )
-        pos["miss_count"] = 0
+
+        pos = positions.setdefault(code_key, {"strategies": {}})
+        entries = pos.setdefault("strategies", {})
+        for sid, entry in list(entries.items()):
+            if sid not in strategies:
+                entries.pop(sid, None)
+                continue
+            if not isinstance(entry, dict):
+                entries.pop(sid, None)
+                continue
+            ledger_qty = int(remaining_qty_for_strategy(lot_state, code_key, sid))
+            if int(entry.get("qty") or 0) > ledger_qty:
+                logger.warning(
+                    "[STATE] qty exceeds ledger: code=%s sid=%s state=%s ledger=%s",
+                    code_key,
+                    sid,
+                    entry.get("qty"),
+                    ledger_qty,
+                )
+                entry["qty"] = int(ledger_qty)
+
+        for sid, qty in strategies.items():
+            entry = entries.get(sid)
+            if not isinstance(entry, dict):
+                if sid == "ORPHAN":
+                    entry = _orphan_entry(
+                        code_key, qty, broker_map.get(code_key, {}).get("avg_price")
+                    )
+                else:
+                    now_ts = datetime.now(KST).isoformat()
+                    entry = {
+                        "qty": int(qty),
+                        "avg_price": float(
+                            broker_map.get(code_key, {}).get("avg_price") or 0.0
+                        ),
+                        "entry": {
+                            "time": now_ts,
+                            "strategy_id": sid,
+                            "engine": "reconcile",
+                            "entry_reason": "RECONCILE",
+                            "order_type": "unknown",
+                            "best_k": None,
+                            "tgt_px": None,
+                            "gap_pct_at_entry": None,
+                        },
+                        "meta": {},
+                    }
+                entry["flags"] = {
+                    "bear_s1_done": False,
+                    "bear_s2_done": False,
+                    "sold_p1": False,
+                    "sold_p2": False,
+                }
+                entries[sid] = entry
+            entry["qty"] = int(qty)
+        active_codes.add(code_key)
 
     for code in list(positions.keys()):
-        if code in broker_map:
-            continue
-        pos = positions.get(code) or {}
-        miss_count = int(pos.get("miss_count") or 0) + 1
-        pos["miss_count"] = miss_count
-        positions[code] = pos
-        if miss_count >= 3:
+        if code not in active_codes:
             positions.pop(code, None)
             memory.get("last_price", {}).pop(code, None)
             memory.get("last_seen", {}).pop(code, None)
 
     return state
 
 
 def run_reconcile_self_checks() -> None:
     state = _empty_state()
+    lot_state = {
+        "lots": [{"pdno": "000001", "strategy_id": 1, "remaining_qty": 5}]
+    }
     state["positions"]["000001"] = {
-        "entries": {},
-        "flags": {"bear_s1_done": True, "bear_s2_done": False},
-        "broker_qty": 5,
-        "broker_avg_price": 100.0,
-        "miss_count": 2,
+        "strategies": {
+            "1": {
+                "qty": 7,
+                "avg_price": 100.0,
+                "entry": {},
+                "meta": {},
+                "flags": {},
+            }
+        }
     }
-    state = reconcile_with_broker(state, [])
-    assert state["positions"]["000001"]["miss_count"] == 3
-    state = reconcile_with_broker(state, [])
-    assert "000001" not in state["positions"]
+    state = reconcile_with_broker(state, [], lot_state=lot_state)
+    assert state["positions"]["000001"]["strategies"]["1"]["qty"] == 5
 
 
 if __name__ == "__main__":
     run_reconcile_self_checks()
diff --git a/trader/signals.py b/trader/signals.py
index b42a5bb1e4ac7fae00de25e0f14d67e1153000c6..54e37114989e8666d1685cb3872fdc68c90b14bf 100644
--- a/trader/signals.py
+++ b/trader/signals.py
@@ -727,54 +727,51 @@ def is_bad_entry(
             " / ".join(reasons),
             daily_ctx,
             intraday_ctx,
             regime_state,
         )
         return True
 
     logger.info(
         "[ENTRY-OK] %s | daily=%s intra=%s regime=%s",
         code,
         daily_ctx,
         intraday_ctx,
         regime_state,
     )
     return False
 
 
 def evaluate_setup_gate(
     daily_ctx: Dict[str, Any],
     intraday_ctx: Dict[str, Any],
     regime_state: Optional[Dict[str, Any]] = None,
 ) -> Dict[str, Any]:
     missing_conditions: List[str] = []
     reasons = _collect_bad_entry_reasons(daily_ctx, intraday_ctx, regime_state)
 
-    if not daily_ctx.get("setup_ok"):
-        missing_conditions.append("setup_flag")
-
-    ok = not missing_conditions and not reasons
+    ok = bool(daily_ctx.get("setup_ok")) and not reasons
     return {
         "ok": ok,
         "missing_conditions": missing_conditions,
         "reasons": reasons,
     }
 
 
 def evaluate_trigger_gate(
     daily_ctx: Dict[str, Any],
     intraday_ctx: Dict[str, Any],
     *,
     prev_high: Optional[float] = None,
     prev_price: Optional[float] = None,
     target_price: Optional[float] = None,
     trigger_name: str = "breakout_cross",
 ) -> Dict[str, Any]:
     missing_conditions: List[str] = []
     signals: List[str] = []
 
     cur_px = _to_float(daily_ctx.get("current_price"), None)
     atr = _to_float(daily_ctx.get("atr"), 0.0)
     ma_risk = _to_float(daily_ctx.get("ma20_risk"), 0.0)
     risk = max(atr, ma_risk, (cur_px or 0) * 0.03)
     reward = max(0.0, (daily_ctx.get("peak_price") or 0) - (cur_px or 0)) + atr
     risk_reward = reward / risk if risk else None
@@ -795,53 +792,50 @@ def evaluate_trigger_gate(
         except Exception:
             gap_pct = None
 
     crossed = False
     prev_ref = prev_price
     if prev_ref is None:
         prev_ref = _to_float(daily_ctx.get("prev_close"), None)
         if prev_ref is None and require_cross:
             missing_conditions.append("no_prev_price")
     if require_cross and target_price and cur_px is not None:
         try:
             if prev_ref is not None:
                 crossed = (
                     float(prev_ref) < float(target_price)
                     and float(cur_px) >= float(target_price)
                 )
             else:
                 crossed = False
         except Exception:
             crossed = False
         if not crossed:
             missing_conditions.append("no_cross")
 
     ok = False
     if trigger_name == "pullback_rebound":
-        if not daily_ctx.get("setup_ok"):
-            missing_conditions.append("setup_flag")
-
         pullback = _to_float(daily_ctx.get("pullback_depth_pct"), None)
         if pullback is None:
             missing_conditions.append("pullback_depth")
         elif not (
             GOOD_ENTRY_PULLBACK_RANGE[0] <= pullback <= GOOD_ENTRY_PULLBACK_RANGE[1]
         ):
             missing_conditions.append("pullback_range")
 
         reversal_signals = [
             name
             for name in ("vwap", "range", "volume", "prev_high")
             if name in signals
         ]
         if not reversal_signals:
             missing_conditions.append("reversal_signal")
 
         ok = not missing_conditions and bool(reversal_signals)
 
     elif trigger_name == "close_betting":
         if not daily_ctx.get("strong_trend") and not intraday_ctx.get("vwap_reclaim"):
             missing_conditions.append("trend_confirm")
 
         if not signals:
             missing_conditions.append("intraday_signal")
 
@@ -1164,26 +1158,25 @@ def _notional_to_qty(
         try:
             if kis.is_market_open():
                 price = _safe_get_price(kis, code)
             else:
                 if hasattr(kis, "get_close_price"):
                     try:
                         price = float(kis.get_close_price(code))
                     except Exception:
                         price = None
         except Exception:
             price = None
 
     if price is None or price <= 0:
         return 0
 
     return max(0, int(notional // int(price)))
 # === ATR, ìƒíƒœ ì´ˆê¸°í™” ===
 def _get_atr(kis: KisAPI, code: str, window: int = 14) -> Optional[float]:
     if hasattr(kis, "get_atr"):
         try:
             return kis.get_atr(code, window=window)
         except Exception as e:
             logger.warning(f"[ATR_FAIL] {code}: {e}")
             return None
     return None
-
diff --git a/trader/state_store.py b/trader/state_store.py
index 253a2a8f2cbce79a377afb8cb227ece079ddd43f..1c219798a04f6d6a2eafa9c0fdf1821fb9ab4180 100644
--- a/trader/state_store.py
+++ b/trader/state_store.py
@@ -1,53 +1,246 @@
 from __future__ import annotations
 
 import json
 import logging
 import os
 from datetime import datetime
 from pathlib import Path
 from typing import Any, Dict
 
 from .config import KST
 
 logger = logging.getLogger(__name__)
 
 SCHEMA_VERSION = 1
+RUNTIME_STATE_DIR = Path(".runtime")
+RUNTIME_STATE_PATH = RUNTIME_STATE_DIR / "state.json"
 
 
-def _default_state() -> Dict[str, Any]:
+def _default_runtime_state() -> Dict[str, Any]:
+    return {
+        "schema_version": SCHEMA_VERSION,
+        "updated_at": None,
+        "positions": {},
+        "orders": {},
+    }
+
+
+def load_state() -> Dict[str, Any]:
+    if not RUNTIME_STATE_PATH.exists():
+        return _default_runtime_state()
+    try:
+        with open(RUNTIME_STATE_PATH, "r", encoding="utf-8") as f:
+            state = json.load(f)
+        if not isinstance(state, dict):
+            logger.warning("[RUNTIME_STATE] invalid state format: %s", type(state))
+            return _default_runtime_state()
+        state.setdefault("schema_version", SCHEMA_VERSION)
+        state.setdefault("positions", {})
+        state.setdefault("orders", {})
+        state.setdefault("updated_at", None)
+        return state
+    except Exception:
+        logger.exception("[RUNTIME_STATE] failed to load %s", RUNTIME_STATE_PATH)
+        return _default_runtime_state()
+
+
+def save_state(state: Dict[str, Any]) -> None:
+    try:
+        RUNTIME_STATE_DIR.mkdir(parents=True, exist_ok=True)
+        payload = dict(state)
+        payload.setdefault("schema_version", SCHEMA_VERSION)
+        payload.setdefault("positions", {})
+        payload.setdefault("orders", {})
+        payload["updated_at"] = datetime.now(KST).isoformat()
+        tmp_path = RUNTIME_STATE_PATH.with_name(f"{RUNTIME_STATE_PATH.name}.tmp")
+        with open(tmp_path, "w", encoding="utf-8") as f:
+            json.dump(payload, f, ensure_ascii=False, indent=2)
+        os.replace(tmp_path, RUNTIME_STATE_PATH)
+    except Exception:
+        logger.exception("[RUNTIME_STATE] failed to save %s", RUNTIME_STATE_PATH)
+
+
+def get_position(state: Dict[str, Any], symbol: str) -> Dict[str, Any] | None:
+    positions = state.get("positions", {})
+    if not isinstance(positions, dict):
+        return None
+    return positions.get(str(symbol).zfill(6))
+
+
+def upsert_position(state: Dict[str, Any], symbol: str, fields: Dict[str, Any]) -> None:
+    positions = state.setdefault("positions", {})
+    key = str(symbol).zfill(6)
+    pos = positions.setdefault(key, {})
+    for field, value in fields.items():
+        pos[field] = value
+
+
+def _order_bucket(state: Dict[str, Any], symbol: str, side: str) -> Dict[str, Any]:
+    orders = state.setdefault("orders", {})
+    symbol_key = str(symbol).zfill(6)
+    symbol_bucket = orders.setdefault(symbol_key, {})
+    return symbol_bucket.setdefault(side.upper(), {})
+
+
+def should_block_order(
+    state: Dict[str, Any],
+    symbol: str,
+    side: str,
+    now_ts: str,
+    *,
+    window_sec: int = 300,
+    max_attempts: int = 2,
+) -> bool:
+    bucket = _order_bucket(state, symbol, side)
+    last_ts = bucket.get("last_ts")
+    attempts = int(bucket.get("attempts") or 0)
+    if attempts >= max_attempts:
+        return True
+    if isinstance(last_ts, str):
+        try:
+            last_dt = datetime.fromisoformat(last_ts)
+            now_dt = datetime.fromisoformat(now_ts)
+            if (now_dt - last_dt).total_seconds() <= window_sec:
+                return True
+        except Exception:
+            return False
+    return False
+
+
+def mark_order(
+    state: Dict[str, Any],
+    symbol: str,
+    side: str,
+    strategy_id: Any,
+    qty: int,
+    price: float,
+    ts: str,
+    order_id: str | None = None,
+    status: str = "submitted",
+) -> None:
+    bucket = _order_bucket(state, symbol, side)
+    bucket["last_ts"] = ts
+    bucket["last_order_id"] = order_id
+    bucket["attempts"] = int(bucket.get("attempts") or 0) + 1
+    upsert_position(
+        state,
+        symbol,
+        {
+            "strategy_id": strategy_id,
+            "last_action": side.upper(),
+            "last_action_ts": ts,
+            "last_order_status": status,
+            "last_order_qty": int(qty),
+            "last_order_price": float(price),
+        },
+    )
+
+
+def mark_fill(
+    state: Dict[str, Any],
+    symbol: str,
+    side: str,
+    strategy_id: Any,
+    qty: int,
+    price: float,
+    ts: str,
+    order_id: str | None = None,
+    status: str = "filled",
+) -> None:
+    pos = get_position(state, symbol) or {}
+    cur_qty = int(pos.get("qty") or 0)
+    cur_avg = float(pos.get("avg_price") or 0.0)
+    if side.upper() == "BUY":
+        total_qty = cur_qty + int(qty)
+        avg_price = (
+            (cur_avg * cur_qty + float(price) * int(qty)) / total_qty
+            if total_qty > 0
+            else 0.0
+        )
+        pos.update({"qty": total_qty, "avg_price": avg_price, "last_buy_ts": ts})
+    else:
+        pos.update({"qty": max(0, cur_qty - int(qty)), "last_sell_ts": ts})
+    pos["strategy_id"] = strategy_id
+    pos["last_order_id"] = order_id
+    pos["last_action"] = side.upper()
+    pos["last_action_ts"] = ts
+    pos["last_order_status"] = status
+    upsert_position(state, symbol, pos)
+
+
+def reconcile_with_kis_balance(
+    state: Dict[str, Any],
+    balance: Dict[str, Any],
+    *,
+    preferred_strategy: Dict[str, Any] | None = None,
+) -> Dict[str, Any]:
+    preferred_strategy = preferred_strategy or {}
+    positions = state.setdefault("positions", {})
+    balance_positions = balance.get("positions") if isinstance(balance, dict) else None
+    if not isinstance(balance_positions, list):
+        return state
+    seen = set()
+    for row in balance_positions:
+        symbol = str(row.get("code") or row.get("pdno") or "").zfill(6)
+        if not symbol:
+            continue
+        qty = int(row.get("qty") or 0)
+        if qty <= 0:
+            continue
+        seen.add(symbol)
+        pos = positions.setdefault(symbol, {})
+        strategy_id = pos.get("strategy_id") or preferred_strategy.get(symbol) or "UNKNOWN"
+        pos.update(
+            {
+                "strategy_id": strategy_id,
+                "qty": qty,
+                "avg_price": float(row.get("avg_price") or 0.0),
+                "last_action": "RECONCILE",
+            }
+        )
+        positions[symbol] = pos
+    for symbol, pos in list(positions.items()):
+        if symbol not in seen:
+            pos["qty"] = 0
+            pos["last_action"] = "RECONCILE"
+            positions[symbol] = pos
+    return state
+
+
+def _default_lot_state() -> Dict[str, Any]:
     return {"version": SCHEMA_VERSION, "lots": [], "updated_at": None}
 
 
-def load_state(path_json: str) -> Dict[str, Any]:
+def load_lot_state(path_json: str) -> Dict[str, Any]:
     path = Path(path_json)
     if not path.exists():
-        return _default_state()
+        return _default_lot_state()
     try:
         with open(path, "r", encoding="utf-8") as f:
             state = json.load(f)
         if not isinstance(state, dict):
             logger.warning("[STATE_STORE] invalid state format: %s", type(state))
-            return _default_state()
+            return _default_lot_state()
         state.setdefault("version", SCHEMA_VERSION)
         state.setdefault("lots", [])
         state.setdefault("updated_at", None)
         return state
     except Exception:
         logger.exception("[STATE_STORE] failed to load %s", path_json)
-        return _default_state()
+        return _default_lot_state()
 
 
-def save_state(path_json: str, state: Dict[str, Any]) -> None:
+def save_lot_state(path_json: str, state: Dict[str, Any]) -> None:
     path = Path(path_json)
     try:
         path.parent.mkdir(parents=True, exist_ok=True)
         payload = dict(state)
         payload.setdefault("version", SCHEMA_VERSION)
         payload.setdefault("lots", [])
         payload["updated_at"] = datetime.now(KST).isoformat()
         tmp_path = path.with_name(f"{path.name}.tmp")
         with open(tmp_path, "w", encoding="utf-8") as f:
             json.dump(payload, f, ensure_ascii=False, indent=2)
         os.replace(tmp_path, path)
     except Exception:
         logger.exception("[STATE_STORE] failed to save %s", path_json)
diff --git a/trader/trader.py b/trader/trader.py
index 4165a29f897b3aad46e735d131448a2084f5c83b..72c94072f0348462ce6ad0d8f551bad922a307da 100644
--- a/trader/trader.py
+++ b/trader/trader.py
@@ -1,26 +1,39 @@
 # -*- coding: utf-8 -*-
 """Thin entrypoint orchestrating KOSPI core + KOSDAQ alpha engines."""
 from __future__ import annotations
 
 import logging
 
 from portfolio.portfolio_manager import PortfolioManager
+from trader.kis_wrapper import KisAPI
+from trader import state_store as runtime_state_store
 from trader.time_utils import is_trading_day, now_kst
 from trader.subject_flow import get_subject_flow_with_fallback  # noqa: F401 - exported for engines
 
 logger = logging.getLogger(__name__)
 
 
 def main() -> None:
     now = now_kst()
     if not is_trading_day(now):
         logger.warning("[TRADER] ë¹„ê±°ë˜ì¼(%s) â†’ ì¦‰ì‹œ ì¢…ë£Œ", now.date())
         return
+    try:
+        runtime_state = runtime_state_store.load_state()
+        kis = KisAPI()
+        balance = kis.get_balance()
+        runtime_state = runtime_state_store.reconcile_with_kis_balance(
+            runtime_state, balance
+        )
+        runtime_state_store.save_state(runtime_state)
+        logger.info("[TRADER] runtime state reconciled")
+    except Exception:
+        logger.exception("[TRADER] runtime state reconcile failed")
 
     mgr = PortfolioManager()
     result = mgr.run_once()
     logger.info("[TRADER] cycle complete %s", result)
 
 
 if __name__ == "__main__":
     main()
